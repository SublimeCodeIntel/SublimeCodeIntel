<?xml version="1.0" encoding="utf-8" ?>
<codeintel version="2.0" name="Ruby 1.9.2" description="Cix data for Ruby 1.9.2">
  <file lang="Ruby" mtime="1338831382" path="ruby-1.9.2.cix">
    <scope ilk="blob" lang="Ruby" name="*">
      <scope name="Object" ilk="class" >
        <scope name="__id__" ilk="function" signature="__id__()" doc="Returns an integer identifier for obj. The same number will be returned on all calls to id for a given object, and no two active objects will share an id. Object#object_id is a different concept from the :name notation, which returns the symbol id of name. Replaces the deprecated Object#id." />
        <scope name="class" ilk="function" signature="class()" doc="Returns the class of obj. This method must always be called with an explicit receiver, as class is also a reserved word in Ruby. &#xA;    1.class      =&gt; Fixnum&#xA;   self.class   =&gt; Object" />
        <scope name="clone" ilk="function" signature="clone()" doc="Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. Copies the frozen and tainted state of obj. See also the discussion under Object#dup. &#xA;    class Klass&#xA;      attr_accessor :str&#xA;   end&#xA;   s1 = Klass.new      =&gt; #&lt;Klass:0x401b3a38&gt;&#xA;   s1.str = &quot;Hello&quot;    =&gt; &quot;Hello&quot;&#xA;   s2 = s1.clone       =&gt; #&lt;Klass:0x401b3998 @str=&quot;Hello&quot;&gt;&#xA;   s2.str[1,4] = &quot;i&quot;   =&gt; &quot;i&quot;&#xA;   s1.inspect          =&gt; &quot;#&lt;Klass:0x401b3a38 @str=\&quot;Hi\&quot;&gt;&quot;&#xA;   s2.inspect          =&gt; &quot;#&lt;Klass:0x401b3998 @str=\&quot;Hi\&quot;&gt;&quot;&#xA; This method may have class-specific behavior.  If so, that behavior will be documented under the #+initialize_copy+ method of the class." />
        <scope name="define_singleton_method" ilk="function" signature="define_singleton_method(...)" doc="Defines a singleton method in the receiver. The _method_ parameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object. If a block is specified, it is used as the method body. &#xA;    class A&#xA;     class &lt;&lt; self&#xA;       def class_name&#xA;         to_s&#xA;       end&#xA;     end&#xA;   end&#xA;   A.define_singleton_method(:who_am_i) do&#xA;     &quot;I am: #{class_name}&quot;&#xA;   end&#xA;   A.who_am_i   # ==&gt; &quot;I am: A&quot;&#xA;   guy = &quot;Bob&quot;" />
        <scope name="display" ilk="function" signature="display(...)" doc="Prints obj on the given port (default $&gt;). Equivalent to: &#xA;    def display(port=$&gt;)&#xA;     port.write self&#xA;   end&#xA; For example: &#xA;    1.display&#xA;   &quot;cat&quot;.display&#xA;   [ 4, 5, 6 ].display&#xA;   puts&#xA; produces: &#xA;    1cat456" />
        <scope name="dup" ilk="function" signature="dup()" doc="Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. dup copies the tainted state of obj. See also the discussion under Object#clone. In general, clone and dup may have different semantics in descendant classes. While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendant object to create the new instance. &#xA; This method may have class-specific behavior.  If so, that behavior will be documented under the #+initialize_copy+ method of the class." />
        <scope name="enum_for" ilk="function" signature="enum_for(...)" doc="Returns Enumerator.new(self, method, *args). &#xA; e.g.: &#xA;    str = &quot;xyz&quot;&#xA;&#xA;   enum = str.enum_for(:each_byte)&#xA;   a = enum.map {|b| &apos;%02x&apos; % b } =&gt; [&quot;78&quot;, &quot;79&quot;, &quot;7a&quot;]&#xA;&#xA;   # protects an array from being modified&#xA;   a = [1, 2, 3]&#xA;   some_method(a.to_enum)" />
        <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Equality---At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning. &#xA; Unlike ==, the equal? method should never be overridden by subclasses: it is used to determine object identity (that is, a.equal?(b) iff a is the same object as b). &#xA; The eql? method returns true if obj and anObject have the same value. Used by Hash to test members for equality.  For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so: &#xA;    1 == 1.0     =&gt; true&#xA;   1.eql? 1.0   =&gt; false" />
        <scope name="extend" ilk="function" signature="extend(...)" doc="Adds to _obj_ the instance methods from each module given as a parameter. &#xA;    module Mod&#xA;     def hello&#xA;       &quot;Hello from Mod.\n&quot;&#xA;     end&#xA;   end&#xA;   class Klass&#xA;     def hello&#xA;       &quot;Hello from Klass.\n&quot;&#xA;     end&#xA;   end&#xA;   k = Klass.new&#xA;   k.hello         =&gt; &quot;Hello from Klass.\n&quot;" />
        <scope name="freeze" ilk="function" signature="freeze()" doc="Prevents further modifications to obj. A RuntimeError will be raised if modification is attempted. There is no way to unfreeze a frozen object. See also Object#frozen?. &#xA; This method returns self. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.freeze&#xA;   a &lt;&lt; &quot;z&quot;&#xA; produces: &#xA;    prog.rb:3:in `&lt;&lt;&apos;: can&apos;t modify frozen array (RuntimeError)&#xA;    from prog.rb:3" />
        <scope name="frozen?" ilk="function" signature="frozen?()" doc="Returns the freeze status of obj. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.freeze    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;   a.frozen?   =&gt; true" />
        <scope name="hash" ilk="function" />
        <scope name="initialize_clone" ilk="function" />
        <scope name="initialize_dup" ilk="function" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a human-readable representation of the set. (&quot;#&lt;Set: {element1, element2, ...}&gt;&quot;)" />
        <scope name="instance_of?" ilk="function" signature="instance_of?(p1)" doc="Returns true if obj is an instance of the given class. See also Object#kind_of?." />
        <scope name="instance_variable_defined?" ilk="function" signature="instance_variable_defined?(p1)" doc="Returns true if the given instance variable is defined in obj. &#xA;    class Fred&#xA;     def initialize(p1, p2)&#xA;       @a, @b = p1, p2&#xA;     end&#xA;   end&#xA;   fred = Fred.new(&apos;cat&apos;, 99)&#xA;   fred.instance_variable_defined?(:@a)    =&gt; true&#xA;   fred.instance_variable_defined?(&quot;@b&quot;)   =&gt; true&#xA;   fred.instance_variable_defined?(&quot;@c&quot;)   =&gt; false" />
        <scope name="instance_variable_get" ilk="function" signature="instance_variable_get(p1)" doc="Returns the value of the given instance variable, or nil if the instance variable is not set. The @ part of the variable name should be included for regular instance variables. Throws a NameError exception if the supplied symbol is not valid as an instance variable name. &#xA;    class Fred&#xA;     def initialize(p1, p2)&#xA;       @a, @b = p1, p2&#xA;     end&#xA;   end&#xA;   fred = Fred.new(&apos;cat&apos;, 99)&#xA;   fred.instance_variable_get(:@a)    =&gt; &quot;cat&quot;&#xA;   fred.instance_variable_get(&quot;@b&quot;)   =&gt; 99" />
        <scope name="instance_variable_set" ilk="function" signature="instance_variable_set(p1, p2)" doc="Sets the instance variable names by symbol to object, thereby frustrating the efforts of the class&apos;s author to attempt to provide proper encapsulation. The variable did not have to exist prior to this call. &#xA;    class Fred&#xA;     def initialize(p1, p2)&#xA;       @a, @b = p1, p2&#xA;     end&#xA;   end&#xA;   fred = Fred.new(&apos;cat&apos;, 99)&#xA;   fred.instance_variable_set(:@a, &apos;dog&apos;)   =&gt; &quot;dog&quot;&#xA;   fred.instance_variable_set(:@c, &apos;cat&apos;)   =&gt; &quot;cat&quot;&#xA;   fred.inspect                             =&gt; &quot;#&lt;Fred:0x401b3da8 @a=\&quot;dog\&quot;, @b=99, @c=\&quot;cat\&quot;&gt;&quot;" />
        <scope name="instance_variables" ilk="function" signature="instance_variables()" doc="Returns an array of instance variable names for the receiver. Note that simply defining an accessor does not create the corresponding instance variable. &#xA;    class Fred&#xA;     attr_accessor :a1&#xA;     def initialize&#xA;       @iv = 3&#xA;     end&#xA;   end&#xA;   Fred.new.instance_variables   =&gt; [:@iv]" />
        <scope name="is_a?" ilk="function" signature="is_a?(p1)" doc="Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj. &#xA;    module M;    end&#xA;   class A&#xA;     include M&#xA;   end&#xA;   class B &lt; A; end&#xA;   class C &lt; B; end&#xA;   b = B.new&#xA;   b.instance_of? A   =&gt; false&#xA;   b.instance_of? B   =&gt; true&#xA;   b.instance_of? C   =&gt; false&#xA;   b.instance_of? M   =&gt; false&#xA;   b.kind_of? A       =&gt; true" />
        <scope name="kind_of?" ilk="function" signature="kind_of?(p1)" doc="Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj. &#xA;    module M;    end&#xA;   class A&#xA;     include M&#xA;   end&#xA;   class B &lt; A; end&#xA;   class C &lt; B; end&#xA;   b = B.new&#xA;   b.instance_of? A   =&gt; false&#xA;   b.instance_of? B   =&gt; true&#xA;   b.instance_of? C   =&gt; false&#xA;   b.instance_of? M   =&gt; false&#xA;   b.kind_of? A       =&gt; true" />
        <scope name="method" ilk="function" signature="method(p1)" doc="Looks up the named method as a receiver in obj, returning a Method object (or raising NameError). The Method object acts as a closure in obj&apos;s object instance, so instance variables and the value of self remain available. &#xA;    class Demo&#xA;     def initialize(n)&#xA;       @iv = n&#xA;     end&#xA;     def hello()&#xA;       &quot;Hello, @iv = #{@iv}&quot;&#xA;     end&#xA;   end&#xA;   k = Demo.new(99)&#xA;   m = k.method(:hello)&#xA;   m.call   =&gt; &quot;Hello, @iv = 99&quot;&#xA;   l = Demo.new(&apos;Fred&apos;)" />
        <scope name="methods" ilk="function" />
        <scope name="nil?" ilk="function" signature="nil?()" doc="call_seq:   nil.nil?               -&gt; true&#xA;  &lt;anything_else&gt;.nil?   -&gt; false&#xA; Only the object nil responds true to nil?." />
        <scope name="object_id" ilk="function" signature="object_id()" doc="Returns an integer identifier for obj. The same number will be returned on all calls to id for a given object, and no two active objects will share an id. Object#object_id is a different concept from the :name notation, which returns the symbol id of name. Replaces the deprecated Object#id." />
        <scope name="private_methods" ilk="function" />
        <scope name="protected_methods" ilk="function" />
        <scope name="public_method" ilk="function" signature="public_method(p1)" doc="Similar to _method_, searches public method only." />
        <scope name="public_methods" ilk="function" />
        <scope name="public_send" ilk="function" signature="public_send(...)" doc="Invokes the method identified by _symbol_, passing it any arguments specified. Unlike send, public_send calls public methods only. &#xA;    1.public_send(:puts, &quot;hello&quot;)  # causes NoMethodError" />
        <scope name="respond_to?" ilk="function" signature="respond_to?(...)" doc="Returns +true+ if _obj_ responds to the given method. Private methods are included in the search only if the optional second parameter evaluates to +true+. &#xA; If the method is not implemented, as Process.fork on Windows, File.lchmod on GNU/Linux, etc., false is returned. &#xA; If the method is not defined, respond_to_missing? method is called and the result is returned." />
        <scope name="respond_to_missing?" ilk="function" signature="respond_to_missing?(p1, p2)" doc="Hook method to return whether the _obj_ can respond to _id_ method or not. &#xA; See #respond_to?." />
        <scope name="send" ilk="function" signature="send(...)" doc="Invokes the method identified by _symbol_, passing it any arguments specified. You can use __send__ if the name +send+ clashes with an existing method in _obj_. &#xA;    class Klass&#xA;     def hello(*args)&#xA;       &quot;Hello &quot; + args.join(&apos; &apos;)&#xA;     end&#xA;   end&#xA;   k = Klass.new&#xA;   k.send :hello, &quot;gentle&quot;, &quot;readers&quot;   =&gt; &quot;Hello gentle readers&quot;" />
        <scope name="singleton_class" ilk="function" signature="singleton_class()" doc="Returns the singleton class of obj.  This method creates a new singleton class if obj does not have it. &#xA; If obj is nil, true, or false, it returns NilClass, TrueClass, or FalseClass, respectively. If obj is a Fixnum or a Symbol, it raises a TypeError. &#xA;    Object.new.singleton_class  =&gt; #&lt;Class:#&lt;Object:0xb7ce1e24&gt;&gt;&#xA;   String.singleton_class      =&gt; #&lt;Class:String&gt;&#xA;   nil.singleton_class         =&gt; NilClass" />
        <scope name="singleton_methods" ilk="function" signature="singleton_methods(...)" doc="Returns an array of the names of singleton methods for obj. If the optional all parameter is true, the list will include methods in modules included in obj. Only public and protected singleton methods are returned. &#xA;    module Other&#xA;     def three() end&#xA;   end&#xA;   class Single&#xA;     def Single.four() end&#xA;   end&#xA;   a = Single.new&#xA;   def a.one()&#xA;   end&#xA;   class &lt;&lt; a&#xA;     include Other&#xA;     def two()" />
        <scope name="syck_to_yaml" ilk="function" />
        <scope name="taguri" ilk="function" />
        <scope name="taguri=" ilk="function" />
        <scope name="taint" ilk="function" signature="taint()" doc="Marks obj as tainted---if the $SAFE level is set appropriately, many method calls which might alter the running programs environment will refuse to accept tainted strings." />
        <scope name="tainted?" ilk="function" signature="tainted?()" doc="Returns true if the object is tainted." />
        <scope name="tap" ilk="function" signature="tap()" doc="Yields x to the block, and then returns x. The primary purpose of this method is to &quot;tap into&quot; a method chain, in order to perform operations on intermediate results within the chain. &#xA;     (1..10)                .tap {|x| puts &quot;original: #{x.inspect}&quot;}&#xA;      .to_a                .tap {|x| puts &quot;array: #{x.inspect}&quot;}&#xA;      .select {|x| x%2==0} .tap {|x| puts &quot;evens: #{x.inspect}&quot;}&#xA;      .map { |x| x*x }     .tap {|x| puts &quot;squares: #{x.inspect}&quot;}" />
        <scope name="to_enum" ilk="function" signature="to_enum(...)" doc="Returns Enumerator.new(self, method, *args). &#xA; e.g.: &#xA;    str = &quot;xyz&quot;&#xA;&#xA;   enum = str.enum_for(:each_byte)&#xA;   a = enum.map {|b| &apos;%02x&apos; % b } =&gt; [&quot;78&quot;, &quot;79&quot;, &quot;7a&quot;]&#xA;&#xA;   # protects an array from being modified&#xA;   a = [1, 2, 3]&#xA;   some_method(a.to_enum)" />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Returns a string representing obj. The default to_s prints the object&apos;s class and an encoding of the object id. As a special case, the top-level object that is the initial execution context of Ruby programs returns ``main.&apos;&apos;" />
        <scope name="to_yaml" ilk="function" />
        <scope name="to_yaml_properties" ilk="function" />
        <scope name="to_yaml_style" ilk="function" />
        <scope name="trust" ilk="function" signature="trust()" doc="Removes the untrusted mark from obj." />
        <scope name="untaint" ilk="function" signature="untaint()" doc="Removes the taint from obj." />
        <scope name="untrust" ilk="function" signature="untrust()" doc="Marks obj as untrusted." />
        <scope name="untrusted?" ilk="function" signature="untrusted?()" doc="Returns true if the object is untrusted." />
        <scope name="yaml_tag_subclasses?" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Module" ilk="class" classrefs="Object" >
        <scope name="ancestors" ilk="function" signature="ancestors()" doc="Returns a list of modules included in mod (including mod itself). &#xA;    module Mod&#xA;     include Math&#xA;     include Comparable&#xA;   end&#xA;&#xA;   Mod.ancestors    =&gt; [Mod, Comparable, Math]&#xA;   Math.ancestors   =&gt; [Math]" />
        <scope name="autoload" ilk="function" signature="autoload(p1, p2)" doc="Registers _filename_ to be loaded (using Kernel::require) the first time that _module_ (which may be a String or a symbol) is accessed in the namespace of _mod_. &#xA;    module A&#xA;   end&#xA;   A.autoload(:B, &quot;b&quot;)&#xA;   A::B.doit            # autoloads &quot;b&quot;" />
        <scope name="autoload?" ilk="function" signature="autoload?(p1)" doc="Returns _filename_ to be loaded if _name_ is registered as +autoload+ in the namespace of _mod_. &#xA;    module A&#xA;   end&#xA;   A.autoload(:B, &quot;b&quot;)&#xA;   A.autoload?(:B)            =&gt; &quot;b&quot;" />
        <scope name="class_eval" ilk="function" signature="class_eval(...)" doc="Evaluates the string or block in the context of _mod_. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional _filename_ and _lineno_ parameters set the text for error messages. &#xA;    class Thing&#xA;   end&#xA;   a = %q{def hello() &quot;Hello there!&quot; end}&#xA;   Thing.module_eval(a)&#xA;   puts Thing.new.hello()&#xA;   Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)&#xA; produces: &#xA;    Hello there!&#xA;   dummy:123:in `module_eval&apos;: undefined local variable&#xA;       or method `code&apos; for Thing:Class" />
        <scope name="class_exec" ilk="function" signature="class_exec(...)" doc="Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. &#xA;    class Thing&#xA;   end&#xA;   Thing.class_exec{&#xA;     def hello() &quot;Hello there!&quot; end&#xA;   }&#xA;   puts Thing.new.hello()&#xA; produces: &#xA;    Hello there!" />
        <scope name="class_variable_defined?" ilk="function" signature="class_variable_defined?(p1)" doc="Returns true if the given class variable is defined in obj. &#xA;    class Fred&#xA;     @@foo = 99&#xA;   end&#xA;   Fred.class_variable_defined?(:@@foo)    =&gt; true&#xA;   Fred.class_variable_defined?(:@@bar)    =&gt; false" />
        <scope name="class_variable_get" ilk="function" signature="class_variable_get(p1)" doc="Returns the value of the given class variable (or throws a NameError exception). The @@ part of the variable name should be included for regular class variables &#xA;    class Fred&#xA;     @@foo = 99&#xA;   end&#xA;   Fred.class_variable_get(:@@foo)     =&gt; 99" />
        <scope name="class_variable_set" ilk="function" signature="class_variable_set(p1, p2)" doc="Sets the class variable names by symbol to object. &#xA;    class Fred&#xA;     @@foo = 99&#xA;     def foo&#xA;       @@foo&#xA;     end&#xA;   end&#xA;   Fred.class_variable_set(:@@foo, 101)     =&gt; 101&#xA;   Fred.new.foo                             =&gt; 101" />
        <scope name="class_variables" ilk="function" signature="class_variables()" doc="Returns an array of the names of class variables in mod. &#xA;    class One&#xA;     @@var1 = 1&#xA;   end&#xA;   class Two &lt; One&#xA;     @@var2 = 2&#xA;   end&#xA;   One.class_variables   =&gt; [:@@var1]&#xA;   Two.class_variables   =&gt; [:@@var2]" />
        <scope name="const_defined?" ilk="function" signature="const_defined?(...)" doc="Returns true if a constant with the given name is defined by mod, or its ancestors if +inherit+ is not false. &#xA;    Math.const_defined? &quot;PI&quot;   =&gt; true&#xA;   IO.const_defined? &quot;SYNC&quot;   =&gt; true&#xA;   IO.const_defined? &quot;SYNC&quot;, false   =&gt; false" />
        <scope name="const_get" ilk="function" signature="const_get(...)" doc="Returns the value of the named constant in mod. &#xA;    Math.const_get(:PI)   =&gt; 3.14159265358979&#xA; If the constant is not defined or is defined by the ancestors and +inherit+ is false, +NameError+ will be raised." />
        <scope name="const_missing" ilk="function" signature="const_missing(p1)" doc="Invoked when a reference is made to an undefined constant in mod. It is passed a symbol for the undefined constant, and returns a value to be used for that constant. The following code is a (very bad) example: if reference is made to an undefined constant, it attempts to load a file whose name is the lowercase version of the constant (thus class Fred is assumed to be in file fred.rb). If found, it returns the value of the loaded class. It therefore implements a perverse kind of autoload facility. &#xA;   def Object.const_missing(name)&#xA;    @looked_for ||= {}&#xA;    str_name = name.to_s&#xA;    raise &quot;Class not found: #{name}&quot; if @looked_for[str_name]&#xA;    @looked_for[str_name] = 1&#xA;    file = str_name.downcase&#xA;    require file&#xA;    klass = const_get(name)&#xA;    return klass if klass&#xA;    raise &quot;Class not found: #{name}&quot;&#xA;  end" />
        <scope name="const_set" ilk="function" signature="const_set(p1, p2)" doc="Sets the named constant to the given object, returning that object. Creates a new constant if no constant with the given name previously existed. &#xA;    Math.const_set(&quot;HIGH_SCHOOL_PI&quot;, 22.0/7.0)   =&gt; 3.14285714285714&#xA;   Math::HIGH_SCHOOL_PI - Math::PI              =&gt; 0.00126448926734968" />
        <scope name="constants" ilk="function" signature="constants(...)" doc="Returns an array of the names of the constants accessible in mod. This includes the names of constants in any included modules (example at start of section), unless the all parameter is set to false. &#xA;   IO.constants.include?(:SYNC)        =&gt; true&#xA;  IO.constants(false).include?(:SYNC) =&gt; false&#xA; Also see Module::const_defined?." />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if module is included in mod or one of mod&apos;s ancestors. &#xA;    module A&#xA;   end&#xA;   class B&#xA;     include A&#xA;   end&#xA;   class C &lt; B&#xA;   end&#xA;   B.include?(A)   =&gt; true&#xA;   C.include?(A)   =&gt; true&#xA;   A.include?(A)   =&gt; false" />
        <scope name="included_modules" ilk="function" signature="included_modules()" doc="Returns the list of modules included in mod. &#xA;    module Mixin&#xA;   end&#xA;&#xA;   module Outer&#xA;     include Mixin&#xA;   end&#xA;&#xA;   Mixin.included_modules   =&gt; []&#xA;   Outer.included_modules   =&gt; [Mixin]" />
        <scope name="instance_method" ilk="function" signature="instance_method(p1)" doc="Returns an +UnboundMethod+ representing the given instance method in _mod_. &#xA;    class Interpreter&#xA;     def do_a() print &quot;there, &quot;; end&#xA;     def do_d() print &quot;Hello &quot;;  end&#xA;     def do_e() print &quot;!\n&quot;;     end&#xA;     def do_v() print &quot;Dave&quot;;    end&#xA;     Dispatcher = {&#xA;       &quot;a&quot; =&gt; instance_method(:do_a),&#xA;       &quot;d&quot; =&gt; instance_method(:do_d),&#xA;       &quot;e&quot; =&gt; instance_method(:do_e),&#xA;       &quot;v&quot; =&gt; instance_method(:do_v)&#xA;     }&#xA;     def interpret(string)" />
        <scope name="instance_methods" ilk="function" signature="instance_methods(...)" doc="Returns an array containing the names of the public and protected instance methods in the receiver. For a module, these are the public and protected methods; for a class, they are the instance (not singleton) methods. With no argument, or with an argument that is false, the instance methods in mod are returned, otherwise the methods in mod and mod&apos;s superclasses are returned. &#xA;    module A&#xA;     def method1()  end&#xA;   end&#xA;   class B&#xA;     def method2()  end&#xA;   end&#xA;   class C &lt; B&#xA;     def method3()  end&#xA;   end&#xA;   A.instance_methods                =&gt; [:method1]&#xA;   B.instance_methods(false)         =&gt; [:method2]&#xA;   C.instance_methods(false)         =&gt; [:method3]" />
        <scope name="method_defined?" ilk="function" signature="method_defined?(p1)" doc="Returns +true+ if the named method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). Public and protected methods are matched. &#xA;    module A&#xA;     def method1()  end&#xA;   end&#xA;   class B&#xA;     def method2()  end&#xA;   end&#xA;   class C &lt; B&#xA;     include A&#xA;     def method3()  end&#xA;   end&#xA;   A.method_defined? :method1    =&gt; true&#xA;   C.method_defined? &quot;method1&quot;   =&gt; true" />
        <scope name="module_eval" ilk="function" signature="module_eval(...)" doc="Evaluates the string or block in the context of _mod_. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional _filename_ and _lineno_ parameters set the text for error messages. &#xA;    class Thing&#xA;   end&#xA;   a = %q{def hello() &quot;Hello there!&quot; end}&#xA;   Thing.module_eval(a)&#xA;   puts Thing.new.hello()&#xA;   Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)&#xA; produces: &#xA;    Hello there!&#xA;   dummy:123:in `module_eval&apos;: undefined local variable&#xA;       or method `code&apos; for Thing:Class" />
        <scope name="module_exec" ilk="function" signature="module_exec(...)" doc="Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. &#xA;    class Thing&#xA;   end&#xA;   Thing.class_exec{&#xA;     def hello() &quot;Hello there!&quot; end&#xA;   }&#xA;   puts Thing.new.hello()&#xA; produces: &#xA;    Hello there!" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the module mod.  Returns nil for anonymous modules." />
        <scope name="private_class_method" ilk="function" signature="private_class_method(...)" doc="Makes existing class methods private. Often used to hide the default constructor new. &#xA;    class SimpleSingleton  # Not thread safe&#xA;     private_class_method :new&#xA;     def SimpleSingleton.create(*args, &amp;block)&#xA;       @me = new(*args, &amp;block) if ! @me&#xA;       @me&#xA;     end&#xA;   end" />
        <scope name="private_instance_methods" ilk="function" signature="private_instance_methods(...)" doc="Returns a list of the private instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included. &#xA;    module Mod&#xA;     def method1()  end&#xA;     private :method1&#xA;     def method2()  end&#xA;   end&#xA;   Mod.instance_methods           =&gt; [:method2]&#xA;   Mod.private_instance_methods   =&gt; [:method1]" />
        <scope name="private_method_defined?" ilk="function" signature="private_method_defined?(p1)" doc="Returns +true+ if the named private method is defined by _ mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA;    module A&#xA;     def method1()  end&#xA;   end&#xA;   class B&#xA;     private&#xA;     def method2()  end&#xA;   end&#xA;   class C &lt; B&#xA;     include A&#xA;     def method3()  end&#xA;   end&#xA;   A.method_defined? :method1            =&gt; true" />
        <scope name="protected_instance_methods" ilk="function" signature="protected_instance_methods(...)" doc="Returns a list of the protected instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included." />
        <scope name="protected_method_defined?" ilk="function" signature="protected_method_defined?(p1)" doc="Returns +true+ if the named protected method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA;    module A&#xA;     def method1()  end&#xA;   end&#xA;   class B&#xA;     protected&#xA;     def method2()  end&#xA;   end&#xA;   class C &lt; B&#xA;     include A&#xA;     def method3()  end&#xA;   end&#xA;   A.method_defined? :method1              =&gt; true" />
        <scope name="public_class_method" ilk="function" signature="public_class_method(...)" doc="Makes a list of existing class methods public." />
        <scope name="public_instance_method" ilk="function" signature="public_instance_method(p1)" doc="Similar to _instance_method_, searches public method only." />
        <scope name="public_instance_methods" ilk="function" signature="public_instance_methods(...)" doc="Returns a list of the public instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included." />
        <scope name="public_method_defined?" ilk="function" signature="public_method_defined?(p1)" doc="Returns +true+ if the named public method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA;    module A&#xA;     def method1()  end&#xA;   end&#xA;   class B&#xA;     protected&#xA;     def method2()  end&#xA;   end&#xA;   class C &lt; B&#xA;     include A&#xA;     def method3()  end&#xA;   end&#xA;   A.method_defined? :method1           =&gt; true" />
        <scope name="remove_class_variable" ilk="function" signature="remove_class_variable(p1)" doc="Removes the definition of the sym, returning that constant&apos;s value. &#xA;    class Dummy&#xA;     @@var = 99&#xA;     puts @@var&#xA;     remove_class_variable(:@@var)&#xA;     p(defined? @@var)&#xA;   end&#xA; produces: &#xA;    99&#xA;   nil" />
        <scope name="syck_yaml_as" ilk="function" />
        <scope name="yaml_as" ilk="function" />
        <scope name="yaml_tag_class_name" ilk="function" />
        <scope name="yaml_tag_read_class" ilk="function" />
        <scope name="constants" ilk="function" attributes="__classmethod__" signature="constants(...)" doc="Returns an array of the names of all constants defined in the system. This list includes the names of all modules and classes. &#xA;    p Module.constants.sort[1..5]&#xA; produces: &#xA;    [&quot;ARGV&quot;, &quot;ArgumentError&quot;, &quot;Array&quot;, &quot;Bignum&quot;, &quot;Binding&quot;]" />
        <scope name="nesting" ilk="function" attributes="__classmethod__" signature="nesting()" doc="Returns the list of +Modules+ nested at the point of call. &#xA;    module M1&#xA;     module M2&#xA;       $a = Module.nesting&#xA;     end&#xA;   end&#xA;   $a           =&gt; [M1::M2, M1]&#xA;   $a[0].name   =&gt; &quot;M1::M2&quot;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new anonymous module. If a block is given, it is passed the module object, and the block is evaluated in the context of this module using module_eval. &#xA;    Fred = Module.new do&#xA;     def meth1&#xA;       &quot;hello&quot;&#xA;     end&#xA;     def meth2&#xA;       &quot;bye&quot;&#xA;     end&#xA;   end&#xA;   a = &quot;my string&quot;&#xA;   a.extend(Fred)   =&gt; &quot;my string&quot;&#xA;   a.meth1          =&gt; &quot;hello&quot;&#xA;   a.meth2          =&gt; &quot;bye&quot;" />
      </scope>
      <scope name="Class" ilk="class" classrefs="Module" >
        <scope name="allocate" ilk="function" signature="allocate()" doc="Allocates space for a new object of class&apos;s class and does not call initialize on the new instance. The returned object must be an instance of class. &#xA;     klass = Class.new do&#xA;      def initialize(*args)&#xA;        @initialized = true&#xA;      end&#xA;&#xA;      def initialized?&#xA;        @initialized || false&#xA;      end&#xA;    end&#xA;&#xA;    klass.allocate.initialized? =&gt; false" />
        <scope name="new" ilk="function" signature="new(...)" doc="Calls allocate to create a new object of class&apos;s class, then invokes that object&apos;s initialize method, passing it args. This is the method that ends up getting called whenever an object is constructed using .new." />
        <scope name="superclass" ilk="function" signature="superclass()" doc="Returns the superclass of class, or nil. &#xA;    File.superclass          =&gt; IO&#xA;   IO.superclass            =&gt; Object&#xA;   Object.superclass        =&gt; BasicObject&#xA;   class Foo; end&#xA;   class Bar &lt; Foo; end&#xA;   Bar.superclass           =&gt; Foo&#xA; returns nil when the given class hasn&apos;t a parent class: &#xA;    BasicObject.superclass   =&gt; nil" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). You can give a class a name by assigning the class object to a constant." />
      </scope>
      <scope name="Kernel" ilk="namespace" >
        <scope name="Array" ilk="function" signature="Array(p1)" doc="Returns arg as an Array. First tries to call arg.to_ary, then arg.to_a. &#xA;    Array(1..5)   =&gt; [1, 2, 3, 4, 5]" />
        <scope name="Complex" ilk="function" signature="Complex(...)" doc="Returns x+i*y;" />
        <scope name="Float" ilk="function" signature="Float(p1)" doc="Returns arg converted to a float. Numeric types are converted directly, the rest are converted using arg.to_f. As of Ruby 1.8, converting nil generates a TypeError. &#xA;    Float(1)           =&gt; 1.0&#xA;   Float(&quot;123.456&quot;)   =&gt; 123.456" />
        <scope name="Integer" ilk="function" signature="Integer(...)" doc="Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating point numbers being truncated).    base (0, or between 2 and 36) is a base for integer string representation.  If arg is a String, when base is omitted or equals to zero, radix indicators (0, 0b, and 0x) are honored. In any case, strings should be strictly conformed to numeric representation. This behavior is different from that of String#to_i.  Non string values will be converted using to_int, and to_i. &#xA;    Integer(123.999)    =&gt; 123&#xA;   Integer(&quot;0x1a&quot;)     =&gt; 26&#xA;   Integer(Time.new)   =&gt; 1204973019" />
        <scope name="Rational" ilk="function" signature="Rational(...)" doc="Returns x/y;" />
        <scope name="String" ilk="function" signature="String(p1)" doc="Converts arg to a String by calling its to_s method. &#xA;    String(self)        =&gt; &quot;main&quot;&#xA;   String(self.class)  =&gt; &quot;Object&quot;&#xA;   String(123456)      =&gt; &quot;123456&quot;" />
        <scope name="__callee__" ilk="function" signature="__callee__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
        <scope name="__method__" ilk="function" signature="__method__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
        <scope name="abort" ilk="function" signature="abort(...)" doc="Terminate execution immediately, effectively by calling Kernel.exit(false). If _msg_ is given, it is written to STDERR prior to terminating." />
        <scope name="at_exit" ilk="function" signature="at_exit()" doc="Converts _block_ to a +Proc+ object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration. &#xA;    def do_at_exit(str1)&#xA;     at_exit { print str1 }&#xA;   end&#xA;   at_exit { puts &quot;cruel world&quot; }&#xA;   do_at_exit(&quot;goodbye &quot;)&#xA;   exit&#xA; produces: &#xA;    goodbye cruel world" />
        <scope name="binding" ilk="function" signature="binding()" doc="Returns a +Binding+ object, describing the variable and method bindings at the point of call. This object can be used when calling +eval+ to execute the evaluated command in this environment. Also see the description of class +Binding+. &#xA;    def getBinding(param)&#xA;     return binding&#xA;   end&#xA;   b = getBinding(&quot;hello&quot;)&#xA;   eval(&quot;param&quot;, b)   =&gt; &quot;hello&quot;" />
        <scope name="block_given?" ilk="function" signature="block_given?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA;    def try&#xA;     if block_given?&#xA;       yield&#xA;     else&#xA;       &quot;no block&quot;&#xA;     end&#xA;   end&#xA;   try                  =&gt; &quot;no block&quot;&#xA;   try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;   try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
        <scope name="caller" ilk="function" signature="caller(...)" doc="Returns the current execution stack---an array containing strings in the form ``file:line&apos;&apos; or ``file:line: in `method&apos;&apos;&apos;. The optional _start_ parameter determines the number of initial stack entries to omit from the result. &#xA; Returns +nil+ if _start_ is greater than the size of current execution stack. &#xA;    def a(skip)&#xA;     caller(skip)&#xA;   end&#xA;   def b(skip)&#xA;     a(skip)&#xA;   end&#xA;   def c(skip)&#xA;     b(skip)&#xA;   end&#xA;   c(0)   =&gt; [&quot;prog:2:in `a&apos;&quot;, &quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:10:in `&lt;main&gt;&apos;&quot;]&#xA;   c(1)   =&gt; [&quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:11:in `&lt;main&gt;&apos;&quot;]" />
        <scope name="catch" ilk="function" signature="catch(...)" doc="+catch+ executes its block. If a +throw+ is executed, Ruby searches up its stack for a +catch+ block with a tag corresponding to the +throw+&apos;s _tag_. If found, that block is terminated, and +catch+ returns the value given to +throw+. If +throw+ is not called, the block terminates normally, and the value of +catch+ is the value of the last expression evaluated. +catch+ expressions may be nested, and the +throw+ call need not be in lexical scope. &#xA;    def routine(n)&#xA;     puts n&#xA;     throw :done if n &lt;= 0&#xA;     routine(n-1)&#xA;   end&#xA;   catch(:done) { routine(3) }&#xA; produces: &#xA;    3&#xA;   2&#xA;   1&#xA;   0&#xA; when _arg_ is given, +catch+ yields it as is, or when no _arg_ is given, +catch+ assigns a new unique object to +throw+.  this is useful for nested +catch+.  _arg_ can be an arbitrary object, not only Symbol." />
        <scope name="eval" ilk="function" signature="eval(...)" doc="Evaluates the Ruby expression(s) in string. If binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA;    def getBinding(str)&#xA;     return binding&#xA;   end&#xA;   str = &quot;hello&quot;&#xA;   eval &quot;str + &apos; Fred&apos;&quot;                      =&gt; &quot;hello Fred&quot;&#xA;   eval &quot;str + &apos; Fred&apos;&quot;, getBinding(&quot;bye&quot;)   =&gt; &quot;bye Fred&quot;" />
        <scope name="exec" ilk="function" signature="exec(...)" doc="Replaces the current process by running the given external _command_. _command..._ is one of following forms. &#xA;   commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; If single string is given as the command, it is taken as a command line that is subject to shell expansion before being executed. &#xA; The standard shell means always &quot;/bin/sh&quot; on Unix-like systems, ENV[&quot;RUBYSHELL&quot;] or ENV[&quot;COMSPEC&quot;] on Windows NT series, and similar. &#xA; If two or more +string+ given, the first is taken as a command name and the rest are passed as parameters to command with no shell expansion. &#xA; If a two-element array at the beginning of the command, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. &#xA; In order to execute the command, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors). This behavior is modified by env and options. See spawn for details. &#xA; Raises SystemCallError if the command couldn&apos;t execute (typically Errno::ENOENT when it was not found). &#xA;    exec &quot;echo *&quot;       # echoes list of files in current directory&#xA;   # never get here&#xA;   exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk" />
        <scope name="exit" ilk="function" signature="exit(...)" doc="Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment. +true+ and +FALSE+ of _status_ means success and failure respectively.  The interpretation of other integer values are system dependent. &#xA;    begin&#xA;     exit&#xA;     puts &quot;never get here&quot;&#xA;   rescue SystemExit&#xA;     puts &quot;rescued a SystemExit exception&quot;&#xA;   end&#xA;   puts &quot;after begin block&quot;&#xA; produces: &#xA;    rescued a SystemExit exception&#xA;   after begin block&#xA; Just prior to termination, Ruby executes any at_exit functions (see Kernel::at_exit) and runs any object finalizers (see ObjectSpace::define_finalizer). &#xA;    at_exit { puts &quot;at_exit function&quot; }" />
        <scope name="exit!" ilk="function" signature="exit!(...)" doc="Exits the process immediately. No exit handlers are run. status is returned to the underlying system as the exit status. &#xA;    Process.exit!(true)" />
        <scope name="fail" ilk="function" signature="fail(...)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA;    raise &quot;Failed to create socket&quot;&#xA;   raise ArgumentError, &quot;No parameters&quot;, caller" />
        <scope name="fork" ilk="function" signature="fork()" doc="Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the +fork+ call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning _nil_. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; The thread calling fork is the only thread in the created child process. fork doesn&apos;t copy other threads. &#xA; If fork is not usable, Process.respond_to?(:fork) returns false." />
        <scope name="format" ilk="function" signature="format(...)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA;   %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA;     Field |  Integer Format&#xA;    ------+--------------------------------------------------------------&#xA;      b   | Convert argument as a binary number.&#xA;          | Negative numbers will be displayed as a two&apos;s complement&#xA;          | prefixed with `..1&apos;.&#xA;      B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;          | in the alternative format by #.&#xA;      d   | Convert argument as a decimal number." />
        <scope name="gets" ilk="function" signature="gets(...)" doc="Returns (and assigns to $_) the next line from the list of files in +ARGV+ (or $*), or from standard input if no files are present on the command line. Returns +nil+ at end of file. The optional argument specifies the record separator. The separator is included with the contents of each record. A separator of +nil+ reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes.  If multiple filenames are present in +ARGV+, +gets(nil)+ will read the contents one file at a time. &#xA;    ARGV &lt;&lt; &quot;testfile&quot;&#xA;   print while gets&#xA; produces: &#xA;    This is line one&#xA;   This is line two&#xA;   This is line three&#xA;   And so on...&#xA; The style of programming using $_ as an implicit parameter is gradually losing favor in the Ruby community." />
        <scope name="global_variables" ilk="function" signature="global_variables()" doc="Returns an array of the names of global variables. &#xA;    global_variables.grep /std/   =&gt; [:$stdin, :$stdout, :$stderr]" />
        <scope name="iterator?" ilk="function" signature="iterator?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA;    def try&#xA;     if block_given?&#xA;       yield&#xA;     else&#xA;       &quot;no block&quot;&#xA;     end&#xA;   end&#xA;   try                  =&gt; &quot;no block&quot;&#xA;   try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;   try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
        <scope name="lambda" ilk="function" signature="lambda()" doc="Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called." />
        <scope name="load" ilk="function" signature="load(...)" doc="Loads and executes the Ruby program in the file _filename_. If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. If the optional _wrap_ parameter is +true+, the loaded script will be executed under an anonymous module, protecting the calling program&apos;s global namespace. In no circumstance will any local variables in the loaded file be propagated to the loading environment." />
        <scope name="local_variables" ilk="function" signature="local_variables()" doc="Returns the names of the current local variables. &#xA;    fred = 1&#xA;   for i in 1..10&#xA;      # ...&#xA;   end&#xA;   local_variables   =&gt; [:fred, :i]" />
        <scope name="loop" ilk="function" signature="loop()" doc="Repeatedly executes the block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    loop do&#xA;     print &quot;Input: &quot;&#xA;     line = gets&#xA;     break if !line or line =~ /^qQ/&#xA;     # ...&#xA;   end&#xA; StopIteration raised in the block breaks the loop." />
        <scope name="open" ilk="function" signature="open(...)" doc="Creates an IO object connected to the given stream, file, or subprocess. &#xA; If path does not start with a pipe character (``|&apos;&apos;), treat it as the name of a file to open using the specified mode (defaulting to ``r&apos;&apos;). &#xA; The mode_enc is either a string or an integer.  If it is an integer, it must be bitwise-or of open(2) flags, such as File::RDWR or File::EXCL. If it is a string, it is either &quot;mode&quot;, &quot;mode:ext_enc&quot;, or &quot;mode:ext_enc:int_enc&quot;. The mode is one of the following: &#xA;  r: read (default)&#xA; w: write&#xA; a: append&#xA; The mode can be followed by &quot;b&quot; (means binary-mode), or &quot;+&quot; (means both reading and writing allowed) or both. If ext_enc (external encoding) is specified, read string will be tagged by the encoding in reading, and output string will be converted to the specified encoding in writing. If ext_enc starts with &apos;BOM|&apos;, check whether the input has a BOM. If there is a BOM, strip it and set external encoding as what the BOM tells. If there is no BOM, use ext_enc without &apos;BOM|&apos;. If two encoding names, ext_enc and int_enc (external encoding and internal encoding), are specified, the read string is converted from ext_enc to int_enc then tagged with the int_enc in read mode, and in write mode, the output string will be converted from int_enc to ext_enc before writing. &#xA; If a file is being created, its initial permissions may be set using the integer third parameter. &#xA; If a block is specified, it will be invoked with the File object as a parameter, and the file will be automatically closed when the block terminates. The call returns the value of the block. &#xA; If path starts with a pipe character, a subprocess is created, connected to the caller by a pair of pipes. The returned IO object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the ``|&apos;&apos; is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the open call returns nil. If the command is not ``-&apos;&apos;, the subprocess runs the command. If a block is associated with an open(&quot;|-&quot;) call, that block will be run twice---once in the parent and once in the child. The block parameter will be an IO object in the parent and nil in the child. The parent&apos;s IO object will be connected to the child&apos;s $stdin and $stdout. The subprocess will be terminated at the end of the block. &#xA;    open(&quot;testfile&quot;) do |f|&#xA;     print f.gets&#xA;   end" />
        <scope name="p" ilk="function" signature="p(...)" doc="For each object, directly writes _obj_.+inspect+ followed by the current output record separator to the program&apos;s standard output. &#xA;    S = Struct.new(:name, :state)&#xA;   s = S[&apos;dave&apos;, &apos;TX&apos;]&#xA;   p s&#xA; produces: &#xA;    #&lt;S name=&quot;dave&quot;, state=&quot;TX&quot;&gt;" />
        <scope name="print" ilk="function" signature="print(...)" doc="Prints each object in turn to $stdout. If the output field separator ($,) is not +nil+, its contents will appear between each field. If the output record separator ($\\) is not +nil+, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. &#xA;    print &quot;cat&quot;, [1,2,3], 99, &quot;\n&quot;&#xA;   $, = &quot;, &quot;&#xA;   $\ = &quot;\n&quot;&#xA;   print &quot;cat&quot;, [1,2,3], 99&#xA; produces: &#xA;    cat12399&#xA;   cat, 1, 2, 3, 99" />
        <scope name="printf" ilk="function" signature="printf(...)" doc="Equivalent to:    io.write(sprintf(string, obj, ...)&#xA; or    $stdout.write(sprintf(string, obj, ...)" />
        <scope name="proc" ilk="function" signature="proc()" doc="Equivalent to Proc.new." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc=" &#xA; Equivalent to:&#xA;&#xA;   $stdout.putc(int)&#xA; Refer to the documentation for IO#putc for important information regarding multi-byte characters." />
        <scope name="puts" ilk="function" signature="puts(...)" doc="Equivalent to &#xA;     $stdout.puts(obj, ...)" />
        <scope name="raise" ilk="function" signature="raise(...)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA;    raise &quot;Failed to create socket&quot;&#xA;   raise ArgumentError, &quot;No parameters&quot;, caller" />
        <scope name="rand" ilk="function" signature="rand(...)" doc="Converts max to an integer using max1 = max.to_i.abs. If _max_ is +nil+ the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1. &#xA;    srand 1234                 =&gt; 0&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]&#xA;   [ rand(10), rand(1000) ]   =&gt; [6, 817]&#xA;   srand 1234                 =&gt; 1234&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]" />
        <scope name="readline" ilk="function" signature="readline(...)" doc="Equivalent to Kernel::gets, except +readline+ raises +EOFError+ at end of file." />
        <scope name="readlines" ilk="function" signature="readlines(...)" doc="Returns an array containing the lines returned by calling Kernel.gets(sep) until the end of file." />
        <scope name="require" ilk="function" signature="require(p1)" doc="Ruby tries to load the library named _string_, returning +true+ if successful. If the filename does not resolve to an absolute path, it will be searched for in the directories listed in $:. If the file has the extension ``.rb&apos;&apos;, it is loaded as a source file; if the extension is ``.so&apos;&apos;, ``.o&apos;&apos;, or ``.dll&apos;&apos;, or whatever the default shared library extension is on the current platform, Ruby loads the shared library as a Ruby extension. Otherwise, Ruby tries adding ``.rb&apos;&apos;, ``.so&apos;&apos;, and so on to the name. The name of the loaded feature is added to the array in $&quot;. A feature will not be loaded if its name already appears in $&quot;. The file name is converted to an absolute path, so ``require &apos;a&apos;; require &apos;./a&apos;&apos;&apos; will not load a.rb twice. &#xA;    require &quot;my-library.rb&quot;&#xA;   require &quot;db-driver&quot;" />
        <scope name="require_relative" ilk="function" />
        <scope name="select" ilk="function" signature="select(...)" doc="See Kernel#select." />
        <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ as the handler for tracing, or disables tracing if the parameter is +nil+. _proc_ takes up to six parameters: an event name, a filename, a line number, an object id, a binding, and the name of a class. _proc_ is invoked whenever an event occurs. Events are: c-call (call a C-language routine), c-return (return from a C-language routine), call (call a Ruby method), class (start a class or module definition), end (finish a class or module definition), line (execute code on a new line), raise (raise an exception), and return (return from a Ruby method). Tracing is disabled within the context of _proc_. &#xA;     class Test&#xA;    def test&#xA;      a = 1&#xA;      b = 2&#xA;    end&#xA;    end&#xA;    set_trace_func proc { |event, file, line, id, binding, classname|&#xA;       printf &quot;%8s %s:%-2d %10s %8s\n&quot;, event, file, line, id, classname&#xA;    }&#xA;    t = Test.new&#xA;    t.test&#xA;      line prog.rb:11               false" />
        <scope name="sleep" ilk="function" signature="sleep(...)" doc="Suspends the current thread for _duration_ seconds (which may be any number, including a +Float+ with fractional seconds). Returns the actual number of seconds slept (rounded), which may be less than that asked for if another thread calls Thread#run. Called without an argument, sleep() will sleep forever. &#xA;    Time.new    =&gt; 2008-03-08 19:56:19 +0900&#xA;   sleep 1.2   =&gt; 1&#xA;   Time.new    =&gt; 2008-03-08 19:56:20 +0900&#xA;   sleep 1.9   =&gt; 2&#xA;   Time.new    =&gt; 2008-03-08 19:56:22 +0900" />
        <scope name="spawn" ilk="function" signature="spawn(...)" doc="spawn executes specified command and return its pid. &#xA; This method doesn&apos;t wait for end of the command. The parent process should use Process.wait to collect the termination status of its child or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; spawn has bunch of options to specify process attributes: &#xA;   env: hash&#xA;    name =&gt; val : set the environment variable&#xA;    name =&gt; nil : unset the environment variable&#xA;  command...:&#xA;    commandline                 : command line string which is passed to the standard shell&#xA;    cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA;  options: hash&#xA;    clearing environment variables:&#xA;      :unsetenv_others =&gt; true   : clear environment variables except specified by env" />
        <scope name="sprintf" ilk="function" signature="sprintf(...)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA;   %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA;     Field |  Integer Format&#xA;    ------+--------------------------------------------------------------&#xA;      b   | Convert argument as a binary number.&#xA;          | Negative numbers will be displayed as a two&apos;s complement&#xA;          | prefixed with `..1&apos;.&#xA;      B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;          | in the alternative format by #.&#xA;      d   | Convert argument as a decimal number." />
        <scope name="srand" ilk="function" signature="srand(...)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted or zero, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
        <scope name="syscall" ilk="function" signature="syscall(...)" doc="Calls the operating system function identified by _fixnum_, passing in the arguments, which must be either +String+ objects, or +Integer+ objects that ultimately fit within a native +long+. Up to nine parameters may be passed (14 on the Atari-ST). The function identified by _fixnum_ is system dependent. On some Unix systems, the numbers may be obtained from a header file called syscall.h. &#xA;    syscall 4, 1, &quot;hello\n&quot;, 6   # &apos;4&apos; is write(2) on our box&#xA; produces: &#xA;    hello" />
        <scope name="system" ilk="function" signature="system(...)" doc="Executes _command..._ in a subshell. _command..._ is one of following forms. &#xA;   commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; system returns +true+ if the command gives zero exit status, +false+ for non zero exit status. Returns +nil+ if command execution fails. An error status is available in $?. The arguments are processed in the same way as for Kernel.spawn. &#xA; The hash arguments, env and options, are same as exec and spawn. See Kernel.spawn for details. &#xA;    system(&quot;echo *&quot;)&#xA;   system(&quot;echo&quot;, &quot;*&quot;)&#xA; produces: &#xA;    config.h main.rb&#xA;   *  See Kernel.exec for the standard shell." />
        <scope name="test" ilk="function" signature="test(...)" doc=" &#xA; Uses the integer aCmd to perform various tests on&#xA; file1 (first table below) or on file1 and&#xA; file2 (second table).&#xA; File tests on a single file:&#xA;   Test   Returns   Meaning&#xA;   &quot;A&quot;  | Time    | Last access time for file1&#xA;   &quot;b&quot;  | boolean | True if file1 is a block device&#xA;   &quot;c&quot;  | boolean | True if file1 is a character device&#xA;   &quot;C&quot;  | Time    | Last change time for file1&#xA;   &quot;d&quot;  | boolean | True if file1 exists and is a directory&#xA;   &quot;e&quot;  | boolean | True if file1 exists&#xA;   &quot;f&quot;  | boolean | True if file1 exists and is a regular file" />
        <scope name="throw" ilk="function" signature="throw(...)" doc="Transfers control to the end of the active +catch+ block waiting for _tag_. Raises +ArgumentError+ if there is no +catch+ block for the _tag_. The optional second parameter supplies a return value for the +catch+ block, which otherwise defaults to +nil+. For examples, see Kernel::catch." />
        <scope name="trace_var" ilk="function" signature="trace_var(...)" doc="Controls tracing of assignments to global variables. The parameter +symbol_ identifies the variable (as either a string name or a symbol identifier). _cmd_ (which may be a string or a +Proc+ object) or block is executed whenever the variable is assigned. The block or +Proc+ object receives the variable&apos;s new value as a parameter. Also see Kernel::untrace_var. &#xA;    trace_var :$_, proc {|v| puts &quot;$_ is now &apos;#{v}&apos;&quot; }&#xA;   $_ = &quot;hello&quot;&#xA;   $_ = &apos; there&apos;&#xA; produces: &#xA;    $_ is now &apos;hello&apos;&#xA;   $_ is now &apos; there&apos;" />
        <scope name="trap" ilk="function" signature="trap(...)" doc="Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM&apos;&apos;, ``SIGUSR1&apos;&apos;, and so on) or a signal number. The characters ``SIG&apos;&apos; may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE&apos;&apos; or ``SIG_IGN&apos;&apos;, the signal will be ignored. If the command is ``DEFAULT&apos;&apos; or ``SIG_DFL&apos;&apos;, the Ruby&apos;s default handler will be invoked. If the command is ``EXIT&apos;&apos;, the script will be terminated by the signal. If the command is ``SYSTEM_DEFAULT&apos;&apos;, the operating system&apos;s default handler will be invoked. Otherwise, the given command or block will be run. The special signal name ``EXIT&apos;&apos; or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal. &#xA;     Signal.trap(0, proc { puts &quot;Terminating: #{$$}&quot; })&#xA;    Signal.trap(&quot;CLD&quot;)  { puts &quot;Child died&quot; }&#xA;    fork &amp;&amp; Process.wait&#xA; produces:     Terminating: 27461&#xA;    Child died&#xA;    Terminating: 27460" />
        <scope name="untrace_var" ilk="function" signature="untrace_var(...)" doc="Removes tracing for the specified command on the given global variable and returns +nil+. If no command is specified, removes all tracing for that variable and returns an array containing the commands actually removed." />
        <scope name="warn" ilk="function" signature="warn(p1)" doc="Display the given message (followed by a newline) on STDERR unless warnings are disabled (for example with the -W0 flag)." />
      </scope>
      <scope name="NilClass" ilk="class" classrefs="Object" >
        <scope name="rationalize" ilk="function" signature="rationalize(...)" doc="Returns zero as a rational.  An optional argument eps is always ignored." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Always returns an empty array. &#xA;    nil.to_a   =&gt; []" />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns zero as a complex." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Always returns zero. &#xA;    nil.to_f   =&gt; 0.0" />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Always returns zero. &#xA;    nil.to_i   =&gt; 0" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns zero as a rational." />
      </scope>
      <variable name="NIL" attributes="__const__" citdl="NilClass" />
      <scope name="Data" ilk="class" classrefs="Object" >
      </scope>
      <scope name="TrueClass" ilk="class" classrefs="Object" >
      </scope>
      <variable name="TRUE" attributes="__const__" citdl="TrueClass" />
      <scope name="FalseClass" ilk="class" classrefs="Object" >
      </scope>
      <variable name="FALSE" attributes="__const__" citdl="FalseClass" />
      <scope name="Encoding" ilk="class" classrefs="Object" >
        <scope name="_dump" ilk="function" />
        <scope name="ascii_compatible?" ilk="function" signature="ascii_compatible?()" doc="Returns whether ASCII-compatible or not. &#xA;   Encoding::UTF_8.ascii_compatible?     =&gt; true&#xA;  Encoding::UTF_16BE.ascii_compatible?  =&gt; false" />
        <scope name="dummy?" ilk="function" signature="dummy?()" doc="Returns true for dummy encodings. A dummy encoding is an encoding for which character handling is not properly implemented. It is used for stateful encodings. &#xA;   Encoding::ISO_2022_JP.dummy?       =&gt; true&#xA;  Encoding::UTF_8.dummy?             =&gt; false" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the encoding. &#xA;   Encoding::UTF_8.name      =&gt; &quot;UTF-8&quot;" />
        <scope name="names" ilk="function" signature="names()" doc="Returns the list of name and aliases of the encoding. &#xA;   Encoding::WINDOWS_31J.names  =&gt; [&quot;Windows-31J&quot;, &quot;CP932&quot;, &quot;csWindows31J&quot;]" />
        <scope name="replicate" ilk="function" signature="replicate(p1)" doc="Returns a replicated encoding of _enc_ whose name is _name_. The new encoding should have the same byte structure of _enc_. If _name_ is used by another encoding, raise ArgumentError." />
        <scope name="_load" ilk="function" attributes="__classmethod__" />
        <scope name="aliases" ilk="function" attributes="__classmethod__" signature="aliases()" doc="Returns the hash of available encoding alias and original encoding name. &#xA;   Encoding.aliases&#xA;  =&gt; {&quot;BINARY&quot;=&gt;&quot;ASCII-8BIT&quot;, &quot;ASCII&quot;=&gt;&quot;US-ASCII&quot;, &quot;ANSI_X3.4-1986&quot;=&gt;&quot;US-ASCII&quot;,&#xA;        &quot;SJIS&quot;=&gt;&quot;Shift_JIS&quot;, &quot;eucJP&quot;=&gt;&quot;EUC-JP&quot;, &quot;CP932&quot;=&gt;&quot;Windows-31J&quot;}" />
        <scope name="compatible?" ilk="function" attributes="__classmethod__" signature="compatible?(p1, p2)" doc="Checks the compatibility of two strings. If they are compatible, means concatenatable, returns an encoding which the concatenated string will be. If they are not compatible, nil is returned. &#xA;   Encoding.compatible?(&quot;\xa1&quot;.force_encoding(&quot;iso-8859-1&quot;), &quot;b&quot;)&#xA;  =&gt; #&lt;Encoding:ISO-8859-1&gt;&#xA;&#xA;  Encoding.compatible?(&#xA;    &quot;\xa1&quot;.force_encoding(&quot;iso-8859-1&quot;),&#xA;    &quot;\xa1\xa1&quot;.force_encoding(&quot;euc-jp&quot;))&#xA;  =&gt; nil" />
        <scope name="default_external" ilk="function" attributes="__classmethod__" signature="default_external()" doc="Returns default external encoding. &#xA; It is initialized by the locale or -E option." />
        <scope name="default_external=" ilk="function" attributes="__classmethod__" signature="default_external=(p1)" doc="Sets default external encoding." />
        <scope name="default_internal" ilk="function" attributes="__classmethod__" signature="default_internal()" doc="Returns default internal encoding. &#xA; It is initialized by the source internal_encoding or -E option." />
        <scope name="default_internal=" ilk="function" attributes="__classmethod__" signature="default_internal=(p1)" doc="Sets default internal encoding. Or removes default internal encoding when passed nil." />
        <scope name="find" ilk="function" attributes="__classmethod__" signature="find(p1)" doc="Search the encoding with specified name. name should be a string or symbol. &#xA;   Encoding.find(&quot;US-ASCII&quot;)  =&gt; #&lt;Encoding:US-ASCII&gt;&#xA;  Encoding.find(:Shift_JIS)  =&gt; #&lt;Encoding:Shift_JIS&gt;&#xA; Names which this method accept are encoding names and aliases including following special aliases &#xA; default external encoding&#xA;default internal encoding&#xA;locale encoding&#xA;filesystem encoding &#xA; An ArgumentError is raised when no encoding with name. Only Encoding.find(&quot;internal&quot;) however returns nil when no encoding named &quot;internal&quot;, in other words, when Ruby has no default internal encoding." />
        <scope name="list" ilk="function" attributes="__classmethod__" signature="list()" doc="Returns the list of loaded encodings. &#xA;   Encoding.list&#xA;  =&gt; [#&lt;Encoding:ASCII-8BIT&gt;, #&lt;Encoding:UTF-8&gt;,&#xA;        #&lt;Encoding:ISO-2022-JP (dummy)&gt;]&#xA;&#xA;  Encoding.find(&quot;US-ASCII&quot;)&#xA;  =&gt; #&lt;Encoding:US-ASCII&gt;&#xA;&#xA;  Encoding.list&#xA;  =&gt; [#&lt;Encoding:ASCII-8BIT&gt;, #&lt;Encoding:UTF-8&gt;,&#xA;        #&lt;Encoding:US-ASCII&gt;, #&lt;Encoding:ISO-2022-JP (dummy)&gt;]" />
        <scope name="locale_charmap" ilk="function" attributes="__classmethod__" signature="locale_charmap()" doc="Returns the locale charmap name. &#xA;   Debian GNU/Linux&#xA;    LANG=C&#xA;      Encoding.locale_charmap  =&gt; &quot;ANSI_X3.4-1968&quot;&#xA;    LANG=ja_JP.EUC-JP&#xA;      Encoding.locale_charmap  =&gt; &quot;EUC-JP&quot;&#xA;&#xA;  SunOS 5&#xA;    LANG=C&#xA;      Encoding.locale_charmap  =&gt; &quot;646&quot;&#xA;    LANG=ja&#xA;      Encoding.locale_charmap  =&gt; &quot;eucJP&quot;&#xA; The result is highly platform dependent. So Encoding.find(Encoding.locale_charmap) may cause an error. If you need some encoding object even for unknown locale, Encoding.find(&quot;locale&quot;) can be used." />
        <scope name="name_list" ilk="function" attributes="__classmethod__" signature="name_list()" doc="Returns the list of available encoding names. &#xA;   Encoding.name_list&#xA;  =&gt; [&quot;US-ASCII&quot;, &quot;ASCII-8BIT&quot;, &quot;UTF-8&quot;,&#xA;        &quot;ISO-8859-1&quot;, &quot;Shift_JIS&quot;, &quot;EUC-JP&quot;,&#xA;        &quot;Windows-31J&quot;,&#xA;        &quot;BINARY&quot;, &quot;CP932&quot;, &quot;eucJP&quot;]" />
        <variable name="ANSI_X3_4_1968" attributes="__const__" citdl="Encoding" />
        <variable name="ASCII" attributes="__const__" citdl="Encoding" />
        <variable name="ASCII_8BIT" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5_HKSCS" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5_UAO" attributes="__const__" citdl="Encoding" />
        <variable name="BINARY" attributes="__const__" citdl="Encoding" />
        <variable name="Big5" attributes="__const__" citdl="Encoding" />
        <variable name="Big5_HKSCS" attributes="__const__" citdl="Encoding" />
        <variable name="Big5_UAO" attributes="__const__" citdl="Encoding" />
        <variable name="CP1250" attributes="__const__" citdl="Encoding" />
        <variable name="CP1251" attributes="__const__" citdl="Encoding" />
        <variable name="CP1252" attributes="__const__" citdl="Encoding" />
        <variable name="CP1253" attributes="__const__" citdl="Encoding" />
        <variable name="CP1254" attributes="__const__" citdl="Encoding" />
        <variable name="CP1255" attributes="__const__" citdl="Encoding" />
        <variable name="CP1256" attributes="__const__" citdl="Encoding" />
        <variable name="CP1257" attributes="__const__" citdl="Encoding" />
        <variable name="CP1258" attributes="__const__" citdl="Encoding" />
        <variable name="CP437" attributes="__const__" citdl="Encoding" />
        <variable name="CP50220" attributes="__const__" citdl="Encoding" />
        <variable name="CP50221" attributes="__const__" citdl="Encoding" />
        <variable name="CP51932" attributes="__const__" citdl="Encoding" />
        <variable name="CP65000" attributes="__const__" citdl="Encoding" />
        <variable name="CP65001" attributes="__const__" citdl="Encoding" />
        <variable name="CP737" attributes="__const__" citdl="Encoding" />
        <variable name="CP775" attributes="__const__" citdl="Encoding" />
        <variable name="CP850" attributes="__const__" citdl="Encoding" />
        <variable name="CP852" attributes="__const__" citdl="Encoding" />
        <variable name="CP855" attributes="__const__" citdl="Encoding" />
        <variable name="CP857" attributes="__const__" citdl="Encoding" />
        <variable name="CP860" attributes="__const__" citdl="Encoding" />
        <variable name="CP861" attributes="__const__" citdl="Encoding" />
        <variable name="CP862" attributes="__const__" citdl="Encoding" />
        <variable name="CP863" attributes="__const__" citdl="Encoding" />
        <variable name="CP864" attributes="__const__" citdl="Encoding" />
        <variable name="CP865" attributes="__const__" citdl="Encoding" />
        <variable name="CP866" attributes="__const__" citdl="Encoding" />
        <variable name="CP869" attributes="__const__" citdl="Encoding" />
        <variable name="CP874" attributes="__const__" citdl="Encoding" />
        <variable name="CP878" attributes="__const__" citdl="Encoding" />
        <variable name="CP932" attributes="__const__" citdl="Encoding" />
        <variable name="CP936" attributes="__const__" citdl="Encoding" />
        <variable name="CP949" attributes="__const__" citdl="Encoding" />
        <variable name="CP950" attributes="__const__" citdl="Encoding" />
        <variable name="CP951" attributes="__const__" citdl="Encoding" />
        <variable name="CSWINDOWS31J" attributes="__const__" citdl="Encoding" />
        <scope name="CompatibilityError" ilk="class" classrefs="EncodingError" >
        </scope>
        <scope name="Converter" ilk="class" classrefs="Data" >
          <scope name="convert" ilk="function" />
          <scope name="convpath" ilk="function" />
          <scope name="destination_encoding" ilk="function" />
          <scope name="finish" ilk="function" />
          <scope name="insert_output" ilk="function" />
          <scope name="last_error" ilk="function" />
          <scope name="primitive_convert" ilk="function" />
          <scope name="primitive_errinfo" ilk="function" />
          <scope name="putback" ilk="function" />
          <scope name="replacement" ilk="function" />
          <scope name="replacement=" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="asciicompat_encoding" ilk="function" attributes="__classmethod__" />
          <scope name="search_convpath" ilk="function" attributes="__classmethod__" />
          <variable name="AFTER_OUTPUT" attributes="__const__" citdl="Fixnum" />
          <variable name="CRLF_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="CR_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="INVALID_MASK" attributes="__const__" citdl="Fixnum" />
          <variable name="INVALID_REPLACE" attributes="__const__" citdl="Fixnum" />
          <variable name="PARTIAL_INPUT" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_HEX_CHARREF" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_MASK" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_REPLACE" attributes="__const__" citdl="Fixnum" />
          <variable name="UNIVERSAL_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_ATTR_CONTENT_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_ATTR_QUOTE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_TEXT_DECORATOR" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ConverterNotFoundError" ilk="class" classrefs="EncodingError" >
        </scope>
        <variable name="CsWindows31J" attributes="__const__" citdl="Encoding" />
        <variable name="EMACS_MULE" attributes="__const__" citdl="Encoding" />
        <variable name="EUCCN" attributes="__const__" citdl="Encoding" />
        <variable name="EUCJP" attributes="__const__" citdl="Encoding" />
        <variable name="EUCJP_MS" attributes="__const__" citdl="Encoding" />
        <variable name="EUCKR" attributes="__const__" citdl="Encoding" />
        <variable name="EUCTW" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_CN" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_JP" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_JP_MS" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_KR" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_TW" attributes="__const__" citdl="Encoding" />
        <variable name="Emacs_Mule" attributes="__const__" citdl="Encoding" />
        <variable name="EucCN" attributes="__const__" citdl="Encoding" />
        <variable name="EucJP" attributes="__const__" citdl="Encoding" />
        <variable name="EucJP_ms" attributes="__const__" citdl="Encoding" />
        <variable name="EucKR" attributes="__const__" citdl="Encoding" />
        <variable name="EucTW" attributes="__const__" citdl="Encoding" />
        <variable name="GB12345" attributes="__const__" citdl="Encoding" />
        <variable name="GB18030" attributes="__const__" citdl="Encoding" />
        <variable name="GB1988" attributes="__const__" citdl="Encoding" />
        <variable name="GBK" attributes="__const__" citdl="Encoding" />
        <variable name="IBM437" attributes="__const__" citdl="Encoding" />
        <variable name="IBM737" attributes="__const__" citdl="Encoding" />
        <variable name="IBM775" attributes="__const__" citdl="Encoding" />
        <variable name="IBM850" attributes="__const__" citdl="Encoding" />
        <variable name="IBM852" attributes="__const__" citdl="Encoding" />
        <variable name="IBM855" attributes="__const__" citdl="Encoding" />
        <variable name="IBM857" attributes="__const__" citdl="Encoding" />
        <variable name="IBM860" attributes="__const__" citdl="Encoding" />
        <variable name="IBM861" attributes="__const__" citdl="Encoding" />
        <variable name="IBM862" attributes="__const__" citdl="Encoding" />
        <variable name="IBM863" attributes="__const__" citdl="Encoding" />
        <variable name="IBM864" attributes="__const__" citdl="Encoding" />
        <variable name="IBM865" attributes="__const__" citdl="Encoding" />
        <variable name="IBM866" attributes="__const__" citdl="Encoding" />
        <variable name="IBM869" attributes="__const__" citdl="Encoding" />
        <variable name="ISO2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="ISO2022_JP2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_1" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_10" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_11" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_13" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_14" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_15" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_16" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_3" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_4" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_5" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_6" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_7" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_8" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_9" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_1" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_10" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_11" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_13" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_14" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_15" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_16" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_3" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_4" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_5" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_6" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_7" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_8" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_9" attributes="__const__" citdl="Encoding" />
        <scope name="InvalidByteSequenceError" ilk="class" classrefs="EncodingError" >
          <scope name="destination_encoding" ilk="function" />
          <scope name="destination_encoding_name" ilk="function" />
          <scope name="error_bytes" ilk="function" />
          <scope name="incomplete_input?" ilk="function" />
          <scope name="readagain_bytes" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="source_encoding_name" ilk="function" />
        </scope>
        <variable name="KOI8_R" attributes="__const__" citdl="Encoding" />
        <variable name="KOI8_U" attributes="__const__" citdl="Encoding" />
        <variable name="MACCENTEURO" attributes="__const__" citdl="Encoding" />
        <variable name="MACCROATIAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACCYRILLIC" attributes="__const__" citdl="Encoding" />
        <variable name="MACGREEK" attributes="__const__" citdl="Encoding" />
        <variable name="MACICELAND" attributes="__const__" citdl="Encoding" />
        <variable name="MACJAPAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACJAPANESE" attributes="__const__" citdl="Encoding" />
        <variable name="MACROMAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACROMANIA" attributes="__const__" citdl="Encoding" />
        <variable name="MACTHAI" attributes="__const__" citdl="Encoding" />
        <variable name="MACTURKISH" attributes="__const__" citdl="Encoding" />
        <variable name="MACUKRAINE" attributes="__const__" citdl="Encoding" />
        <variable name="MacCentEuro" attributes="__const__" citdl="Encoding" />
        <variable name="MacCroatian" attributes="__const__" citdl="Encoding" />
        <variable name="MacCyrillic" attributes="__const__" citdl="Encoding" />
        <variable name="MacGreek" attributes="__const__" citdl="Encoding" />
        <variable name="MacIceland" attributes="__const__" citdl="Encoding" />
        <variable name="MacJapan" attributes="__const__" citdl="Encoding" />
        <variable name="MacJapanese" attributes="__const__" citdl="Encoding" />
        <variable name="MacRoman" attributes="__const__" citdl="Encoding" />
        <variable name="MacRomania" attributes="__const__" citdl="Encoding" />
        <variable name="MacThai" attributes="__const__" citdl="Encoding" />
        <variable name="MacTurkish" attributes="__const__" citdl="Encoding" />
        <variable name="MacUkraine" attributes="__const__" citdl="Encoding" />
        <variable name="SHIFT_JIS" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_DOCOMO" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_DoCoMo" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_SOFTBANK" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_SoftBank" attributes="__const__" citdl="Encoding" />
        <variable name="STATELESS_ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="STATELESS_ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="Shift_JIS" attributes="__const__" citdl="Encoding" />
        <variable name="Stateless_ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="Stateless_ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="TIS_620" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_2BE" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_4BE" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_4LE" attributes="__const__" citdl="Encoding" />
        <variable name="US_ASCII" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_DOCOMO" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_DoCoMo" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_MAC" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_SOFTBANK" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_SoftBank" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_16BE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_16LE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_32BE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_32LE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_7" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8_HFS" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8_MAC" attributes="__const__" citdl="Encoding" />
        <scope name="UndefinedConversionError" ilk="class" classrefs="EncodingError" >
          <scope name="destination_encoding" ilk="function" />
          <scope name="destination_encoding_name" ilk="function" />
          <scope name="error_char" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="source_encoding_name" ilk="function" />
        </scope>
        <variable name="WINDOWS_1250" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1251" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1252" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1253" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1254" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1255" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1256" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1257" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1258" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_31J" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_874" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1250" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1251" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1252" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1253" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1254" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1255" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1256" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1257" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1258" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_31J" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_874" attributes="__const__" citdl="Encoding" />
      </scope>
      <scope name="Comparable" ilk="namespace" >
        <scope name="between?" ilk="function" signature="between?(p1, p2)" doc="Returns false if obj &lt;=&gt; min is less than zero or if anObject &lt;=&gt; max is greater than zero, true otherwise. &#xA;    3.between?(1, 5)               =&gt; true&#xA;   6.between?(1, 5)               =&gt; false&#xA;   &apos;cat&apos;.between?(&apos;ant&apos;, &apos;dog&apos;)   =&gt; true&#xA;   &apos;gnu&apos;.between?(&apos;ant&apos;, &apos;dog&apos;)   =&gt; false" />
      </scope>
      <scope name="Enumerable" ilk="namespace" >
        <scope name="all?" ilk="function" signature="all?()" doc="Passes each element of the collection to the given block. The method returns true if the block never returns false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is all? will return true only if none of the collection members are false or nil.) &#xA;    %w{ant bear cat}.all? {|word| word.length &gt;= 3}   =&gt; true&#xA;   %w{ant bear cat}.all? {|word| word.length &gt;= 4}   =&gt; false&#xA;   [ nil, true, 99 ].all?                            =&gt; false" />
        <scope name="any?" ilk="function" signature="any?()" doc="Passes each element of the collection to the given block. The method returns true if the block ever returns a value other than false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is any? will return true if at least one of the collection members is not false or nil. &#xA;    %w{ant bear cat}.any? {|word| word.length &gt;= 3}   =&gt; true&#xA;   %w{ant bear cat}.any? {|word| word.length &gt;= 4}   =&gt; true&#xA;   [ nil, true, 99 ].any?                            =&gt; true" />
        <scope name="chunk" ilk="function" signature="chunk(...)" doc="Creates an enumerator for each chunked elements. The consecutive elements which have same block value are chunked. &#xA; The result enumerator yields the block value and an array of chunked elements. So &quot;each&quot; method can be called as follows. &#xA;   enum.chunk {|elt| key }.each {|key, ary| ... }&#xA;  enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }&#xA; For example, consecutive even numbers and odd numbers can be splitted as follows. &#xA;   [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|&#xA;    n.even?&#xA;  }.each {|even, ary|&#xA;    p [even, ary]&#xA;  }&#xA;  =&gt; [false, [3, 1]]&#xA;  #   [true, [4]]&#xA;  #   [false, [1, 5, 9]]" />
        <scope name="collect" ilk="function" signature="collect()" doc="Returns a new array with the results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..4).collect {|i| i*i }   =&gt; [1, 4, 9, 16]&#xA;   (1..4).collect { &quot;cat&quot;  }   =&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]" />
        <scope name="collect_concat" ilk="function" signature="collect_concat()" doc="Returns a new array with the concatenated results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA;    [[1,2],[3,4]].flat_map {|i| i }   =&gt; [1, 2, 3, 4]" />
        <scope name="count" ilk="function" signature="count(...)" doc="Returns the number of items in enum, where #size is called if it responds to it, otherwise the items are counted through enumeration.  If an argument is given, counts the number of items in enum, for which equals to item.  If a block is given, counts the number of elements yielding a true value. &#xA;    ary = [1, 2, 4, 2]&#xA;   ary.count             =&gt; 4&#xA;   ary.count(2)          =&gt; 2&#xA;   ary.count{|x|x%2==0}  =&gt; 3" />
        <scope name="cycle" ilk="function" signature="cycle(...)" doc="Calls block for each element of enum repeatedly _n_ times or forever if none or +nil+ is given.  If a non-positive number is given or the collection is empty, does nothing.  Returns +nil+ if the loop has finished without getting interrupted. &#xA; Enumerable#cycle saves elements in an internal array so changes to enum after the first pass have no effect. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;   a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.&#xA;   a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c." />
        <scope name="detect" ilk="function" signature="detect(...)" doc="Passes each entry in enum to block. Returns the first for which block is not false.  If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 35" />
        <scope name="drop" ilk="function" signature="drop(p1)" doc="Drops first n elements from enum, and returns rest elements in an array. &#xA;    a = [1, 2, 3, 4, 5, 0]&#xA;   a.drop(3)             =&gt; [4, 5, 0]" />
        <scope name="drop_while" ilk="function" signature="drop_while()" doc="Drops elements up to, but not including, the first element for which the block returns +nil+ or +false+ and returns an array containing the remaining elements. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [1, 2, 3, 4, 5, 0]&#xA;   a.drop_while {|i| i &lt; 3 }   =&gt; [3, 4, 5, 0]" />
        <scope name="each_cons" ilk="function" signature="each_cons(p1)" doc="Iterates the given block for each array of consecutive &lt;n&gt; elements.  If no block is given, returns an enumerator. &#xA; e.g.:     (1..10).each_cons(3) {|a| p a}&#xA;    # outputs below&#xA;    [1, 2, 3]&#xA;    [2, 3, 4]&#xA;    [3, 4, 5]&#xA;    [4, 5, 6]&#xA;    [5, 6, 7]&#xA;    [6, 7, 8]&#xA;    [7, 8, 9]&#xA;    [8, 9, 10]" />
        <scope name="each_entry" ilk="function" signature="each_entry(...)" doc="Calls block once for each element in +self+, passing that element as a parameter, converting multiple values from yield to an array. &#xA; If no block is given, an enumerator is returned instead. &#xA;    class Foo&#xA;     include Enumerable&#xA;     def each&#xA;       yield 1&#xA;       yield 1,2&#xA;     end&#xA;   end&#xA;   Foo.new.each_entry{|o| print o, &quot; -- &quot;}&#xA; produces: &#xA;    1 -- [1, 2] --" />
        <scope name="each_slice" ilk="function" signature="each_slice(p1)" doc="Iterates the given block for each slice of &lt;n&gt; elements.  If no block is given, returns an enumerator. &#xA; e.g.:     (1..10).each_slice(3) {|a| p a}&#xA;    # outputs below&#xA;    [1, 2, 3]&#xA;    [4, 5, 6]&#xA;    [7, 8, 9]&#xA;    [10]" />
        <scope name="each_with_index" ilk="function" signature="each_with_index(...)" doc="Calls block with two arguments, the item and its index, for each item in enum.  Given arguments are passed through to #each(). &#xA; If no block is given, an enumerator is returned instead. &#xA;    hash = Hash.new&#xA;   %w(cat dog wombat).each_with_index {|item, index|&#xA;     hash[item] = index&#xA;   }&#xA;   hash   =&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}" />
        <scope name="each_with_object" ilk="function" signature="each_with_object(p1)" doc="Iterates the given block for each element with an arbitrary object given, and returns the initially given object. &#xA; If no block is given, returns an enumerator. &#xA; e.g.:     evens = (1..10).each_with_object([]) {|i, a| a &lt;&lt; i*2 }&#xA;    =&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]" />
        <scope name="entries" ilk="function" signature="entries(...)" doc="Returns an array containing the items in enum. &#xA;    (1..7).to_a                       =&gt; [1, 2, 3, 4, 5, 6, 7]&#xA;   { &apos;a&apos;=&gt;1, &apos;b&apos;=&gt;2, &apos;c&apos;=&gt;3 }.to_a   =&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]" />
        <scope name="find" ilk="function" signature="find(...)" doc="Passes each entry in enum to block. Returns the first for which block is not false.  If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;   (1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 35" />
        <scope name="find_all" ilk="function" signature="find_all()" doc="Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject). &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..10).find_all {|i|  i % 3 == 0 }   =&gt; [3, 6, 9]" />
        <scope name="find_index" ilk="function" signature="find_index(...)" doc="Compares each entry in enum with value or passes to block.  Returns the index for the first for which the evaluated value is non-false.  If no object matches, returns nil &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA;    (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;   (1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 34&#xA;   (1..100).find_index(50)                                =&gt; 49" />
        <scope name="first" ilk="function" signature="first(...)" doc="Returns the first element, or the first +n+ elements, of the enumerable. If the enumerable is empty, the first form returns nil, and the second form returns an empty array." />
        <scope name="flat_map" ilk="function" signature="flat_map()" doc="Returns a new array with the concatenated results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA;    [[1,2],[3,4]].flat_map {|i| i }   =&gt; [1, 2, 3, 4]" />
        <scope name="grep" ilk="function" signature="grep(p1)" doc="Returns an array of every element in enum for which Pattern === element. If the optional block is supplied, each matching element is passed to it, and the block&apos;s result is stored in the output array. &#xA;    (1..100).grep 38..44   =&gt; [38, 39, 40, 41, 42, 43, 44]&#xA;   c = IO.constants&#xA;   c.grep(/SEEK/)         =&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]&#xA;   res = c.grep(/SEEK/) {|v| IO.const_get(v) }&#xA;   res                    =&gt; [0, 1, 2]" />
        <scope name="group_by" ilk="function" signature="group_by()" doc="Returns a hash, which keys are evaluated result from the block, and values are arrays of elements in enum corresponding to the key. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..6).group_by {|i| i%3}   =&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}" />
        <scope name="inject" ilk="function" signature="inject(...)" doc="   enum.reduce(initial, sym) -&gt; obj&#xA;   enum.reduce(sym)          -&gt; obj&#xA;   enum.reduce(initial) {| memo, obj | block }  -&gt; obj&#xA;   enum.reduce          {| memo, obj | block }  -&gt; obj&#xA; Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. &#xA; If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value fo the method. &#xA; If you do not explicitly specify an initial value for memo, then uses the first element of collection is used as the initial value of memo. &#xA; Examples: &#xA;    # Sum some numbers&#xA;   (5..10).reduce(:+)                            =&gt; 45&#xA;   # Same using a block and inject&#xA;   (5..10).inject {|sum, n| sum + n }            =&gt; 45&#xA;   # Multiply some numbers" />
        <scope name="map" ilk="function" signature="map()" doc="Returns a new array with the results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..4).collect {|i| i*i }   =&gt; [1, 4, 9, 16]&#xA;   (1..4).collect { &quot;cat&quot;  }   =&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]" />
        <scope name="max" ilk="function" signature="max()" doc="Returns the object in _enum_ with the maximum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA;    a = %w(albatross dog horse)&#xA;   a.max                                  =&gt; &quot;horse&quot;&#xA;   a.max {|a,b| a.length &lt;=&gt; b.length }   =&gt; &quot;albatross&quot;" />
        <scope name="max_by" ilk="function" signature="max_by()" doc="Returns the object in enum that gives the maximum value from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = %w(albatross dog horse)&#xA;   a.max_by {|x| x.length }   =&gt; &quot;albatross&quot;" />
        <scope name="member?" ilk="function" signature="member?(p1)" doc="Returns true if any member of enum equals obj. Equality is tested using ==. &#xA;    IO.constants.include? :SEEK_SET          =&gt; true&#xA;   IO.constants.include? :SEEK_NO_FURTHER   =&gt; false" />
        <scope name="min" ilk="function" signature="min()" doc="Returns the object in enum with the minimum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA;    a = %w(albatross dog horse)&#xA;   a.min                                  =&gt; &quot;albatross&quot;&#xA;   a.min {|a,b| a.length &lt;=&gt; b.length }   =&gt; &quot;dog&quot;" />
        <scope name="min_by" ilk="function" signature="min_by()" doc="Returns the object in enum that gives the minimum value from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = %w(albatross dog horse)&#xA;   a.min_by {|x| x.length }   =&gt; &quot;dog&quot;" />
        <scope name="minmax" ilk="function" signature="minmax()" doc="Returns two elements array which contains the minimum and the maximum value in the enumerable.  The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA;    a = %w(albatross dog horse)&#xA;   a.minmax                                  =&gt; [&quot;albatross&quot;, &quot;horse&quot;]&#xA;   a.minmax {|a,b| a.length &lt;=&gt; b.length }   =&gt; [&quot;dog&quot;, &quot;albatross&quot;]" />
        <scope name="minmax_by" ilk="function" signature="minmax_by()" doc="Returns two elements array array containing the objects in enum that gives the minimum and maximum values respectively from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = %w(albatross dog horse)&#xA;   a.minmax_by {|x| x.length }   =&gt; [&quot;dog&quot;, &quot;albatross&quot;]" />
        <scope name="none?" ilk="function" signature="none?()" doc="Passes each element of the collection to the given block. The method returns true if the block never returns true for all elements. If the block is not given, none? will return true only if none of the collection members is true. &#xA;    %w{ant bear cat}.none? {|word| word.length == 5}  =&gt; true&#xA;   %w{ant bear cat}.none? {|word| word.length &gt;= 4}  =&gt; false&#xA;   [].none?                                          =&gt; true&#xA;   [nil].none?                                       =&gt; true&#xA;   [nil,false].none?                                 =&gt; true" />
        <scope name="one?" ilk="function" signature="one?()" doc="Passes each element of the collection to the given block. The method returns true if the block returns true exactly once. If the block is not given, one? will return true only if exactly one of the collection members is true. &#xA;    %w{ant bear cat}.one? {|word| word.length == 4}   =&gt; true&#xA;   %w{ant bear cat}.one? {|word| word.length &gt; 4}    =&gt; false&#xA;   %w{ant bear cat}.one? {|word| word.length &lt; 4}    =&gt; false&#xA;   [ nil, true, 99 ].one?                            =&gt; false&#xA;   [ nil, true, false ].one?                         =&gt; true" />
        <scope name="partition" ilk="function" signature="partition()" doc="Returns two arrays, the first containing the elements of enum for which the block evaluates to true, the second containing the rest. &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..6).partition {|i| (i&amp;1).zero?}   =&gt; [[2, 4, 6], [1, 3, 5]]" />
        <scope name="reduce" ilk="function" signature="reduce(...)" doc="   enum.reduce(initial, sym) -&gt; obj&#xA;   enum.reduce(sym)          -&gt; obj&#xA;   enum.reduce(initial) {| memo, obj | block }  -&gt; obj&#xA;   enum.reduce          {| memo, obj | block }  -&gt; obj&#xA; Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. &#xA; If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value fo the method. &#xA; If you do not explicitly specify an initial value for memo, then uses the first element of collection is used as the initial value of memo. &#xA; Examples: &#xA;    # Sum some numbers&#xA;   (5..10).reduce(:+)                            =&gt; 45&#xA;   # Same using a block and inject&#xA;   (5..10).inject {|sum, n| sum + n }            =&gt; 45&#xA;   # Multiply some numbers" />
        <scope name="reject" ilk="function" signature="reject()" doc="Returns an array for all elements of enum for which block is false (see also Enumerable#find_all). &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..10).reject {|i|  i % 3 == 0 }   =&gt; [1, 2, 4, 5, 7, 8, 10]" />
        <scope name="reverse_each" ilk="function" signature="reverse_each(...)" doc="Builds a temporary array and traverses that array in reverse order. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="select" ilk="function" signature="select()" doc="Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject). &#xA; If no block is given, an enumerator is returned instead. &#xA;    (1..10).find_all {|i|  i % 3 == 0 }   =&gt; [3, 6, 9]" />
        <scope name="slice_before" ilk="function" signature="slice_before(...)" doc=" &#xA; Creates an enumerator for each chunked elements.&#xA; The beginnings of chunks are defined by _pattern_ and the block.&#xA; If _pattern_ === _elt_ returns true or&#xA; the block returns true for the element,&#xA; the element is beginning of a chunk.&#xA; The === and block is called from the first element to the last element&#xA; of _enum_.&#xA; The result for the first element is ignored.&#xA; The result enumerator yields the chunked elements as an array for +each+&#xA; method.&#xA; +each+ method can be called as follows.&#xA;   enum.slice_before(pattern).each {|ary| ... }" />
        <scope name="sort" ilk="function" signature="sort()" doc="Returns an array containing the items in enum sorted, either according to their own &lt;=&gt; method, or by using the results of the supplied block. The block should return -1, 0, or +1 depending on the comparison between a and b. As of Ruby 1.8, the method Enumerable#sort_by implements a built-in Schwartzian Transform, useful when key computation or comparison is expensive. &#xA;    %w(rhea kea flea).sort         =&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]&#xA;   (1..10).sort {|a,b| b &lt;=&gt; a}   =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]" />
        <scope name="sort_by" ilk="function" signature="sort_by()" doc="Sorts enum using a set of keys generated by mapping the values in enum through the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    %w{ apple pear fig }.sort_by {|word| word.length}&#xA;                 =&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]&#xA; The current implementation of sort_by generates an array of tuples containing the original collection element and the mapped value. This makes sort_by fairly expensive when the keysets are simple &#xA;    require &apos;benchmark&apos;&#xA;   a = (1..100000).map {rand(100000)}&#xA;   Benchmark.bm(10) do |b|&#xA;     b.report(&quot;Sort&quot;)    { a.sort }&#xA;     b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }&#xA;   end&#xA; produces: &#xA;    user     system      total        real" />
        <scope name="take" ilk="function" signature="take(p1)" doc="Returns first n elements from enum. &#xA;    a = [1, 2, 3, 4, 5, 0]&#xA;   a.take(3)             =&gt; [1, 2, 3]" />
        <scope name="take_while" ilk="function" signature="take_while()" doc="Passes elements to the block until the block returns +nil+ or +false+, then stops iterating and returns an array of all prior elements. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [1, 2, 3, 4, 5, 0]&#xA;   a.take_while {|i| i &lt; 3 }   =&gt; [1, 2]" />
        <scope name="to_a" ilk="function" signature="to_a(...)" doc="Returns an array containing the items in enum. &#xA;    (1..7).to_a                       =&gt; [1, 2, 3, 4, 5, 6, 7]&#xA;   { &apos;a&apos;=&gt;1, &apos;b&apos;=&gt;2, &apos;c&apos;=&gt;3 }.to_a   =&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]" />
        <scope name="zip" ilk="function" signature="zip(...)" doc="Takes one element from enum and merges corresponding elements from each args.  This generates a sequence of n-element arrays, where n is one more than the count of arguments.  The length of the resulting sequence will be enum#size.  If the size of any argument is less than enum#size, nil values are supplied. If a block is given, it is invoked for each output array, otherwise an array of arrays is returned. &#xA;    a = [ 4, 5, 6 ]&#xA;   b = [ 7, 8, 9 ]&#xA;&#xA;   [1,2,3].zip(a, b)      =&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]&#xA;   [1,2].zip(a,b)         =&gt; [[1, 4, 7], [2, 5, 8]]&#xA;   a.zip([1,2],[8])       =&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]" />
      </scope>
      <scope name="String" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="ascii_only?" ilk="function" signature="ascii_only?()" doc="Returns true for a string which has only ASCII characters. &#xA;   &quot;abc&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?          =&gt; true&#xA;  &quot;abc\u{6666}&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?  =&gt; false" />
        <scope name="bytes" ilk="function" signature="bytes()" doc="   str.each_byte {|fixnum| block }    -&gt; str&#xA;   str.each_byte                      -&gt; an_enumerator&#xA; Passes each byte in str to the given block, or returns an enumerator if no block is given. &#xA;    &quot;hello&quot;.each_byte {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    104 101 108 108 111" />
        <scope name="bytesize" ilk="function" signature="bytesize()" doc="Returns the length of str in bytes." />
        <scope name="capitalize" ilk="function" signature="capitalize()" doc="Returns a copy of str with the first character converted to uppercase and the remainder to lowercase. Note: case conversion is effective only in ASCII region. &#xA;    &quot;hello&quot;.capitalize    =&gt; &quot;Hello&quot;&#xA;   &quot;HELLO&quot;.capitalize    =&gt; &quot;Hello&quot;&#xA;   &quot;123ABC&quot;.capitalize   =&gt; &quot;123abc&quot;" />
        <scope name="capitalize!" ilk="function" signature="capitalize!()" doc="Modifies str by converting the first character to uppercase and the remainder to lowercase. Returns nil if no changes are made. Note: case conversion is effective only in ASCII region. &#xA;    a = &quot;hello&quot;&#xA;   a.capitalize!   =&gt; &quot;Hello&quot;&#xA;   a               =&gt; &quot;Hello&quot;&#xA;   a.capitalize!   =&gt; nil" />
        <scope name="casecmp" ilk="function" signature="casecmp(p1)" doc="Case-insensitive version of String#&lt;=&gt;. &#xA;    &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     =&gt; 1&#xA;   &quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    =&gt; 0&#xA;   &quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   =&gt; -1&#xA;   &quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    =&gt; 0" />
        <scope name="center" ilk="function" signature="center(...)" doc="If integer is greater than the length of str, returns a new String of length integer with str centered and padded with padstr; otherwise, returns str. &#xA;    &quot;hello&quot;.center(4)         =&gt; &quot;hello&quot;&#xA;   &quot;hello&quot;.center(20)        =&gt; &quot;       hello        &quot;&#xA;   &quot;hello&quot;.center(20, &apos;123&apos;) =&gt; &quot;1231231hello12312312&quot;" />
        <scope name="chars" ilk="function" signature="chars()" doc="   str.each_char {|cstr| block }    -&gt; str&#xA;   str.each_char                    -&gt; an_enumerator&#xA; Passes each character in str to the given block, or returns an enumerator if no block is given. &#xA;    &quot;hello&quot;.each_char {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    h e l l o" />
        <scope name="chomp" ilk="function" signature="chomp(...)" doc="Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n). &#xA;    &quot;hello&quot;.chomp            =&gt; &quot;hello&quot;&#xA;   &quot;hello\n&quot;.chomp          =&gt; &quot;hello&quot;&#xA;   &quot;hello\r\n&quot;.chomp        =&gt; &quot;hello&quot;&#xA;   &quot;hello\n\r&quot;.chomp        =&gt; &quot;hello\n&quot;&#xA;   &quot;hello\r&quot;.chomp          =&gt; &quot;hello&quot;&#xA;   &quot;hello \n there&quot;.chomp   =&gt; &quot;hello \n there&quot;&#xA;   &quot;hello&quot;.chomp(&quot;llo&quot;)     =&gt; &quot;he&quot;" />
        <scope name="chomp!" ilk="function" signature="chomp!(...)" doc="Modifies str in place as described for String#chomp, returning str, or nil if no modifications were made." />
        <scope name="chop" ilk="function" signature="chop()" doc="Returns a new String with the last character removed.  If the string ends with \r\n, both characters are removed. Applying chop to an empty string returns an empty string. String#chomp is often a safer alternative, as it leaves the string unchanged if it doesn&apos;t end in a record separator. &#xA;    &quot;string\r\n&quot;.chop   =&gt; &quot;string&quot;&#xA;   &quot;string\n\r&quot;.chop   =&gt; &quot;string\n&quot;&#xA;   &quot;string\n&quot;.chop     =&gt; &quot;string&quot;&#xA;   &quot;string&quot;.chop       =&gt; &quot;strin&quot;&#xA;   &quot;x&quot;.chop.chop       =&gt; &quot;&quot;" />
        <scope name="chop!" ilk="function" signature="chop!()" doc="Processes str as for String#chop, returning str, or nil if str is the empty string.  See also String#chomp!." />
        <scope name="chr" ilk="function" signature="chr()" doc="Returns a one-character string at the beginning of the string. &#xA;    a = &quot;abcde&quot;&#xA;   a.chr    =&gt; &quot;a&quot;" />
        <scope name="clear" ilk="function" signature="clear()" doc="Makes string empty. &#xA;    a = &quot;abcde&quot;&#xA;   a.clear    =&gt; &quot;&quot;" />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="   str.each_codepoint {|integer| block }    -&gt; str&#xA;   str.each_codepoint                       -&gt; an_enumerator&#xA; Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    &quot;hello\u0639&quot;.each_codepoint {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    104 101 108 108 111 1593" />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Append---Concatenates the given object to str. If the object is a Integer, it is considered as a codepoint, and is converted to a character before concatenation. &#xA;    a = &quot;hello &quot;&#xA;   a &lt;&lt; &quot;world&quot;   =&gt; &quot;hello world&quot;&#xA;   a.concat(33)   =&gt; &quot;hello world!&quot;" />
        <scope name="count" ilk="function" signature="count(...)" doc="Each other_str parameter defines a set of characters to count.  The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1--c2 means all characters between c1 and c2. &#xA;    a = &quot;hello world&quot;&#xA;   a.count &quot;lo&quot;            =&gt; 5&#xA;   a.count &quot;lo&quot;, &quot;o&quot;       =&gt; 2&#xA;   a.count &quot;hello&quot;, &quot;^l&quot;   =&gt; 4&#xA;   a.count &quot;ej-m&quot;          =&gt; 4" />
        <scope name="crypt" ilk="function" signature="crypt(p1)" doc="Applies a one-way cryptographic hash to str by invoking the standard library function crypt. The argument is the salt string, which should be two characters long, each character drawn from [a-zA-Z0-9./]." />
        <scope name="delete" ilk="function" signature="delete(...)" doc="Returns a copy of str with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as String#count. &#xA;    &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        =&gt; &quot;heo&quot;&#xA;   &quot;hello&quot;.delete &quot;lo&quot;            =&gt; &quot;he&quot;&#xA;   &quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   =&gt; &quot;hell&quot;&#xA;   &quot;hello&quot;.delete &quot;ej-m&quot;          =&gt; &quot;ho&quot;" />
        <scope name="delete!" ilk="function" signature="delete!(...)" doc="Performs a delete operation in place, returning str, or nil if str was not modified." />
        <scope name="downcase" ilk="function" signature="downcase()" doc="Returns a copy of str with all uppercase letters replaced with their lowercase counterparts. The operation is locale insensitive---only characters ``A&apos;&apos; to ``Z&apos;&apos; are affected. Note: case replacement is effective only in ASCII region. &#xA;    &quot;hEllO&quot;.downcase   =&gt; &quot;hello&quot;" />
        <scope name="downcase!" ilk="function" signature="downcase!()" doc="Downcases the contents of str, returning nil if no changes were made. Note: case replacement is effective only in ASCII region." />
        <scope name="dump" ilk="function" signature="dump()" doc="Produces a version of str with all nonprinting characters replaced by \nnn notation and all special characters escaped." />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="   str.each_byte {|fixnum| block }    -&gt; str&#xA;   str.each_byte                      -&gt; an_enumerator&#xA; Passes each byte in str to the given block, or returns an enumerator if no block is given. &#xA;    &quot;hello&quot;.each_byte {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    104 101 108 108 111" />
        <scope name="each_char" ilk="function" signature="each_char()" doc="   str.each_char {|cstr| block }    -&gt; str&#xA;   str.each_char                    -&gt; an_enumerator&#xA; Passes each character in str to the given block, or returns an enumerator if no block is given. &#xA;    &quot;hello&quot;.each_char {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    h e l l o" />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="   str.each_codepoint {|integer| block }    -&gt; str&#xA;   str.each_codepoint                       -&gt; an_enumerator&#xA; Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    &quot;hello\u0639&quot;.each_codepoint {|c| print c, &apos; &apos; }&#xA; produces: &#xA;    104 101 108 108 111 1593" />
        <scope name="each_line" ilk="function" signature="each_line(...)" doc="   str.lines(separator=$/) {|substr| block }       -&gt; str&#xA;   str.lines(separator=$/)                         -&gt; an_enumerator&#xA; Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split into paragraphs delimited by multiple successive newlines. &#xA; If no block is given, an enumerator is returned instead. &#xA;    print &quot;Example one\n&quot;&#xA;   &quot;hello\nworld&quot;.each_line {|s| p s}&#xA;   print &quot;Example two\n&quot;&#xA;   &quot;hello\nworld&quot;.each_line(&apos;l&apos;) {|s| p s}&#xA;   print &quot;Example three\n&quot;&#xA;   &quot;hello\n\n\nworld&quot;.each_line(&apos;&apos;) {|s| p s}&#xA; produces: &#xA;    Example one&#xA;   &quot;hello\n&quot;" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if str has a length of zero. &#xA;    &quot;hello&quot;.empty?   =&gt; false&#xA;   &quot;&quot;.empty?        =&gt; true" />
        <scope name="encode" ilk="function" signature="encode(...)" doc="The first form returns a copy of str transcoded to encoding +encoding+. The second form returns a copy of str transcoded from src_encoding to dst_encoding. The last form returns a copy of str transcoded to Encoding.default_internal. By default, the first and second form raise Encoding::UndefinedConversionError for characters that are undefined in the destination encoding, and Encoding::InvalidByteSequenceError for invalid byte sequences in the source encoding. The last form by default does not raise exceptions but uses replacement strings. The options Hash gives details for conversion. &#xA; options The hash options can have the following keys: If the value is :replace, #encode replaces invalid byte sequences in str with the replacement character. The default is to raise the exception&#xA;If the value is :replace, #encode replaces characters which are undefined in the destination encoding with the replacement character.&#xA;Sets the replacement string to the value. The default replacement string is &quot;\uFFFD&quot; for Unicode encoding forms, and &quot;?&quot; otherwise.&#xA;Sets the replacement string by the hash for undefined character. Its key is a such undefined character encoded in source encoding of current transcoder. Its value can be any encoding until it can be converted into the destination encoding of the transcoder.&#xA;The value must be :text or :attr. If the value is :text #encode replaces undefined characters with their (upper-case hexadecimal) numeric character references. &apos;&amp;&apos;, &apos;&lt;&apos;, and &apos;&gt;&apos; are converted to &quot;&amp;amp;&quot;, &quot;&amp;lt;&quot;, and &quot;&amp;gt;&quot;, respectively. If the value is :attr, #encode also quotes the replacement result (using &apos;&quot;&apos;), and replaces &apos;&quot;&apos; with &quot;&amp;quot;&quot;.&#xA;Replaces LF (&quot;\n&quot;) with CR (&quot;\r&quot;) if value is true.&#xA;Replaces LF (&quot;\n&quot;) with CRLF (&quot;\r\n&quot;) if value is true.&#xA;Replaces CRLF (&quot;\r\n&quot;) and CR (&quot;\r&quot;) with LF (&quot;\n&quot;) if value is true." />
        <scope name="encode!" ilk="function" signature="encode!(...)" doc="The first form transcodes the contents of str from str.encoding to +encoding+. The second form transcodes the contents of str from src_encoding to dst_encoding. The options Hash gives details for conversion. See String#encode for details. Returns the string even if no changes were made." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of obj." />
        <scope name="end_with?" ilk="function" signature="end_with?(...)" doc="Returns true if str ends with a suffix given." />
        <scope name="ends_with?" ilk="function" />
        <scope name="force_encoding" ilk="function" signature="force_encoding(p1)" doc="Changes the encoding to +encoding+ and returns self." />
        <scope name="getbyte" ilk="function" signature="getbyte(p1)" doc="returns the indexth byte as an integer." />
        <scope name="gsub" ilk="function" signature="gsub(...)" doc="Returns a copy of str with the all occurrences of pattern substituted for the second argument. The pattern is typically a Regexp; if given as a String, any regular expression metacharacters it contains will be interpreted literally, e.g. &apos;\\\d&apos; will match a backlash followed by &apos;d&apos;, instead of a digit. &#xA; If replacement is a String it will be substituted for the matched text. It may contain back-references to the pattern&apos;s capture groups of the form \\\d, where d is a group number, or \\\k&lt;n&gt;, where n is a group name. If it is a double-quoted string, both back-references must be preceded by an additional backslash. However, within replacement the special match variables, such as &amp;$, will not refer to the current match. &#xA; If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string. &#xA; In the block form, the current match string is passed in as a parameter, and variables such as $1, $2, $`, $&amp;, and $&apos; will be set appropriately. The value returned by the block will be substituted for the match on each call. &#xA; The result inherits any tainting in the original string or any supplied replacement string. &#xA; When neither a block nor a second argument is supplied, an Enumerator is returned. &#xA;    &quot;hello&quot;.gsub(/[aeiou]/, &apos;*&apos;)                  =&gt; &quot;h*ll*&quot;&#xA;   &quot;hello&quot;.gsub(/([aeiou])/, &apos;&lt;\1&gt;&apos;)             =&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;&#xA;   &quot;hello&quot;.gsub(/./) {|s| s.ord.to_s + &apos; &apos;}      =&gt; &quot;104 101 108 108 111 &quot;&#xA;   &quot;hello&quot;.gsub(/(?&lt;foo&gt;[aeiou])/, &apos;{\k&lt;foo&gt;}&apos;)  =&gt; &quot;h{e}ll{o}&quot;&#xA;   &apos;hello&apos;.gsub(/[eo]/, &apos;e&apos; =&gt; 3, &apos;o&apos; =&gt; &apos;*&apos;)    =&gt; &quot;h3ll*&quot;" />
        <scope name="gsub!" ilk="function" signature="gsub!(...)" doc="Performs the substitutions of String#gsub in place, returning str, or nil if no substitutions were performed. If no block and no replacement is given, an enumerator is returned instead." />
        <scope name="hex" ilk="function" signature="hex()" doc="Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number. Zero is returned on error. &#xA;    &quot;0x0a&quot;.hex     =&gt; 10&#xA;   &quot;-1234&quot;.hex    =&gt; -4660&#xA;   &quot;0&quot;.hex        =&gt; 0&#xA;   &quot;wombat&quot;.hex   =&gt; 0" />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if str contains the given string or character. &#xA;    &quot;hello&quot;.include? &quot;lo&quot;   =&gt; true&#xA;   &quot;hello&quot;.include? &quot;ol&quot;   =&gt; false&#xA;   &quot;hello&quot;.include? ?h     =&gt; true" />
        <scope name="index" ilk="function" signature="index(...)" doc="Returns the index of the first occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to begin the search. &#xA;    &quot;hello&quot;.index(&apos;e&apos;)             =&gt; 1&#xA;   &quot;hello&quot;.index(&apos;lo&apos;)            =&gt; 3&#xA;   &quot;hello&quot;.index(&apos;a&apos;)             =&gt; nil&#xA;   &quot;hello&quot;.index(?e)              =&gt; 1&#xA;   &quot;hello&quot;.index(/[aeiou]/, -3)   =&gt; 4" />
        <scope name="insert" ilk="function" signature="insert(p1, p2)" doc="Inserts other_str before the character at the given index, modifying str. Negative indices count from the end of the string, and insert after the given character. The intent is insert aString so that it starts at the given index. &#xA;    &quot;abcd&quot;.insert(0, &apos;X&apos;)    =&gt; &quot;Xabcd&quot;&#xA;   &quot;abcd&quot;.insert(3, &apos;X&apos;)    =&gt; &quot;abcXd&quot;&#xA;   &quot;abcd&quot;.insert(4, &apos;X&apos;)    =&gt; &quot;abcdX&quot;&#xA;   &quot;abcd&quot;.insert(-3, &apos;X&apos;)   =&gt; &quot;abXcd&quot;&#xA;   &quot;abcd&quot;.insert(-1, &apos;X&apos;)   =&gt; &quot;abcdX&quot;" />
        <scope name="intern" ilk="function" signature="intern()" doc="Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name. &#xA;    &quot;Koala&quot;.intern         =&gt; :Koala&#xA;   s = &apos;cat&apos;.to_sym       =&gt; :cat&#xA;   s == :cat              =&gt; true&#xA;   s = &apos;@cat&apos;.to_sym      =&gt; :@cat&#xA;   s == :@cat             =&gt; true&#xA; This can also be used to create symbols that cannot be represented using the :xxx notation. &#xA;    &apos;cat and dog&apos;.to_sym   =&gt; :&quot;cat and dog&quot;" />
        <scope name="is_binary_data?" ilk="function" />
        <scope name="is_complex_yaml?" ilk="function" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the character length of str." />
        <scope name="lines" ilk="function" signature="lines(...)" doc="   str.lines(separator=$/) {|substr| block }       -&gt; str&#xA;   str.lines(separator=$/)                         -&gt; an_enumerator&#xA; Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split into paragraphs delimited by multiple successive newlines. &#xA; If no block is given, an enumerator is returned instead. &#xA;    print &quot;Example one\n&quot;&#xA;   &quot;hello\nworld&quot;.each_line {|s| p s}&#xA;   print &quot;Example two\n&quot;&#xA;   &quot;hello\nworld&quot;.each_line(&apos;l&apos;) {|s| p s}&#xA;   print &quot;Example three\n&quot;&#xA;   &quot;hello\n\n\nworld&quot;.each_line(&apos;&apos;) {|s| p s}&#xA; produces: &#xA;    Example one&#xA;   &quot;hello\n&quot;" />
        <scope name="ljust" ilk="function" signature="ljust(...)" doc="If integer is greater than the length of str, returns a new String of length integer with str left justified and padded with padstr; otherwise, returns str. &#xA;    &quot;hello&quot;.ljust(4)            =&gt; &quot;hello&quot;&#xA;   &quot;hello&quot;.ljust(20)           =&gt; &quot;hello               &quot;&#xA;   &quot;hello&quot;.ljust(20, &apos;1234&apos;)   =&gt; &quot;hello123412341234123&quot;" />
        <scope name="lstrip" ilk="function" signature="lstrip()" doc="Returns a copy of str with leading whitespace removed. See also String#rstrip and String#strip. &#xA;    &quot;  hello  &quot;.lstrip   =&gt; &quot;hello  &quot;&#xA;   &quot;hello&quot;.lstrip       =&gt; &quot;hello&quot;" />
        <scope name="lstrip!" ilk="function" signature="lstrip!()" doc="Removes leading whitespace from str, returning nil if no change was made. See also String#rstrip! and String#strip!. &#xA;    &quot;  hello  &quot;.lstrip   =&gt; &quot;hello  &quot;&#xA;   &quot;hello&quot;.lstrip!      =&gt; nil" />
        <scope name="match" ilk="function" signature="match(...)" doc="Converts pattern to a Regexp (if it isn&apos;t already one), then invokes its match method on str.  If the second parameter is present, it specifies the position in the string to begin the search. If the second parameter is present, it specifies the position in the string to begin the search. &#xA;    &apos;hello&apos;.match(&apos;(.)\1&apos;)      =&gt; #&lt;MatchData &quot;ll&quot; 1:&quot;l&quot;&gt;&#xA;   &apos;hello&apos;.match(&apos;(.)\1&apos;)[0]   =&gt; &quot;ll&quot;&#xA;   &apos;hello&apos;.match(/(.)\1/)[0]   =&gt; &quot;ll&quot;&#xA;   &apos;hello&apos;.match(&apos;xx&apos;)         =&gt; nil&#xA; If a block is given, invoke the block with MatchData if match succeed, so that you can write &#xA;    str.match(pat) {|m| ...}&#xA; instead of &#xA;    if m = str.match(pat)&#xA;     ...&#xA;   end&#xA; The return value is a value from block execution in this case." />
        <scope name="next" ilk="function" signature="next()" doc="Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set&apos;s collating sequence. &#xA; If the increment generates a ``carry,&apos;&apos; the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary. &#xA;    &quot;abcd&quot;.succ        =&gt; &quot;abce&quot;&#xA;   &quot;THX1138&quot;.succ     =&gt; &quot;THX1139&quot;&#xA;   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;&#xA;   &quot;1999zzz&quot;.succ     =&gt; &quot;2000aaa&quot;&#xA;   &quot;ZZZ9999&quot;.succ     =&gt; &quot;AAAA0000&quot;&#xA;   &quot;***&quot;.succ         =&gt; &quot;**+&quot;" />
        <scope name="next!" ilk="function" signature="next!()" doc="Equivalent to String#succ, but modifies the receiver in place." />
        <scope name="oct" ilk="function" signature="oct()" doc="Treats leading characters of str as a string of octal digits (with an optional sign) and returns the corresponding number.  Returns 0 if the conversion fails. &#xA;    &quot;123&quot;.oct       =&gt; 83&#xA;   &quot;-377&quot;.oct      =&gt; -255&#xA;   &quot;bad&quot;.oct       =&gt; 0&#xA;   &quot;0377bad&quot;.oct   =&gt; 255" />
        <scope name="ord" ilk="function" signature="ord()" doc="Return the Integer ordinal of a one-character string. &#xA;    &quot;a&quot;.ord         =&gt; 97" />
        <scope name="partition" ilk="function" signature="partition(p1)" doc="Searches sep or pattern (regexp) in the string and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str. &#xA;    &quot;hello&quot;.partition(&quot;l&quot;)         =&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]&#xA;   &quot;hello&quot;.partition(&quot;x&quot;)         =&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]&#xA;   &quot;hello&quot;.partition(/.l/)        =&gt; [&quot;h&quot;, &quot;el&quot;, &quot;lo&quot;]" />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents and taintedness of str with the corresponding values in other_str. &#xA;    s = &quot;hello&quot;         =&gt; &quot;hello&quot;&#xA;   s.replace &quot;world&quot;   =&gt; &quot;world&quot;" />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a new string with the characters from str in reverse order. &#xA;    &quot;stressed&quot;.reverse   =&gt; &quot;desserts&quot;" />
        <scope name="reverse!" ilk="function" signature="reverse!()" doc="Reverses str in place." />
        <scope name="rindex" ilk="function" signature="rindex(...)" doc="Returns the index of the last occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to end the search---characters beyond this point will not be considered. &#xA;    &quot;hello&quot;.rindex(&apos;e&apos;)             =&gt; 1&#xA;   &quot;hello&quot;.rindex(&apos;l&apos;)             =&gt; 3&#xA;   &quot;hello&quot;.rindex(&apos;a&apos;)             =&gt; nil&#xA;   &quot;hello&quot;.rindex(?e)              =&gt; 1&#xA;   &quot;hello&quot;.rindex(/[aeiou]/, -2)   =&gt; 1" />
        <scope name="rjust" ilk="function" signature="rjust(...)" doc="If integer is greater than the length of str, returns a new String of length integer with str right justified and padded with padstr; otherwise, returns str. &#xA;    &quot;hello&quot;.rjust(4)            =&gt; &quot;hello&quot;&#xA;   &quot;hello&quot;.rjust(20)           =&gt; &quot;               hello&quot;&#xA;   &quot;hello&quot;.rjust(20, &apos;1234&apos;)   =&gt; &quot;123412341234123hello&quot;" />
        <scope name="rpartition" ilk="function" signature="rpartition(p1)" doc="Searches sep or pattern (regexp) in the string from the end of the string, and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str. &#xA;    &quot;hello&quot;.rpartition(&quot;l&quot;)         =&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]&#xA;   &quot;hello&quot;.rpartition(&quot;x&quot;)         =&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]&#xA;   &quot;hello&quot;.rpartition(/.l/)        =&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]" />
        <scope name="rstrip" ilk="function" signature="rstrip()" doc="Returns a copy of str with trailing whitespace removed. See also String#lstrip and String#strip. &#xA;    &quot;  hello  &quot;.rstrip   =&gt; &quot;  hello&quot;&#xA;   &quot;hello&quot;.rstrip       =&gt; &quot;hello&quot;" />
        <scope name="rstrip!" ilk="function" signature="rstrip!()" doc="Removes trailing whitespace from str, returning nil if no change was made. See also String#lstrip! and String#strip!. &#xA;    &quot;  hello  &quot;.rstrip   =&gt; &quot;  hello&quot;&#xA;   &quot;hello&quot;.rstrip!      =&gt; nil" />
        <scope name="scan" ilk="function" signature="scan(p1)" doc="Both forms iterate through str, matching the pattern (which may be a Regexp or a String). For each match, a result is generated and either added to the result array or passed to the block. If the pattern contains no groups, each individual result consists of the matched string, $&amp;.  If the pattern contains groups, each individual result is itself an array containing one entry per group. &#xA;    a = &quot;cruel world&quot;&#xA;   a.scan(/\w+/)        =&gt; [&quot;cruel&quot;, &quot;world&quot;]&#xA;   a.scan(/.../)        =&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]&#xA;   a.scan(/(...)/)      =&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]&#xA;   a.scan(/(..)(..)/)   =&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]&#xA; And the block form: &#xA;    a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }&#xA;   print &quot;\n&quot;&#xA;   a.scan(/(.)(.)/) {|x,y| print y, x }&#xA;   print &quot;\n&quot;&#xA; produces: &#xA;    &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;" />
        <scope name="setbyte" ilk="function" signature="setbyte(p1, p2)" doc="modifies the indexth byte as int." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the character length of str." />
        <scope name="slice" ilk="function" signature="slice(...)" doc="Element Reference---If passed a single Fixnum, returns a substring of one character at that position. If passed two Fixnum objects, returns a substring starting at the offset given by the first, and a length given by the second. If given a range, a substring containing characters at offsets given by the range is returned. In all three cases, if an offset is negative, it is counted from the end of str. Returns nil if the initial offset falls outside the string, the length is negative, or the beginning of the range is greater than the end. &#xA; If a Regexp is supplied, the matching portion of str is returned. If a numeric or name parameter follows the regular expression, that component of the MatchData is returned instead. If a String is given, that string is returned if it occurs in str. In both cases, nil is returned if there is no match. &#xA;    a = &quot;hello there&quot;&#xA;   a[1]                   =&gt; &quot;e&quot;&#xA;   a[1,3]                 =&gt; &quot;ell&quot;&#xA;   a[1..3]                =&gt; &quot;ell&quot;&#xA;   a[-3,2]                =&gt; &quot;er&quot;&#xA;   a[-4..-2]              =&gt; &quot;her&quot;&#xA;   a[12..-1]              =&gt; nil&#xA;   a[-2..-4]              =&gt; &quot;&quot;&#xA;   a[/[aeiou](.)\1/]      =&gt; &quot;ell&quot;&#xA;   a[/[aeiou](.)\1/, 0]   =&gt; &quot;ell&quot;&#xA;   a[/[aeiou](.)\1/, 1]   =&gt; &quot;l&quot;" />
        <scope name="slice!" ilk="function" signature="slice!(...)" doc="Deletes the specified portion from str, and returns the portion deleted. &#xA;    string = &quot;this is a string&quot;&#xA;   string.slice!(2)        =&gt; &quot;i&quot;&#xA;   string.slice!(3..6)     =&gt; &quot; is &quot;&#xA;   string.slice!(/s.*t/)   =&gt; &quot;sa st&quot;&#xA;   string.slice!(&quot;r&quot;)      =&gt; &quot;r&quot;&#xA;   string                  =&gt; &quot;thing&quot;" />
        <scope name="split" ilk="function" signature="split(...)" doc="Divides str into substrings based on a delimiter, returning an array of these substrings. &#xA; If pattern is a String, then its contents are used as the delimiter when splitting str. If pattern is a single space, str is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored. &#xA; If pattern is a Regexp, str is divided where the pattern matches. Whenever the pattern matches a zero-length string, str is split into individual characters. If pattern contains groups, the respective matches will be returned in the array as well. &#xA; If pattern is omitted, the value of $; is used.  If $; is nil (which is the default), str is split on whitespace as if ` &apos; were specified. &#xA; If the limit parameter is omitted, trailing null fields are suppressed. If limit is a positive number, at most that number of fields will be returned (if limit is 1, the entire string is returned as the only entry in an array). If negative, there is no limit to the number of fields returned, and trailing null fields are not suppressed. &#xA;    &quot; now&apos;s  the time&quot;.split        =&gt; [&quot;now&apos;s&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;   &quot; now&apos;s  the time&quot;.split(&apos; &apos;)   =&gt; [&quot;now&apos;s&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;   &quot; now&apos;s  the time&quot;.split(/ /)   =&gt; [&quot;&quot;, &quot;now&apos;s&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;   &quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) =&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]&#xA;   &quot;hello&quot;.split(//)               =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]&#xA;   &quot;hello&quot;.split(//, 3)            =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]&#xA;   &quot;hi mom&quot;.split(%r{\s*})         =&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]&#xA;   &quot;mellow yellow&quot;.split(&quot;ello&quot;)   =&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]" />
        <scope name="squeeze" ilk="function" signature="squeeze(...)" doc="Builds a set of characters from the other_str parameter(s) using the procedure described for String#count. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character. &#xA;    &quot;yellow moon&quot;.squeeze                  =&gt; &quot;yelow mon&quot;&#xA;   &quot;  now   is  the&quot;.squeeze(&quot; &quot;)         =&gt; &quot; now is the&quot;&#xA;   &quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   =&gt; &quot;puters shot balls&quot;" />
        <scope name="squeeze!" ilk="function" signature="squeeze!(...)" doc="Squeezes str in place, returning either str, or nil if no changes were made." />
        <scope name="start_with?" ilk="function" signature="start_with?(...)" doc="Returns true if str starts with a prefix given. &#xA;   p &quot;hello&quot;.start_with?(&quot;hell&quot;)               =&gt; true&#xA;&#xA;  # returns true if one of prefix matches.&#xA;  p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;hell&quot;)     =&gt; true&#xA;  p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;paradice&quot;) =&gt; false" />
        <scope name="strip" ilk="function" signature="strip()" doc="Returns a copy of str with leading and trailing whitespace removed. &#xA;    &quot;    hello    &quot;.strip   =&gt; &quot;hello&quot;&#xA;   &quot;\tgoodbye\r\n&quot;.strip   =&gt; &quot;goodbye&quot;" />
        <scope name="strip!" ilk="function" signature="strip!()" doc="Removes leading and trailing whitespace from str. Returns nil if str was not altered." />
        <scope name="sub" ilk="function" signature="sub(...)" doc="Returns a copy of str with the first occurrence of pattern substituted for the second argument. The pattern is typically a Regexp; if given as a String, any regular expression metacharacters it contains will be interpreted literally, e.g. &apos;\\\d&apos; will match a backlash followed by &apos;d&apos;, instead of a digit. &#xA; If replacement is a String it will be substituted for the matched text. It may contain back-references to the pattern&apos;s capture groups of the form \\\d, where d is a group number, or \\\k&lt;n&gt;, where n is a group name. If it is a double-quoted string, both back-references must be preceded by an additional backslash. However, within replacement the special match variables, such as &amp;$, will not refer to the current match. &#xA; If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string. &#xA; In the block form, the current match string is passed in as a parameter, and variables such as $1, $2, $`, $&amp;, and $&apos; will be set appropriately. The value returned by the block will be substituted for the match on each call. &#xA; The result inherits any tainting in the original string or any supplied replacement string. &#xA;    &quot;hello&quot;.sub(/[aeiou]/, &apos;*&apos;)                  =&gt; &quot;h*llo&quot;&#xA;   &quot;hello&quot;.sub(/([aeiou])/, &apos;&lt;\1&gt;&apos;)             =&gt; &quot;h&lt;e&gt;llo&quot;&#xA;   &quot;hello&quot;.sub(/./) {|s| s.ord.to_s + &apos; &apos; }     =&gt; &quot;104 ello&quot;&#xA;   &quot;hello&quot;.sub(/(?&lt;foo&gt;[aeiou])/, &apos;*\k&lt;foo&gt;*&apos;)  =&gt; &quot;h*e*llo&quot;&#xA;   &apos;Is SHELL your preferred shell?&apos;.sub(/[[:upper:]]{2,}/, ENV)&#xA;    =&gt; &quot;Is /bin/bash your preferred shell?&quot;" />
        <scope name="sub!" ilk="function" signature="sub!(...)" doc="Performs the substitutions of String#sub in place, returning str, or nil if no substitutions were performed." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set&apos;s collating sequence. &#xA; If the increment generates a ``carry,&apos;&apos; the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary. &#xA;    &quot;abcd&quot;.succ        =&gt; &quot;abce&quot;&#xA;   &quot;THX1138&quot;.succ     =&gt; &quot;THX1139&quot;&#xA;   &quot;&lt;&lt;koala&gt;&gt;&quot;.succ   =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;&#xA;   &quot;1999zzz&quot;.succ     =&gt; &quot;2000aaa&quot;&#xA;   &quot;ZZZ9999&quot;.succ     =&gt; &quot;AAAA0000&quot;&#xA;   &quot;***&quot;.succ         =&gt; &quot;**+&quot;" />
        <scope name="succ!" ilk="function" signature="succ!()" doc="Equivalent to String#succ, but modifies the receiver in place." />
        <scope name="sum" ilk="function" signature="sum(...)" doc="Returns a basic n-bit checksum of the characters in str, where n is the optional Fixnum parameter, defaulting to 16. The result is simply the sum of the binary value of each character in str modulo 2**n - 1. This is not a particularly good checksum." />
        <scope name="swapcase" ilk="function" signature="swapcase()" doc="Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. Note: case conversion is effective only in ASCII region. &#xA;    &quot;Hello&quot;.swapcase          =&gt; &quot;hELLO&quot;&#xA;   &quot;cYbEr_PuNk11&quot;.swapcase   =&gt; &quot;CyBeR_pUnK11&quot;" />
        <scope name="swapcase!" ilk="function" signature="swapcase!()" doc="Equivalent to String#swapcase, but modifies the receiver in place, returning str, or nil if no changes were made. Note: case conversion is effective only in ASCII region." />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns a complex which denotes the string form.  The parser ignores leading whitespaces and trailing garbage.  Any digit sequences can be separated by an underscore.  Returns zero for null or garbage string. &#xA; For example: &#xA;    &apos;9&apos;.to_c           =&gt; (9+0i)&#xA;   &apos;2.5&apos;.to_c         =&gt; (2.5+0i)&#xA;   &apos;2.5/1&apos;.to_c       =&gt; ((5/2)+0i)&#xA;   &apos;-3/2&apos;.to_c        =&gt; ((-3/2)+0i)&#xA;   &apos;-i&apos;.to_c          =&gt; (0-1i)&#xA;   &apos;45i&apos;.to_c         =&gt; (0+45i)&#xA;   &apos;3-4i&apos;.to_c        =&gt; (3-4i)&#xA;   &apos;-4e2-4e-2i&apos;.to_c  =&gt; (-400.0-0.04i)&#xA;   &apos;-0.0-0.0i&apos;.to_c   =&gt; (-0.0-0.0i)&#xA;   &apos;1/2+3/4i&apos;.to_c    =&gt; ((1/2)+(3/4)*i)&#xA;   &apos;ruby&apos;.to_c        =&gt; (0+0i)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the result of interpreting leading characters in str as a floating point number. Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0.0 is returned. This method never raises an exception. &#xA;    &quot;123.45e1&quot;.to_f        =&gt; 1234.5&#xA;   &quot;45.67 degrees&quot;.to_f   =&gt; 45.67&#xA;   &quot;thx1138&quot;.to_f         =&gt; 0.0" />
        <scope name="to_i" ilk="function" signature="to_i(...)" doc="Returns the result of interpreting leading characters in str as an integer base base (between 2 and 36). Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0 is returned. This method never raises an exception when base is valid. &#xA;    &quot;12345&quot;.to_i             =&gt; 12345&#xA;   &quot;99 red balloons&quot;.to_i   =&gt; 99&#xA;   &quot;0a&quot;.to_i                =&gt; 0&#xA;   &quot;0a&quot;.to_i(16)            =&gt; 10&#xA;   &quot;hello&quot;.to_i             =&gt; 0&#xA;   &quot;1100101&quot;.to_i(2)        =&gt; 101&#xA;   &quot;1100101&quot;.to_i(8)        =&gt; 294977&#xA;   &quot;1100101&quot;.to_i(10)       =&gt; 1100101&#xA;   &quot;1100101&quot;.to_i(16)       =&gt; 17826049" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns a rational which denotes the string form.  The parser ignores leading whitespaces and trailing garbage.  Any digit sequences can be separated by an underscore.  Returns zero for null or garbage string. &#xA; NOTE: &apos;0.3&apos;.to_r isn&apos;t the same as 0.3.to_r.  The former is equivalent to &apos;3/10&apos;.to_r, but the latter isn&apos;t so. &#xA; For example: &#xA;    &apos;  2  &apos;.to_r       =&gt; (2/1)&#xA;   &apos;300/2&apos;.to_r       =&gt; (150/1)&#xA;   &apos;-9.2&apos;.to_r        =&gt; (-46/5)&#xA;   &apos;-9.2e2&apos;.to_r      =&gt; (-920/1)&#xA;   &apos;1_234_567&apos;.to_r   =&gt; (1234567/1)&#xA;   &apos;21 june 09&apos;.to_r  =&gt; (21/1)&#xA;   &apos;21/06/09&apos;.to_r    =&gt; (7/2)&#xA;   &apos;bwv 1079&apos;.to_r    =&gt; (0/1)" />
        <scope name="to_str" ilk="function" signature="to_str()" doc="Returns the receiver." />
        <scope name="to_sym" ilk="function" signature="to_sym()" doc="Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name. &#xA;    &quot;Koala&quot;.intern         =&gt; :Koala&#xA;   s = &apos;cat&apos;.to_sym       =&gt; :cat&#xA;   s == :cat              =&gt; true&#xA;   s = &apos;@cat&apos;.to_sym      =&gt; :@cat&#xA;   s == :@cat             =&gt; true&#xA; This can also be used to create symbols that cannot be represented using the :xxx notation. &#xA;    &apos;cat and dog&apos;.to_sym   =&gt; :&quot;cat and dog&quot;" />
        <scope name="tr" ilk="function" signature="tr(p1, p2)" doc="Returns a copy of str with the characters in from_str replaced by the corresponding characters in to_str. If to_str is shorter than from_str, it is padded with its last character. Both strings may use the c1--c2 notation to denote ranges of characters, and from_str may start with a ^, which denotes all characters except those listed. &#xA;    &quot;hello&quot;.tr(&apos;aeiou&apos;, &apos;*&apos;)    =&gt; &quot;h*ll*&quot;&#xA;   &quot;hello&quot;.tr(&apos;^aeiou&apos;, &apos;*&apos;)   =&gt; &quot;*e**o&quot;&#xA;   &quot;hello&quot;.tr(&apos;el&apos;, &apos;ip&apos;)      =&gt; &quot;hippo&quot;&#xA;   &quot;hello&quot;.tr(&apos;a-y&apos;, &apos;b-z&apos;)    =&gt; &quot;ifmmp&quot;" />
        <scope name="tr!" ilk="function" signature="tr!(p1, p2)" doc="Translates str in place, using the same rules as String#tr. Returns str, or nil if no changes were made." />
        <scope name="tr_s" ilk="function" signature="tr_s(p1, p2)" doc="Processes a copy of str as described under String#tr, then removes duplicate characters in regions that were affected by the translation. &#xA;    &quot;hello&quot;.tr_s(&apos;l&apos;, &apos;r&apos;)     =&gt; &quot;hero&quot;&#xA;   &quot;hello&quot;.tr_s(&apos;el&apos;, &apos;*&apos;)    =&gt; &quot;h*o&quot;&#xA;   &quot;hello&quot;.tr_s(&apos;el&apos;, &apos;hx&apos;)   =&gt; &quot;hhxo&quot;" />
        <scope name="tr_s!" ilk="function" signature="tr_s!(p1, p2)" doc="Performs String#tr_s processing on str in place, returning str, or nil if no changes were made." />
        <scope name="unpack" ilk="function" signature="unpack(p1)" doc="Decodes str (which may contain binary data) according to the format string, returning an array of each value extracted. The format string consists of a sequence of single-character directives, summarized in the table at the end of this entry. Each directive may be followed by a number, indicating the number of times to repeat with this directive. An asterisk (``*&apos;&apos;) will use up all remaining elements. The directives sSiIlL may each be followed by an underscore (``_&apos;&apos;) or exclamation mark (``!&apos;&apos;) to use the underlying platform&apos;s native size for the specified type; otherwise, it uses a platform-independent consistent size. Spaces are ignored in the format string. See also Array#pack. &#xA;    &quot;abc \0\0abc \0\0&quot;.unpack(&apos;A6Z6&apos;)   =&gt; [&quot;abc&quot;, &quot;abc &quot;]&#xA;   &quot;abc \0\0&quot;.unpack(&apos;a3a3&apos;)           =&gt; [&quot;abc&quot;, &quot; \000\000&quot;]&#xA;   &quot;abc \0abc \0&quot;.unpack(&apos;Z*Z*&apos;)       =&gt; [&quot;abc &quot;, &quot;abc &quot;]&#xA;   &quot;aa&quot;.unpack(&apos;b8B8&apos;)                 =&gt; [&quot;10000110&quot;, &quot;01100001&quot;]&#xA;   &quot;aaa&quot;.unpack(&apos;h2H2c&apos;)               =&gt; [&quot;16&quot;, &quot;61&quot;, 97]&#xA;   &quot;\xfe\xff\xfe\xff&quot;.unpack(&apos;sS&apos;)     =&gt; [-2, 65534]&#xA;   &quot;now=20is&quot;.unpack(&apos;M*&apos;)             =&gt; [&quot;now is&quot;]&#xA;   &quot;whole&quot;.unpack(&apos;xax2aX2aX1aX2a&apos;)    =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]&#xA; This table summarizes the various formats and the Ruby classes returned by each. &#xA;  Integer      |         |&#xA; Directive    | Returns | Meaning&#xA; -----------------------------------------------------------------" />
        <scope name="upcase" ilk="function" signature="upcase()" doc="Returns a copy of str with all lowercase letters replaced with their uppercase counterparts. The operation is locale insensitive---only characters ``a&apos;&apos; to ``z&apos;&apos; are affected. Note: case replacement is effective only in ASCII region. &#xA;    &quot;hEllO&quot;.upcase   =&gt; &quot;HELLO&quot;" />
        <scope name="upcase!" ilk="function" signature="upcase!()" doc="Upcases the contents of str, returning nil if no changes were made. Note: case replacement is effective only in ASCII region." />
        <scope name="upto" ilk="function" signature="upto(...)" doc="Iterates through successive values, starting at str and ending at other_str inclusive, passing each value in turn to the block. The String#succ method is used to generate each value.  If optional second argument exclusive is omitted or is false, the last value will be included; otherwise it will be excluded. &#xA; If no block is given, an enumerator is returned instead. &#xA;    &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, &apos; &apos; }&#xA;   for s in &quot;a8&quot;..&quot;b6&quot;&#xA;     print s, &apos; &apos;&#xA;   end&#xA; produces: &#xA;    a8 a9 b0 b1 b2 b3 b4 b5 b6&#xA;   a8 a9 b0 b1 b2 b3 b4 b5 b6&#xA; If str and other_str contains only ascii numeric characters, both are recognized as decimal numbers. In addition, the width of string (e.g. leading zeros) is handled appropriately. &#xA;    &quot;9&quot;.upto(&quot;11&quot;).to_a   =&gt; [&quot;9&quot;, &quot;10&quot;, &quot;11&quot;]&#xA;   &quot;25&quot;.upto(&quot;5&quot;).to_a   =&gt; []&#xA;   &quot;07&quot;.upto(&quot;11&quot;).to_a  =&gt; [&quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;]" />
        <scope name="valid_encoding?" ilk="function" signature="valid_encoding?()" doc="Returns true for a string which encoded correctly. &#xA;   &quot;\xc2\xa1&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?  =&gt; true&#xA;  &quot;\xc2&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      =&gt; false&#xA;  &quot;\x80&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      =&gt; false" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a String, using to_str method. Returns converted string or nil if obj cannot be converted for any reason. &#xA;    String.try_convert(&quot;str&quot;)     =&gt; &quot;str&quot;&#xA;   String.try_convert(/re/)      =&gt; nil" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new string object containing a copy of str." />
      </scope>
      <scope name="Symbol" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="capitalize" ilk="function" signature="capitalize()" doc="Same as sym.to_s.capitalize.intern." />
        <scope name="casecmp" ilk="function" signature="casecmp(p1)" doc="  sym.casecmp(other)  -&gt; -1, 0, +1 or nil&#xA; Case-insensitive version of Symbol#&lt;=&gt;." />
        <scope name="downcase" ilk="function" signature="downcase()" doc="Same as sym.to_s.downcase.intern." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns that _sym_ is :&quot;&quot; or not." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of _sym_." />
        <scope name="id2name" ilk="function" signature="id2name()" doc="Returns the name or string corresponding to sym. &#xA;    :fred.id2name   =&gt; &quot;fred&quot;" />
        <scope name="intern" ilk="function" signature="intern()" doc="In general, to_sym returns the Symbol corresponding to an object. As sym is already a symbol, self is returned in this case." />
        <scope name="length" ilk="function" signature="length()" doc="Same as sym.to_s.length." />
        <scope name="match" ilk="function" signature="match(p1)" doc="Returns sym.to_s =~ obj." />
        <scope name="next" ilk="function" signature="next()" doc="  sym.succ&#xA; Same as sym.to_s.succ.intern." />
        <scope name="size" ilk="function" signature="size()" doc="Same as sym.to_s.length." />
        <scope name="slice" ilk="function" signature="slice(...)" doc="Returns sym.to_s[]." />
        <scope name="succ" ilk="function" signature="succ()" doc="  sym.succ&#xA; Same as sym.to_s.succ.intern." />
        <scope name="swapcase" ilk="function" signature="swapcase()" doc="Same as sym.to_s.swapcase.intern." />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Returns a _Proc_ object which respond to the given method by _sym_. &#xA;   (1..3).collect(&amp;:to_s)  =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]" />
        <scope name="to_sym" ilk="function" signature="to_sym()" doc="In general, to_sym returns the Symbol corresponding to an object. As sym is already a symbol, self is returned in this case." />
        <scope name="upcase" ilk="function" signature="upcase()" doc="Same as sym.to_s.upcase.intern." />
        <scope name="all_symbols" ilk="function" attributes="__classmethod__" signature="all_symbols()" doc="Returns an array of all the symbols currently in Ruby&apos;s symbol table. &#xA;    Symbol.all_symbols.size    =&gt; 903&#xA;   Symbol.all_symbols[1,20]   =&gt; [:floor, :ARGV, :Binding, :symlink,&#xA;                                   :chown, :EOFError, :$;, :String,&#xA;                                   :LOCK_SH, :&quot;setuid?&quot;, :$&lt;,&#xA;                                   :default_proc, :compact, :extend,&#xA;                                   :Tms, :getwd, :$=, :ThreadGroup,&#xA;                                   :wait2, :$&gt;]" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Exception" ilk="class" classrefs="Object" >
        <scope name="backtrace" ilk="function" signature="backtrace()" doc="Returns any backtrace associated with the exception. The backtrace is an array of strings, each containing either ``filename:lineNo: in `method&apos;&apos;&apos; or ``filename:lineNo.&apos;&apos; &#xA;    def a&#xA;     raise &quot;boom&quot;&#xA;   end&#xA;   def b&#xA;     a()&#xA;   end&#xA;   begin&#xA;     b()&#xA;   rescue =&gt; detail&#xA;     print detail.backtrace.join(&quot;\n&quot;)&#xA;   end&#xA; produces: " />
        <scope name="exception" ilk="function" signature="exception(...)" doc="With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str." />
        <scope name="message" ilk="function" signature="message()" doc="Returns the result of invoking exception.to_s. Normally this returns the exception&apos;s message or name. By supplying a to_str method, exceptions are agreeing to be used where Strings are expected." />
        <scope name="set_backtrace" ilk="function" signature="set_backtrace(p1)" doc="Sets the backtrace information associated with exc. The argument must be an array of String objects in the format described in Exception#backtrace." />
        <scope name="exception" ilk="function" attributes="__classmethod__" signature="exception(...)" doc="With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str." />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Construct a new Exception object, optionally passing in a message." />
      </scope>
      <scope name="SystemExit" ilk="class" classrefs="Exception" >
        <scope name="status" ilk="function" signature="status()" doc="Return the status value associated with this system exit." />
        <scope name="success?" ilk="function" signature="success?()" doc="Returns +true+ if exiting successful, +false+ if not." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Create a new +SystemExit+ exception with the given status." />
      </scope>
      <scope name="SignalException" ilk="class" classrefs="Exception" >
        <scope name="signm" ilk="function" />
        <scope name="signo" ilk="function" />
      </scope>
      <scope name="Interrupt" ilk="class" classrefs="SignalException" >
      </scope>
      <scope name="StandardError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="TypeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ArgumentError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="IndexError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="KeyError" ilk="class" classrefs="IndexError" >
      </scope>
      <scope name="RangeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ScriptError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="SyntaxError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="LoadError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="NotImplementedError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="NameError" ilk="class" classrefs="StandardError" >
        <scope name="name" ilk="function" signature="name()" doc="Return the name associated with this NameError exception." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Construct a new NameError exception. If given the name parameter may subsequently be examined using the NameError.name method." />
      </scope>
      <scope name="NoMethodError" ilk="class" classrefs="NameError" >
        <scope name="args" ilk="function" signature="args()" doc="Return the arguments passed in as the third parameter to the constructor." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Construct a NoMethodError exception for a method of the given name called with the given arguments. The name may be accessed using the #name method on the resulting object, and the arguments using the #args method." />
      </scope>
      <scope name="RuntimeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="SecurityError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="NoMemoryError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="EncodingError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="SystemCallError" ilk="class" classrefs="StandardError" >
        <scope name="errno" ilk="function" signature="errno()" doc="Return this SystemCallError&apos;s error number." />
        <scope name="===" ilk="function" attributes="__classmethod__" signature="===(p1)" doc="Return +true+ if the receiver is a generic +SystemCallError+, or if the error numbers +self+ and _other_ are the same." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="If _errno_ corresponds to a known system error code, constructs the appropriate Errno class for that error, otherwise constructs a generic SystemCallError object. The error number is subsequently available via the errno method." />
      </scope>
      <scope name="Errno" ilk="namespace" >
        <scope name="E2BIG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EACCES" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADDRINUSE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADDRNOTAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAFNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAGAIN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EALREADY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAUTH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADF" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADFD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADMSG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADRPC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADRQC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADSLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBFONT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBUSY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECANCELED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECHILD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECHRNG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECOMM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNABORTED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNREFUSED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNRESET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDEADLK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDEADLOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDESTADDRREQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOOFUS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOTDOT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDQUOT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EEXIST" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFAULT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFBIG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EHOSTDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EHOSTUNREACH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIDRM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EILSEQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINPROGRESS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINVAL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIPSEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISCONN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISDIR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISNAM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYEXPIRED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYREJECTED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYREVOKED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL2HLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL2NSYNC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL3HLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL3RST" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBACC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBBAD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBEXEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBMAX" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBSCN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELNRNG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELOOP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMEDIUMTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMFILE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMLINK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMSGSIZE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMULTIHOP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENAMETOOLONG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENEEDAUTH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETRESET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETUNREACH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENFILE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOANO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOATTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOBUFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOCSI" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENODATA" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENODEV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOENT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOEXEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOKEY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOLCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOLINK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMEDIUM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMEM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMSG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENONET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOPKG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOPROTOOPT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSPC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSYS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTBLK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTCONN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTDIR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTEMPTY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTNAM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTRECOVERABLE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTSOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTSUP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTTY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTUNIQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENXIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOPNOTSUPP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOVERFLOW" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOWNERDEAD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPERM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPFNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROCLIM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROCUNAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROGMISMATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROGUNAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTONOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTOTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERANGE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMCHG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMOTE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMOTEIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERESTART" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERFKILL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EROFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERPCMISMATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESHUTDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESOCKTNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESRCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESRMNT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESTALE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESTRPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETIME" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETIMEDOUT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETOOMANYREFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETXTBSY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUCLEAN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUNATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUSERS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EWOULDBLOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EXDEV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EXFULL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="NOERROR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
      </scope>
      <scope name="ZeroDivisionError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="FloatDomainError" ilk="class" classrefs="RangeError" >
      </scope>
      <scope name="Numeric" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="abs" ilk="function" signature="abs()" doc="Returns the absolute value of num. &#xA;    12.abs         =&gt; 12&#xA;   (-34.56).abs   =&gt; 34.56&#xA;   -34.56.abs     =&gt; 34.56" />
        <scope name="abs2" ilk="function" signature="abs2()" doc="Returns square of self." />
        <scope name="angle" ilk="function" signature="angle()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="arg" ilk="function" signature="arg()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="ceil" ilk="function" signature="ceil()" doc="Returns the smallest Integer greater than or equal to num. Class Numeric achieves this by converting itself to a Float then invoking Float#ceil. &#xA;    1.ceil        =&gt; 1&#xA;   1.2.ceil      =&gt; 2&#xA;   (-1.2).ceil   =&gt; -1&#xA;   (-1.0).ceil   =&gt; -1" />
        <scope name="coerce" ilk="function" signature="coerce(p1)" doc="If aNumeric is the same type as num, returns an array containing aNumeric and num. Otherwise, returns an array with both aNumeric and num represented as Float objects. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. &#xA;    1.coerce(2.5)   =&gt; [2.5, 1.0]&#xA;   1.2.coerce(3)   =&gt; [3.0, 1.2]&#xA;   1.coerce(2)     =&gt; [2, 1]" />
        <scope name="conj" ilk="function" signature="conj()" doc="Returns self." />
        <scope name="conjugate" ilk="function" signature="conjugate()" doc="Returns self." />
        <scope name="denominator" ilk="function" signature="denominator()" doc="Returns the denominator (always positive)." />
        <scope name="div" ilk="function" signature="div(p1)" doc="Uses / to perform division, then converts the result to an integer. numeric does not define the / operator; this is left to subclasses. &#xA; Equivalent to num.divmod(aNumeric)[0]. &#xA; See Numeric#divmod." />
        <scope name="divmod" ilk="function" signature="divmod(p1)" doc="Returns an array containing the quotient and modulus obtained by dividing num by numeric. If q, r = x.divmod(y), then &#xA;     q = floor(x/y)&#xA;    x = q*y+r&#xA; The quotient is rounded toward -infinity, as shown in the following table: &#xA;    a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)&#xA;  ------+-----+---------------+---------+-------------+---------------&#xA;   13   |  4  |   3,    1     |   3     |    1        |     1&#xA;  ------+-----+---------------+---------+-------------+---------------&#xA;   13   | -4  |  -4,   -3     |  -4     |   -3        |     1&#xA;  ------+-----+---------------+---------+-------------+---------------&#xA;  -13   |  4  |  -4,    3     |  -4     |    3        |    -1&#xA;  ------+-----+---------------+---------+-------------+---------------&#xA;  -13   | -4  |   3,   -1     |   3     |   -1        |    -1" />
        <scope name="fdiv" ilk="function" signature="fdiv(p1)" doc="Returns float division." />
        <scope name="floor" ilk="function" signature="floor()" doc="Returns the largest integer less than or equal to num. Numeric implements this by converting anInteger to a Float and invoking Float#floor. &#xA;    1.floor      =&gt; 1&#xA;   (-1).floor   =&gt; -1" />
        <scope name="i" ilk="function" signature="i()" doc="Returns the corresponding imaginary number. Not available for complex numbers." />
        <scope name="imag" ilk="function" signature="imag()" doc="Returns zero." />
        <scope name="imaginary" ilk="function" signature="imaginary()" doc="Returns zero." />
        <scope name="integer?" ilk="function" signature="integer?()" doc="Returns true if num is an Integer (including Fixnum and Bignum)." />
        <scope name="magnitude" ilk="function" signature="magnitude()" doc="Returns the absolute value of num. &#xA;    12.abs         =&gt; 12&#xA;   (-34.56).abs   =&gt; 34.56&#xA;   -34.56.abs     =&gt; 34.56" />
        <scope name="modulo" ilk="function" signature="modulo(p1)" doc="   x.modulo(y) means x-y*(x/y).floor&#xA; Equivalent to num.divmod(aNumeric)[1]. &#xA; See Numeric#divmod." />
        <scope name="nonzero?" ilk="function" signature="nonzero?()" doc="Returns +self+ if num is not zero, nil otherwise. This behavior is useful when chaining comparisons: &#xA;    a = %w( z Bb bB bb BB a aA Aa AA A )&#xA;   b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }&#xA;   b   =&gt; [&quot;A&quot;, &quot;a&quot;, &quot;AA&quot;, &quot;Aa&quot;, &quot;aA&quot;, &quot;BB&quot;, &quot;Bb&quot;, &quot;bB&quot;, &quot;bb&quot;, &quot;z&quot;]" />
        <scope name="numerator" ilk="function" signature="numerator()" doc="Returns the numerator." />
        <scope name="phase" ilk="function" signature="phase()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="polar" ilk="function" signature="polar()" doc="Returns an array; [num.abs, num.arg]." />
        <scope name="quo" ilk="function" signature="quo(p1)" doc="Returns most exact division (rational for integers, float for floats)." />
        <scope name="real" ilk="function" signature="real()" doc="Returns self." />
        <scope name="real?" ilk="function" signature="real?()" doc="Returns true if num is a Real (i.e. non Complex)." />
        <scope name="rect" ilk="function" signature="rect()" doc="Returns an array; [num, 0]." />
        <scope name="rectangular" ilk="function" signature="rectangular()" doc="Returns an array; [num, 0]." />
        <scope name="remainder" ilk="function" signature="remainder(p1)" doc="   x.remainder(y) means x-y*(x/y).truncate&#xA; See Numeric#divmod." />
        <scope name="round" ilk="function" signature="round(...)" doc="Rounds num to a given precision in decimal digits (default 0 digits). Precision may be negative.  Returns a floating point number when ndigits is more than zero.  Numeric implements this by converting itself to a Float and invoking Float#round." />
        <scope name="singleton_method_added" ilk="function" signature="singleton_method_added(p1)" doc="Trap attempts to add methods to Numeric objects. Always raises a TypeError" />
        <scope name="step" ilk="function" signature="step(...)" doc="Invokes block with the sequence of numbers starting at num, incremented by step (default 1) on each call. The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative). If all the arguments are integers, the loop operates using an integer counter. If any of the arguments are floating point numbers, all are converted to floats, and the loop is executed floor(n + n*epsilon)+ 1 times, where n = (limit - num)/step. Otherwise, the loop starts at num, uses either the &lt; or &gt; operator to compare the counter against limit, and increments itself using the + operator. &#xA; If no block is given, an enumerator is returned instead. &#xA;    1.step(10, 2) { |i| print i, &quot; &quot; }&#xA;   Math::E.step(Math::PI, 0.2) { |f| print f, &quot; &quot; }&#xA; produces: &#xA;    1 3 5 7 9&#xA;   2.71828182845905 2.91828182845905 3.11828182845905" />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns the value as a complex." />
        <scope name="to_int" ilk="function" signature="to_int()" doc="Invokes the child class&apos;s to_i method to convert num to an integer." />
        <scope name="truncate" ilk="function" signature="truncate()" doc="Returns num truncated to an integer. Numeric implements this by converting its value to a float and invoking Float#truncate." />
        <scope name="zero?" ilk="function" signature="zero?()" doc="Returns true if num has a zero value." />
      </scope>
      <scope name="Integer" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="chr" ilk="function" />
        <scope name="downto" ilk="function" />
        <scope name="even?" ilk="function" />
        <scope name="gcd" ilk="function" />
        <scope name="gcdlcm" ilk="function" signature="gcdlcm(p1)" doc="Returns an array; [int.gcd(int2), int.lcm(int2)]. &#xA; For example: &#xA;    2.gcdlcm(2)                    =&gt; [2, 2]&#xA;   3.gcdlcm(-7)                   =&gt; [1, 21]&#xA;   ((1&lt;&lt;31)-1).gcdlcm((1&lt;&lt;61)-1)  =&gt; [1, 4951760154835678088235319297]" />
        <scope name="lcm" ilk="function" />
        <scope name="next" ilk="function" signature="next()" doc="Returns the Integer equal to int + 1. &#xA;    1.next      =&gt; 2&#xA;   (-1).next   =&gt; 0" />
        <scope name="odd?" ilk="function" signature="odd?()" doc="Returns true if int is an odd number." />
        <scope name="ord" ilk="function" signature="ord()" doc="Returns the int itself. &#xA;    ?a.ord    =&gt; 97&#xA; This method is intended for compatibility to character constant in Ruby 1.9. For example, ?a.ord returns 97 both in 1.8 and 1.9." />
        <scope name="pred" ilk="function" />
        <scope name="rationalize" ilk="function" />
        <scope name="succ" ilk="function" />
        <scope name="times" ilk="function" signature="times()" doc="Iterates block int times, passing in values from zero to int - 1. &#xA; If no block is given, an enumerator is returned instead. &#xA;    5.times do |i|&#xA;     print i, &quot; &quot;&#xA;   end&#xA; produces: &#xA;    0 1 2 3 4" />
        <scope name="to_i" ilk="function" />
        <scope name="to_r" ilk="function" />
        <scope name="upto" ilk="function" />
      </scope>
      <scope name="Fixnum" ilk="class" classrefs="Integer" >
        <import symbol="Comparable" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of bytes in the machine representation of a Fixnum. &#xA;    1.size            =&gt; 4&#xA;   -1.size           =&gt; 4&#xA;   2147483647.size   =&gt; 4" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Converts fix to a Float." />
      </scope>
      <scope name="Float" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="finite?" ilk="function" signature="finite?()" doc="Returns true if flt is a valid IEEE floating point number (it is not infinite, and nan? is false)." />
        <scope name="infinite?" ilk="function" signature="infinite?()" doc="Returns nil, -1, or +1 depending on whether flt is finite, -infinity, or +infinity. &#xA;    (0.0).infinite?        =&gt; nil&#xA;   (-1.0/0.0).infinite?   =&gt; -1&#xA;   (+1.0/0.0).infinite?   =&gt; 1" />
        <scope name="nan?" ilk="function" signature="nan?()" doc="Returns true if flt is an invalid IEEE floating point number. &#xA;    a = -1.0      =&gt; -1.0&#xA;   a.nan?        =&gt; false&#xA;   a = 0.0/0.0   =&gt; NaN&#xA;   a.nan?        =&gt; true" />
        <scope name="rationalize" ilk="function" signature="rationalize(...)" doc="Returns a simpler approximation of the value (flt-|eps| &lt;= result &lt;= flt+|eps|).  if eps is not given, it will be chosen automatically. &#xA; For example: &#xA;    0.3.rationalize          =&gt; (3/10)&#xA;   1.333.rationalize        =&gt; (1333/1000)&#xA;   1.333.rationalize(0.01)  =&gt; (4/3)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="As flt is already a float, returns +self+." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns flt truncated to an Integer." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value as a rational. &#xA; NOTE: 0.3.to_r isn&apos;t the same as &apos;0.3&apos;.to_r.  The latter is equivalent to &apos;3/10&apos;.to_r, but the former isn&apos;t so. &#xA; For example: &#xA;    2.0.to_r    =&gt; (2/1)&#xA;   2.5.to_r    =&gt; (5/2)&#xA;   -0.75.to_r  =&gt; (-3/4)&#xA;   0.0.to_r    =&gt; (0/1)" />
        <variable name="DIG" attributes="__const__" citdl="Fixnum" />
        <variable name="EPSILON" attributes="__const__" citdl="Float" />
        <variable name="INFINITY" attributes="__const__" citdl="Float" />
        <variable name="MANT_DIG" attributes="__const__" citdl="Fixnum" />
        <variable name="MAX" attributes="__const__" citdl="Float" />
        <variable name="MAX_10_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MAX_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MIN" attributes="__const__" citdl="Float" />
        <variable name="MIN_10_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MIN_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="NAN" attributes="__const__" citdl="Float" />
        <variable name="RADIX" attributes="__const__" citdl="Fixnum" />
        <variable name="ROUNDS" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Bignum" ilk="class" classrefs="Integer" >
        <import symbol="Comparable" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of bytes in the machine representation of big. &#xA;    (256**10 - 1).size   =&gt; 12&#xA;   (256**20 - 1).size   =&gt; 20&#xA;   (256**40 - 1).size   =&gt; 40" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Converts big to a Float. If big doesn&apos;t fit in a Float, the result is infinity." />
      </scope>
      <scope name="Array" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="assoc" ilk="function" signature="assoc(p1)" doc="Searches through an array whose elements are also arrays comparing _obj_ with the first element of each contained array using obj.==. Returns the first contained array that matches (that is, the first associated array), or +nil+ if no match is found. See also Array#rassoc. &#xA;    s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]&#xA;   s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   s3 = &quot;foo&quot;&#xA;   a  = [ s1, s2, s3 ]&#xA;   a.assoc(&quot;letters&quot;)  =&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.assoc(&quot;foo&quot;)      =&gt; nil" />
        <scope name="at" ilk="function" signature="at(p1)" doc="Returns the element at _index_. A negative index counts from the end of +self+.  Returns +nil+ if the index is out of range. See also Array#[]. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;   a.at(0)     =&gt; &quot;a&quot;&#xA;   a.at(-1)    =&gt; &quot;e&quot;" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all elements from +self+. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;   a.clear    =&gt; [ ]" />
        <scope name="collect!" ilk="function" signature="collect!()" doc="Invokes the block once for each element of +self+, replacing the element with the value returned by _block_. See also Enumerable#collect. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.collect! {|x| x + &quot;!&quot; }&#xA;   a             =&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]" />
        <scope name="combination" ilk="function" signature="combination(p1)" doc=" &#xA; When invoked with a block, yields all combinations of length n of elements from ary and then returns ary itself. The implementation makes no guarantees about the order in which the combinations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA;     a = [1, 2, 3, 4]&#xA;    a.combination(1).to_a  =&gt; [[1],[2],[3],[4]]&#xA;    a.combination(2).to_a  =&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]&#xA;    a.combination(3).to_a  =&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]&#xA;    a.combination(4).to_a  =&gt; [[1,2,3,4]]&#xA;    a.combination(0).to_a  =&gt; [[]] # one combination of length 0&#xA;    a.combination(5).to_a  =&gt; []   # no combinations of length 5" />
        <scope name="compact" ilk="function" signature="compact()" doc="Returns a copy of +self+ with all +nil+ elements removed. &#xA;    [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact&#xA;                     =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]" />
        <scope name="compact!" ilk="function" signature="compact!()" doc="Removes +nil+ elements from the array. Returns +nil+ if no changes were made, otherwise returns ary. &#xA;    [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           =&gt; nil" />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Appends the elements of other_ary to +self+. &#xA;    [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]" />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Deletes items from +self+ that are equal to obj. If any items are found, returns obj.   If the item is not found, returns nil. If the optional code block is given, returns the result of block if the item is not found.  (To remove nil elements and get an informative return value, use #compact!) &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.delete(&quot;b&quot;)                   =&gt; &quot;b&quot;&#xA;   a                               =&gt; [&quot;a&quot;, &quot;c&quot;]&#xA;   a.delete(&quot;z&quot;)                   =&gt; nil&#xA;   a.delete(&quot;z&quot;) { &quot;not found&quot; }   =&gt; &quot;not found&quot;" />
        <scope name="delete_at" ilk="function" signature="delete_at(p1)" doc="Deletes the element at the specified index, returning that element, or nil if the index is out of range. See also Array#slice!. &#xA;    a = %w( ant bat cat dog )&#xA;   a.delete_at(2)    =&gt; &quot;cat&quot;&#xA;   a                 =&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]&#xA;   a.delete_at(99)   =&gt; nil" />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every element of +self+ for which block evaluates to true. See also Array#reject! &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.delete_if {|x| x &gt;= &quot;b&quot; }   =&gt; [&quot;a&quot;]" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each element in +self+, passing that element as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.each {|x| print x, &quot; -- &quot; }&#xA; produces: &#xA;    a -- b -- c --" />
        <scope name="each_index" ilk="function" signature="each_index()" doc="Same as Array#each, but passes the index of the element instead of the element itself. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.each_index {|x| print x, &quot; -- &quot; }&#xA; produces: &#xA;    0 -- 1 -- 2 --" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if +self+ contains no elements. &#xA;    [].empty?   =&gt; true" />
        <scope name="fetch" ilk="function" signature="fetch(...)" doc="Tries to return the element at position index. If the index lies outside the array, the first form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking the block, passing in the index. Negative values of index count from the end of the array. &#xA;    a = [ 11, 22, 33, 44 ]&#xA;   a.fetch(1)               =&gt; 22&#xA;   a.fetch(-1)              =&gt; 44&#xA;   a.fetch(4, &apos;cat&apos;)        =&gt; &quot;cat&quot;&#xA;   a.fetch(4) { |i| i*i }   =&gt; 16" />
        <scope name="fill" ilk="function" signature="fill(...)" doc="The first three forms set the selected elements of +self+ (which may be the entire array) to obj. A start of nil is equivalent to zero. A length of nil is equivalent to self.length. The last three forms fill the array with the value of the block. The block is passed the absolute index of each element to be filled. Negative values of start count from the end of the array. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.fill(&quot;x&quot;)              =&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]&#xA;   a.fill(&quot;z&quot;, 2, 2)        =&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]&#xA;   a.fill(&quot;y&quot;, 0..1)        =&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]&#xA;   a.fill {|i| i*i}         =&gt; [0, 1, 4, 9]&#xA;   a.fill(-2) {|i| i*i*i}   =&gt; [0, 1, 8, 27]" />
        <scope name="flatten" ilk="function" signature="flatten(...)" doc="Returns a new array that is a one-dimensional flattening of this array (recursively). That is, for every element that is an array, extract its elements into the new array.  If the optional level argument determines the level of recursion to flatten. &#xA;    s = [ 1, 2, 3 ]           =&gt; [1, 2, 3]&#xA;   t = [ 4, 5, 6, [7, 8] ]   =&gt; [4, 5, 6, [7, 8]]&#xA;   a = [ s, t, 9, 10 ]       =&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]&#xA;   a.flatten                 =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#xA;   a = [ 1, 2, [3, [4, 5] ] ]&#xA;   a.flatten(1)              =&gt; [1, 2, 3, [4, 5]]" />
        <scope name="flatten!" ilk="function" signature="flatten!(...)" doc="Flattens +self+ in place. Returns nil if no modifications were made (i.e., ary contains no subarrays.)  If the optional level argument determines the level of recursion to flatten. &#xA;    a = [ 1, 2, [3, [4, 5] ] ]&#xA;   a.flatten!   =&gt; [1, 2, 3, 4, 5]&#xA;   a.flatten!   =&gt; nil&#xA;   a            =&gt; [1, 2, 3, 4, 5]&#xA;   a = [ 1, 2, [3, [4, 5] ] ]&#xA;   a.flatten!(1) =&gt; [1, 2, 3, [4, 5]]" />
        <scope name="index" ilk="function" signature="index(...)" doc="Returns the index of the first object in +self+ such that is == to obj. If a block is given instead of an argument, returns first object for which block is true. Returns nil if no match is found. See also Array#rindex. &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.index(&quot;b&quot;)        =&gt; 1&#xA;   a.index(&quot;z&quot;)        =&gt; nil&#xA;   a.index{|x|x==&quot;b&quot;}  =&gt; 1&#xA; This is an alias of #find_index." />
        <scope name="insert" ilk="function" signature="insert(...)" doc="Inserts the given values before the element with the given index (which may be negative). &#xA;    a = %w{ a b c d }&#xA;   a.insert(2, 99)         =&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]&#xA;   a.insert(-2, 1, 2, 3)   =&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]" />
        <scope name="join" ilk="function" signature="join(...)" doc="Returns a string created by converting each element of the array to a string, separated by sep. &#xA;    [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        =&gt; &quot;abc&quot;&#xA;   [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   =&gt; &quot;a-b-c&quot;" />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every element of +self+ for which block evaluates to false. See also Array#select! &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = %w{ a b c d e f }&#xA;   a.keep_if {|v| v =~ /[aeiou]/}   =&gt; [&quot;a&quot;, &quot;e&quot;]" />
        <scope name="last" ilk="function" signature="last(...)" doc="Returns the last element(s) of +self+. If the array is empty, the first form returns nil. &#xA;    a = [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ]&#xA;   a.last     =&gt; &quot;z&quot;&#xA;   a.last(2)  =&gt; [&quot;y&quot;, &quot;z&quot;]" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of elements in +self+. May be zero. &#xA;    [ 1, 2, 3, 4, 5 ].length   =&gt; 5" />
        <scope name="map!" ilk="function" signature="map!()" doc="Invokes the block once for each element of +self+, replacing the element with the value returned by _block_. See also Enumerable#collect. &#xA; If no block is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.collect! {|x| x + &quot;!&quot; }&#xA;   a             =&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]" />
        <scope name="pack" ilk="function" signature="pack(p1)" doc="Packs the contents of arr into a binary sequence according to the directives in aTemplateString (see the table below) Directives ``A,&apos;&apos; ``a,&apos;&apos; and ``Z&apos;&apos; may be followed by a count, which gives the width of the resulting field. The remaining directives also may take a count, indicating the number of array elements to convert. If the count is an asterisk (``*&apos;&apos;), all remaining array elements will be converted. Any of the directives ``sSiIlL&apos;&apos; may be followed by an underscore (``_&apos;&apos;) or exclamation mark (``!&apos;&apos;) to use the underlying platform&apos;s native size for the specified type; otherwise, they use a platform-independent size. Spaces are ignored in the template string. See also String#unpack. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   n = [ 65, 66, 67 ]&#xA;   a.pack(&quot;A3A3A3&quot;)   =&gt; &quot;a  b  c  &quot;&#xA;   a.pack(&quot;a3a3a3&quot;)   =&gt; &quot;a\000\000b\000\000c\000\000&quot;&#xA;   n.pack(&quot;ccc&quot;)      =&gt; &quot;ABC&quot;&#xA; Directives for +pack+. &#xA;  Integer      | Array   |&#xA; Directive    | Element | Meaning&#xA; ---------------------------------------------------------------------------&#xA;    C         | Integer | 8-bit unsigned integer (unsigned char)&#xA;    S         | Integer | 16-bit unsigned integer, native endian (uint16_t)&#xA;    L         | Integer | 32-bit unsigned integer, native endian (uint32_t)" />
        <scope name="permutation" ilk="function" signature="permutation(...)" doc=" &#xA; When invoked with a block, yield all permutations of length n of the elements of ary, then return the array itself. If n is not specified, yield all permutations of all elements. The implementation makes no guarantees about the order in which the permutations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA;     a = [1, 2, 3]&#xA;    a.permutation.to_a     =&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&#xA;    a.permutation(1).to_a  =&gt; [[1],[2],[3]]&#xA;    a.permutation(2).to_a  =&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]&#xA;    a.permutation(3).to_a  =&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&#xA;    a.permutation(0).to_a  =&gt; [[]] # one permutation of length 0&#xA;    a.permutation(4).to_a  =&gt; []   # no permutations of length 4" />
        <scope name="pop" ilk="function" signature="pop(...)" doc="Removes the last element from +self+ and returns it, or nil if the array is empty. &#xA; If a number _n_ is given, returns an array of the last n elements (or less) just like array.slice!(-n, n) does. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.pop     =&gt; &quot;d&quot;&#xA;   a.pop(2)  =&gt; [&quot;b&quot;, &quot;c&quot;]&#xA;   a         =&gt; [&quot;a&quot;]" />
        <scope name="product" ilk="function" signature="product(...)" doc="Returns an array of all combinations of elements from all arrays, The length of the returned array is the product of the length of +self+ and the argument arrays. If given a block, product will yield all combinations and return +self+ instead. &#xA;    [1,2,3].product([4,5])     =&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]&#xA;   [1,2].product([1,2])       =&gt; [[1,1],[1,2],[2,1],[2,2]]&#xA;   [1,2].product([3,4],[5,6]) =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],&#xA;                              #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]&#xA;   [1,2].product()            =&gt; [[1],[2]]&#xA;   [1,2].product([])          =&gt; []" />
        <scope name="push" ilk="function" signature="push(...)" doc="Append---Pushes the given object(s) on to the end of this array. This expression returns the array itself, so several appends may be chained together. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)&#xA;           =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]" />
        <scope name="rassoc" ilk="function" signature="rassoc(p1)" doc="Searches through the array whose elements are also arrays. Compares _obj_ with the second element of each contained array using ==. Returns the first contained array that matches. See also Array#assoc. &#xA;    a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]&#xA;   a.rassoc(&quot;two&quot;)    =&gt; [2, &quot;two&quot;]&#xA;   a.rassoc(&quot;four&quot;)   =&gt; nil" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Array#delete_if, deleting elements from +self+ for which the block evaluates to true, but returns nil if no changes were made. See also Enumerable#reject and Array#delete_if. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="repeated_combination" ilk="function" signature="repeated_combination(p1)" doc=" &#xA; When invoked with a block, yields all repeated combinations of length n of elements from ary and then returns ary itself. The implementation makes no guarantees about the order in which the repeated combinations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA;     a = [1, 2, 3]&#xA;    a.repeated_combination(1).to_a  =&gt; [[1], [2], [3]]&#xA;    a.repeated_combination(2).to_a  =&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]&#xA;    a.repeated_combination(3).to_a  =&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],&#xA;                                    #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]&#xA;    a.repeated_combination(4).to_a  =&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],&#xA;                                    #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],&#xA;                                    #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]&#xA;    a.repeated_combination(0).to_a  =&gt; [[]] # one combination of length 0" />
        <scope name="repeated_permutation" ilk="function" signature="repeated_permutation(p1)" doc=" &#xA; When invoked with a block, yield all repeated permutations of length n of the elements of ary, then return the array itself. The implementation makes no guarantees about the order in which the repeated permutations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA;     a = [1, 2]&#xA;    a.repeated_permutation(1).to_a  =&gt; [[1], [2]]&#xA;    a.repeated_permutation(2).to_a  =&gt; [[1,1],[1,2],[2,1],[2,2]]&#xA;    a.repeated_permutation(3).to_a  =&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],&#xA;                                    #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]&#xA;    a.repeated_permutation(0).to_a  =&gt; [[]] # one permutation of length 0" />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents of +self+ with the contents of other_ary, truncating or expanding if necessary. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;   a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]&#xA;   a                              =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]" />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a new array containing +self+&apos;s elements in reverse order. &#xA;    [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]&#xA;   [ 1 ].reverse               =&gt; [1]" />
        <scope name="reverse!" ilk="function" signature="reverse!()" doc="Reverses +self+ in place. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.reverse!       =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]&#xA;   a                =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]" />
        <scope name="rindex" ilk="function" signature="rindex(...)" doc="Returns the index of the last object in +self+ == to obj. If a block is given instead of an argument, returns first object for which block is true, starting from the last object. Returns nil if no match is found. See also Array#index. &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.rindex(&quot;b&quot;)        =&gt; 3&#xA;   a.rindex(&quot;z&quot;)        =&gt; nil&#xA;   a.rindex{|x|x==&quot;b&quot;}  =&gt; 3" />
        <scope name="rotate" ilk="function" signature="rotate(...)" doc="Returns new array by rotating +self+, whose first element is the element at +cnt+ in +self+.  If +cnt+ is negative then it rotates in counter direction. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.rotate         =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;   a                =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#xA;   a.rotate(2)      =&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]&#xA;   a.rotate(-3)     =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]" />
        <scope name="rotate!" ilk="function" signature="rotate!(...)" doc="Rotates +self+ in place so that the element at +cnt+ comes first, and returns +self+.  If +cnt+ is negative then it rotates in counter direction. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.rotate!        =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;   a                =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;   a.rotate!(2)     =&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;   a.rotate!(-3)    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="sample" ilk="function" signature="sample(...)" doc="Choose a random element or +n+ random elements from the array. The elements are chosen by using random and unique indices into the array in order to ensure that an element doesn&apos;t repeat itself unless the array already contained duplicate elements. If the array is empty the first form returns nil and the second form returns an empty array." />
        <scope name="select!" ilk="function" signature="select!()" doc="Invokes the block passing in successive elements from +self+, deleting elements for which the block returns a false value. It returns +self+ if changes were made, otherwise it returns nil. See also Array#keep_if &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="shift" ilk="function" signature="shift(...)" doc="Returns the first element of +self+ and removes it (shifting all other elements down by one). Returns nil if the array is empty. &#xA; If a number _n_ is given, returns an array of the first n elements (or less) just like array.slice!(0, n) does. &#xA;    args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]&#xA;   args.shift     =&gt; &quot;-m&quot;&#xA;   args           =&gt; [&quot;-q&quot;, &quot;filename&quot;]&#xA;&#xA;   args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]&#xA;   args.shift(2)  =&gt; [&quot;-m&quot;, &quot;-q&quot;]&#xA;   args           =&gt; [&quot;filename&quot;]" />
        <scope name="shuffle" ilk="function" signature="shuffle()" doc="Returns a new array with elements of this array shuffled. &#xA;    a = [ 1, 2, 3 ]           =&gt; [1, 2, 3]&#xA;   a.shuffle                 =&gt; [2, 3, 1]" />
        <scope name="shuffle!" ilk="function" signature="shuffle!()" doc="Shuffles elements in +self+ in place." />
        <scope name="size" ilk="function" signature="size()" />
        <scope name="slice" ilk="function" signature="slice(...)" doc="Element Reference---Returns the element at _index_, or returns a subarray starting at _start_ and continuing for _length_ elements, or returns a subarray specified by _range_. Negative indices count backward from the end of the array (-1 is the last element). Returns +nil+ if the index (or starting index) are out of range. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;   a[2] +  a[0] + a[1]    =&gt; &quot;cab&quot;&#xA;   a[6]                   =&gt; nil&#xA;   a[1, 2]                =&gt; [ &quot;b&quot;, &quot;c&quot; ]&#xA;   a[1..3]                =&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a[4..7]                =&gt; [ &quot;e&quot; ]&#xA;   a[6..10]               =&gt; nil&#xA;   a[-3, 3]               =&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;   # special cases&#xA;   a[5]                   =&gt; nil&#xA;   a[5, 1]                =&gt; []&#xA;   a[5..10]               =&gt; []" />
        <scope name="slice!" ilk="function" signature="slice!(...)" doc="Deletes the element(s) given by an index (optionally with a length) or by a range. Returns the deleted object (or objects), or nil if the index is out of range. &#xA;    a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.slice!(1)     =&gt; &quot;b&quot;&#xA;   a               =&gt; [&quot;a&quot;, &quot;c&quot;]&#xA;   a.slice!(-1)    =&gt; &quot;c&quot;&#xA;   a               =&gt; [&quot;a&quot;]&#xA;   a.slice!(100)   =&gt; nil&#xA;   a               =&gt; [&quot;a&quot;]" />
        <scope name="sort!" ilk="function" signature="sort!()" doc="Sorts +self+. Comparisons for the sort will be done using the &lt;=&gt; operator or using an optional code block. The block implements a comparison between a and b, returning -1, 0, or +1. See also Enumerable#sort_by. &#xA;    a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]&#xA;   a.sort                    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]&#xA;   a.sort {|x,y| y &lt;=&gt; x }   =&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]" />
        <scope name="sort_by!" ilk="function" signature="sort_by!()" doc="Sorts +self+ in place using a set of keys generated by mapping the values in +self+ through the given block. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="to_ary" ilk="function" signature="to_ary()" doc="Returns +self+." />
        <scope name="transpose" ilk="function" signature="transpose()" doc="Assumes that +self+ is an array of arrays and transposes the rows and columns. &#xA;    a = [[1,2], [3,4], [5,6]]&#xA;   a.transpose   =&gt; [[1, 3, 5], [2, 4, 6]]" />
        <scope name="uniq" ilk="function" signature="uniq()" doc="Returns a new array by removing duplicate values in +self+. &#xA;    a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.uniq   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;   c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]&#xA;   c.uniq {|s| s[/^\w+/]}  =&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]" />
        <scope name="uniq!" ilk="function" signature="uniq!()" doc="Removes duplicate elements from +self+. Returns nil if no changes are made (that is, no duplicates are found). &#xA;    a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   a.uniq!   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;   b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;   b.uniq!   =&gt; nil&#xA;   c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]&#xA;   c.uniq! {|s| s[/^\w+/]}  =&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]" />
        <scope name="unshift" ilk="function" signature="unshift(...)" doc="Prepends objects to the front of +self+, moving other elements upwards. &#xA;    a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;   a.unshift(&quot;a&quot;)   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#xA;   a.unshift(1, 2)  =&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="values_at" ilk="function" signature="values_at(...)" doc="Returns an array containing the elements in +self+ corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also Array#select. &#xA;    a = %w{ a b c d e f }&#xA;   a.values_at(1, 3, 5)&#xA;   a.values_at(1, 3, 5, 7)&#xA;   a.values_at(-1, -3, -5, -7)&#xA;   a.values_at(1..3, 2...5)" />
        <scope name="yaml_initialize" ilk="function" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](...)" doc="Returns a new array populated with the given objects. &#xA;   Array.[]( 1, &apos;a&apos;, /^A/ )&#xA;  Array[ 1, &apos;a&apos;, /^A/ ]&#xA;  [ 1, &apos;a&apos;, /^A/ ]" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into an array, using +to_ary+ method. Returns converted array or +nil+ if obj cannot be converted for any reason. This method can be used to check if an argument is an array. &#xA;    Array.try_convert([1])   =&gt; [1]&#xA;   Array.try_convert(&quot;1&quot;)   =&gt; nil&#xA;&#xA;   if tmp = Array.try_convert(arg)&#xA;     # the argument is an array&#xA;   elsif tmp = String.try_convert(arg)&#xA;     # the argument is a string&#xA;   end" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new array. In the first form, the new array is empty. In the second it is created with _size_ copies of _obj_ (that is, _size_ references to the same _obj_). The third form creates a copy of the array passed as a parameter (the array is generated by calling to_ary  on the parameter). In the last form, an array of the given size is created. Each element in this array is calculated by passing the element&apos;s index to the given block and storing the return value. &#xA;    Array.new&#xA;   Array.new(2)&#xA;   Array.new(5, &quot;A&quot;)&#xA;   # only one copy of the object is created&#xA;   a = Array.new(2, Hash.new)&#xA;   a[0][&apos;cat&apos;] = &apos;feline&apos;&#xA;   a&#xA;   a[1][&apos;cat&apos;] = &apos;Felix&apos;&#xA;   a&#xA;   # here multiple copies are created&#xA;   a = Array.new(2) { Hash.new }&#xA;   a[0][&apos;cat&apos;] = &apos;feline&apos;" />
      </scope>
      <scope name="Hash" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="assoc" ilk="function" signature="assoc(p1)" doc="Searches through the hash comparing _obj_ with the key using ==. Returns the key-value pair (two elements array) or +nil+ if no match is found.  See Array#assoc. &#xA;    h = {&quot;colors&quot;  =&gt; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;],&#xA;        &quot;letters&quot; =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]}&#xA;   h.assoc(&quot;letters&quot;)  =&gt; [&quot;letters&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]&#xA;   h.assoc(&quot;foo&quot;)      =&gt; nil" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all key-value pairs from hsh. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;   h.clear                          =&gt; {}" />
        <scope name="compare_by_identity" ilk="function" signature="compare_by_identity()" doc="Makes hsh compare its keys by their identity, i.e. it will consider exact same objects as same keys. &#xA;    h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, :c =&gt; &quot;c&quot; }&#xA;   h1[&quot;a&quot;]        =&gt; 100&#xA;   h1.compare_by_identity&#xA;   h1.compare_by_identity? =&gt; true&#xA;   h1[&quot;a&quot;]        =&gt; nil  # different objects.&#xA;   h1[:c]         =&gt; &quot;c&quot;  # same symbols are all same." />
        <scope name="compare_by_identity?" ilk="function" signature="compare_by_identity?()" doc="Returns true if hsh will compare its keys by their identity.  Also see Hash#compare_by_identity." />
        <scope name="default" ilk="function" signature="default(...)" doc="Returns the default value, the value that would be returned by hsh[key] if key did not exist in hsh. See also Hash::new and Hash#default=. &#xA;    h = Hash.new                            =&gt; {}&#xA;   h.default                               =&gt; nil&#xA;   h.default(2)                            =&gt; nil&#xA;&#xA;   h = Hash.new(&quot;cat&quot;)                     =&gt; {}&#xA;   h.default                               =&gt; &quot;cat&quot;&#xA;   h.default(2)                            =&gt; &quot;cat&quot;&#xA;&#xA;   h = Hash.new {|h,k| h[k] = k.to_i*10}   =&gt; {}&#xA;   h.default                               =&gt; nil&#xA;   h.default(2)                            =&gt; 20" />
        <scope name="default=" ilk="function" signature="default=(p1)" doc="Sets the default value, the value returned for a key that does not exist in the hash. It is not possible to set the default to a Proc that will be executed on each key lookup. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.default = &quot;Go fish&quot;&#xA;   h[&quot;a&quot;]     =&gt; 100&#xA;   h[&quot;z&quot;]     =&gt; &quot;Go fish&quot;&#xA;   # This doesn&apos;t do what you might hope...&#xA;   h.default = proc do |hash, key|&#xA;     hash[key] = key + key&#xA;   end&#xA;   h[2]       =&gt; #&lt;Proc:0x401b3948@-:6&gt;&#xA;   h[&quot;cat&quot;]   =&gt; #&lt;Proc:0x401b3948@-:6&gt;" />
        <scope name="default_proc" ilk="function" signature="default_proc()" doc="If Hash::new was invoked with a block, return that block, otherwise return nil. &#xA;    h = Hash.new {|h,k| h[k] = k*k }   =&gt; {}&#xA;   p = h.default_proc                 =&gt; #&lt;Proc:0x401b3d08@-:1&gt;&#xA;   a = []                             =&gt; []&#xA;   p.call(a, 2)&#xA;   a                                  =&gt; [nil, nil, 4]" />
        <scope name="default_proc=" ilk="function" signature="default_proc=(p1)" doc="Sets the default proc to be executed on each key lookup. &#xA;    h.default_proc = proc do |hash, key|&#xA;     hash[key] = key + key&#xA;   end&#xA;   h[2]       =&gt; 4&#xA;   h[&quot;cat&quot;]   =&gt; &quot;catcat&quot;" />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Deletes and returns a key-value pair from hsh whose key is equal to key. If the key is not found, returns the default value. If the optional code block is given and the key is not found, pass in the key and return the result of block. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.delete(&quot;a&quot;)                              =&gt; 100&#xA;   h.delete(&quot;z&quot;)                              =&gt; nil&#xA;   h.delete(&quot;z&quot;) { |el| &quot;#{el} not found&quot; }   =&gt; &quot;z not found&quot;" />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every key-value pair from hsh for which block evaluates to true. &#xA; If no block is given, an enumerator is returned instead. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300 }&#xA;   h.delete_if {|key, value| key &gt;= &quot;b&quot; }   =&gt; {&quot;a&quot;=&gt;100}" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each key in hsh, passing the key-value pair as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.each {|key, value| puts &quot;#{key} is #{value}&quot; }&#xA; produces: &#xA;    a is 100&#xA;   b is 200" />
        <scope name="each_key" ilk="function" signature="each_key()" doc="Calls block once for each key in hsh, passing the key as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.each_key {|key| puts key }&#xA; produces: &#xA;    a&#xA;   b" />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Calls block once for each key in hsh, passing the key-value pair as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.each {|key, value| puts &quot;#{key} is #{value}&quot; }&#xA; produces: &#xA;    a is 100&#xA;   b is 200" />
        <scope name="each_value" ilk="function" signature="each_value()" doc="Calls block once for each key in hsh, passing the value as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.each_value {|value| puts value }&#xA; produces: &#xA;    100&#xA;   200" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if hsh contains no key-value pairs. &#xA;    {}.empty?   =&gt; true" />
        <scope name="fetch" ilk="function" signature="fetch(...)" doc="Returns a value from the hash for the given key. If the key can&apos;t be found, there are several options: With no other arguments, it will raise an KeyError exception; if default is given, then that will be returned; if the optional code block is specified, then that will be run and its result returned. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.fetch(&quot;a&quot;)                            =&gt; 100&#xA;   h.fetch(&quot;z&quot;, &quot;go fish&quot;)                 =&gt; &quot;go fish&quot;&#xA;   h.fetch(&quot;z&quot;) { |el| &quot;go fish, #{el}&quot;}   =&gt; &quot;go fish, z&quot;&#xA; The following example shows that an exception is raised if the key is not found and a default value is not supplied. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.fetch(&quot;z&quot;)&#xA; produces: &#xA;    prog.rb:2:in `fetch&apos;: key not found (KeyError)&#xA;    from prog.rb:2" />
        <scope name="flatten" ilk="function" signature="flatten(...)" doc="Returns a new array that is a one-dimensional flattening of this hash. That is, for every key or value that is an array, extract its elements into the new array.  Unlike Array#flatten, this method does not flatten recursively by default.  The optional level argument determines the level of recursion to flatten. &#xA;    a =  {1=&gt; &quot;one&quot;, 2 =&gt; [2,&quot;two&quot;], 3 =&gt; &quot;three&quot;}&#xA;   a.flatten    # =&gt; [1, &quot;one&quot;, 2, [2, &quot;two&quot;], 3, &quot;three&quot;]&#xA;   a.flatten(2) # =&gt; [1, &quot;one&quot;, 2, 2, &quot;two&quot;, 3, &quot;three&quot;]" />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" doc="Returns true if the given key is present in hsh. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.has_key?(&quot;a&quot;)   =&gt; true&#xA;   h.has_key?(&quot;z&quot;)   =&gt; false" />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" doc="Returns true if the given value is present for some key in hsh. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.has_value?(100)   =&gt; true&#xA;   h.has_value?(999)   =&gt; false" />
        <scope name="index" ilk="function" />
        <scope name="invert" ilk="function" signature="invert()" doc="Returns a new hash created by using hsh&apos;s values as keys, and the keys as values. &#xA;    h = { &quot;n&quot; =&gt; 100, &quot;m&quot; =&gt; 100, &quot;y&quot; =&gt; 300, &quot;d&quot; =&gt; 200, &quot;a&quot; =&gt; 0 }&#xA;   h.invert   =&gt; {0=&gt;&quot;a&quot;, 100=&gt;&quot;m&quot;, 200=&gt;&quot;d&quot;, 300=&gt;&quot;y&quot;}" />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every key-value pair from hsh for which block evaluates to false. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="key" ilk="function" signature="key(p1)" doc="Returns the key for a given value. If not found, returns nil. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.key(200)   =&gt; &quot;b&quot;&#xA;   h.key(999)   =&gt; nil" />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given key is present in hsh. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.has_key?(&quot;a&quot;)   =&gt; true&#xA;   h.has_key?(&quot;z&quot;)   =&gt; false" />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns a new array populated with the keys from this hash. See also Hash#values. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 }&#xA;   h.keys   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of key-value pairs in the hash. &#xA;    h = { &quot;d&quot; =&gt; 100, &quot;a&quot; =&gt; 200, &quot;v&quot; =&gt; 300, &quot;e&quot; =&gt; 400 }&#xA;   h.length        =&gt; 4&#xA;   h.delete(&quot;a&quot;)   =&gt; 200&#xA;   h.length        =&gt; 3" />
        <scope name="merge" ilk="function" signature="merge(p1)" doc="Returns a new hash containing the contents of other_hash and the contents of hsh. If no block is specified, the value for entries with duplicate keys will be that of other_hash. Otherwise the value for each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA;    h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;   h1.merge(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;   h1.merge(h2){|key, oldval, newval| newval - oldval}&#xA;                  =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;54,  &quot;c&quot;=&gt;300}&#xA;   h1             =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}" />
        <scope name="merge!" ilk="function" signature="merge!(p1)" doc="Adds the contents of other_hash to hsh.  If no block is specified, entries with duplicate keys are overwritten with the values from other_hash, otherwise the value of each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA;    h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;   h1.merge!(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;&#xA;   h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;   h1.merge!(h2) { |key, v1, v2| v1 }&#xA;                   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;300}" />
        <scope name="rassoc" ilk="function" signature="rassoc(p1)" doc="Searches through the hash comparing _obj_ with the value using ==. Returns the first key-value pair (two-element array) that matches. See also Array#rassoc. &#xA;    a = {1=&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;, &quot;ii&quot; =&gt; &quot;two&quot;}&#xA;   a.rassoc(&quot;two&quot;)    =&gt; [2, &quot;two&quot;]&#xA;   a.rassoc(&quot;four&quot;)   =&gt; nil" />
        <scope name="rehash" ilk="function" signature="rehash()" doc="Rebuilds the hash based on the current hash values for each key. If values of key objects have changed since they were inserted, this method will reindex hsh. If Hash#rehash is called while an iterator is traversing the hash, an RuntimeError will be raised in the iterator. &#xA;    a = [ &quot;a&quot;, &quot;b&quot; ]&#xA;   c = [ &quot;c&quot;, &quot;d&quot; ]&#xA;   h = { a =&gt; 100, c =&gt; 300 }&#xA;   h[a]       =&gt; 100&#xA;   a[0] = &quot;z&quot;&#xA;   h[a]       =&gt; nil&#xA;   h.rehash   =&gt; {[&quot;z&quot;, &quot;b&quot;]=&gt;100, [&quot;c&quot;, &quot;d&quot;]=&gt;300}&#xA;   h[a]       =&gt; 100" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Hash#delete_if, but returns nil if no changes were made." />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents of hsh with the contents of other_hash. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.replace({ &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 })   =&gt; {&quot;c&quot;=&gt;300, &quot;d&quot;=&gt;400}" />
        <scope name="select!" ilk="function" signature="select!()" doc="Equivalent to Hash#keep_if, but returns nil if no changes were made." />
        <scope name="shift" ilk="function" signature="shift()" doc="Removes a key-value pair from hsh and returns it as the two-item array [ key, value ], or the hash&apos;s default value if the hash is empty. &#xA;    h = { 1 =&gt; &quot;a&quot;, 2 =&gt; &quot;b&quot;, 3 =&gt; &quot;c&quot; }&#xA;   h.shift   =&gt; [1, &quot;a&quot;]&#xA;   h         =&gt; {2=&gt;&quot;b&quot;, 3=&gt;&quot;c&quot;}" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of key-value pairs in the hash. &#xA;    h = { &quot;d&quot; =&gt; 100, &quot;a&quot; =&gt; 200, &quot;v&quot; =&gt; 300, &quot;e&quot; =&gt; 400 }&#xA;   h.length        =&gt; 4&#xA;   h.delete(&quot;a&quot;)   =&gt; 200&#xA;   h.length        =&gt; 3" />
        <scope name="store" ilk="function" signature="store(p1, p2)" doc="Element Assignment---Associates the value given by value with the key given by key. key should not have its value changed while it is in use as a key (a String passed as a key will be duplicated and frozen). &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h[&quot;a&quot;] = 9&#xA;   h[&quot;c&quot;] = 4&#xA;   h   =&gt; {&quot;a&quot;=&gt;9, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;4}" />
        <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns +self+." />
        <scope name="update" ilk="function" signature="update(p1)" doc="Adds the contents of other_hash to hsh.  If no block is specified, entries with duplicate keys are overwritten with the values from other_hash, otherwise the value of each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA;    h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;   h1.merge!(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;&#xA;   h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;   h1.merge!(h2) { |key, v1, v2| v1 }&#xA;                   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;300}" />
        <scope name="value?" ilk="function" signature="value?(p1)" doc="Returns true if the given value is present for some key in hsh. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;   h.has_value?(100)   =&gt; true&#xA;   h.has_value?(999)   =&gt; false" />
        <scope name="values" ilk="function" signature="values()" doc="Returns a new array populated with the values from hsh. See also Hash#keys. &#xA;    h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300 }&#xA;   h.values   =&gt; [100, 200, 300]" />
        <scope name="values_at" ilk="function" signature="values_at(...)" doc="Return an array containing the values associated with the given keys. Also see Hash.select. &#xA;   h = { &quot;cat&quot; =&gt; &quot;feline&quot;, &quot;dog&quot; =&gt; &quot;canine&quot;, &quot;cow&quot; =&gt; &quot;bovine&quot; }&#xA;  h.values_at(&quot;cow&quot;, &quot;cat&quot;)  =&gt; [&quot;bovine&quot;, &quot;feline&quot;]" />
        <scope name="yaml_initialize" ilk="function" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](...)" doc="Creates a new hash populated with the given objects. Equivalent to the literal { key =&gt; value, ... }. In the first form, keys and values occur in pairs, so there must be an even number of arguments. The second and third form take a single argument which is either an array of key-value pairs or an object convertible to a hash. &#xA;    Hash[&quot;a&quot;, 100, &quot;b&quot;, 200]             =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;   Hash[ [ [&quot;a&quot;, 100], [&quot;b&quot;, 200] ] ]   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;   Hash[&quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200]         =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a hash, using to_hash method. Returns converted hash or nil if obj cannot be converted for any reason. &#xA;    Hash.try_convert({1=&gt;2})   # =&gt; {1=&gt;2}&#xA;   Hash.try_convert(&quot;1=&gt;2&quot;)   # =&gt; nil" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new, empty hash. If this hash is subsequently accessed by a key that doesn&apos;t correspond to a hash entry, the value returned depends on the style of new used to create the hash. In the first form, the access returns nil. If obj is specified, this single object will be used for all default values. If a block is specified, it will be called with the hash object and the key, and should return the default value. It is the block&apos;s responsibility to store the value in the hash if required. &#xA;    h = Hash.new(&quot;Go Fish&quot;)&#xA;   h[&quot;a&quot;] = 100&#xA;   h[&quot;b&quot;] = 200&#xA;   h[&quot;a&quot;]           =&gt; 100&#xA;   h[&quot;c&quot;]           =&gt; &quot;Go Fish&quot;&#xA;   # The following alters the single default object&#xA;   h[&quot;c&quot;].upcase!   =&gt; &quot;GO FISH&quot;&#xA;   h[&quot;d&quot;]           =&gt; &quot;GO FISH&quot;&#xA;   h.keys           =&gt; [&quot;a&quot;, &quot;b&quot;]&#xA;   # While this creates a new default object each time&#xA;   h = Hash.new { |hash, key| hash[key] = &quot;Go Fish: #{key}&quot; }&#xA;   h[&quot;c&quot;]           =&gt; &quot;Go Fish: c&quot;" />
      </scope>
      <variable name="ENV" attributes="__const__" citdl="Object" />
      <scope name="Struct" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each instance variable, passing the value as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.each {|x| puts(x) }&#xA; produces: &#xA;    Joe Smith&#xA;   123 Maple, Anytown NC&#xA;   12345" />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Calls block once for each instance variable, passing the name (as a symbol) and the value as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }&#xA; produces: &#xA;    name =&gt; Joe Smith&#xA;   address =&gt; 123 Maple, Anytown NC&#xA;   zip =&gt; 12345" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of instance variables. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.length   =&gt; 3" />
        <scope name="members" ilk="function" signature="members()" doc="Returns an array of strings representing the names of the instance variables. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.members   =&gt; [:name, :address, :zip]" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of instance variables. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.length   =&gt; 3" />
        <scope name="values" ilk="function" signature="values()" doc="Returns the values for this instance as an array. &#xA;    Customer = Struct.new(:name, :address, :zip)&#xA;   joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;   joe.to_a[1]   =&gt; &quot;123 Maple, Anytown NC&quot;" />
        <scope name="values_at" ilk="function" signature="values_at(...)" doc="Returns an array containing the elements in +self+ corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also .select. &#xA;    a = %w{ a b c d e f }&#xA;   a.values_at(1, 3, 5)&#xA;   a.values_at(1, 3, 5, 7)&#xA;   a.values_at(-1, -3, -5, -7)&#xA;   a.values_at(1..3, 2...5)" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" />
        <scope name="Group" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="gid" ilk="function" />
          <scope name="gid=" ilk="function" />
          <scope name="mem" ilk="function" />
          <scope name="mem=" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="passwd" ilk="function" />
          <scope name="passwd=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="all?" ilk="function" attributes="__classmethod__" />
          <scope name="any?" ilk="function" attributes="__classmethod__" />
          <scope name="chunk" ilk="function" attributes="__classmethod__" />
          <scope name="collect" ilk="function" attributes="__classmethod__" />
          <scope name="collect_concat" ilk="function" attributes="__classmethod__" />
          <scope name="count" ilk="function" attributes="__classmethod__" />
          <scope name="cycle" ilk="function" attributes="__classmethod__" />
          <scope name="detect" ilk="function" attributes="__classmethod__" />
          <scope name="drop" ilk="function" attributes="__classmethod__" />
          <scope name="drop_while" ilk="function" attributes="__classmethod__" />
          <scope name="each" ilk="function" attributes="__classmethod__" />
          <scope name="each_cons" ilk="function" attributes="__classmethod__" />
          <scope name="each_entry" ilk="function" attributes="__classmethod__" />
          <scope name="each_slice" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_index" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_object" ilk="function" attributes="__classmethod__" />
          <scope name="entries" ilk="function" attributes="__classmethod__" />
          <scope name="find" ilk="function" attributes="__classmethod__" />
          <scope name="find_all" ilk="function" attributes="__classmethod__" />
          <scope name="find_index" ilk="function" attributes="__classmethod__" />
          <scope name="first" ilk="function" attributes="__classmethod__" />
          <scope name="flat_map" ilk="function" attributes="__classmethod__" />
          <scope name="grep" ilk="function" attributes="__classmethod__" />
          <scope name="group_by" ilk="function" attributes="__classmethod__" />
          <scope name="inject" ilk="function" attributes="__classmethod__" />
          <scope name="map" ilk="function" attributes="__classmethod__" />
          <scope name="max" ilk="function" attributes="__classmethod__" />
          <scope name="max_by" ilk="function" attributes="__classmethod__" />
          <scope name="member?" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
          <scope name="min" ilk="function" attributes="__classmethod__" />
          <scope name="min_by" ilk="function" attributes="__classmethod__" />
          <scope name="minmax" ilk="function" attributes="__classmethod__" />
          <scope name="minmax_by" ilk="function" attributes="__classmethod__" />
          <scope name="none?" ilk="function" attributes="__classmethod__" />
          <scope name="one?" ilk="function" attributes="__classmethod__" />
          <scope name="partition" ilk="function" attributes="__classmethod__" />
          <scope name="reduce" ilk="function" attributes="__classmethod__" />
          <scope name="reject" ilk="function" attributes="__classmethod__" />
          <scope name="reverse_each" ilk="function" attributes="__classmethod__" />
          <scope name="select" ilk="function" attributes="__classmethod__" />
          <scope name="slice_before" ilk="function" attributes="__classmethod__" />
          <scope name="sort" ilk="function" attributes="__classmethod__" />
          <scope name="sort_by" ilk="function" attributes="__classmethod__" />
          <scope name="take" ilk="function" attributes="__classmethod__" />
          <scope name="take_while" ilk="function" attributes="__classmethod__" />
          <scope name="to_a" ilk="function" attributes="__classmethod__" />
          <scope name="zip" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Passwd" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="dir" ilk="function" />
          <scope name="dir=" ilk="function" />
          <scope name="gecos" ilk="function" />
          <scope name="gecos=" ilk="function" />
          <scope name="gid" ilk="function" />
          <scope name="gid=" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="passwd" ilk="function" />
          <scope name="passwd=" ilk="function" />
          <scope name="shell" ilk="function" />
          <scope name="shell=" ilk="function" />
          <scope name="uid" ilk="function" />
          <scope name="uid=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="all?" ilk="function" attributes="__classmethod__" />
          <scope name="any?" ilk="function" attributes="__classmethod__" />
          <scope name="chunk" ilk="function" attributes="__classmethod__" />
          <scope name="collect" ilk="function" attributes="__classmethod__" />
          <scope name="collect_concat" ilk="function" attributes="__classmethod__" />
          <scope name="count" ilk="function" attributes="__classmethod__" />
          <scope name="cycle" ilk="function" attributes="__classmethod__" />
          <scope name="detect" ilk="function" attributes="__classmethod__" />
          <scope name="drop" ilk="function" attributes="__classmethod__" />
          <scope name="drop_while" ilk="function" attributes="__classmethod__" />
          <scope name="each" ilk="function" attributes="__classmethod__" />
          <scope name="each_cons" ilk="function" attributes="__classmethod__" />
          <scope name="each_entry" ilk="function" attributes="__classmethod__" />
          <scope name="each_slice" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_index" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_object" ilk="function" attributes="__classmethod__" />
          <scope name="entries" ilk="function" attributes="__classmethod__" />
          <scope name="find" ilk="function" attributes="__classmethod__" />
          <scope name="find_all" ilk="function" attributes="__classmethod__" />
          <scope name="find_index" ilk="function" attributes="__classmethod__" />
          <scope name="first" ilk="function" attributes="__classmethod__" />
          <scope name="flat_map" ilk="function" attributes="__classmethod__" />
          <scope name="grep" ilk="function" attributes="__classmethod__" />
          <scope name="group_by" ilk="function" attributes="__classmethod__" />
          <scope name="inject" ilk="function" attributes="__classmethod__" />
          <scope name="map" ilk="function" attributes="__classmethod__" />
          <scope name="max" ilk="function" attributes="__classmethod__" />
          <scope name="max_by" ilk="function" attributes="__classmethod__" />
          <scope name="member?" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
          <scope name="min" ilk="function" attributes="__classmethod__" />
          <scope name="min_by" ilk="function" attributes="__classmethod__" />
          <scope name="minmax" ilk="function" attributes="__classmethod__" />
          <scope name="minmax_by" ilk="function" attributes="__classmethod__" />
          <scope name="none?" ilk="function" attributes="__classmethod__" />
          <scope name="one?" ilk="function" attributes="__classmethod__" />
          <scope name="partition" ilk="function" attributes="__classmethod__" />
          <scope name="reduce" ilk="function" attributes="__classmethod__" />
          <scope name="reject" ilk="function" attributes="__classmethod__" />
          <scope name="reverse_each" ilk="function" attributes="__classmethod__" />
          <scope name="select" ilk="function" attributes="__classmethod__" />
          <scope name="slice_before" ilk="function" attributes="__classmethod__" />
          <scope name="sort" ilk="function" attributes="__classmethod__" />
          <scope name="sort_by" ilk="function" attributes="__classmethod__" />
          <scope name="take" ilk="function" attributes="__classmethod__" />
          <scope name="take_while" ilk="function" attributes="__classmethod__" />
          <scope name="to_a" ilk="function" attributes="__classmethod__" />
          <scope name="zip" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Tms" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="cstime" ilk="function" />
          <scope name="cstime=" ilk="function" />
          <scope name="cutime" ilk="function" />
          <scope name="cutime=" ilk="function" />
          <scope name="stime" ilk="function" />
          <scope name="stime=" ilk="function" />
          <scope name="utime" ilk="function" />
          <scope name="utime=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
        </scope>
      </scope>
      <scope name="RegexpError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Regexp" ilk="class" classrefs="Object" >
        <scope name="casefold?" ilk="function" signature="casefold?()" doc="Returns the value of the case-insensitive flag. &#xA;     /a/.casefold?           =&gt; false&#xA;    /a/i.casefold?          =&gt; true&#xA;    /(?i:a)/.casefold?      =&gt; false" />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of obj." />
        <scope name="fixed_encoding?" ilk="function" signature="fixed_encoding?()" doc="Returns false if rxp is applicable to a string with any ASCII compatible encoding. Returns true otherwise. &#xA;     r = /a/&#xA;    r.fixed_encoding?                               =&gt; false&#xA;    r =~ &quot;\u{6666} a&quot;                               =&gt; 2&#xA;    r =~ &quot;\xa1\xa2 a&quot;.force_encoding(&quot;euc-jp&quot;)      =&gt; 2&#xA;    r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             =&gt; 0&#xA;    r = /a/u&#xA;    r.fixed_encoding?                               =&gt; true&#xA;    r.encoding                                      =&gt; #&lt;Encoding:UTF-8&gt;&#xA;    r =~ &quot;\u{6666} a&quot;                               =&gt; 2&#xA;    r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        =&gt; ArgumentError&#xA;    r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             =&gt; 0&#xA;    r = /\u{6666}/" />
        <scope name="match" ilk="function" signature="match(...)" doc="Returns a MatchData object describing the match, or nil if there was no match. This is equivalent to retrieving the value of the special variable $~ following a normal match. If the second parameter is present, it specifies the position in the string to begin the search. &#xA;    /(.)(.)(.)/.match(&quot;abc&quot;)[2]   =&gt; &quot;b&quot;&#xA;   /(.)(.)/.match(&quot;abc&quot;, 1)[2]   =&gt; &quot;c&quot;&#xA; If a block is given, invoke the block with MatchData if match succeed, so that you can write &#xA;    pat.match(str) {|m| ...}&#xA; instead of &#xA;    if m = pat.match(str)&#xA;     ...&#xA;   end&#xA; The return value is a value from block execution in this case." />
        <scope name="named_captures" ilk="function" signature="named_captures()" doc="Returns a hash representing information about named captures of rxp. &#xA; A key of the hash is a name of the named captures. A value of the hash is an array which is list of indexes of corresponding named captures. &#xA;    /(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.named_captures&#xA;   =&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}&#xA;&#xA;   /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.named_captures&#xA;   =&gt; {&quot;foo&quot;=&gt;[1, 2]}&#xA; If there are no named captures, an empty hash is returned. &#xA;    /(.)(.)/.named_captures&#xA;   =&gt; {}" />
        <scope name="names" ilk="function" signature="names()" doc="Returns a list of names of captures as an array of strings. &#xA;     /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names&#xA;    =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#xA;&#xA;    /(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names&#xA;    =&gt; [&quot;foo&quot;]&#xA;&#xA;    /(.)(.)/.names&#xA;    =&gt; []" />
        <scope name="options" ilk="function" signature="options()" doc="Returns the set of bits corresponding to the options used when creating this Regexp (see Regexp::new for details. Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to Regexp::new. &#xA;    Regexp::IGNORECASE                  =&gt; 1&#xA;   Regexp::EXTENDED                    =&gt; 2&#xA;   Regexp::MULTILINE                   =&gt; 4&#xA;&#xA;   /cat/.options                       =&gt; 0&#xA;   /cat/ix.options                     =&gt; 3&#xA;   Regexp.new(&apos;cat&apos;, true).options     =&gt; 1&#xA;   /\xa1\xa2/e.options                 =&gt; 16&#xA;&#xA;   r = /cat/ix&#xA;   Regexp.new(r.source, r.options)     =&gt; /cat/ix" />
        <scope name="source" ilk="function" signature="source()" doc="Returns the original string of the pattern. &#xA;     /ab+c/ix.source =&gt; &quot;ab+c&quot;&#xA; Note that escape sequences are retained as is. &#xA;    /\x20\+/.source  =&gt; &quot;\\x20\\+&quot;" />
        <scope name="compile" ilk="function" attributes="__classmethod__" signature="compile(...)" doc="Synonym for Regexp.new" />
        <scope name="escape" ilk="function" attributes="__classmethod__" signature="escape(p1)" doc="Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped.  For any string, Regexp.new(Regexp.escape(str))=~str will be true. &#xA;    Regexp.escape(&apos;\*?{}.&apos;)   =&gt; \\\*\?\{\}\." />
        <scope name="last_match" ilk="function" attributes="__classmethod__" signature="last_match(...)" doc="The first form returns the MatchData object generated by the last successful pattern match. Equivalent to reading the global variable $~. The second form returns the nth field in this MatchData object. n can be a string or symbol to reference a named capture. &#xA; Note that the last_match is local to the thread and method scope of the method that did the pattern match. &#xA;    /c(.)t/ =~ &apos;cat&apos;        =&gt; 0&#xA;   Regexp.last_match       =&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;&#xA;   Regexp.last_match(0)    =&gt; &quot;cat&quot;&#xA;   Regexp.last_match(1)    =&gt; &quot;a&quot;&#xA;   Regexp.last_match(2)    =&gt; nil&#xA;&#xA;   /(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;var = val&quot;&#xA;   Regexp.last_match       =&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;&#xA;   Regexp.last_match(:lhs) =&gt; &quot;var&quot;&#xA;   Regexp.last_match(:rhs) =&gt; &quot;val&quot;" />
        <scope name="quote" ilk="function" attributes="__classmethod__" signature="quote(p1)" doc="Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped.  For any string, Regexp.new(Regexp.escape(str))=~str will be true. &#xA;    Regexp.escape(&apos;\*?{}.&apos;)   =&gt; \\\*\?\{\}\." />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a Regexp, using to_regexp method. Returns converted regexp or nil if obj cannot be converted for any reason. &#xA;    Regexp.try_convert(/re/)         =&gt; /re/&#xA;   Regexp.try_convert(&quot;re&quot;)         =&gt; nil&#xA;&#xA;   o = Object.new&#xA;   Regexp.try_convert(o)            =&gt; nil&#xA;   def o.to_regexp() /foo/ end&#xA;   Regexp.try_convert(o)            =&gt; /foo/" />
        <scope name="union" ilk="function" attributes="__classmethod__" signature="union(...)" doc="Return a Regexp object that is the union of the given patterns, i.e., will match any of its parts. The patterns can be Regexp objects, in which case their options will be preserved, or Strings. If no patterns are given, returns /(?!)/. The behavior is unspecified if any given pattern contains capture. &#xA;    Regexp.union                         =&gt; /(?!)/&#xA;   Regexp.union(&quot;penzance&quot;)             =&gt; /penzance/&#xA;   Regexp.union(&quot;a+b*c&quot;)                =&gt; /a\+b\*c/&#xA;   Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   =&gt; /skiing|sledding/&#xA;   Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) =&gt; /skiing|sledding/&#xA;   Regexp.union(/dogs/, /cats/i)        =&gt; /(?-mix:dogs)|(?i-mx:cats)/" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Constructs a new regular expression from pattern, which can be either a String or a Regexp (in which case that regexp&apos;s options are propagated, and new options may not be specified (a change as of Ruby 1.8). If options is a Fixnum, it should be one or more of the constants Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, or-ed together. Otherwise, if options is not nil, the regexp will be case insensitive. When the lang parameter is `n&apos; or `N&apos; sets the regexp no encoding. &#xA;    r1 = Regexp.new(&apos;^a-z+:\\s+\w+&apos;)           =&gt; /^a-z+:\s+\w+/&#xA;   r2 = Regexp.new(&apos;cat&apos;, true)               =&gt; /cat/i&#xA;   r3 = Regexp.new(&apos;dog&apos;, Regexp::EXTENDED)   =&gt; /dog/x&#xA;   r4 = Regexp.new(r2)                        =&gt; /cat/i" />
        <variable name="EXTENDED" attributes="__const__" citdl="Fixnum" />
        <variable name="FIXEDENCODING" attributes="__const__" citdl="Fixnum" />
        <variable name="IGNORECASE" attributes="__const__" citdl="Fixnum" />
        <variable name="MULTILINE" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="MatchData" ilk="class" classrefs="Object" >
        <scope name="begin" ilk="function" signature="begin(p1)" doc="Returns the offset of the start of the nth element of the match array in the string. n can be a string or symbol to reference a named capture. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.begin(0)       =&gt; 1&#xA;   m.begin(2)       =&gt; 2&#xA;&#xA;   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;   p m.begin(:foo)  =&gt; 0&#xA;   p m.begin(:bar)  =&gt; 2" />
        <scope name="captures" ilk="function" signature="captures()" doc="Returns the array of captures; equivalent to mtch.to_a[1..-1]. &#xA;    f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;).captures&#xA;   f1    =&gt; &quot;H&quot;&#xA;   f2    =&gt; &quot;X&quot;&#xA;   f3    =&gt; &quot;113&quot;&#xA;   f4    =&gt; &quot;8&quot;" />
        <scope name="end" ilk="function" signature="end(p1)" doc="Returns the offset of the character immediately following the end of the nth element of the match array in the string. n can be a string or symbol to reference a named capture. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.end(0)         =&gt; 7&#xA;   m.end(2)         =&gt; 3&#xA;&#xA;   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;   p m.end(:foo)    =&gt; 1&#xA;   p m.end(:bar)    =&gt; 3" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of elements in the match array. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.length   =&gt; 5&#xA;   m.size     =&gt; 5" />
        <scope name="names" ilk="function" signature="names()" doc="Returns a list of names of captures as an array of strings. It is same as mtch.regexp.names. &#xA;     /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).names&#xA;    =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#xA;&#xA;    m = /(?&lt;x&gt;.)(?&lt;y&gt;.)?/.match(&quot;a&quot;) =&gt; #&lt;MatchData &quot;a&quot; x:&quot;a&quot; y:nil&gt;&#xA;    m.names                          =&gt; [&quot;x&quot;, &quot;y&quot;]" />
        <scope name="offset" ilk="function" signature="offset(p1)" doc="Returns a two-element array containing the beginning and ending offsets of the nth match. n can be a string or symbol to reference a named capture. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.offset(0)      =&gt; [1, 7]&#xA;   m.offset(4)      =&gt; [6, 7]&#xA;&#xA;   m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;   p m.offset(:foo) =&gt; [0, 1]&#xA;   p m.offset(:bar) =&gt; [2, 3]" />
        <scope name="post_match" ilk="function" signature="post_match()" doc="Returns the portion of the original string after the current match. Equivalent to the special variable $&apos;. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)&#xA;   m.post_match   =&gt; &quot;: The Movie&quot;" />
        <scope name="pre_match" ilk="function" signature="pre_match()" doc="Returns the portion of the original string before the current match. Equivalent to the special variable $`. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.pre_match   =&gt; &quot;T&quot;" />
        <scope name="regexp" ilk="function" signature="regexp()" doc="Returns the regexp. &#xA;     m = /a.*b/.match(&quot;abc&quot;)&#xA;    m.regexp =&gt; /a.*b/" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of elements in the match array. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.length   =&gt; 5&#xA;   m.size     =&gt; 5" />
        <scope name="string" ilk="function" signature="string()" doc="Returns a frozen copy of the string passed in to match. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.string   =&gt; &quot;THX1138.&quot;" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns the array of matches. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;   m.to_a   =&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]&#xA; Because to_a is called when expanding *variable, there&apos;s a useful assignment shortcut for extracting matched fields. This is slightly slower than accessing the fields directly (as an intermediate array is generated). &#xA;    all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;))&#xA;   all   =&gt; &quot;HX1138&quot;&#xA;   f1    =&gt; &quot;H&quot;&#xA;   f2    =&gt; &quot;X&quot;&#xA;   f3    =&gt; &quot;113&quot;" />
        <scope name="values_at" ilk="function" signature="values_at(...)" doc="   mtch.values_at([index]*)   -&gt; array&#xA; Uses each index to access the matching values, returning an array of the corresponding matches. &#xA;    m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)&#xA;   m.to_a               =&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]&#xA;   m.values_at(0, 2, -2)   =&gt; [&quot;HX1138&quot;, &quot;X&quot;, &quot;113&quot;]" />
      </scope>
      <scope name="Marshal" ilk="namespace" >
        <scope name="dump" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="restore" ilk="function" />
        <variable name="MAJOR_VERSION" attributes="__const__" citdl="Fixnum" />
        <variable name="MINOR_VERSION" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Range" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="begin" ilk="function" signature="begin()" doc="Returns the first object in rng." />
        <scope name="cover?" ilk="function" signature="cover?(p1)" doc="Returns true if obj is between beg and end, i.e beg &lt;= obj &lt;= end (or end exclusive when exclude_end? is true). &#xA;    (&quot;a&quot;..&quot;z&quot;).cover?(&quot;c&quot;)    =&gt; true&#xA;   (&quot;a&quot;..&quot;z&quot;).cover?(&quot;5&quot;)    =&gt; false" />
        <scope name="each" ilk="function" signature="each()" doc="Iterates over the elements rng, passing each in turn to the block. You can only iterate if the start object of the range supports the +succ+ method (which means that you can&apos;t iterate over ranges of +Float+ objects). &#xA; If no block is given, an enumerator is returned instead. &#xA;    (10..15).each do |n|&#xA;      print n, &apos; &apos;&#xA;   end&#xA; produces: &#xA;    10 11 12 13 14 15" />
        <scope name="end" ilk="function" signature="end()" doc="Returns the object that defines the end of rng. &#xA;    (1..10).end    =&gt; 10&#xA;   (1...10).end   =&gt; 10" />
        <scope name="exclude_end?" ilk="function" signature="exclude_end?()" doc="Returns true if rng excludes its end value." />
        <scope name="last" ilk="function" signature="last(...)" doc="Returns the last object in rng, or the last +n+ elements." />
        <scope name="step" ilk="function" signature="step(...)" doc="Iterates over rng, passing each nth element to the block. If the range contains numbers, n is added for each iteration.  Otherwise step invokes succ to iterate through range elements. The following code uses class Xs, which is defined in the class-level documentation. &#xA; If no block is given, an enumerator is returned instead. &#xA;    range = Xs.new(1)..Xs.new(10)&#xA;   range.step(2) {|x| puts x}&#xA;   range.step(3) {|x| puts x}&#xA; produces: &#xA;     1 x&#xA;    3 xxx&#xA;    5 xxxxx&#xA;    7 xxxxxxx&#xA;    9 xxxxxxxxx&#xA;    1 x&#xA;    4 xxxx" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Constructs a range using the given start and end. If the third parameter is omitted or is false, the range will include the end object; otherwise, it will be excluded." />
      </scope>
      <scope name="IOError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="EOFError" ilk="class" classrefs="IOError" >
      </scope>
      <scope name="IO" ilk="class" classrefs="Object" >
        <import symbol="File::Constants" />
        <import symbol="Enumerable" />
        <scope name="autoclose=" ilk="function" signature="autoclose=(p1)" doc="Sets auto-close flag. &#xA;    f = open(&quot;/dev/null&quot;)&#xA;   IO.for_fd(f.fileno)&#xA;   # ...&#xA;   f.gets # may cause IOError&#xA;&#xA;   f = open(&quot;/dev/null&quot;)&#xA;   IO.for_fd(f.fileno).autoclose = true&#xA;   # ...&#xA;   f.gets # won&apos;t cause IOError" />
        <scope name="autoclose?" ilk="function" signature="autoclose?()" doc="Returns +true+ if the underlying file descriptor of _ios_ will be closed automatically at its finalization, otherwise +false+." />
        <scope name="binmode" ilk="function" signature="binmode()" doc="Puts ios into binary mode. Once a stream is in binary mode, it cannot be reset to nonbinary mode. &#xA; newline conversion disabled&#xA;encoding conversion disabled&#xA;content is treated as ASCII-8BIT" />
        <scope name="binmode?" ilk="function" signature="binmode?()" doc="Returns true if ios is binmode." />
        <scope name="bytes" ilk="function" signature="bytes()" doc="   ios.each_byte {|byte| block }  -&gt; ios&#xA;   ios.each_byte                  -&gt; an_enumerator&#xA; Calls the given block once for each byte (0..255) in ios, passing the byte as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   checksum = 0&#xA;   f.each_byte {|x| checksum ^= x }   =&gt; #&lt;File:testfile&gt;&#xA;   checksum                           =&gt; 12" />
        <scope name="chars" ilk="function" signature="chars()" doc="   ios.each_char {|c| block }  -&gt; ios&#xA;   ios.each_char               -&gt; an_enumerator&#xA; Calls the given block once for each character in ios, passing the character as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.each_char {|c| print c, &apos; &apos; }   =&gt; #&lt;File:testfile&gt;" />
        <scope name="close" ilk="function" signature="close()" doc="Closes ios and flushes any pending writes to the operating system. The stream is unavailable for any further data operations; an IOError is raised if such an attempt is made. I/O streams are automatically closed when they are claimed by the garbage collector. &#xA; If ios is opened by IO.popen, close sets $?." />
        <scope name="close_on_exec=" ilk="function" signature="close_on_exec=(p1)" doc="Sets a close-on-exec flag. &#xA;    f = open(&quot;/dev/null&quot;)&#xA;   f.close_on_exec = true&#xA;   system(&quot;cat&quot;, &quot;/proc/self/fd/#{f.fileno}&quot;) # cat: /proc/self/fd/3: No such file or directory&#xA;   f.closed?                =&gt; false" />
        <scope name="close_on_exec?" ilk="function" signature="close_on_exec?()" doc="Returns true if ios will be closed on exec. &#xA;    f = open(&quot;/dev/null&quot;)&#xA;   f.close_on_exec?                 =&gt; false&#xA;   f.close_on_exec = true&#xA;   f.close_on_exec?                 =&gt; true&#xA;   f.close_on_exec = false&#xA;   f.close_on_exec?                 =&gt; false" />
        <scope name="close_read" ilk="function" signature="close_read()" doc="Closes the read end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed. &#xA;    f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;   f.close_read&#xA;   f.readlines&#xA; produces: &#xA;    prog.rb:3:in `readlines&apos;: not opened for reading (IOError)&#xA;    from prog.rb:3" />
        <scope name="close_write" ilk="function" signature="close_write()" doc="Closes the write end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed. &#xA;    f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;   f.close_write&#xA;   f.print &quot;nowhere&quot;&#xA; produces: &#xA;    prog.rb:3:in `write&apos;: not opened for writing (IOError)&#xA;    from prog.rb:3:in `print&apos;&#xA;    from prog.rb:3" />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if ios is completely closed (for duplex streams, both reader and writer), false otherwise. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.close         =&gt; nil&#xA;   f.closed?       =&gt; true&#xA;   f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;   f.close_write   =&gt; nil&#xA;   f.closed?       =&gt; false&#xA;   f.close_read    =&gt; nil&#xA;   f.closed?       =&gt; true" />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="Passes the Integer ordinal of each character in ios, passing the codepoint as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="each" ilk="function" signature="each(...)" doc="   ios.each_line(sep=$/) {|line| block }    -&gt; ios&#xA;   ios.each_line(limit) {|line| block }     -&gt; ios&#xA;   ios.each_line(sep,limit) {|line| block } -&gt; ios&#xA;   ios.each_line(...)                       -&gt; an_enumerator&#xA;   ios.lines(sep=$/) {|line| block }        -&gt; ios&#xA;   ios.lines(limit) {|line| block }         -&gt; ios&#xA;   ios.lines(sep,limit) {|line| block }     -&gt; ios&#xA;   ios.lines(...)                           -&gt; an_enumerator&#xA; Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: " />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="   ios.each_byte {|byte| block }  -&gt; ios&#xA;   ios.each_byte                  -&gt; an_enumerator&#xA; Calls the given block once for each byte (0..255) in ios, passing the byte as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   checksum = 0&#xA;   f.each_byte {|x| checksum ^= x }   =&gt; #&lt;File:testfile&gt;&#xA;   checksum                           =&gt; 12" />
        <scope name="each_char" ilk="function" signature="each_char()" doc="   ios.each_char {|c| block }  -&gt; ios&#xA;   ios.each_char               -&gt; an_enumerator&#xA; Calls the given block once for each character in ios, passing the character as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.each_char {|c| print c, &apos; &apos; }   =&gt; #&lt;File:testfile&gt;" />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="Passes the Integer ordinal of each character in ios, passing the codepoint as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="each_line" ilk="function" signature="each_line(...)" doc="   ios.each_line(sep=$/) {|line| block }    -&gt; ios&#xA;   ios.each_line(limit) {|line| block }     -&gt; ios&#xA;   ios.each_line(sep,limit) {|line| block } -&gt; ios&#xA;   ios.each_line(...)                       -&gt; an_enumerator&#xA;   ios.lines(sep=$/) {|line| block }        -&gt; ios&#xA;   ios.lines(limit) {|line| block }         -&gt; ios&#xA;   ios.lines(sep,limit) {|line| block }     -&gt; ios&#xA;   ios.lines(...)                           -&gt; an_enumerator&#xA; Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: " />
        <scope name="eof" ilk="function" signature="eof()" doc="Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   dummy = f.readlines&#xA;   f.eof   =&gt; true&#xA; If ios is a stream such as pipe or socket, IO#eof? blocks until the other end sends some data or closes it. &#xA;    r, w = IO.pipe&#xA;   Thread.new { sleep 1; w.close }&#xA;   r.eof?  =&gt; true after 1 second blocking&#xA;   r, w = IO.pipe&#xA;   Thread.new { sleep 1; w.puts &quot;a&quot; }&#xA;   r.eof?  =&gt; false after 1 second blocking&#xA;   r, w = IO.pipe&#xA;   r.eof?  # blocks forever" />
        <scope name="eof?" ilk="function" signature="eof?()" doc="Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   dummy = f.readlines&#xA;   f.eof   =&gt; true&#xA; If ios is a stream such as pipe or socket, IO#eof? blocks until the other end sends some data or closes it. &#xA;    r, w = IO.pipe&#xA;   Thread.new { sleep 1; w.close }&#xA;   r.eof?  =&gt; true after 1 second blocking&#xA;   r, w = IO.pipe&#xA;   Thread.new { sleep 1; w.puts &quot;a&quot; }&#xA;   r.eof?  =&gt; false after 1 second blocking&#xA;   r, w = IO.pipe&#xA;   r.eof?  # blocks forever" />
        <scope name="external_encoding" ilk="function" signature="external_encoding()" doc="Returns the Encoding object that represents the encoding of the file. If io is write mode and no encoding is specified, returns nil." />
        <scope name="fcntl" ilk="function" signature="fcntl(...)" doc="Provides a mechanism for issuing low-level commands to control or query file-oriented I/O streams. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes (Array#pack might be a useful way to build this string). On Unix platforms, see fcntl(2) for details. Not implemented on all platforms." />
        <scope name="fdatasync" ilk="function" signature="fdatasync()" doc="Immediately writes all buffered data in ios to disk. &#xA; NotImplementedError is raised if the underlying operating system does not support fdatasync(2)." />
        <scope name="fileno" ilk="function" signature="fileno()" doc="Returns an integer representing the numeric file descriptor for ios. &#xA;    $stdin.fileno    =&gt; 0&#xA;   $stdout.fileno   =&gt; 1" />
        <scope name="flush" ilk="function" signature="flush()" doc="Flushes any buffered data within ios to the underlying operating system (note that this is Ruby internal buffering only; the OS may buffer the data as well). &#xA;    $stdout.print &quot;no newline&quot;&#xA;   $stdout.flush&#xA; produces: &#xA;    no newline" />
        <scope name="fsync" ilk="function" signature="fsync()" doc="Immediately writes all buffered data in ios to disk. Note that fsync differs from using IO#sync=. The latter ensures that data is flushed from Ruby&apos;s buffers, but doesn&apos;t not guarantee that the underlying operating system actually writes it to disk. &#xA; NotImplementedError is raised if the underlying operating system does not support fsync(2)." />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="Gets the next 8-bit byte (0..255) from ios. Returns nil if called at end of file. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.getbyte   =&gt; 84&#xA;   f.getbyte   =&gt; 104" />
        <scope name="getc" ilk="function" signature="getc()" doc="Reads a one-character string from ios. Returns nil if called at end of file. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.getc   =&gt; &quot;h&quot;&#xA;   f.getc   =&gt; &quot;e&quot;" />
        <scope name="gets" ilk="function" signature="gets(...)" doc="Reads the next ``line&apos;&apos; from the I/O stream; lines are separated by sep. A separator of nil reads the entire contents, and a zero-length separator reads the input a paragraph at a time (two successive newlines in the input separate paragraphs). The stream must be opened for reading or an IOError will be raised. The line read in will be returned and also assigned to $_. Returns nil if called at end of file.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes. &#xA;    File.new(&quot;testfile&quot;).gets   =&gt; &quot;This is line one\n&quot;&#xA;   $_                          =&gt; &quot;This is line one\n&quot;" />
        <scope name="internal_encoding" ilk="function" signature="internal_encoding()" doc="Returns the Encoding of the internal string if conversion is specified.  Otherwise returns nil." />
        <scope name="ioctl" ilk="function" signature="ioctl(...)" doc="Provides a mechanism for issuing low-level commands to control or query I/O devices. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes. On Unix platforms, see ioctl(2) for details. Not implemented on all platforms." />
        <scope name="isatty" ilk="function" signature="isatty()" doc="Returns true if ios is associated with a terminal device (tty), false otherwise. &#xA;    File.new(&quot;testfile&quot;).isatty   =&gt; false&#xA;   File.new(&quot;/dev/tty&quot;).isatty   =&gt; true" />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Returns the current line number in ios. The stream must be opened for reading. lineno counts the number of times gets is called, rather than the number of newlines encountered. The two values will differ if gets is called with a separator other than newline. See also the $. variable. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.lineno   =&gt; 0&#xA;   f.gets     =&gt; &quot;This is line one\n&quot;&#xA;   f.lineno   =&gt; 1&#xA;   f.gets     =&gt; &quot;This is line two\n&quot;&#xA;   f.lineno   =&gt; 2" />
        <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="Manually sets the current line number to the given value. $. is updated only on the next read. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.gets                     =&gt; &quot;This is line one\n&quot;&#xA;   $.                         =&gt; 1&#xA;   f.lineno = 1000&#xA;   f.lineno                   =&gt; 1000&#xA;   $.                         =&gt; 1         # lineno of last read&#xA;   f.gets                     =&gt; &quot;This is line two\n&quot;&#xA;   $.                         =&gt; 1001      # lineno of last read" />
        <scope name="lines" ilk="function" signature="lines(...)" doc="   ios.each_line(sep=$/) {|line| block }    -&gt; ios&#xA;   ios.each_line(limit) {|line| block }     -&gt; ios&#xA;   ios.each_line(sep,limit) {|line| block } -&gt; ios&#xA;   ios.each_line(...)                       -&gt; an_enumerator&#xA;   ios.lines(sep=$/) {|line| block }        -&gt; ios&#xA;   ios.lines(limit) {|line| block }         -&gt; ios&#xA;   ios.lines(sep,limit) {|line| block }     -&gt; ios&#xA;   ios.lines(...)                           -&gt; an_enumerator&#xA; Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: " />
        <scope name="pid" ilk="function" signature="pid()" doc="Returns the process ID of a child process associated with ios. This will be set by IO.popen. &#xA;    pipe = IO.popen(&quot;-&quot;)&#xA;   if pipe&#xA;     $stderr.puts &quot;In parent, child pid is #{pipe.pid}&quot;&#xA;   else&#xA;     $stderr.puts &quot;In child, pid is #{$$}&quot;&#xA;   end&#xA; produces: &#xA;    In child, pid is 26209&#xA;   In parent, child pid is 26209" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current offset (in bytes) of ios. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.pos    =&gt; 0&#xA;   f.gets   =&gt; &quot;This is line one\n&quot;&#xA;   f.pos    =&gt; 17" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Seeks to the given position (in bytes) in ios. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.pos = 17&#xA;   f.gets   =&gt; &quot;This is line two\n&quot;" />
        <scope name="print" ilk="function" signature="print(...)" doc="Writes the given object(s) to ios. The stream must be opened for writing. If the output field separator ($,) is not nil, it will be inserted between each object. If the output record separator ($\\) is not nil, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. With no argument, prints the contents of the variable $_. Returns nil. &#xA;    $stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)&#xA; produces: &#xA;    This is 100 percent." />
        <scope name="printf" ilk="function" signature="printf(...)" doc="Formats and writes to ios, converting parameters under control of the format string. See Kernel#sprintf for details." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc="If obj is Numeric, write the character whose code is the least-significant byte of obj, otherwise write the first byte of the string representation of obj to ios. Note: This method is not safe for use with multi-byte characters as it will truncate them. &#xA;    $stdout.putc &quot;A&quot;&#xA;   $stdout.putc 65&#xA; produces: &#xA;    AA" />
        <scope name="puts" ilk="function" signature="puts(...)" doc="Writes the given objects to ios as with IO#print. Writes a record separator (typically a newline) after any that do not already end with a newline sequence. If called with an array argument, writes each element on a new line. If called without arguments, outputs a single record separator. &#xA;    $stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)&#xA; produces: &#xA;    this&#xA;   is&#xA;   a&#xA;   test" />
        <scope name="read" ilk="function" signature="read(...)" doc="Reads length bytes from the I/O stream. &#xA; length must be a non-negative integer or nil. &#xA; If length is a positive integer, it try to read length bytes without any conversion (binary mode). It returns nil or a string whose length is 1 to length bytes. nil means it met EOF at beginning. The 1 to length-1 bytes string means it met EOF after reading the result. The length bytes string means it doesn&apos;t meet EOF. The resulted string is always ASCII-8BIT encoding. &#xA; If length is omitted or is nil, it reads until EOF and the encoding conversion is applied. It returns a string even if EOF is met at beginning. &#xA; If length is zero, it returns &quot;&quot;. &#xA; If the optional buffer argument is present, it must reference a String, which will receive the data. &#xA; At end of file, it returns nil or &quot;&quot; depend on length. ios.read() and ios.read(nil) returns &quot;&quot;. ios.read(positive-integer) returns nil. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.read(16)   =&gt; &quot;This is line one&quot;&#xA;   # reads whole file&#xA;   open(&quot;file&quot;) {|f|&#xA;     data = f.read # This returns a string even if the file is empty.&#xA;     ..." />
        <scope name="read_nonblock" ilk="function" signature="read_nonblock(...)" doc="Reads at most maxlen bytes from ios using the read(2) system call after O_NONBLOCK is set for the underlying file descriptor. &#xA; If the optional outbuf argument is present, it must reference a String, which will receive the data. &#xA; read_nonblock just calls the read(2) system call. It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller should care such errors. &#xA; If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for retrying read_nonblock. &#xA; read_nonblock causes EOFError on EOF. &#xA; If the read byte buffer is not empty, read_nonblock reads from the buffer like readpartial. In this case, the read(2) system call is not called. &#xA; When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock should not be called until io is readable for avoiding busy loop. This can be done as follows. &#xA;   # emulates blocking read (readpartial).&#xA;  begin&#xA;    result = io.read_nonblock(maxlen)&#xA;  rescue IO::WaitReadable&#xA;    IO.select([io])&#xA;    retry" />
        <scope name="readbyte" ilk="function" signature="readbyte()" doc="Reads a byte as with IO#getbyte, but raises an EOFError on end of file." />
        <scope name="readchar" ilk="function" signature="readchar()" doc="Reads a one-character string from ios. Raises an EOFError on end of file. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.readchar   =&gt; &quot;h&quot;&#xA;   f.readchar   =&gt; &quot;e&quot;" />
        <scope name="readline" ilk="function" signature="readline(...)" doc="Reads a line as with IO#gets, but raises an EOFError on end of file." />
        <scope name="readlines" ilk="function" signature="readlines(...)" doc="Reads all of the lines in ios, and returns them in anArray. Lines are separated by the optional sep. If sep is nil, the rest of the stream is returned as a single record.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes. The stream must be opened for reading or an IOError will be raised. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.readlines[0]   =&gt; &quot;This is line one\n&quot;" />
        <scope name="readpartial" ilk="function" signature="readpartial(...)" doc="Reads at most maxlen bytes from the I/O stream. It blocks only if ios has no data immediately available. It doesn&apos;t block if some data available. If the optional outbuf argument is present, it must reference a String, which will receive the data. It raises EOFError on end of file. &#xA; readpartial is designed for streams such as pipe, socket, tty, etc. It blocks only when no data immediately available. This means that it blocks only when following all conditions hold. the byte buffer in the IO object is empty.&#xA;the content of the stream is empty.&#xA;the stream is not reached to EOF. &#xA; When readpartial blocks, it waits data or EOF on the stream. If some data is reached, readpartial returns with the data. If EOF is reached, readpartial raises EOFError. &#xA; When readpartial doesn&apos;t blocks, it returns or raises immediately. If the byte buffer is not empty, it returns the data in the buffer. Otherwise if the stream has some content, it returns the data in the stream. Otherwise if the stream is reached to EOF, it raises EOFError. &#xA;    r, w = IO.pipe           #               buffer          pipe content&#xA;   w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;.&#xA;   r.readpartial(4096)      =&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;&#xA;   r.readpartial(4096)      # blocks because buffer and pipe is empty.&#xA;   r, w = IO.pipe           #               buffer          pipe content&#xA;   w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;&#xA;   w.close                  #               &quot;&quot;              &quot;abc&quot; EOF" />
        <scope name="reopen" ilk="function" signature="reopen(...)" doc="Reassociates ios with the I/O stream given in other_IO or to a new stream opened on path. This may dynamically change the actual class of this stream. &#xA;    f1 = File.new(&quot;testfile&quot;)&#xA;   f2 = File.new(&quot;testfile&quot;)&#xA;   f2.readlines[0]   =&gt; &quot;This is line one\n&quot;&#xA;   f2.reopen(f1)     =&gt; #&lt;File:testfile&gt;&#xA;   f2.readlines[0]   =&gt; &quot;This is line one\n&quot;" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Positions ios to the beginning of input, resetting lineno to zero. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.readline   =&gt; &quot;This is line one\n&quot;&#xA;   f.rewind     =&gt; 0&#xA;   f.lineno     =&gt; 0&#xA;   f.readline   =&gt; &quot;This is line one\n&quot;&#xA; Note that it cannot be used with streams such as pipes, ttys, and sockets." />
        <scope name="seek" ilk="function" signature="seek(...)" doc="Seeks to a given offset anInteger in the stream according to the value of whence: &#xA;   IO::SEEK_CUR  | Seeks to _amount_ plus current position&#xA;  --------------+----------------------------------------------------&#xA;  IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably&#xA;                | want a negative value for _amount_)&#xA;  --------------+----------------------------------------------------&#xA;  IO::SEEK_SET  | Seeks to the absolute location given by _amount_&#xA; Example: &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.seek(-13, IO::SEEK_END)   =&gt; 0&#xA;   f.readline                  =&gt; &quot;And so on...\n&quot;" />
        <scope name="set_encoding" ilk="function" signature="set_encoding(...)" doc="If single argument is specified, read string from io is tagged with the encoding specified.  If encoding is a colon separated two encoding names &quot;A:B&quot;, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B.  If two arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option." />
        <scope name="stat" ilk="function" signature="stat()" doc="Returns status information for ios as an object of type File::Stat. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   s = f.stat&#xA;   &quot;%o&quot; % s.mode   =&gt; &quot;100644&quot;&#xA;   s.blksize       =&gt; 4096&#xA;   s.atime         =&gt; Wed Apr 09 08:53:54 CDT 2003" />
        <scope name="sync" ilk="function" signature="sync()" doc="Returns the current ``sync mode&apos;&apos; of ios. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered by Ruby internally. See also IO#fsync. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.sync   =&gt; false" />
        <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Sets the ``sync mode&apos;&apos; to true or false. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered internally. Returns the new state. See also IO#fsync. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.sync = true&#xA; (produces no output)" />
        <scope name="sysread" ilk="function" signature="sysread(...)" doc="Reads integer bytes from ios using a low-level read and returns them as a string. Do not mix with other methods that read from ios or you may get unpredictable results. If the optional outbuf argument is present, it must reference a String, which will receive the data. Raises SystemCallError on error and EOFError at end of file. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.sysread(16)   =&gt; &quot;This is line one&quot;" />
        <scope name="sysseek" ilk="function" signature="sysseek(...)" doc="Seeks to a given offset in the stream according to the value of whence (see IO#seek for values of whence). Returns the new offset into the file. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.sysseek(-13, IO::SEEK_END)   =&gt; 53&#xA;   f.sysread(10)                  =&gt; &quot;And so on.&quot;" />
        <scope name="syswrite" ilk="function" signature="syswrite(p1)" doc="Writes the given string to ios using a low-level write. Returns the number of bytes written. Do not mix with other methods that write to ios or you may get unpredictable results. Raises SystemCallError on error. &#xA;    f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;   f.syswrite(&quot;ABCDEF&quot;)   =&gt; 6" />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current offset (in bytes) of ios. &#xA;    f = File.new(&quot;testfile&quot;)&#xA;   f.pos    =&gt; 0&#xA;   f.gets   =&gt; &quot;This is line one\n&quot;&#xA;   f.pos    =&gt; 17" />
        <scope name="to_i" ilk="function" signature="to_i()" />
        <scope name="to_io" ilk="function" signature="to_io()" doc="Returns ios." />
        <scope name="tty?" ilk="function" signature="tty?()" doc="Returns true if ios is associated with a terminal device (tty), false otherwise. &#xA;    File.new(&quot;testfile&quot;).isatty   =&gt; false&#xA;   File.new(&quot;/dev/tty&quot;).isatty   =&gt; true" />
        <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="Pushes back bytes (passed as a parameter) onto ios, such that a subsequent buffered read will return it. Only one byte may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several bytes that have been pushed back). Has no effect with unbuffered reads (such as IO#sysread). &#xA;    f = File.new(&quot;testfile&quot;)   =&gt; #&lt;File:testfile&gt;&#xA;   b = f.getbyte              =&gt; 0x38&#xA;   f.ungetbyte(b)             =&gt; nil&#xA;   f.getbyte                  =&gt; 0x38" />
        <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="Pushes back one character (passed as a parameter) onto ios, such that a subsequent buffered character read will return it. Only one character may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several characters that have been pushed back). Has no effect with unbuffered reads (such as IO#sysread). &#xA;    f = File.new(&quot;testfile&quot;)   =&gt; #&lt;File:testfile&gt;&#xA;   c = f.getc                 =&gt; &quot;8&quot;&#xA;   f.ungetc(c)                =&gt; nil&#xA;   f.getc                     =&gt; &quot;8&quot;" />
        <scope name="write" ilk="function" signature="write(p1)" doc="Writes the given string to ios. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written. &#xA;    count = $stdout.write( &quot;This is a test\n&quot; )&#xA;   puts &quot;That was #{count} bytes of data&quot;&#xA; produces: &#xA;    This is a test&#xA;   That was 15 bytes of data" />
        <scope name="write_nonblock" ilk="function" signature="write_nonblock(p1)" doc="Writes the given string to ios using the write(2) system call after O_NONBLOCK is set for the underlying file descriptor. &#xA; It returns the number of bytes written. &#xA; write_nonblock just calls the write(2) system call. It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result may also be smaller than string.length (partial write). The caller should care such errors and partial write. &#xA; If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock. &#xA;   # Creates a pipe.&#xA;  r, w = IO.pipe&#xA;  # write_nonblock writes only 65536 bytes and return 65536.&#xA;  # (The pipe size is 65536 bytes on this environment.)&#xA;  s = &quot;a&quot; * 100000&#xA;  p w.write_nonblock(s)     =&gt; 65536&#xA;  # write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).&#xA;  p w.write_nonblock(&quot;b&quot;)   # Resource temporarily unavailable (Errno::EAGAIN)&#xA; If the write buffer is not empty, it is flushed at first. " />
        <scope name="binread" ilk="function" attributes="__classmethod__" signature="binread(...)" doc="Opens the file, optionally seeks to the given offset, then returns length bytes (defaulting to the rest of the file). binread ensures the file is closed before returning. The open mode would be &quot;rb:ASCII-8BIT&quot;. &#xA;    IO.binread(&quot;testfile&quot;)           =&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;&#xA;   IO.binread(&quot;testfile&quot;, 20)       =&gt; &quot;This is line one\nThi&quot;&#xA;   IO.binread(&quot;testfile&quot;, 20, 10)   =&gt; &quot;ne one\nThis is line &quot;" />
        <scope name="copy_stream" ilk="function" attributes="__classmethod__" signature="copy_stream(...)" doc="IO.copy_stream copies src to dst. src and dst is either a filename or an IO. &#xA; This method returns the number of bytes copied. &#xA; If optional arguments are not given, the start position of the copy is the beginning of the filename or the current file offset of the IO. The end position of the copy is the end of file. &#xA; If copy_length is given, No more than copy_length bytes are copied. &#xA; If src_offset is given, it specifies the start position of the copy. &#xA; When src_offset is specified and src is an IO, IO.copy_stream doesn&apos;t move the current file offset." />
        <scope name="for_fd" ilk="function" attributes="__classmethod__" signature="for_fd(...)" doc="Synonym for IO.new." />
        <scope name="foreach" ilk="function" attributes="__classmethod__" signature="foreach(...)" doc="Executes the block for every line in the named I/O port, where lines are separated by sep. &#xA; If no block is given, an enumerator is returned instead. &#xA;    IO.foreach(&quot;testfile&quot;) {|x| print &quot;GOT &quot;, x }&#xA; produces: &#xA;    GOT This is line one&#xA;   GOT This is line two&#xA;   GOT This is line three&#xA;   GOT And so on...&#xA; If the last argument is a hash, it&apos;s the keyword argument to open. See IO.read for detail." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new IO object (a stream) for the given IO object or integer file descriptor and mode string. See also IO.sysopen and IO.for_fd. &#xA; Parameters numeric file descriptor&#xA;file mode. a string or an integer&#xA;hash for specifying mode by name. &#xA; Mode When mode is an integer it must be combination of the modes defined in File::Constants. &#xA; When mode is a string it must be in one of the following forms: &quot;fmode&quot;,&#xA;&quot;fmode:extern&quot;,&#xA;&quot;fmode:extern:intern&quot;. extern is the external encoding name for the IO. intern is the internal encoding. fmode must be combination of the directives. See the description of class +IO+ for a description of the directives. &#xA; When the mode of original IO is read only, the mode cannot be changed to be writable.  Similarly, the mode cannot be changed from write only to readable. If such a wrong change is directed, timing where the error actually occurs is different according to the platform. &#xA; Options opt can have the following keys same as mode parameter&#xA;external encoding for the IO. &quot;-&quot; is a synonym for the default external encoding.&#xA;internal encoding for the IO. &quot;-&quot; is a synonym for the default internal encoding. If the value is nil no conversion occurs.&#xA;specifies external and internal encodings as &quot;extern:intern&quot;." />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(...)" doc="With no associated block, open is a synonym for IO.new. If the optional code block is given, it will be passed io as an argument, and the IO object will automatically be closed when the block terminates. In this instance, IO.open returns the value of the block." />
        <scope name="pipe" ilk="function" attributes="__classmethod__" signature="pipe(...)" doc="   IO.pipe(...) {|read_io, write_io| ... }&#xA; Creates a pair of pipe endpoints (connected to each other) and returns them as a two-element array of IO objects: [ read_io, write_io ]. &#xA; If a block is given, the block is called and returns the value of the block. read_io and write_io are sent to the block as arguments. If read_io and write_io are not closed when the block exits, they are closed. i.e. closing read_io and/or write_io doesn&apos;t cause an error. &#xA; Not available on all platforms. &#xA; If an encoding (encoding name or encoding object) is specified as an optional argument, read string from pipe is tagged with the encoding specified. If the argument is a colon separated two encoding names &quot;A:B&quot;, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B. If two optional arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option. &#xA; In the example below, the two processes close the ends of the pipe that they are not using. This is not just a cosmetic nicety. The read end of a pipe will not generate an end of file condition if there are any writers with the pipe still open. In the case of the parent process, the rd.read will never return if it does not first issue a wr.close. &#xA;    rd, wr = IO.pipe&#xA;   if fork&#xA;     wr.close&#xA;     puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;&#xA;     rd.close&#xA;     Process.wait&#xA;   else" />
        <scope name="popen" ilk="function" attributes="__classmethod__" signature="popen(...)" doc="Runs the specified command as a subprocess; the subprocess&apos;s standard input and output will be connected to the returned IO object. &#xA; The PID of the started process can be obtained by IO#pid method. &#xA; _cmd_ is a string or an array as follows. &#xA;   cmd:&#xA;    &quot;-&quot;                                      : fork&#xA;    commandline                              : command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)&#xA;    [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)&#xA;  (env and opts are optional.)&#xA; If _cmd_ is a +String+ ``-&apos;&apos;, then a new instance of Ruby is started as the subprocess. &#xA; If cmd is an +Array+ of +String+, then it will be used as the subprocess&apos;s +argv+ bypassing a shell. The array can contains a hash at first for environments and a hash at last for options similar to spawn. &#xA; The default mode for the new file object is ``r&apos;&apos;, but mode may be set to any of the modes listed in the description for class IO. The last argument opt qualifies mode. &#xA;   # set IO encoding" />
        <scope name="read" ilk="function" attributes="__classmethod__" signature="read(...)" doc="Opens the file, optionally seeks to the given offset, then returns length bytes (defaulting to the rest of the file). read ensures the file is closed before returning. &#xA; If the last argument is a hash, it specifies option for internal open().  The key would be the following.  open_args: is exclusive to others. &#xA;  encoding: string or encoding&#xA;  specifies encoding of the read string.  encoding will be ignored&#xA;  if length is specified.&#xA; mode: string&#xA;  specifies mode argument for open().  it should start with &quot;r&quot;&#xA;  otherwise it would cause error.&#xA; open_args: array of strings&#xA;  specifies arguments for open() as an array.&#xA;   IO.read(&quot;testfile&quot;)           =&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;&#xA;   IO.read(&quot;testfile&quot;, 20)       =&gt; &quot;This is line one\nThi&quot;&#xA;   IO.read(&quot;testfile&quot;, 20, 10)   =&gt; &quot;ne one\nThis is line &quot;" />
        <scope name="readlines" ilk="function" attributes="__classmethod__" signature="readlines(...)" doc="Reads the entire file specified by name as individual lines, and returns those lines in an array. Lines are separated by sep. &#xA;    a = IO.readlines(&quot;testfile&quot;)&#xA;   a[0]   =&gt; &quot;This is line one\n&quot;&#xA; If the last argument is a hash, it&apos;s the keyword argument to open. See IO.read for detail." />
        <scope name="select" ilk="function" attributes="__classmethod__" signature="select(...)" doc="See Kernel#select." />
        <scope name="sysopen" ilk="function" attributes="__classmethod__" signature="sysopen(...)" doc="Opens the given path, returning the underlying file descriptor as a Fixnum. &#xA;    IO.sysopen(&quot;testfile&quot;)   =&gt; 3" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into an IO, using to_io method. Returns converted IO or nil if obj cannot be converted for any reason. &#xA;    IO.try_convert(STDOUT)     =&gt; STDOUT&#xA;   IO.try_convert(&quot;STDOUT&quot;)   =&gt; nil&#xA;&#xA;   require &apos;zlib&apos;&#xA;   f = open(&quot;/tmp/zz.gz&quot;)       =&gt; #&lt;File:/tmp/zz.gz&gt;&#xA;   z = Zlib::GzipReader.open(f) =&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;&#xA;   IO.try_convert(z)            =&gt; #&lt;File:/tmp/zz.gz&gt;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new IO object (a stream) for the given IO object or integer file descriptor and mode string. See also IO.sysopen and IO.for_fd. &#xA; Parameters numeric file descriptor&#xA;file mode. a string or an integer&#xA;hash for specifying mode by name. &#xA; Mode When mode is an integer it must be combination of the modes defined in File::Constants. &#xA; When mode is a string it must be in one of the following forms: &quot;fmode&quot;,&#xA;&quot;fmode:extern&quot;,&#xA;&quot;fmode:extern:intern&quot;. extern is the external encoding name for the IO. intern is the internal encoding. fmode must be combination of the directives. See the description of class +IO+ for a description of the directives. &#xA; When the mode of original IO is read only, the mode cannot be changed to be writable.  Similarly, the mode cannot be changed from write only to readable. If such a wrong change is directed, timing where the error actually occurs is different according to the platform. &#xA; Options opt can have the following keys same as mode parameter&#xA;external encoding for the IO. &quot;-&quot; is a synonym for the default external encoding.&#xA;internal encoding for the IO. &quot;-&quot; is a synonym for the default internal encoding. If the value is nil no conversion occurs.&#xA;specifies external and internal encodings as &quot;extern:intern&quot;." />
        <variable name="APPEND" attributes="__const__" citdl="Fixnum" />
        <variable name="BINARY" attributes="__const__" citdl="Fixnum" />
        <variable name="CREAT" attributes="__const__" citdl="Fixnum" />
        <variable name="DSYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="EXCL" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_CASEFOLD" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_DOTMATCH" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_NOESCAPE" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_PATHNAME" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_SYSCASE" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_EX" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_NB" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_SH" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_UN" attributes="__const__" citdl="Fixnum" />
        <variable name="NOATIME" attributes="__const__" citdl="Fixnum" />
        <variable name="NOCTTY" attributes="__const__" citdl="Fixnum" />
        <variable name="NOFOLLOW" attributes="__const__" citdl="Fixnum" />
        <variable name="NONBLOCK" attributes="__const__" citdl="Fixnum" />
        <variable name="RDONLY" attributes="__const__" citdl="Fixnum" />
        <variable name="RDWR" attributes="__const__" citdl="Fixnum" />
        <variable name="RSYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_CUR" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_END" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_SET" attributes="__const__" citdl="Fixnum" />
        <variable name="SYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="TRUNC" attributes="__const__" citdl="Fixnum" />
        <variable name="WRONLY" attributes="__const__" citdl="Fixnum" />
        <scope name="WaitReadable" ilk="namespace" >
        </scope>
        <scope name="WaitWritable" ilk="namespace" >
        </scope>
      </scope>
      <variable name="STDIN" attributes="__const__" citdl="IO" />
      <variable name="STDOUT" attributes="__const__" citdl="IO" />
      <variable name="STDERR" attributes="__const__" citdl="IO" />
      <variable name="ARGF" attributes="__const__" citdl="ARGF.class" />
      <scope name="FileTest" ilk="namespace" >
        <scope name="blockdev?" ilk="function" signature="blockdev?(p1)" doc="Returns true if the named file is a block device." />
        <scope name="chardev?" ilk="function" signature="chardev?(p1)" doc="Returns true if the named file is a character device." />
        <scope name="directory?" ilk="function" signature="directory?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA;    File.directory?(&quot;.&quot;)" />
        <scope name="executable?" ilk="function" signature="executable?(p1)" doc="Returns true if the named file is executable by the effective user id of this process." />
        <scope name="executable_real?" ilk="function" signature="executable_real?(p1)" doc="Returns true if the named file is executable by the real user id of this process." />
        <scope name="exist?" ilk="function" signature="exist?(p1)" doc="Returns true if the named file is a directory, false otherwise." />
        <scope name="exists?" ilk="function" signature="exists?(p1)" doc="Return true if the named file exists." />
        <scope name="file?" ilk="function" signature="file?(p1)" doc="Returns true if the named file exists and is a regular file." />
        <scope name="grpowned?" ilk="function" signature="grpowned?(p1)" doc="Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows." />
        <scope name="identical?" ilk="function" signature="identical?(p1, p2)" doc="Returns true if the named files are identical. &#xA;     open(&quot;a&quot;, &quot;w&quot;) {}&#xA;    p File.identical?(&quot;a&quot;, &quot;a&quot;)      =&gt; true&#xA;    p File.identical?(&quot;a&quot;, &quot;./a&quot;)    =&gt; true&#xA;    File.link(&quot;a&quot;, &quot;b&quot;)&#xA;    p File.identical?(&quot;a&quot;, &quot;b&quot;)      =&gt; true&#xA;    File.symlink(&quot;a&quot;, &quot;c&quot;)&#xA;    p File.identical?(&quot;a&quot;, &quot;c&quot;)      =&gt; true&#xA;    open(&quot;d&quot;, &quot;w&quot;) {}&#xA;    p File.identical?(&quot;a&quot;, &quot;d&quot;)      =&gt; false" />
        <scope name="owned?" ilk="function" signature="owned?(p1)" doc="Returns true if the named file exists and the effective used id of the calling process is the owner of the file." />
        <scope name="pipe?" ilk="function" signature="pipe?(p1)" doc="Returns true if the named file is a pipe." />
        <scope name="readable?" ilk="function" signature="readable?(p1)" doc="Returns true if the named file is readable by the effective user id of this process." />
        <scope name="readable_real?" ilk="function" signature="readable_real?(p1)" doc="Returns true if the named file is readable by the real user id of this process." />
        <scope name="setgid?" ilk="function" signature="setgid?(p1)" doc="Returns true if the named file has the setgid bit set." />
        <scope name="setuid?" ilk="function" signature="setuid?(p1)" doc="Returns true if the named file has the setuid bit set." />
        <scope name="size" ilk="function" signature="size(p1)" doc="Returns the size of file_name." />
        <scope name="size?" ilk="function" signature="size?(p1)" doc="Returns +nil+ if +file_name+ doesn&apos;t exist or has zero size, the size of the file otherwise." />
        <scope name="socket?" ilk="function" signature="socket?(p1)" doc="Returns true if the named file is a socket." />
        <scope name="sticky?" ilk="function" signature="sticky?(p1)" doc="Returns true if the named file has the sticky bit set." />
        <scope name="symlink?" ilk="function" signature="symlink?(p1)" doc="Returns true if the named file is a symbolic link." />
        <scope name="world_readable?" ilk="function" signature="world_readable?(p1)" doc="If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA;    File.world_readable?(&quot;/etc/passwd&quot;)           =&gt; 420&#xA;   m = File.world_readable?(&quot;/etc/passwd&quot;)&#xA;   sprintf(&quot;%o&quot;, m)                              =&gt; &quot;644&quot;" />
        <scope name="world_writable?" ilk="function" signature="world_writable?(p1)" doc="If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA;    File.world_writable?(&quot;/tmp&quot;)                  =&gt; 511&#xA;   m = File.world_writable?(&quot;/tmp&quot;)&#xA;   sprintf(&quot;%o&quot;, m)                              =&gt; &quot;777&quot;" />
        <scope name="writable?" ilk="function" signature="writable?(p1)" doc="Returns true if the named file is writable by the effective user id of this process." />
        <scope name="writable_real?" ilk="function" signature="writable_real?(p1)" doc="Returns true if the named file is writable by the real user id of this process." />
        <scope name="zero?" ilk="function" signature="zero?(p1)" doc="Returns true if the named file exists and has a zero size." />
      </scope>
      <scope name="File" ilk="class" classrefs="IO" >
        <import symbol="File::Constants" />
        <import symbol="Enumerable" />
        <scope name="atime" ilk="function" signature="atime()" doc="Returns the last access time (a Time object)  for file, or epoch if file has not been accessed.&#xA;&#xA;   File.new(&quot;testfile&quot;).atime   =&gt; Wed Dec 31 18:00:00 CST 1969" />
        <scope name="chmod" ilk="function" signature="chmod(p1)" doc="Changes permission bits on file to the bit pattern represented by mode_int. Actual effects are platform dependent; on Unix systems, see chmod(2) for details. Follows symbolic links. Also see File#lchmod. &#xA;    f = File.new(&quot;out&quot;, &quot;w&quot;);&#xA;   f.chmod(0644)   =&gt; 0" />
        <scope name="chown" ilk="function" signature="chown(p1, p2)" doc="Changes the owner and group of file to the given numeric owner and group id&apos;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&apos;s group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown. &#xA;    File.new(&quot;testfile&quot;).chown(502, 1000)" />
        <scope name="ctime" ilk="function" signature="ctime()" doc="Returns the change time for file (that is, the time directory information about the file was changed, not the file itself). &#xA;    File.new(&quot;testfile&quot;).ctime   =&gt; Wed Apr 09 08:53:14 CDT 2003" />
        <scope name="flock" ilk="function" signature="flock(p1)" doc="Locks or unlocks a file according to locking_constant (a logical or of the values in the table below). Returns false if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms. &#xA; Locking constants (in class File): &#xA;    LOCK_EX   | Exclusive lock. Only one process may hold an&#xA;             | exclusive lock for a given file at a time.&#xA;   ----------+------------------------------------------------&#xA;   LOCK_NB   | Don&apos;t block when locking. May be combined&#xA;             | with other lock options using logical or.&#xA;   ----------+------------------------------------------------&#xA;   LOCK_SH   | Shared lock. Multiple processes may each hold a&#xA;             | shared lock for a given file at the same time.&#xA;   ----------+------------------------------------------------&#xA;   LOCK_UN   | Unlock.&#xA; Example: " />
        <scope name="lstat" ilk="function" signature="lstat()" doc="Same as IO#stat, but does not follow the last symbolic link. Instead, reports on the link itself. &#xA;    File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;   File.stat(&quot;testfile&quot;).size              =&gt; 66&#xA;   f = File.new(&quot;link2test&quot;)&#xA;   f.lstat.size                            =&gt; 8&#xA;   f.stat.size                             =&gt; 66" />
        <scope name="mtime" ilk="function" signature="mtime()" doc="Returns the modification time for file. &#xA;    File.new(&quot;testfile&quot;).mtime   =&gt; Wed Apr 09 08:53:14 CDT 2003" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the pathname used to create file as a string. Does not normalize the name. &#xA;    File.new(&quot;testfile&quot;).path               =&gt; &quot;testfile&quot;&#xA;   File.new(&quot;/tmp/../tmp/xxx&quot;, &quot;w&quot;).path   =&gt; &quot;/tmp/../tmp/xxx&quot;" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of file in bytes. &#xA;    File.new(&quot;testfile&quot;).size   =&gt; 66" />
        <scope name="to_path" ilk="function" signature="to_path()" doc="Returns the pathname used to create file as a string. Does not normalize the name. &#xA;    File.new(&quot;testfile&quot;).path               =&gt; &quot;testfile&quot;&#xA;   File.new(&quot;/tmp/../tmp/xxx&quot;, &quot;w&quot;).path   =&gt; &quot;/tmp/../tmp/xxx&quot;" />
        <scope name="truncate" ilk="function" signature="truncate(p1)" doc="Truncates file to at most integer bytes. The file must be opened for writing. Not available on all platforms. &#xA;    f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;   f.syswrite(&quot;1234567890&quot;)   =&gt; 10&#xA;   f.truncate(5)              =&gt; 0&#xA;   f.close()                  =&gt; nil&#xA;   File.size(&quot;out&quot;)           =&gt; 5" />
        <scope name="absolute_path" ilk="function" attributes="__classmethod__" signature="absolute_path(...)" doc="Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. If the given pathname starts with a ``~&apos;&apos; it is NOT expanded, it is treated as a normal directory name. &#xA;    File.absolute_path(&quot;~oracle/bin&quot;)       =&gt; &quot;&lt;relative_path&gt;/~oracle/bin&quot;" />
        <scope name="atime" ilk="function" attributes="__classmethod__" signature="atime(p1)" doc="Returns the last access time for the named file as a Time object). &#xA;    File.atime(&quot;testfile&quot;)   =&gt; Wed Apr 09 08:51:48 CDT 2003" />
        <scope name="basename" ilk="function" attributes="__classmethod__" signature="basename(...)" doc="Returns the last component of the filename given in file_name, which must be formed using forward slashes (``/&apos;&apos;) regardless of the separator used on the local file system. If suffix is given and present at the end of file_name, it is removed. &#xA;    File.basename(&quot;/home/gumby/work/ruby.rb&quot;)          =&gt; &quot;ruby.rb&quot;&#xA;   File.basename(&quot;/home/gumby/work/ruby.rb&quot;, &quot;.rb&quot;)   =&gt; &quot;ruby&quot;" />
        <scope name="blockdev?" ilk="function" attributes="__classmethod__" signature="blockdev?(p1)" doc="Returns true if the named file is a block device." />
        <scope name="chardev?" ilk="function" attributes="__classmethod__" signature="chardev?(p1)" doc="Returns true if the named file is a character device." />
        <scope name="chmod" ilk="function" attributes="__classmethod__" signature="chmod(...)" doc="Changes permission bits on the named file(s) to the bit pattern represented by mode_int. Actual effects are operating system dependent (see the beginning of this section). On Unix systems, see chmod(2) for details. Returns the number of files processed. &#xA;    File.chmod(0644, &quot;testfile&quot;, &quot;out&quot;)   =&gt; 2" />
        <scope name="chown" ilk="function" attributes="__classmethod__" signature="chown(...)" doc="Changes the owner and group of the named file(s) to the given numeric owner and group id&apos;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&apos;s group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Returns the number of files processed. &#xA;    File.chown(nil, 100, &quot;testfile&quot;)" />
        <scope name="ctime" ilk="function" attributes="__classmethod__" signature="ctime(p1)" doc="Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself). &#xA;    File.ctime(&quot;testfile&quot;)   =&gt; Wed Apr 09 08:53:13 CDT 2003" />
        <scope name="delete" ilk="function" attributes="__classmethod__" signature="delete(...)" doc="Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir." />
        <scope name="directory?" ilk="function" attributes="__classmethod__" signature="directory?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA;    File.directory?(&quot;.&quot;)" />
        <scope name="dirname" ilk="function" attributes="__classmethod__" signature="dirname(p1)" doc="Returns all components of the filename given in file_name except the last one. The filename must be formed using forward slashes (``/&apos;&apos;) regardless of the separator used on the local file system. &#xA;    File.dirname(&quot;/home/gumby/work/ruby.rb&quot;)   =&gt; &quot;/home/gumby/work&quot;" />
        <scope name="executable?" ilk="function" attributes="__classmethod__" signature="executable?(p1)" doc="Returns true if the named file is executable by the effective user id of this process." />
        <scope name="executable_real?" ilk="function" attributes="__classmethod__" signature="executable_real?(p1)" doc="Returns true if the named file is executable by the real user id of this process." />
        <scope name="exist?" ilk="function" attributes="__classmethod__" signature="exist?(p1)" doc="Returns true if the named file is a directory, false otherwise." />
        <scope name="exists?" ilk="function" attributes="__classmethod__" signature="exists?(p1)" doc="Return true if the named file exists." />
        <scope name="expand_path" ilk="function" attributes="__classmethod__" signature="expand_path(...)" doc="Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a ``~&apos;&apos;, which expands to the process owner&apos;s home directory (the environment variable HOME must be set correctly). ``~user&apos;&apos; expands to the named user&apos;s home directory. &#xA;    File.expand_path(&quot;~oracle/bin&quot;)           =&gt; &quot;/home/oracle/bin&quot;&#xA;   File.expand_path(&quot;../../bin&quot;, &quot;/tmp/x&quot;)   =&gt; &quot;/bin&quot;" />
        <scope name="extname" ilk="function" attributes="__classmethod__" signature="extname(p1)" doc="Returns the extension (the portion of file name in path after the period). &#xA;    File.extname(&quot;test.rb&quot;)         =&gt; &quot;.rb&quot;&#xA;   File.extname(&quot;a/b/d/test.rb&quot;)   =&gt; &quot;.rb&quot;&#xA;   File.extname(&quot;test&quot;)            =&gt; &quot;&quot;&#xA;   File.extname(&quot;.profile&quot;)        =&gt; &quot;&quot;" />
        <scope name="file?" ilk="function" attributes="__classmethod__" signature="file?(p1)" doc="Returns true if the named file exists and is a regular file." />
        <scope name="fnmatch" ilk="function" attributes="__classmethod__" signature="fnmatch(...)" doc="Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters: &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and *c* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp.&#xA;Matches directories recursively or files expansively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Escapes the next metacharacter. &#xA; flags is a bitwise OR of the FNM_xxx parameters. The same glob pattern and flags are used by Dir::glob. &#xA;    File.fnmatch(&apos;cat&apos;,       &apos;cat&apos;)        =&gt; true  # match entire string&#xA;   File.fnmatch(&apos;cat&apos;,       &apos;category&apos;)   =&gt; false # only match partial string&#xA;   File.fnmatch(&apos;c{at,ub}s&apos;, &apos;cats&apos;)       =&gt; false # { } isn&apos;t supported&#xA;   File.fnmatch(&apos;c?t&apos;,     &apos;cat&apos;)          =&gt; true  # &apos;?&apos; match only 1 character&#xA;   File.fnmatch(&apos;c??t&apos;,    &apos;cat&apos;)          =&gt; false # ditto&#xA;   File.fnmatch(&apos;c*&apos;,      &apos;cats&apos;)         =&gt; true  # &apos;*&apos; match 0 or more characters" />
        <scope name="fnmatch?" ilk="function" attributes="__classmethod__" signature="fnmatch?(...)" doc="Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters: &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and *c* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp.&#xA;Matches directories recursively or files expansively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Escapes the next metacharacter. &#xA; flags is a bitwise OR of the FNM_xxx parameters. The same glob pattern and flags are used by Dir::glob. &#xA;    File.fnmatch(&apos;cat&apos;,       &apos;cat&apos;)        =&gt; true  # match entire string&#xA;   File.fnmatch(&apos;cat&apos;,       &apos;category&apos;)   =&gt; false # only match partial string&#xA;   File.fnmatch(&apos;c{at,ub}s&apos;, &apos;cats&apos;)       =&gt; false # { } isn&apos;t supported&#xA;   File.fnmatch(&apos;c?t&apos;,     &apos;cat&apos;)          =&gt; true  # &apos;?&apos; match only 1 character&#xA;   File.fnmatch(&apos;c??t&apos;,    &apos;cat&apos;)          =&gt; false # ditto&#xA;   File.fnmatch(&apos;c*&apos;,      &apos;cats&apos;)         =&gt; true  # &apos;*&apos; match 0 or more characters" />
        <scope name="ftype" ilk="function" attributes="__classmethod__" signature="ftype(p1)" doc="Identifies the type of the named file; the return string is one of ``file&apos;&apos;, ``directory&apos;&apos;, ``characterSpecial&apos;&apos;, ``blockSpecial&apos;&apos;, ``fifo&apos;&apos;, ``link&apos;&apos;, ``socket&apos;&apos;, or ``unknown&apos;&apos;. &#xA;    File.ftype(&quot;testfile&quot;)            =&gt; &quot;file&quot;&#xA;   File.ftype(&quot;/dev/tty&quot;)            =&gt; &quot;characterSpecial&quot;&#xA;   File.ftype(&quot;/tmp/.X11-unix/X0&quot;)   =&gt; &quot;socket&quot;" />
        <scope name="grpowned?" ilk="function" attributes="__classmethod__" signature="grpowned?(p1)" doc="Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows." />
        <scope name="identical?" ilk="function" attributes="__classmethod__" signature="identical?(p1, p2)" doc="Returns true if the named files are identical. &#xA;     open(&quot;a&quot;, &quot;w&quot;) {}&#xA;    p File.identical?(&quot;a&quot;, &quot;a&quot;)      =&gt; true&#xA;    p File.identical?(&quot;a&quot;, &quot;./a&quot;)    =&gt; true&#xA;    File.link(&quot;a&quot;, &quot;b&quot;)&#xA;    p File.identical?(&quot;a&quot;, &quot;b&quot;)      =&gt; true&#xA;    File.symlink(&quot;a&quot;, &quot;c&quot;)&#xA;    p File.identical?(&quot;a&quot;, &quot;c&quot;)      =&gt; true&#xA;    open(&quot;d&quot;, &quot;w&quot;) {}&#xA;    p File.identical?(&quot;a&quot;, &quot;d&quot;)      =&gt; false" />
        <scope name="join" ilk="function" attributes="__classmethod__" signature="join(...)" doc="Returns a new string formed by joining the strings using File::SEPARATOR. &#xA;    File.join(&quot;usr&quot;, &quot;mail&quot;, &quot;gumby&quot;)   =&gt; &quot;usr/mail/gumby&quot;" />
        <scope name="lchmod" ilk="function" attributes="__classmethod__" signature="lchmod(...)" doc="Equivalent to File::chmod, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available." />
        <scope name="lchown" ilk="function" attributes="__classmethod__" signature="lchown(...)" doc="Equivalent to File::chown, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list." />
        <scope name="link" ilk="function" attributes="__classmethod__" signature="link(p1, p2)" doc="Creates a new name for an existing file using a hard link. Will not overwrite new_name if it already exists (raising a subclass of SystemCallError). Not available on all platforms. &#xA;    File.link(&quot;testfile&quot;, &quot;.testfile&quot;)   =&gt; 0&#xA;   IO.readlines(&quot;.testfile&quot;)[0]         =&gt; &quot;This is line one\n&quot;" />
        <scope name="lstat" ilk="function" attributes="__classmethod__" signature="lstat(p1)" doc="Same as File::stat, but does not follow the last symbolic link. Instead, reports on the link itself. &#xA;    File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;   File.stat(&quot;testfile&quot;).size              =&gt; 66&#xA;   File.lstat(&quot;link2test&quot;).size            =&gt; 8&#xA;   File.stat(&quot;link2test&quot;).size             =&gt; 66" />
        <scope name="mtime" ilk="function" attributes="__classmethod__" signature="mtime(p1)" doc="Returns the modification time for the named file as a Time object. &#xA;    File.mtime(&quot;testfile&quot;)   =&gt; Tue Apr 08 12:58:04 CDT 2003" />
        <scope name="owned?" ilk="function" attributes="__classmethod__" signature="owned?(p1)" doc="Returns true if the named file exists and the effective used id of the calling process is the owner of the file." />
        <scope name="path" ilk="function" attributes="__classmethod__" signature="path(p1)" doc="Returns the string representation of the path &#xA;    File.path(&quot;/dev/null&quot;)          =&gt; &quot;/dev/null&quot;&#xA;   File.path(Pathname.new(&quot;/tmp&quot;)) =&gt; &quot;/tmp&quot;" />
        <scope name="pipe?" ilk="function" attributes="__classmethod__" signature="pipe?(p1)" doc="Returns true if the named file is a pipe." />
        <scope name="readable?" ilk="function" attributes="__classmethod__" signature="readable?(p1)" doc="Returns true if the named file is readable by the effective user id of this process." />
        <scope name="readable_real?" ilk="function" attributes="__classmethod__" signature="readable_real?(p1)" doc="Returns true if the named file is readable by the real user id of this process." />
        <scope name="readlink" ilk="function" attributes="__classmethod__" signature="readlink(p1)" doc="Returns the name of the file referenced by the given link. Not available on all platforms. &#xA;    File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;   File.readlink(&quot;link2test&quot;)              =&gt; &quot;testfile&quot;" />
        <scope name="realdirpath" ilk="function" attributes="__classmethod__" signature="realdirpath(...)" doc="Returns the real (absolute) pathname of _pathname_ in the actual filesystem. The real pathname doesn&apos;t contain symlinks or useless dots. &#xA; If _dir_string_ is given, it is used as a base directory for interpreting relative pathname instead of the current directory. &#xA; The last component of the real pathname can be nonexistent." />
        <scope name="realpath" ilk="function" attributes="__classmethod__" signature="realpath(...)" doc="Returns the real (absolute) pathname of _pathname_ in the actual filesystem not containing symlinks or useless dots. &#xA; If _dir_string_ is given, it is used as a base directory for interpreting relative pathname instead of the current directory. &#xA; All components of the pathname must exist when this method is called." />
        <scope name="rename" ilk="function" attributes="__classmethod__" signature="rename(p1, p2)" doc="Renames the given file to the new name. Raises a SystemCallError if the file cannot be renamed. &#xA;    File.rename(&quot;afile&quot;, &quot;afile.bak&quot;)   =&gt; 0" />
        <scope name="setgid?" ilk="function" attributes="__classmethod__" signature="setgid?(p1)" doc="Returns true if the named file has the setgid bit set." />
        <scope name="setuid?" ilk="function" attributes="__classmethod__" signature="setuid?(p1)" doc="Returns true if the named file has the setuid bit set." />
        <scope name="size" ilk="function" attributes="__classmethod__" signature="size(p1)" doc="Returns the size of file_name." />
        <scope name="size?" ilk="function" attributes="__classmethod__" signature="size?(p1)" doc="Returns +nil+ if +file_name+ doesn&apos;t exist or has zero size, the size of the file otherwise." />
        <scope name="socket?" ilk="function" attributes="__classmethod__" signature="socket?(p1)" doc="Returns true if the named file is a socket." />
        <scope name="split" ilk="function" attributes="__classmethod__" signature="split(p1)" doc="Splits the given string into a directory and a file component and returns them in a two-element array. See also File::dirname and File::basename. &#xA;    File.split(&quot;/home/gumby/.profile&quot;)   =&gt; [&quot;/home/gumby&quot;, &quot;.profile&quot;]" />
        <scope name="stat" ilk="function" attributes="__classmethod__" signature="stat(p1)" doc="Returns a File::Stat object for the named file (see File::Stat). &#xA;    File.stat(&quot;testfile&quot;).mtime   =&gt; Tue Apr 08 12:58:04 CDT 2003" />
        <scope name="sticky?" ilk="function" attributes="__classmethod__" signature="sticky?(p1)" doc="Returns true if the named file has the sticky bit set." />
        <scope name="symlink" ilk="function" attributes="__classmethod__" signature="symlink(p1, p2)" doc="Creates a symbolic link called new_name for the existing file old_name. Raises a NotImplemented exception on platforms that do not support symbolic links. &#xA;    File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0" />
        <scope name="symlink?" ilk="function" attributes="__classmethod__" signature="symlink?(p1)" doc="Returns true if the named file is a symbolic link." />
        <scope name="truncate" ilk="function" attributes="__classmethod__" signature="truncate(p1, p2)" doc="Truncates the file file_name to be at most integer bytes long. Not available on all platforms. &#xA;    f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;   f.write(&quot;1234567890&quot;)     =&gt; 10&#xA;   f.close                   =&gt; nil&#xA;   File.truncate(&quot;out&quot;, 5)   =&gt; 0&#xA;   File.size(&quot;out&quot;)          =&gt; 5" />
        <scope name="umask" ilk="function" attributes="__classmethod__" signature="umask(...)" doc="Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are subtracted from the default permissions, so a umask of 0222 would make a file read-only for everyone. &#xA;    File.umask(0006)   =&gt; 18&#xA;   File.umask         =&gt; 6" />
        <scope name="unlink" ilk="function" attributes="__classmethod__" signature="unlink(...)" doc="Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir." />
        <scope name="utime" ilk="function" attributes="__classmethod__" signature="utime(...)" doc="Sets the access and modification times of each named file to the first two arguments. Returns the number of file names in the argument list." />
        <scope name="world_readable?" ilk="function" attributes="__classmethod__" signature="world_readable?(p1)" doc="If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA;    File.world_readable?(&quot;/etc/passwd&quot;)           =&gt; 420&#xA;   m = File.world_readable?(&quot;/etc/passwd&quot;)&#xA;   sprintf(&quot;%o&quot;, m)                              =&gt; &quot;644&quot;" />
        <scope name="world_writable?" ilk="function" attributes="__classmethod__" signature="world_writable?(p1)" doc="If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA;    File.world_writable?(&quot;/tmp&quot;)                  =&gt; 511&#xA;   m = File.world_writable?(&quot;/tmp&quot;)&#xA;   sprintf(&quot;%o&quot;, m)                              =&gt; &quot;777&quot;" />
        <scope name="writable?" ilk="function" attributes="__classmethod__" signature="writable?(p1)" doc="Returns true if the named file is writable by the effective user id of this process." />
        <scope name="writable_real?" ilk="function" attributes="__classmethod__" signature="writable_real?(p1)" doc="Returns true if the named file is writable by the real user id of this process." />
        <scope name="zero?" ilk="function" attributes="__classmethod__" signature="zero?(p1)" doc="Returns true if the named file exists and has a zero size." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Opens the file named by _filename_ according to _mode_ (default is ``r&apos;&apos;) and returns a new File object. &#xA; Parameters See the description of class +IO+ for a description of _mode_. The file mode may optionally be specified as a +Fixnum+ by _or_-ing together the flags (O_RDONLY etc, again described under +IO+). &#xA; Optional permission bits may be given in _perm_. These mode and permission bits are platform dependent; on Unix systems, see open(2) for details. &#xA; Optional _opt_ parameter is same as in . &#xA; Examples &#xA;    f = File.new(&quot;testfile&quot;, &quot;r&quot;)&#xA;   f = File.new(&quot;newfile&quot;,  &quot;w+&quot;)&#xA;   f = File.new(&quot;newfile&quot;, File::CREAT|File::TRUNC|File::RDWR, 0644)" />
        <variable name="ALT_SEPARATOR" attributes="__const__" citdl="NilClass" />
        <scope name="Constants" ilk="namespace" >
          <variable name="APPEND" attributes="__const__" citdl="Fixnum" />
          <variable name="BINARY" attributes="__const__" citdl="Fixnum" />
          <variable name="CREAT" attributes="__const__" citdl="Fixnum" />
          <variable name="DSYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="EXCL" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_CASEFOLD" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_DOTMATCH" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_NOESCAPE" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_PATHNAME" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_SYSCASE" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_EX" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_NB" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_SH" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_UN" attributes="__const__" citdl="Fixnum" />
          <variable name="NOATIME" attributes="__const__" citdl="Fixnum" />
          <variable name="NOCTTY" attributes="__const__" citdl="Fixnum" />
          <variable name="NOFOLLOW" attributes="__const__" citdl="Fixnum" />
          <variable name="NONBLOCK" attributes="__const__" citdl="Fixnum" />
          <variable name="RDONLY" attributes="__const__" citdl="Fixnum" />
          <variable name="RDWR" attributes="__const__" citdl="Fixnum" />
          <variable name="RSYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="SYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="TRUNC" attributes="__const__" citdl="Fixnum" />
          <variable name="WRONLY" attributes="__const__" citdl="Fixnum" />
        </scope>
        <variable name="PATH_SEPARATOR" attributes="__const__" citdl="String" />
        <variable name="SEEK_CUR" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_END" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_SET" attributes="__const__" citdl="Fixnum" />
        <variable name="SEPARATOR" attributes="__const__" citdl="String" />
        <variable name="Separator" attributes="__const__" citdl="String" />
        <scope name="Stat" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="atime" ilk="function" />
          <scope name="blksize" ilk="function" />
          <scope name="blockdev?" ilk="function" />
          <scope name="blocks" ilk="function" />
          <scope name="chardev?" ilk="function" />
          <scope name="ctime" ilk="function" />
          <scope name="dev" ilk="function" />
          <scope name="dev_major" ilk="function" />
          <scope name="dev_minor" ilk="function" />
          <scope name="directory?" ilk="function" />
          <scope name="executable?" ilk="function" />
          <scope name="executable_real?" ilk="function" />
          <scope name="file?" ilk="function" />
          <scope name="ftype" ilk="function" />
          <scope name="gid" ilk="function" />
          <scope name="grpowned?" ilk="function" />
          <scope name="ino" ilk="function" />
          <scope name="mode" ilk="function" />
          <scope name="mtime" ilk="function" />
          <scope name="nlink" ilk="function" />
          <scope name="owned?" ilk="function" />
          <scope name="pipe?" ilk="function" />
          <scope name="rdev" ilk="function" />
          <scope name="rdev_major" ilk="function" />
          <scope name="rdev_minor" ilk="function" />
          <scope name="readable?" ilk="function" />
          <scope name="readable_real?" ilk="function" />
          <scope name="setgid?" ilk="function" />
          <scope name="setuid?" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="size?" ilk="function" />
          <scope name="socket?" ilk="function" />
          <scope name="sticky?" ilk="function" />
          <scope name="symlink?" ilk="function" />
          <scope name="uid" ilk="function" />
          <scope name="world_readable?" ilk="function" />
          <scope name="world_writable?" ilk="function" />
          <scope name="writable?" ilk="function" />
          <scope name="writable_real?" ilk="function" />
          <scope name="zero?" ilk="function" />
        </scope>
        <scope name="WaitReadable" ilk="namespace" >
        </scope>
        <scope name="WaitWritable" ilk="namespace" >
        </scope>
      </scope>
      <scope name="Dir" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="close" ilk="function" signature="close()" doc="Closes the directory stream. Any further attempts to access dir will raise an IOError. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.close   =&gt; nil" />
        <scope name="each" ilk="function" signature="each()" doc="Calls the block once for each entry in this directory, passing the filename of each entry as a parameter to the block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.each  {|x| puts &quot;Got #{x}&quot; }&#xA; produces: &#xA;    Got .&#xA;   Got ..&#xA;   Got config.h&#xA;   Got main.rb" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the path parameter passed to dir&apos;s constructor. &#xA;    d = Dir.new(&quot;..&quot;)&#xA;   d.path   =&gt; &quot;..&quot;" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current position in dir. See also Dir#seek. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.tell   =&gt; 0&#xA;   d.read   =&gt; &quot;.&quot;&#xA;   d.tell   =&gt; 12" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Synonym for Dir#seek, but returns the position parameter. &#xA;    d = Dir.new(&quot;testdir&quot;)   =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;   d.read                   =&gt; &quot;.&quot;&#xA;   i = d.pos                =&gt; 12&#xA;   d.read                   =&gt; &quot;..&quot;&#xA;   d.pos = i                =&gt; 12&#xA;   d.read                   =&gt; &quot;..&quot;" />
        <scope name="read" ilk="function" signature="read()" doc="Reads the next entry from dir and returns it as a string. Returns nil at the end of the stream. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.read   =&gt; &quot;.&quot;&#xA;   d.read   =&gt; &quot;..&quot;&#xA;   d.read   =&gt; &quot;config.h&quot;" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Repositions dir to the first entry. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.read     =&gt; &quot;.&quot;&#xA;   d.rewind   =&gt; #&lt;Dir:0x401b3fb0&gt;&#xA;   d.read     =&gt; &quot;.&quot;" />
        <scope name="seek" ilk="function" signature="seek(p1)" doc="Seeks to a particular location in dir. integer must be a value returned by Dir#tell. &#xA;    d = Dir.new(&quot;testdir&quot;)   =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;   d.read                   =&gt; &quot;.&quot;&#xA;   i = d.tell               =&gt; 12&#xA;   d.read                   =&gt; &quot;..&quot;&#xA;   d.seek(i)                =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;   d.read                   =&gt; &quot;..&quot;" />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current position in dir. See also Dir#seek. &#xA;    d = Dir.new(&quot;testdir&quot;)&#xA;   d.tell   =&gt; 0&#xA;   d.read   =&gt; &quot;.&quot;&#xA;   d.tell   =&gt; 12" />
        <scope name="to_path" ilk="function" signature="to_path()" doc="Returns the path parameter passed to dir&apos;s constructor. &#xA;    d = Dir.new(&quot;..&quot;)&#xA;   d.path   =&gt; &quot;..&quot;" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](...)" doc="Equivalent to calling Dir.glob(array,0) and Dir.glob([string,...],0)." />
        <scope name="chdir" ilk="function" attributes="__classmethod__" signature="chdir(...)" doc="Changes the current working directory of the process to the given string. When called without an argument, changes the directory to the value of the environment variable HOME, or LOGDIR. SystemCallError (probably Errno::ENOENT) if the target directory does not exist. &#xA; If a block is given, it is passed the name of the new current directory, and the block is executed with that as the current directory. The original working directory is restored when the block exits. The return value of chdir is the value of the block. chdir blocks can be nested, but in a multi-threaded program an error will be raised if a thread attempts to open a chdir block while another thread has one open. &#xA;    Dir.chdir(&quot;/var/spool/mail&quot;)&#xA;   puts Dir.pwd&#xA;   Dir.chdir(&quot;/tmp&quot;) do&#xA;     puts Dir.pwd&#xA;     Dir.chdir(&quot;/usr&quot;) do&#xA;       puts Dir.pwd&#xA;     end&#xA;     puts Dir.pwd&#xA;   end&#xA;   puts Dir.pwd&#xA; produces: " />
        <scope name="chroot" ilk="function" attributes="__classmethod__" signature="chroot(p1)" doc="Changes this process&apos;s idea of the file system root. Only a privileged process may make this call. Not available on all platforms. On Unix systems, see chroot(2) for more information." />
        <scope name="delete" ilk="function" attributes="__classmethod__" signature="delete(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="entries" ilk="function" attributes="__classmethod__" signature="entries(...)" doc="Returns an array containing all of the filenames in the given directory. Will raise a SystemCallError if the named directory doesn&apos;t exist. &#xA;    Dir.entries(&quot;testdir&quot;)   =&gt; [&quot;.&quot;, &quot;..&quot;, &quot;config.h&quot;, &quot;main.rb&quot;]" />
        <scope name="exist?" ilk="function" attributes="__classmethod__" signature="exist?(p1)" doc="? &#xA; Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA;    File.directory?(&quot;.&quot;)" />
        <scope name="exists?" ilk="function" attributes="__classmethod__" signature="exists?(p1)" doc="? &#xA; Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA;    File.directory?(&quot;.&quot;)" />
        <scope name="foreach" ilk="function" attributes="__classmethod__" signature="foreach(...)" doc="Calls the block once for each entry in the named directory, passing the filename of each entry as a parameter to the block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    Dir.foreach(&quot;testdir&quot;) {|x| puts &quot;Got #{x}&quot; }&#xA; produces: &#xA;    Got .&#xA;   Got ..&#xA;   Got config.h&#xA;   Got main.rb" />
        <scope name="getwd" ilk="function" attributes="__classmethod__" signature="getwd()" doc="Returns the path to the current working directory of this process as a string. &#xA;    Dir.chdir(&quot;/tmp&quot;)   =&gt; 0&#xA;   Dir.getwd           =&gt; &quot;/tmp&quot;" />
        <scope name="glob" ilk="function" attributes="__classmethod__" signature="glob(...)" doc="Returns the filenames found by expanding pattern which is an +Array+ of the patterns or the pattern +String+, either as an array or as parameters to the block. Note that this pattern is not a regexp (it&apos;s closer to a shell glob). See File::fnmatch for the meaning of the flags parameter. Note that case sensitivity depends on your system (so File::FNM_CASEFOLD is ignored) &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and \*c\* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp. Note, this will not match Unix-like hidden files (dotfiles). In order to include those in the match results, you must use something like &quot;{*,.*}&quot;.&#xA;Matches directories recursively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Matches either literal p or literal q. Matching literals may be more than one character in length. More than two literals may be specified. Equivalent to pattern alternation in regexp.&#xA;Escapes the next metacharacter. Note that this means you cannot use backslash in windows as part of a glob, i.e. Dir[&quot;c:\\foo*&quot;] will not work use Dir[&quot;c:/foo*&quot;] instead &#xA;    Dir[&quot;config.?&quot;]                     =&gt; [&quot;config.h&quot;]&#xA;   Dir.glob(&quot;config.?&quot;)                =&gt; [&quot;config.h&quot;]&#xA;   Dir.glob(&quot;*.[a-z][a-z]&quot;)            =&gt; [&quot;main.rb&quot;]&#xA;   Dir.glob(&quot;*.[^r]*&quot;)                 =&gt; [&quot;config.h&quot;]&#xA;   Dir.glob(&quot;*.{rb,h}&quot;)                =&gt; [&quot;main.rb&quot;, &quot;config.h&quot;]&#xA;   Dir.glob(&quot;*&quot;)                       =&gt; [&quot;config.h&quot;, &quot;main.rb&quot;]" />
        <scope name="home" ilk="function" attributes="__classmethod__" signature="home(...)" doc="Returns the home directory of the current user or the named user if given." />
        <scope name="mkdir" ilk="function" attributes="__classmethod__" signature="mkdir(...)" doc="Makes a new directory named by string, with permissions specified by the optional parameter anInteger. The permissions may be modified by the value of File::umask, and are ignored on NT. Raises a SystemCallError if the directory cannot be created. See also the discussion of permissions in the class documentation for File." />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(...)" doc="With no block, open is a synonym for Dir::new. If a block is present, it is passed aDir as a parameter. The directory is closed at the end of the block, and Dir::open returns the value of the block." />
        <scope name="pwd" ilk="function" attributes="__classmethod__" signature="pwd()" doc="Returns the path to the current working directory of this process as a string. &#xA;    Dir.chdir(&quot;/tmp&quot;)   =&gt; 0&#xA;   Dir.getwd           =&gt; &quot;/tmp&quot;" />
        <scope name="rmdir" ilk="function" attributes="__classmethod__" signature="rmdir(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="unlink" ilk="function" attributes="__classmethod__" signature="unlink(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a new directory object for the named directory." />
      </scope>
      <scope name="Time" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="_dump" ilk="function" signature="_dump(...)" doc="Dump _time_ for marshaling." />
        <scope name="asctime" ilk="function" signature="asctime()" doc="Returns a canonical string representation of time. &#xA;    Time.now.asctime   =&gt; &quot;Wed Apr  9 08:56:03 2003&quot;" />
        <scope name="ctime" ilk="function" signature="ctime()" doc="Returns a canonical string representation of time. &#xA;    Time.now.asctime   =&gt; &quot;Wed Apr  9 08:56:03 2003&quot;" />
        <scope name="day" ilk="function" signature="day()" doc="Returns the day of the month (1..n) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:27:03 -0600&#xA;   t.day          =&gt; 19&#xA;   t.mday         =&gt; 19" />
        <scope name="dst?" ilk="function" signature="dst?()" doc="Returns true if time occurs during Daylight Saving Time in its time zone. &#xA;  # CST6CDT:&#xA;   Time.local(2000, 1, 1).zone    =&gt; &quot;CST&quot;&#xA;   Time.local(2000, 1, 1).isdst   =&gt; false&#xA;   Time.local(2000, 1, 1).dst?    =&gt; false&#xA;   Time.local(2000, 7, 1).zone    =&gt; &quot;CDT&quot;&#xA;   Time.local(2000, 7, 1).isdst   =&gt; true&#xA;   Time.local(2000, 7, 1).dst?    =&gt; true&#xA; # Asia/Tokyo:&#xA;   Time.local(2000, 1, 1).zone    =&gt; &quot;JST&quot;&#xA;   Time.local(2000, 1, 1).isdst   =&gt; false&#xA;   Time.local(2000, 1, 1).dst?    =&gt; false&#xA;   Time.local(2000, 7, 1).zone    =&gt; &quot;JST&quot;" />
        <scope name="friday?" ilk="function" signature="friday?()" doc="Returns true if time represents Friday. &#xA;    t = Time.local(1987, 12, 18)     =&gt; 1987-12-18 00:00:00 -0600&#xA;   t.friday?                        =&gt; true" />
        <scope name="getgm" ilk="function" signature="getgm()" doc="Returns a new new_time object representing time in UTC. &#xA;    t = Time.local(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600&#xA;   t.gmt?                             =&gt; false&#xA;   y = t.getgm                        =&gt; 2000-01-02 02:15:01 UTC&#xA;   y.gmt?                             =&gt; true&#xA;   t == y                             =&gt; true" />
        <scope name="getlocal" ilk="function" signature="getlocal(...)" doc="Returns a new new_time object representing time in local time (using the local time zone in effect for this process). &#xA; If _utc_offset_ is given, it is used instead of the local time. &#xA;    t = Time.utc(2000,1,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.utc?                          =&gt; true&#xA;&#xA;   l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;   l.utc?                          =&gt; false&#xA;   t == l                          =&gt; true&#xA;&#xA;   j = t.getlocal(&quot;+09:00&quot;)        =&gt; 2000-01-02 05:15:01 +0900&#xA;   j.utc?                          =&gt; false&#xA;   t == j                          =&gt; true" />
        <scope name="getutc" ilk="function" signature="getutc()" doc="Returns a new new_time object representing time in UTC. &#xA;    t = Time.local(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600&#xA;   t.gmt?                             =&gt; false&#xA;   y = t.getgm                        =&gt; 2000-01-02 02:15:01 UTC&#xA;   y.gmt?                             =&gt; true&#xA;   t == y                             =&gt; true" />
        <scope name="gmt?" ilk="function" signature="gmt?()" doc="Returns true if time represents a time in UTC (GMT). &#xA;    t = Time.now                        =&gt; 2007-11-19 08:15:23 -0600&#xA;   t.utc?                              =&gt; false&#xA;   t = Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.utc?                              =&gt; true&#xA;&#xA;   t = Time.now                        =&gt; 2007-11-19 08:16:03 -0600&#xA;   t.gmt?                              =&gt; false&#xA;   t = Time.gm(2000,1,1,20,15,1)       =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.gmt?                              =&gt; true" />
        <scope name="gmt_offset" ilk="function" signature="gmt_offset()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA;    t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.gmt_offset                    =&gt; 0&#xA;   l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;   l.gmt_offset                    =&gt; -21600" />
        <scope name="gmtime" ilk="function" signature="gmtime()" doc="Converts time to UTC (GMT), modifying the receiver. &#xA;    t = Time.now   =&gt; 2007-11-19 08:18:31 -0600&#xA;   t.gmt?         =&gt; false&#xA;   t.gmtime       =&gt; 2007-11-19 14:18:31 UTC&#xA;   t.gmt?         =&gt; true&#xA;&#xA;   t = Time.now   =&gt; 2007-11-19 08:18:51 -0600&#xA;   t.utc?         =&gt; false&#xA;   t.utc          =&gt; 2007-11-19 14:18:51 UTC&#xA;   t.utc?         =&gt; true" />
        <scope name="gmtoff" ilk="function" signature="gmtoff()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA;    t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.gmt_offset                    =&gt; 0&#xA;   l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;   l.gmt_offset                    =&gt; -21600" />
        <scope name="hour" ilk="function" signature="hour()" doc="Returns the hour of the day (0..23) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:26:20 -0600&#xA;   t.hour         =&gt; 8" />
        <scope name="isdst" ilk="function" signature="isdst()" doc="Returns true if time occurs during Daylight Saving Time in its time zone. &#xA;  # CST6CDT:&#xA;   Time.local(2000, 1, 1).zone    =&gt; &quot;CST&quot;&#xA;   Time.local(2000, 1, 1).isdst   =&gt; false&#xA;   Time.local(2000, 1, 1).dst?    =&gt; false&#xA;   Time.local(2000, 7, 1).zone    =&gt; &quot;CDT&quot;&#xA;   Time.local(2000, 7, 1).isdst   =&gt; true&#xA;   Time.local(2000, 7, 1).dst?    =&gt; true&#xA; # Asia/Tokyo:&#xA;   Time.local(2000, 1, 1).zone    =&gt; &quot;JST&quot;&#xA;   Time.local(2000, 1, 1).isdst   =&gt; false&#xA;   Time.local(2000, 1, 1).dst?    =&gt; false&#xA;   Time.local(2000, 7, 1).zone    =&gt; &quot;JST&quot;" />
        <scope name="localtime" ilk="function" signature="localtime(...)" doc="Converts time to local time (using the local time zone in effect for this process) modifying the receiver. &#xA; If _utc_offset_ is given, it is used instead of the local time. &#xA;    t = Time.utc(2000, &quot;jan&quot;, 1, 20, 15, 1) =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.utc?                                  =&gt; true&#xA;&#xA;   t.localtime                             =&gt; 2000-01-01 14:15:01 -0600&#xA;   t.utc?                                  =&gt; false&#xA;&#xA;   t.localtime(&quot;+09:00&quot;)                   =&gt; 2000-01-02 05:15:01 +0900&#xA;   t.utc?                                  =&gt; false" />
        <scope name="mday" ilk="function" signature="mday()" doc="Returns the day of the month (1..n) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:27:03 -0600&#xA;   t.day          =&gt; 19&#xA;   t.mday         =&gt; 19" />
        <scope name="min" ilk="function" signature="min()" doc="Returns the minute of the hour (0..59) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:25:51 -0600&#xA;   t.min          =&gt; 25" />
        <scope name="mon" ilk="function" signature="mon()" doc="Returns the month of the year (1..12) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:27:30 -0600&#xA;   t.mon          =&gt; 11&#xA;   t.month        =&gt; 11" />
        <scope name="monday?" ilk="function" signature="monday?()" doc="Returns true if time represents Monday. &#xA;    t = Time.local(2003, 8, 4)       =&gt; 2003-08-04 00:00:00 -0500&#xA;   p t.monday?                      =&gt; true" />
        <scope name="month" ilk="function" signature="month()" doc="Returns the month of the year (1..12) for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:27:30 -0600&#xA;   t.mon          =&gt; 11&#xA;   t.month        =&gt; 11" />
        <scope name="nsec" ilk="function" signature="nsec()" doc="Returns just the number of nanoseconds for time. &#xA;    t = Time.now        =&gt; 2007-11-17 15:18:03 +0900&#xA;   &quot;%10.9f&quot; % t.to_f   =&gt; &quot;1195280283.536151409&quot;&#xA;   t.nsec              =&gt; 536151406&#xA; The lowest digit of to_f and nsec is different because IEEE 754 double is not accurate enough to represent nanoseconds from the Epoch. The accurate value is returned by nsec." />
        <scope name="round" ilk="function" signature="round(...)" doc="Rounds sub seconds to a given precision in decimal digits (0 digits by default). It returns a new time object. _ndigits_ should be zero or positive integer. &#xA;     require &apos;time&apos;&#xA;    t = Time.utc(2010,3,30, 5,43,&quot;25.123456789&quot;.to_r)&#xA;    p t.iso8601(10)           =&gt; &quot;2010-03-30T05:43:25.1234567890Z&quot;&#xA;    p t.round.iso8601(10)     =&gt; &quot;2010-03-30T05:43:25.0000000000Z&quot;&#xA;    p t.round(0).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.0000000000Z&quot;&#xA;    p t.round(1).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1000000000Z&quot;&#xA;    p t.round(2).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1200000000Z&quot;&#xA;    p t.round(3).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1230000000Z&quot;&#xA;    p t.round(4).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1235000000Z&quot;&#xA;    p t.round(5).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234600000Z&quot;&#xA;    p t.round(6).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234570000Z&quot;&#xA;    p t.round(7).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234568000Z&quot;" />
        <scope name="saturday?" ilk="function" signature="saturday?()" doc="Returns true if time represents Saturday. &#xA;    t = Time.local(2006, 6, 10)      =&gt; 2006-06-10 00:00:00 -0500&#xA;   t.saturday?                      =&gt; true" />
        <scope name="sec" ilk="function" signature="sec()" doc="Returns the second of the minute (0..60)[Yes, seconds really can range from zero to 60. This allows the system to inject leap seconds every now and then to correct for the fact that years are not really a convenient number of hours long.] for time. &#xA;    t = Time.now   =&gt; 2007-11-19 08:25:02 -0600&#xA;   t.sec          =&gt; 2" />
        <scope name="strftime" ilk="function" signature="strftime(p1)" doc="Formats time according to the directives in the given format string. Any text not listed as a directive will be passed through to the output string. &#xA; Format meaning:   %a - The abbreviated weekday name (``Sun&apos;&apos;)&#xA;  %A - The  full  weekday  name (``Sunday&apos;&apos;)&#xA;  %b - The abbreviated month name (``Jan&apos;&apos;)&#xA;  %B - The  full  month  name (``January&apos;&apos;)&#xA;  %c - The preferred local date and time representation&#xA;  %C - Century (20 in 2009)&#xA;  %d - Day of the month (01..31)&#xA;  %D - Date (%m/%d/%y)&#xA;  %e - Day of the month, blank-padded ( 1..31)&#xA;  %F - Equivalent to %Y-%m-%d (the ISO 8601 date format)&#xA;  %h - Equivalent to %b&#xA;  %H - Hour of the day, 24-hour clock (00..23)" />
        <scope name="subsec" ilk="function" signature="subsec()" doc="Returns just the fraction for time. &#xA; The result is possibly rational. &#xA;    t = Time.now        =&gt; 2009-03-26 22:33:12 +0900&#xA;   &quot;%10.9f&quot; % t.to_f   =&gt; &quot;1238074392.940563917&quot;&#xA;   t.subsec            =&gt; (94056401/100000000)&#xA; The lowest digit of to_f and subsec is different because IEEE 754 double is not accurate enough to represent the rational. The accurate value is returned by subsec." />
        <scope name="succ" ilk="function" signature="succ()" doc="Return a new time object, one second later than time. Time#succ is obsolete since 1.9.2 for time is not a discrete value. &#xA;     t = Time.now       =&gt; 2007-11-19 08:23:57 -0600&#xA;    t.succ             =&gt; 2007-11-19 08:23:58 -0600" />
        <scope name="sunday?" ilk="function" signature="sunday?()" doc="Returns true if time represents Sunday. &#xA;    t = Time.local(1990, 4, 1)       =&gt; 1990-04-01 00:00:00 -0600&#xA;   t.sunday?                        =&gt; true" />
        <scope name="thursday?" ilk="function" signature="thursday?()" doc="Returns true if time represents Thursday. &#xA;    t = Time.local(1995, 12, 21)     =&gt; 1995-12-21 00:00:00 -0600&#xA;   p t.thursday?                    =&gt; true" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns a ten-element array of values for time: {[ sec, min, hour, day, month, year, wday, yday, isdst, zone ]}. See the individual methods for an explanation of the valid ranges of each value. The ten elements can be passed directly to Time::utc or Time::local to create a new Time. &#xA;    t = Time.now     =&gt; 2007-11-19 08:36:01 -0600&#xA;   now = t.to_a     =&gt; [1, 36, 8, 19, 11, 2007, 1, 323, false, &quot;CST&quot;]" />
        <scope name="to_date" ilk="function" signature="to_date()" />
        <scope name="to_datetime" ilk="function" signature="to_datetime()" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the value of time as a floating point number of seconds since the Epoch. &#xA;    t = Time.now&#xA;   &quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968744.77658&quot;&#xA;   t.to_i              =&gt; 1270968744&#xA; Note that IEEE 754 double is not accurate enough to represent number of nanoseconds from the Epoch." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value of time as an integer number of seconds since the Epoch. &#xA;    t = Time.now&#xA;   &quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968656.89607&quot;&#xA;   t.to_i              =&gt; 1270968656" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value of time as a rational number of seconds since the Epoch. &#xA;    t = Time.now&#xA;   p t.to_r            =&gt; (1270968792716287611/1000000000)&#xA; This methods is intended to be used to get an accurate value representing nanoseconds from the Epoch.  You can use this to convert time to another Epoch." />
        <scope name="to_time" ilk="function" signature="to_time()" />
        <scope name="tuesday?" ilk="function" signature="tuesday?()" doc="Returns true if time represents Tuesday. &#xA;    t = Time.local(1991, 2, 19)      =&gt; 1991-02-19 00:00:00 -0600&#xA;   p t.tuesday?                     =&gt; true" />
        <scope name="tv_nsec" ilk="function" signature="tv_nsec()" doc="Returns just the number of nanoseconds for time. &#xA;    t = Time.now        =&gt; 2007-11-17 15:18:03 +0900&#xA;   &quot;%10.9f&quot; % t.to_f   =&gt; &quot;1195280283.536151409&quot;&#xA;   t.nsec              =&gt; 536151406&#xA; The lowest digit of to_f and nsec is different because IEEE 754 double is not accurate enough to represent nanoseconds from the Epoch. The accurate value is returned by nsec." />
        <scope name="tv_sec" ilk="function" signature="tv_sec()" doc="Returns the value of time as an integer number of seconds since the Epoch. &#xA;    t = Time.now&#xA;   &quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968656.89607&quot;&#xA;   t.to_i              =&gt; 1270968656" />
        <scope name="tv_usec" ilk="function" signature="tv_usec()" doc="Returns just the number of microseconds for time. &#xA;    t = Time.now        =&gt; 2007-11-19 08:03:26 -0600&#xA;   &quot;%10.6f&quot; % t.to_f   =&gt; &quot;1195481006.775195&quot;&#xA;   t.usec              =&gt; 775195" />
        <scope name="usec" ilk="function" signature="usec()" doc="Returns just the number of microseconds for time. &#xA;    t = Time.now        =&gt; 2007-11-19 08:03:26 -0600&#xA;   &quot;%10.6f&quot; % t.to_f   =&gt; &quot;1195481006.775195&quot;&#xA;   t.usec              =&gt; 775195" />
        <scope name="utc" ilk="function" signature="utc()" doc="Converts time to UTC (GMT), modifying the receiver. &#xA;    t = Time.now   =&gt; 2007-11-19 08:18:31 -0600&#xA;   t.gmt?         =&gt; false&#xA;   t.gmtime       =&gt; 2007-11-19 14:18:31 UTC&#xA;   t.gmt?         =&gt; true&#xA;&#xA;   t = Time.now   =&gt; 2007-11-19 08:18:51 -0600&#xA;   t.utc?         =&gt; false&#xA;   t.utc          =&gt; 2007-11-19 14:18:51 UTC&#xA;   t.utc?         =&gt; true" />
        <scope name="utc?" ilk="function" signature="utc?()" doc="Returns true if time represents a time in UTC (GMT). &#xA;    t = Time.now                        =&gt; 2007-11-19 08:15:23 -0600&#xA;   t.utc?                              =&gt; false&#xA;   t = Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.utc?                              =&gt; true&#xA;&#xA;   t = Time.now                        =&gt; 2007-11-19 08:16:03 -0600&#xA;   t.gmt?                              =&gt; false&#xA;   t = Time.gm(2000,1,1,20,15,1)       =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.gmt?                              =&gt; true" />
        <scope name="utc_offset" ilk="function" signature="utc_offset()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA;    t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;   t.gmt_offset                    =&gt; 0&#xA;   l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;   l.gmt_offset                    =&gt; -21600" />
        <scope name="wday" ilk="function" signature="wday()" doc="Returns an integer representing the day of the week, 0..6, with Sunday == 0. &#xA;    t = Time.now   =&gt; 2007-11-20 02:35:35 -0600&#xA;   t.wday         =&gt; 2&#xA;   t.sunday?      =&gt; false&#xA;   t.monday?      =&gt; false&#xA;   t.tuesday?     =&gt; true&#xA;   t.wednesday?   =&gt; false&#xA;   t.thursday?    =&gt; false&#xA;   t.friday?      =&gt; false&#xA;   t.saturday?    =&gt; false" />
        <scope name="wednesday?" ilk="function" signature="wednesday?()" doc="Returns true if time represents Wednesday. &#xA;    t = Time.local(1993, 2, 24)      =&gt; 1993-02-24 00:00:00 -0600&#xA;   p t.wednesday?                   =&gt; true" />
        <scope name="yday" ilk="function" signature="yday()" doc="Returns an integer representing the day of the year, 1..366. &#xA;    t = Time.now   =&gt; 2007-11-19 08:32:31 -0600&#xA;   t.yday         =&gt; 323" />
        <scope name="year" ilk="function" signature="year()" doc="Returns the year for time (including the century). &#xA;    t = Time.now   =&gt; 2007-11-19 08:27:51 -0600&#xA;   t.year         =&gt; 2007" />
        <scope name="zone" ilk="function" signature="zone()" doc="Returns the name of the time zone used for time. As of Ruby 1.8, returns ``UTC&apos;&apos; rather than ``GMT&apos;&apos; for UTC times. &#xA;    t = Time.gm(2000, &quot;jan&quot;, 1, 20, 15, 1)&#xA;   t.zone   =&gt; &quot;UTC&quot;&#xA;   t = Time.local(2000, &quot;jan&quot;, 1, 20, 15, 1)&#xA;   t.zone   =&gt; &quot;CST&quot;" />
        <scope name="_load" ilk="function" attributes="__classmethod__" signature="_load(p1)" doc="Unmarshal a dumped +Time+ object." />
        <scope name="at" ilk="function" attributes="__classmethod__" signature="at(...)" doc="Creates a new time object with the value given by time, the given number of seconds_with_frac, or seconds and microseconds_with_frac from the Epoch. seconds_with_frac and microseconds_with_frac can be Integer, Float, Rational, or other Numeric. non-portable feature allows the offset to be negative on some systems. &#xA;    Time.at(0)            =&gt; 1969-12-31 18:00:00 -0600&#xA;   Time.at(Time.at(0))   =&gt; 1969-12-31 18:00:00 -0600&#xA;   Time.at(946702800)    =&gt; 1999-12-31 23:00:00 -0600&#xA;   Time.at(-284061600)   =&gt; 1960-12-31 00:00:00 -0600&#xA;   Time.at(946684800.2).usec =&gt; 200000&#xA;   Time.at(946684800, 123456.789).nsec =&gt; 123456789" />
        <scope name="gm" ilk="function" attributes="__classmethod__" signature="gm(...)" doc="Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a. sec_with_frac and usec_with_frac can have a fractional part. &#xA;    Time.utc(2000,&quot;jan&quot;,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;   Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC" />
        <scope name="local" ilk="function" attributes="__classmethod__" signature="local(...)" doc="Same as Time::gm, but interprets the values in the local time zone. &#xA;    Time.local(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600" />
        <scope name="mktime" ilk="function" attributes="__classmethod__" signature="mktime(...)" doc="Same as Time::gm, but interprets the values in the local time zone. &#xA;    Time.local(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600" />
        <scope name="now" ilk="function" attributes="__classmethod__" signature="now()" doc="Synonym for Time.new. Returns a +Time+ object initialized to the current system time." />
        <scope name="utc" ilk="function" attributes="__classmethod__" signature="utc(...)" doc="Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a. sec_with_frac and usec_with_frac can have a fractional part. &#xA;    Time.utc(2000,&quot;jan&quot;,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;   Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Returns a Time object. &#xA; It is initialized to the current system time if no argument. &lt;b&gt;Note:&lt;/b&gt; The object created will be created using the resolution available on your system clock, and so may include fractional seconds. &#xA; If one or more arguments specified, the time is initialized to the specified time. _sec_ may have fraction if it is a rational. &#xA; _utc_offset_ is the offset from UTC. It is a string such as &quot;+09:00&quot; or a number of seconds such as 32400. &#xA;    a = Time.new      =&gt; 2007-11-19 07:50:02 -0600&#xA;   b = Time.new      =&gt; 2007-11-19 07:50:02 -0600&#xA;   a == b            =&gt; false&#xA;   &quot;%.6f&quot; % a.to_f   =&gt; &quot;1195480202.282373&quot;&#xA;   &quot;%.6f&quot; % b.to_f   =&gt; &quot;1195480202.283415&quot;&#xA;   Time.new(2008,6,21, 13,30,0, &quot;+09:00&quot;) =&gt; 2008-06-21 13:30:00 +0900&#xA;   # A trip for RubyConf 2007&#xA;   t1 = Time.new(2007,11,1,15,25,0, &quot;+09:00&quot;) # JST (Narita)&#xA;   t2 = Time.new(2007,11,1,12, 5,0, &quot;-05:00&quot;) # CDT (Minneapolis)" />
      </scope>
      <scope name="Random" ilk="class" classrefs="Object" >
        <scope name="bytes" ilk="function" signature="bytes(p1)" doc="Returns a random binary string.  The argument size specified the length of the result string." />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rand" ilk="function" signature="rand(...)" doc="When the argument is an +Integer+ or a +Bignum+, it returns a random integer greater than or equal to zero and less than the argument.  Unlike Random.rand, when the argument is a negative integer or zero, it raises an ArgumentError. &#xA; When the argument is a +Float+, it returns a random floating point number between 0.0 and _max_, including 0.0 and excluding _max_. &#xA; When the argument _limit_ is a +Range+, it returns a random number where range.member?(number) == true.     prng.rand(5..9)  =&gt; one of [5, 6, 7, 8, 9]&#xA;    prng.rand(5...9) =&gt; one of [5, 6, 7, 8]&#xA;    prng.rand(5.0..9.0) =&gt; between 5.0 and 9.0, including 9.0&#xA;    prng.rand(5.0...9.0) =&gt; between 5.0 and 9.0, excluding 9.0&#xA; +begin+/+end+ of the range have to have subtract and add methods. &#xA; Otherwise, it raises an ArgumentError." />
        <scope name="seed" ilk="function" signature="seed()" doc="Returns the seed of the generator." />
        <scope name="new_seed" ilk="function" attributes="__classmethod__" signature="new_seed()" doc="Returns arbitrary value for seed." />
        <scope name="rand" ilk="function" attributes="__classmethod__" signature="rand(...)" doc="Converts max to an integer using max1 = max.to_i.abs. If _max_ is +nil+ the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1. &#xA;    srand 1234                 =&gt; 0&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]&#xA;   [ rand(10), rand(1000) ]   =&gt; [6, 817]&#xA;   srand 1234                 =&gt; 1234&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]" />
        <scope name="srand" ilk="function" attributes="__classmethod__" signature="srand(...)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted or zero, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates new Mersenne Twister based pseudorandom number generator with seed.  When the argument seed is omitted, the generator is initialized with Random.new_seed. &#xA; The argument seed is used to ensure repeatable sequences of random numbers between different runs of the program. &#xA;     prng = Random.new(1234)&#xA;    [ prng.rand, prng.rand ]   =&gt; [0.191519450378892, 0.622108771039832]&#xA;    [ prng.integer(10), prng.integer(1000) ]  =&gt; [4, 664]&#xA;    prng = Random.new(1234)&#xA;    [ prng.rand, prng.rand ]   =&gt; [0.191519450378892, 0.622108771039832]" />
      </scope>
      <scope name="Signal" ilk="namespace" >
        <scope name="list" ilk="function" />
        <scope name="trap" ilk="function" />
      </scope>
      <scope name="Process" ilk="namespace" >
        <scope name="abort" ilk="function" />
        <scope name="daemon" ilk="function" />
        <scope name="detach" ilk="function" />
        <scope name="egid" ilk="function" />
        <scope name="egid=" ilk="function" />
        <scope name="euid" ilk="function" />
        <scope name="euid=" ilk="function" />
        <scope name="exec" ilk="function" />
        <scope name="exit" ilk="function" />
        <scope name="exit!" ilk="function" />
        <scope name="fork" ilk="function" />
        <scope name="getpgid" ilk="function" />
        <scope name="getpgrp" ilk="function" />
        <scope name="getpriority" ilk="function" />
        <scope name="getrlimit" ilk="function" />
        <scope name="gid" ilk="function" />
        <scope name="gid=" ilk="function" />
        <scope name="groups" ilk="function" />
        <scope name="groups=" ilk="function" />
        <scope name="initgroups" ilk="function" />
        <scope name="kill" ilk="function" />
        <scope name="maxgroups" ilk="function" />
        <scope name="maxgroups=" ilk="function" />
        <scope name="pid" ilk="function" />
        <scope name="ppid" ilk="function" />
        <scope name="setpgid" ilk="function" />
        <scope name="setpgrp" ilk="function" />
        <scope name="setpriority" ilk="function" />
        <scope name="setrlimit" ilk="function" />
        <scope name="setsid" ilk="function" />
        <scope name="spawn" ilk="function" />
        <scope name="times" ilk="function" />
        <scope name="uid" ilk="function" />
        <scope name="uid=" ilk="function" />
        <scope name="wait" ilk="function" />
        <scope name="wait2" ilk="function" />
        <scope name="waitall" ilk="function" />
        <scope name="waitpid" ilk="function" />
        <scope name="waitpid2" ilk="function" />
        <scope name="GID" ilk="namespace" >
          <scope name="change_privilege" ilk="function" />
          <scope name="eid" ilk="function" />
          <scope name="eid=" ilk="function" />
          <scope name="grant_privilege" ilk="function" />
          <scope name="re_exchange" ilk="function" />
          <scope name="re_exchangeable?" ilk="function" />
          <scope name="rid" ilk="function" />
          <scope name="sid_available?" ilk="function" />
          <scope name="switch" ilk="function" />
        </scope>
        <variable name="PRIO_PGRP" attributes="__const__" citdl="Fixnum" />
        <variable name="PRIO_PROCESS" attributes="__const__" citdl="Fixnum" />
        <variable name="PRIO_USER" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_AS" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_CORE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_CPU" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_DATA" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_FSIZE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_MEMLOCK" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_NOFILE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_NPROC" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_RSS" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_STACK" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIM_INFINITY" attributes="__const__" citdl="Bignum" />
        <variable name="RLIM_SAVED_CUR" attributes="__const__" citdl="Bignum" />
        <variable name="RLIM_SAVED_MAX" attributes="__const__" citdl="Bignum" />
        <scope name="Status" ilk="class" classrefs="Object" >
          <scope name="coredump?" ilk="function" />
          <scope name="exited?" ilk="function" />
          <scope name="exitstatus" ilk="function" />
          <scope name="pid" ilk="function" />
          <scope name="signaled?" ilk="function" />
          <scope name="stopped?" ilk="function" />
          <scope name="stopsig" ilk="function" />
          <scope name="success?" ilk="function" />
          <scope name="termsig" ilk="function" />
          <scope name="to_i" ilk="function" />
        </scope>
        <scope name="Sys" ilk="namespace" >
          <scope name="getegid" ilk="function" />
          <scope name="geteuid" ilk="function" />
          <scope name="getgid" ilk="function" />
          <scope name="getuid" ilk="function" />
          <scope name="issetugid" ilk="function" />
          <scope name="setegid" ilk="function" />
          <scope name="seteuid" ilk="function" />
          <scope name="setgid" ilk="function" />
          <scope name="setregid" ilk="function" />
          <scope name="setresgid" ilk="function" />
          <scope name="setresuid" ilk="function" />
          <scope name="setreuid" ilk="function" />
          <scope name="setrgid" ilk="function" />
          <scope name="setruid" ilk="function" />
          <scope name="setuid" ilk="function" />
        </scope>
        <scope name="UID" ilk="namespace" >
          <scope name="change_privilege" ilk="function" />
          <scope name="eid" ilk="function" />
          <scope name="eid=" ilk="function" />
          <scope name="grant_privilege" ilk="function" />
          <scope name="re_exchange" ilk="function" />
          <scope name="re_exchangeable?" ilk="function" />
          <scope name="rid" ilk="function" />
          <scope name="sid_available?" ilk="function" />
          <scope name="switch" ilk="function" />
        </scope>
        <variable name="WNOHANG" attributes="__const__" citdl="Fixnum" />
        <variable name="WUNTRACED" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Proc" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns the number of arguments that would not be ignored. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, return -n-1, where n is the number of mandatory arguments. A proc with no argument declarations is the same a block declaring || as its arguments. &#xA;    Proc.new {}.arity          =&gt;  0&#xA;   Proc.new {||}.arity        =&gt;  0&#xA;   Proc.new {|a|}.arity       =&gt;  1&#xA;   Proc.new {|a,b|}.arity     =&gt;  2&#xA;   Proc.new {|a,b,c|}.arity   =&gt;  3&#xA;   Proc.new {|*a|}.arity      =&gt; -1&#xA;   Proc.new {|a,*b|}.arity    =&gt; -2&#xA;   Proc.new {|a,*b, c|}.arity    =&gt; -3" />
        <scope name="binding" ilk="function" signature="binding()" doc="Returns the binding associated with prc. Note that Kernel#eval accepts either a Proc or a Binding object as its second parameter. &#xA;    def fred(param)&#xA;     proc {}&#xA;   end&#xA;&#xA;   b = fred(99)&#xA;   eval(&quot;param&quot;, b.binding)   =&gt; 99" />
        <scope name="call" ilk="function" signature="call(...)" doc="Invokes the block, with obj as the block&apos;s parameter.  It is to allow a proc object to be a target of +when+ clause in the case statement." />
        <scope name="curry" ilk="function" signature="curry(...)" doc="Returns a curried proc. If the optional arity argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments. &#xA;    b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }&#xA;   p b.curry[1][2][3]           =&gt; 6&#xA;   p b.curry[1, 2][3, 4]        =&gt; 6&#xA;   p b.curry(5)[1][2][3][4][5]  =&gt; 6&#xA;   p b.curry(5)[1, 2][3, 4][5]  =&gt; 6&#xA;   p b.curry(1)[1]              =&gt; 1&#xA;   b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }&#xA;   p b.curry[1][2][3]           =&gt; 6&#xA;   p b.curry[1, 2][3, 4]        =&gt; 10&#xA;   p b.curry(5)[1][2][3][4][5]  =&gt; 15&#xA;   p b.curry(5)[1, 2][3, 4][5]  =&gt; 15&#xA;   p b.curry(1)[1]              =&gt; 1" />
        <scope name="lambda?" ilk="function" signature="lambda?()" doc="Returns true for a Proc object which argument handling is rigid. Such procs are typically generated by lambda. &#xA; A Proc object generated by proc ignore extra arguments. &#xA;   proc {|a,b| [a,b] }.call(1,2,3)    =&gt; [1,2]&#xA; It provides nil for lacked arguments. &#xA;   proc {|a,b| [a,b] }.call(1)        =&gt; [1,nil]&#xA; It expand single-array argument. &#xA;   proc {|a,b| [a,b] }.call([1,2])    =&gt; [1,2]&#xA; A Proc object generated by lambda doesn&apos;t have such tricks. &#xA;   lambda {|a,b| [a,b] }.call(1,2,3)  =&gt; ArgumentError&#xA;  lambda {|a,b| [a,b] }.call(1)      =&gt; ArgumentError&#xA;  lambda {|a,b| [a,b] }.call([1,2])  =&gt; ArgumentError&#xA; Proc#lambda? is a predicate for the tricks. It returns true if no tricks. &#xA;   lambda {}.lambda?            =&gt; true" />
        <scope name="parameters" ilk="function" signature="parameters()" doc="returns the parameter information of this proc. &#xA;    prc = lambda{|x, y=42, *rest|}&#xA;   prc.parameters  =&gt; [[:req, :x], [:opt, :y], [:rest, :rest]]" />
        <scope name="source_location" ilk="function" signature="source_location()" doc="returns the ruby source filename and line number containing this proc or nil if this proc was not defined in ruby (i.e. native)" />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Part of the protocol for converting objects to Proc objects. Instances of class Proc simply return themselves." />
        <scope name="yield" ilk="function" signature="yield(...)" doc="Invokes the block, with obj as the block&apos;s parameter.  It is to allow a proc object to be a target of +when+ clause in the case statement." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates a new Proc object, bound to the current context. Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object. &#xA;    def proc_from&#xA;     Proc.new&#xA;   end&#xA;   proc = proc_from { &quot;hello&quot; }&#xA;   proc.call   =&gt; &quot;hello&quot;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates a new Proc object, bound to the current context. Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object. &#xA;    def proc_from&#xA;     Proc.new&#xA;   end&#xA;   proc = proc_from { &quot;hello&quot; }&#xA;   proc.call   =&gt; &quot;hello&quot;" />
      </scope>
      <scope name="LocalJumpError" ilk="class" classrefs="StandardError" >
        <scope name="exit_value" ilk="function" signature="exit_value()" doc="call_seq:   local_jump_error.exit_value  -&gt; obj&#xA; Returns the exit value associated with this +LocalJumpError+." />
        <scope name="reason" ilk="function" signature="reason()" doc="The reason this block was terminated: :break, :redo, :retry, :next, :return, or :noreason." />
      </scope>
      <scope name="SystemStackError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="Method" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments. &#xA;    class C&#xA;     def one;    end&#xA;     def two(a); end&#xA;     def three(*a);  end&#xA;     def four(a, b); end&#xA;     def five(a, b, *c);    end&#xA;     def six(a, b, *c, &amp;d); end&#xA;   end&#xA;   c = C.new&#xA;   c.method(:one).arity     =&gt; 0&#xA;   c.method(:two).arity     =&gt; 1&#xA;   c.method(:three).arity   =&gt; -1" />
        <scope name="call" ilk="function" signature="call(...)" doc="Invokes the meth with the specified arguments, returning the method&apos;s return value. &#xA;    m = 12.method(&quot;+&quot;)&#xA;   m.call(3)    =&gt; 15&#xA;   m.call(20)   =&gt; 32" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the method." />
        <scope name="owner" ilk="function" signature="owner()" doc="Returns the class or module that defines the method." />
        <scope name="parameters" ilk="function" signature="parameters()" doc="returns the parameter information of this method" />
        <scope name="receiver" ilk="function" signature="receiver()" doc="Returns the bound receiver of the method object." />
        <scope name="source_location" ilk="function" signature="source_location()" doc="returns the ruby source filename and line number containing this method or nil if this method was not defined in ruby (i.e. native)" />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Returns a Proc object corresponding to this method." />
        <scope name="unbind" ilk="function" signature="unbind()" doc="Dissociates meth from it&apos;s current receiver. The resulting UnboundMethod can subsequently be bound to a new object of the same class (see UnboundMethod)." />
      </scope>
      <scope name="UnboundMethod" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments. &#xA;    class C&#xA;     def one;    end&#xA;     def two(a); end&#xA;     def three(*a);  end&#xA;     def four(a, b); end&#xA;     def five(a, b, *c);    end&#xA;     def six(a, b, *c, &amp;d); end&#xA;   end&#xA;   c = C.new&#xA;   c.method(:one).arity     =&gt; 0&#xA;   c.method(:two).arity     =&gt; 1&#xA;   c.method(:three).arity   =&gt; -1" />
        <scope name="bind" ilk="function" signature="bind(p1)" doc="Bind umeth to obj. If Klass was the class from which umeth was obtained, obj.kind_of?(Klass) must be true. &#xA;    class A&#xA;     def test&#xA;       puts &quot;In test, class = #{self.class}&quot;&#xA;     end&#xA;   end&#xA;   class B &lt; A&#xA;   end&#xA;   class C &lt; B&#xA;   end&#xA;   um = B.instance_method(:test)&#xA;   bm = um.bind(C.new)&#xA;   bm.call" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the method." />
        <scope name="owner" ilk="function" signature="owner()" doc="Returns the class or module that defines the method." />
        <scope name="parameters" ilk="function" signature="parameters()" doc="returns the parameter information of this method" />
        <scope name="source_location" ilk="function" signature="source_location()" doc="returns the ruby source filename and line number containing this method or nil if this method was not defined in ruby (i.e. native)" />
      </scope>
      <scope name="Binding" ilk="class" classrefs="Object" >
        <scope name="eval" ilk="function" signature="eval(...)" doc="Evaluates the Ruby expression(s) in string, in the binding&apos;s context.  If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA;    def getBinding(param)&#xA;     return binding&#xA;   end&#xA;   b = getBinding(&quot;hello&quot;)&#xA;   b.eval(&quot;param&quot;)   =&gt; &quot;hello&quot;" />
      </scope>
      <scope name="Math" ilk="namespace" >
        <scope name="acos" ilk="function" />
        <scope name="acosh" ilk="function" />
        <scope name="asin" ilk="function" />
        <scope name="asinh" ilk="function" />
        <scope name="atan" ilk="function" />
        <scope name="atan2" ilk="function" />
        <scope name="atanh" ilk="function" />
        <scope name="cbrt" ilk="function" />
        <scope name="cos" ilk="function" />
        <scope name="cosh" ilk="function" />
        <scope name="erf" ilk="function" />
        <scope name="erfc" ilk="function" />
        <scope name="exp" ilk="function" />
        <scope name="frexp" ilk="function" />
        <scope name="gamma" ilk="function" />
        <scope name="hypot" ilk="function" />
        <scope name="ldexp" ilk="function" />
        <scope name="lgamma" ilk="function" />
        <scope name="log" ilk="function" />
        <scope name="log10" ilk="function" />
        <scope name="log2" ilk="function" />
        <scope name="sin" ilk="function" />
        <scope name="sinh" ilk="function" />
        <scope name="sqrt" ilk="function" signature="sqrt(a)" />
        <scope name="tan" ilk="function" />
        <scope name="tanh" ilk="function" />
        <scope name="DomainError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="E" attributes="__const__" citdl="Float" />
        <variable name="PI" attributes="__const__" citdl="Float" />
      </scope>
      <scope name="GC" ilk="namespace" >
        <scope name="count" ilk="function" />
        <scope name="disable" ilk="function" />
        <scope name="enable" ilk="function" />
        <scope name="garbage_collect" ilk="function" signature="garbage_collect()" doc="Initiates garbage collection, unless manually disabled." />
        <scope name="start" ilk="function" />
        <scope name="stress" ilk="function" />
        <scope name="stress=" ilk="function" />
        <scope name="Profiler" ilk="namespace" >
          <scope name="clear" ilk="function" />
          <scope name="disable" ilk="function" />
          <scope name="enable" ilk="function" />
          <scope name="enabled?" ilk="function" />
          <scope name="report" ilk="function" />
          <scope name="result" ilk="function" />
          <scope name="total_time" ilk="function" />
        </scope>
      </scope>
      <scope name="ObjectSpace" ilk="namespace" >
        <scope name="_id2ref" ilk="function" />
        <scope name="count_objects" ilk="function" />
        <scope name="define_finalizer" ilk="function" />
        <scope name="each_object" ilk="function" />
        <scope name="garbage_collect" ilk="function" />
        <scope name="undefine_finalizer" ilk="function" />
      </scope>
      <scope name="Enumerator" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="each" ilk="function" signature="each()" doc="Iterates the given block using the object and the method specified in the first place.  If no block is given, returns self." />
        <scope name="feed" ilk="function" signature="feed(p1)" doc="Set the value for the next yield in the enumerator returns. &#xA; If the value is not set, the yield returns nil. &#xA; This value is cleared after used. &#xA;   o = Object.new&#xA;  def o.each&#xA;    # (2)&#xA;    x = yield&#xA;    p x          =&gt; &quot;foo&quot;&#xA;    # (5)&#xA;    x = yield&#xA;    p x          =&gt; nil&#xA;    # (7)&#xA;    x = yield" />
        <scope name="next" ilk="function" signature="next()" doc="Returns the next object in the enumerator, and move the internal position forward.  When the position reached at the end, StopIteration is raised. &#xA;   a = [1,2,3]&#xA;  e = a.to_enum&#xA;  p e.next   =&gt; 1&#xA;  p e.next   =&gt; 2&#xA;  p e.next   =&gt; 3&#xA;  p e.next   #raises StopIteration&#xA; Note that enumeration sequence by next method does not affect other non-external enumeration methods, unless underlying iteration methods itself has side-effect, e.g. IO#each_line." />
        <scope name="next_values" ilk="function" signature="next_values()" doc="Returns the next object as an array in the enumerator, and move the internal position forward. When the position reached at the end, StopIteration is raised. &#xA; This method can be used to distinguish yield and yield nil. &#xA;   o = Object.new&#xA;  def o.each&#xA;    yield&#xA;    yield 1&#xA;    yield 1, 2&#xA;    yield nil&#xA;    yield [1, 2]&#xA;  end&#xA;  e = o.to_enum&#xA;  p e.next_values&#xA;  p e.next_values" />
        <scope name="peek" ilk="function" signature="peek()" doc="Returns the next object in the enumerator, but don&apos;t move the internal position forward.  When the position reached at the end, StopIteration is raised. &#xA;   a = [1,2,3]&#xA;  e = a.to_enum&#xA;  p e.next   =&gt; 1&#xA;  p e.peek   =&gt; 2&#xA;  p e.peek   =&gt; 2&#xA;  p e.peek   =&gt; 2&#xA;  p e.next   =&gt; 2&#xA;  p e.next   =&gt; 3&#xA;  p e.next   #raises StopIteration" />
        <scope name="peek_values" ilk="function" signature="peek_values()" doc="Returns the next object as an array in the enumerator, but don&apos;t move the internal position forward. When the position reached at the end, StopIteration is raised. &#xA;   o = Object.new&#xA;  def o.each&#xA;    yield&#xA;    yield 1&#xA;    yield 1, 2&#xA;  end&#xA;  e = o.to_enum&#xA;  p e.peek_values    =&gt; []&#xA;  e.next&#xA;  p e.peek_values    =&gt; [1]&#xA;  p e.peek_values    =&gt; [1]&#xA;  e.next" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the enumeration sequence by the next method. &#xA; If the enclosed object responds to a &quot;rewind&quot; method, it is called." />
        <scope name="with_index" ilk="function" signature="with_index(...)" doc="Iterates the given block for each element with an index, which starts from +offset+.  If no block is given, returns an enumerator." />
        <scope name="with_object" ilk="function" signature="with_object(p1)" doc="Iterates the given block for each element with an arbitrary object given, and returns the initially given object. &#xA; If no block is given, returns an enumerator." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates a new Enumerator object, which is to be used as an Enumerable object iterating in a given way. &#xA; In the first form, a generated Enumerator iterates over the given object using the given method with the given arguments passed. Use of this form is discouraged.  Use Kernel#enum_for(), alias to_enum, instead. &#xA;   e = Enumerator.new(ObjectSpace, :each_object)&#xA;      #-&gt; ObjectSpace.enum_for(:each_object)&#xA;  e.select { |obj| obj.is_a?(Class) }  =&gt; array of all classes&#xA; In the second form, iteration is defined by the given block, in which a &quot;yielder&quot; object given as block parameter can be used to yield a value by calling the +yield+ method, alias +&lt;&lt;+. &#xA;   fib = Enumerator.new { |y|&#xA;    a = b = 1&#xA;    loop {&#xA;      y &lt;&lt; a&#xA;      a, b = b, a + b&#xA;    }&#xA;  }" />
        <scope name="Generator" ilk="class" classrefs="Object" >
          <import symbol="Enumerable" />
          <scope name="each" ilk="function" />
        </scope>
        <scope name="Yielder" ilk="class" classrefs="Object" >
          <scope name="yield" ilk="function" />
        </scope>
      </scope>
      <scope name="StopIteration" ilk="class" classrefs="IndexError" >
        <scope name="result" ilk="function" signature="result()" doc="Returns the return value of the iterator. &#xA;   o = Object.new&#xA;  def o.each&#xA;    yield 1&#xA;    yield 2&#xA;    yield 3&#xA;    100&#xA;  end&#xA;  e = o.to_enum&#xA;  p e.next                   =&gt; 1&#xA;  p e.next                   =&gt; 2&#xA;  p e.next                   =&gt; 3&#xA;  begin" />
      </scope>
      <scope name="RubyVM" ilk="class" classrefs="Object" >
        <scope name="Env" ilk="class" classrefs="Object" >
        </scope>
        <variable name="INSTRUCTION_NAMES" attributes="__const__" citdl="Array" />
        <scope name="InstructionSequence" ilk="class" classrefs="Object" >
          <scope name="disasm" ilk="function" />
          <scope name="disassemble" ilk="function" />
          <scope name="eval" ilk="function" />
          <scope name="to_a" ilk="function" />
          <scope name="compile" ilk="function" attributes="__classmethod__" />
          <scope name="compile_file" ilk="function" attributes="__classmethod__" />
          <scope name="compile_option" ilk="function" attributes="__classmethod__" />
          <scope name="compile_option=" ilk="function" attributes="__classmethod__" />
          <scope name="disasm" ilk="function" attributes="__classmethod__" />
          <scope name="disassemble" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="OPTS" attributes="__const__" citdl="Array" />
        <variable name="USAGE_ANALYSIS_INSN" attributes="__const__" citdl="Hash" />
        <variable name="USAGE_ANALYSIS_INSN_BIGRAM" attributes="__const__" citdl="Hash" />
        <variable name="USAGE_ANALYSIS_REGS" attributes="__const__" citdl="Hash" />
      </scope>
      <scope name="Thread" ilk="class" classrefs="Object" >
        <scope name="abort_on_exception" ilk="function" signature="abort_on_exception()" doc="Returns the status of the thread-local ``abort on exception&apos;&apos; condition for thr. The default is false. See also Thread::abort_on_exception=." />
        <scope name="abort_on_exception=" ilk="function" signature="abort_on_exception=(p1)" doc="When set to true, causes all threads (including the main program) to abort if an exception is raised in thr. The process will effectively exit(0)." />
        <scope name="add_trace_func" ilk="function" signature="add_trace_func(p1)" doc="Adds _proc_ as a handler for tracing. See Thread#set_trace_func and +set_trace_func+." />
        <scope name="alive?" ilk="function" signature="alive?()" doc="Returns true if thr is running or sleeping. &#xA;    thr = Thread.new { }&#xA;   thr.join                =&gt; #&lt;Thread:0x401b3fb0 dead&gt;&#xA;   Thread.current.alive?   =&gt; true&#xA;   thr.alive?              =&gt; false" />
        <scope name="backtrace" ilk="function" signature="backtrace()" doc="Returns the current back trace of the _thr_." />
        <scope name="exit" ilk="function" signature="exit()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="group" ilk="function" signature="group()" doc="Returns the ThreadGroup which contains thr, or nil if the thread is not a member of any group. &#xA;    Thread.main.group   =&gt; #&lt;ThreadGroup:0x4029d914&gt;" />
        <scope name="join" ilk="function" signature="join(...)" doc="The calling thread will suspend execution and run thr. Does not return until thr exits or until limit seconds have passed. If the time limit expires, nil will be returned, otherwise thr is returned. &#xA; Any threads not joined will be killed when the main program exits.  If thr had previously raised an exception and the abort_on_exception and $DEBUG flags are not set (so the exception has not yet been processed) it will be processed at this time. &#xA;    a = Thread.new { print &quot;a&quot;; sleep(10); print &quot;b&quot;; print &quot;c&quot; }&#xA;   x = Thread.new { print &quot;x&quot;; Thread.pass; print &quot;y&quot;; print &quot;z&quot; }&#xA;   x.join # Let x thread finish, a will be killed on exit.&#xA; produces: &#xA;    axyz&#xA; The following example illustrates the limit parameter. &#xA;    y = Thread.new { 4.times { sleep 0.1; puts &apos;tick... &apos; }}&#xA;   puts &quot;Waiting&quot; until y.join(0.15)&#xA; produces: &#xA;    tick...&#xA;   Waiting" />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given string (or symbol) exists as a thread-local variable. &#xA;    me = Thread.current&#xA;   me[:oliver] = &quot;a&quot;&#xA;   me.key?(:oliver)    =&gt; true&#xA;   me.key?(:stanley)   =&gt; false" />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns an an array of the names of the thread-local variables (as Symbols). &#xA;    thr = Thread.new do&#xA;     Thread.current[:cat] = &apos;meow&apos;&#xA;     Thread.current[&quot;dog&quot;] = &apos;woof&apos;&#xA;   end&#xA;   thr.join   =&gt; #&lt;Thread:0x401b3f10 dead&gt;&#xA;   thr.keys   =&gt; [:dog, :cat]" />
        <scope name="kill" ilk="function" signature="kill()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="priority" ilk="function" signature="priority()" doc="Returns the priority of thr. Default is inherited from the current thread which creating the new thread, or zero for the initial main thread; higher-priority thread will run more frequently than lower-priority threads (but lower-priority threads can also run). &#xA; This is just hint for Ruby thread scheduler.  It may be ignored on some platform. &#xA;    Thread.current.priority   =&gt; 0" />
        <scope name="priority=" ilk="function" signature="priority=(p1)" doc="Sets the priority of thr to integer. Higher-priority threads will run more frequently than lower-priority threads (but lower-priority threads can also run). &#xA; This is just hint for Ruby thread scheduler.  It may be ignored on some platform. &#xA;    count1 = count2 = 0&#xA;   a = Thread.new do&#xA;         loop { count1 += 1 }&#xA;       end&#xA;   a.priority = -1&#xA;   b = Thread.new do&#xA;         loop { count2 += 1 }&#xA;       end&#xA;   b.priority = -2&#xA;   sleep 1   =&gt; 1&#xA;   count1    =&gt; 622504" />
        <scope name="raise" ilk="function" signature="raise(...)" doc="Raises an exception (see Kernel::raise) from thr. The caller does not have to be thr. &#xA;    Thread.abort_on_exception = true&#xA;   a = Thread.new { sleep(200) }&#xA;   a.raise(&quot;Gotcha&quot;)&#xA; produces: &#xA;    prog.rb:3: Gotcha (RuntimeError)&#xA;    from prog.rb:2:in `initialize&apos;&#xA;    from prog.rb:2:in `new&apos;&#xA;    from prog.rb:2" />
        <scope name="run" ilk="function" signature="run()" doc="Wakes up thr, making it eligible for scheduling. &#xA;    a = Thread.new { puts &quot;a&quot;; Thread.stop; puts &quot;c&quot; }&#xA;   Thread.pass&#xA;   puts &quot;Got here&quot;&#xA;   a.run&#xA;   a.join&#xA; produces: &#xA;    a&#xA;   Got here&#xA;   c" />
        <scope name="safe_level" ilk="function" signature="safe_level()" doc="Returns the safe level in effect for thr. Setting thread-local safe levels can help when implementing sandboxes which run insecure code. &#xA;    thr = Thread.new { $SAFE = 3; sleep }&#xA;   Thread.current.safe_level   =&gt; 0&#xA;   thr.safe_level              =&gt; 3" />
        <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ on _thr_ as the handler for tracing, or disables tracing if the parameter is +nil+. See +set_trace_func+." />
        <scope name="status" ilk="function" signature="status()" doc="Returns the status of thr: ``sleep&apos;&apos; if thr is sleeping or waiting on I/O, ``run&apos;&apos; if thr is executing, ``aborting&apos;&apos; if thr is aborting, false if thr terminated normally, and nil if thr terminated with an exception. &#xA;    a = Thread.new { raise(&quot;die now&quot;) }&#xA;   b = Thread.new { Thread.stop }&#xA;   c = Thread.new { Thread.exit }&#xA;   d = Thread.new { sleep }&#xA;   d.kill                  =&gt; #&lt;Thread:0x401b3678 aborting&gt;&#xA;   a.status                =&gt; nil&#xA;   b.status                =&gt; &quot;sleep&quot;&#xA;   c.status                =&gt; false&#xA;   d.status                =&gt; &quot;aborting&quot;&#xA;   Thread.current.status   =&gt; &quot;run&quot;" />
        <scope name="stop?" ilk="function" signature="stop?()" doc="Returns true if thr is dead or sleeping. &#xA;    a = Thread.new { Thread.stop }&#xA;   b = Thread.current&#xA;   a.stop?   =&gt; true&#xA;   b.stop?   =&gt; false" />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="value" ilk="function" signature="value()" doc="Waits for thr to complete (via Thread#join) and returns its value. &#xA;    a = Thread.new { 2 + 2 }&#xA;   a.value   =&gt; 4" />
        <scope name="wakeup" ilk="function" signature="wakeup()" doc="Marks thr as eligible for scheduling (it may still remain blocked on I/O, however). Does not invoke the scheduler (see Thread#run). &#xA;    c = Thread.new { Thread.stop; puts &quot;hey!&quot; }&#xA;   c.wakeup&#xA; produces: &#xA;    hey!" />
        <scope name="abort_on_exception" ilk="function" attributes="__classmethod__" signature="abort_on_exception()" doc="Returns the status of the global ``abort on exception&apos;&apos; condition.  The default is false. When set to true, or if the global $DEBUG flag is true (perhaps because the command line option -d was specified) all threads will abort (the process will exit(0)) if an exception is raised in any thread. See also Thread::abort_on_exception=." />
        <scope name="abort_on_exception=" ilk="function" attributes="__classmethod__" signature="abort_on_exception=(p1)" doc="When set to true, all threads will abort if an exception is raised. Returns the new state. &#xA;    Thread.abort_on_exception = true&#xA;   t1 = Thread.new do&#xA;     puts  &quot;In new thread&quot;&#xA;     raise &quot;Exception from thread&quot;&#xA;   end&#xA;   sleep(1)&#xA;   puts &quot;not reached&quot;&#xA; produces: &#xA;    In new thread&#xA;   prog.rb:4: Exception from thread (RuntimeError)&#xA;    from prog.rb:2:in `initialize&apos;&#xA;    from prog.rb:2:in `new&apos;" />
        <scope name="current" ilk="function" attributes="__classmethod__" signature="current()" doc="Returns the currently executing thread. &#xA;    Thread.current   =&gt; #&lt;Thread:0x401bdf4c run&gt;" />
        <scope name="exclusive" ilk="function" attributes="__classmethod__" signature="exclusive()" doc="Wraps a block in Thread.critical, restoring the original value upon exit from the critical section, and returns the value of the block." />
        <scope name="exit" ilk="function" attributes="__classmethod__" signature="exit()" doc="Terminates the currently running thread and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exit the process." />
        <scope name="fork" ilk="function" attributes="__classmethod__" signature="fork(...)" doc="Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass&apos;s initialize method." />
        <scope name="kill" ilk="function" attributes="__classmethod__" signature="kill(p1)" doc="Causes the given thread to exit (see Thread::exit). &#xA;    count = 0&#xA;   a = Thread.new { loop { count += 1 } }&#xA;   sleep(0.1)       =&gt; 0&#xA;   Thread.kill(a)   =&gt; #&lt;Thread:0x401b3d30 dead&gt;&#xA;   count            =&gt; 93947&#xA;   a.alive?         =&gt; false" />
        <scope name="list" ilk="function" attributes="__classmethod__" signature="list()" doc="Returns an array of Thread objects for all threads that are either runnable or stopped. &#xA;    Thread.new { sleep(200) }&#xA;   Thread.new { 1000000.times {|i| i*i } }&#xA;   Thread.new { Thread.stop }&#xA;   Thread.list.each {|t| p t}&#xA; produces: &#xA;    #&lt;Thread:0x401b3e84 sleep&gt;&#xA;   #&lt;Thread:0x401b3f38 run&gt;&#xA;   #&lt;Thread:0x401b3fb0 sleep&gt;&#xA;   #&lt;Thread:0x401bdf4c run&gt;" />
        <scope name="main" ilk="function" attributes="__classmethod__" signature="main()" doc="Returns the main thread." />
        <scope name="new" ilk="function" attributes="__classmethod__" />
        <scope name="pass" ilk="function" attributes="__classmethod__" signature="pass()" doc="Invokes the thread scheduler to pass execution to another thread. &#xA;    a = Thread.new { print &quot;a&quot;; Thread.pass;&#xA;                    print &quot;b&quot;; Thread.pass;&#xA;                    print &quot;c&quot; }&#xA;   b = Thread.new { print &quot;x&quot;; Thread.pass;&#xA;                    print &quot;y&quot;; Thread.pass;&#xA;                    print &quot;z&quot; }&#xA;   a.join&#xA;   b.join&#xA; produces: &#xA;    axbycz" />
        <scope name="start" ilk="function" attributes="__classmethod__" signature="start(...)" doc="Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass&apos;s initialize method." />
        <scope name="stop" ilk="function" attributes="__classmethod__" signature="stop()" doc="Stops execution of the current thread, putting it into a ``sleep&apos;&apos; state, and schedules execution of another thread. &#xA;    a = Thread.new { print &quot;a&quot;; Thread.stop; print &quot;c&quot; }&#xA;   Thread.pass&#xA;   print &quot;b&quot;&#xA;   a.run&#xA;   a.join&#xA; produces: &#xA;    abc" />
        <variable name="MUTEX_FOR_THREAD_EXCLUSIVE" attributes="__const__" citdl="Mutex" />
      </scope>
      <variable name="TOPLEVEL_BINDING" attributes="__const__" citdl="Binding" />
      <scope name="ThreadGroup" ilk="class" classrefs="Object" >
        <scope name="add" ilk="function" signature="add(p1)" doc="Adds the given thread to this group, removing it from any other group to which it may have previously belonged. &#xA;    puts &quot;Initial group is #{ThreadGroup::Default.list}&quot;&#xA;   tg = ThreadGroup.new&#xA;   t1 = Thread.new { sleep }&#xA;   t2 = Thread.new { sleep }&#xA;   puts &quot;t1 is #{t1}&quot;&#xA;   puts &quot;t2 is #{t2}&quot;&#xA;   tg.add(t1)&#xA;   puts &quot;Initial group now #{ThreadGroup::Default.list}&quot;&#xA;   puts &quot;tg group now #{tg.list}&quot;&#xA; produces: &#xA;    Initial group is #&lt;Thread:0x401bdf4c&gt;&#xA;   t1 is #&lt;Thread:0x401b3c90&gt;" />
        <scope name="enclose" ilk="function" signature="enclose()" doc="Prevents threads from being added to or removed from the receiving ThreadGroup. New threads can still be started in an enclosed ThreadGroup. &#xA;    ThreadGroup::Default.enclose        =&gt; #&lt;ThreadGroup:0x4029d914&gt;&#xA;   thr = Thread::new { Thread.stop }   =&gt; #&lt;Thread:0x402a7210 sleep&gt;&#xA;   tg = ThreadGroup::new               =&gt; #&lt;ThreadGroup:0x402752d4&gt;&#xA;   tg.add thr&#xA; produces: &#xA;    ThreadError: can&apos;t move from the enclosed thread group" />
        <scope name="enclosed?" ilk="function" signature="enclosed?()" doc="Returns true if thgrp is enclosed. See also ThreadGroup#enclose." />
        <scope name="list" ilk="function" signature="list()" doc="Returns an array of all existing Thread objects that belong to this group. &#xA;    ThreadGroup::Default.list   =&gt; [#&lt;Thread:0x401bdf4c run&gt;]" />
        <variable name="Default" attributes="__const__" citdl="ThreadGroup" />
      </scope>
      <scope name="Mutex" ilk="class" classrefs="Object" >
        <scope name="lock" ilk="function" signature="lock()" doc="Attempts to grab the lock and waits if it isn&apos;t available. Raises +ThreadError+ if +mutex+ was locked by the current thread." />
        <scope name="locked?" ilk="function" signature="locked?()" doc="Returns +true+ if this lock is currently held by some thread." />
        <scope name="sleep" ilk="function" signature="sleep(...)" doc="Releases the lock and sleeps +timeout+ seconds if it is given and non-nil or forever.  Raises +ThreadError+ if +mutex+ wasn&apos;t locked by the current thread." />
        <scope name="synchronize" ilk="function" signature="synchronize()" doc="Obtains a lock, runs the block, and releases the lock when the block completes.  See the example under Mutex." />
        <scope name="try_lock" ilk="function" signature="try_lock()" doc="Attempts to obtain the lock and returns immediately. Returns +true+ if the lock was granted." />
        <scope name="unlock" ilk="function" signature="unlock()" doc="Releases the lock. Raises +ThreadError+ if +mutex+ wasn&apos;t locked by the current thread." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new Mutex" />
      </scope>
      <scope name="ThreadError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Fiber" ilk="class" classrefs="Object" >
        <scope name="resume" ilk="function" signature="resume(...)" doc="Resumes the fiber from the point at which the last Fiber.yield was called, or starts running it if it is the first call to resume. Arguments passed to resume will be the value of the Fiber.yield expression or will be passed as block parameters to the fiber&apos;s block if this is the first resume. &#xA; Alternatively, when resume is called it evaluates to the arguments passed to the next Fiber.yield statement inside the fiber&apos;s block or to the block value if it runs to completion without any Fiber.yield" />
        <scope name="yield" ilk="function" attributes="__classmethod__" signature="yield(...)" doc="Yields control back to the context that resumed the fiber, passing along any arguments that were passed to it. The fiber will resume processing at this point when resume is called next. Any arguments passed to the next resume will be the value that this Fiber.yield expression evaluates to." />
      </scope>
      <scope name="FiberError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Rational" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rationalize" ilk="function" signature="rationalize(...)" doc="Returns a simpler approximation of the value if an optional argument eps is given (rat-|eps| &lt;= result &lt;= rat+|eps|), self otherwise. &#xA; For example: &#xA;    r = Rational(5033165, 16777216)&#xA;   r.rationalize                    =&gt; (5033165/16777216)&#xA;   r.rationalize(Rational(&apos;0.01&apos;))  =&gt; (3/10)&#xA;   r.rationalize(Rational(&apos;0.1&apos;))   =&gt; (1/3)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Return the value as a float. &#xA; For example: &#xA;    Rational(2).to_f      =&gt; 2.0&#xA;   Rational(9, 4).to_f   =&gt; 2.25&#xA;   Rational(-3, 4).to_f  =&gt; -0.75&#xA;   Rational(20, 3).to_f  =&gt; 6.666666666666667" />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the truncated value as an integer. &#xA; Equivalent to    rat.truncate.&#xA; For example: &#xA;    Rational(2, 3).to_i   =&gt; 0&#xA;   Rational(3).to_i      =&gt; 3&#xA;   Rational(300.6).to_i  =&gt; 300&#xA;   Rational(98,71).to_i  =&gt; 1&#xA;   Rational(-30,2).to_i  =&gt; -15" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns self. &#xA; For example: &#xA;    Rational(2).to_r      =&gt; (2/1)&#xA;   Rational(-8, 6).to_r  =&gt; (-4/3)" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Complex" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rationalize" ilk="function" signature="rationalize(...)" doc="Returns the value as a rational if possible.  An optional argument eps is always ignored." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the value as a float if possible." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value as an integer if possible." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value as a rational if possible." />
        <scope name="polar" ilk="function" attributes="__classmethod__" signature="polar(...)" doc="Returns a complex object which denotes the given polar form." />
        <scope name="rect" ilk="function" attributes="__classmethod__" signature="rect(...)" doc="Returns a complex object which denotes the given rectangular form." />
        <scope name="rectangular" ilk="function" attributes="__classmethod__" signature="rectangular(...)" doc="Returns a complex object which denotes the given rectangular form." />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <variable name="I" attributes="__const__" citdl="Complex" />
      </scope>
      <variable name="RUBY_VERSION" attributes="__const__" citdl="String" />
      <variable name="RUBY_RELEASE_DATE" attributes="__const__" citdl="String" />
      <variable name="RUBY_PLATFORM" attributes="__const__" citdl="String" />
      <variable name="RUBY_PATCHLEVEL" attributes="__const__" citdl="Fixnum" />
      <variable name="RUBY_REVISION" attributes="__const__" citdl="Fixnum" />
      <variable name="RUBY_DESCRIPTION" attributes="__const__" citdl="String" />
      <variable name="RUBY_COPYRIGHT" attributes="__const__" citdl="String" />
      <variable name="RUBY_ENGINE" attributes="__const__" citdl="String" />
      <variable name="ARGV" attributes="__const__" citdl="Array" />
      <scope name="Gem" ilk="namespace" >
        <scope name="activate" ilk="function" />
        <scope name="all_load_paths" ilk="function" />
        <scope name="available?" ilk="function" />
        <scope name="bin_path" ilk="function" />
        <scope name="binary_mode" ilk="function" />
        <scope name="bindir" ilk="function" />
        <scope name="cache" ilk="function" />
        <scope name="clear_paths" ilk="function" />
        <scope name="config_file" ilk="function" />
        <scope name="configuration" ilk="function" />
        <scope name="configuration=" ilk="function" />
        <scope name="datadir" ilk="function" />
        <scope name="default_bindir" ilk="function" />
        <scope name="default_dir" ilk="function" />
        <scope name="default_exec_format" ilk="function" />
        <scope name="default_path" ilk="function" />
        <scope name="default_sources" ilk="function" />
        <scope name="default_system_source_cache_dir" ilk="function" />
        <scope name="default_user_source_cache_dir" ilk="function" />
        <scope name="deflate" ilk="function" />
        <scope name="dir" ilk="function" />
        <scope name="ensure_gem_subdirectories" ilk="function" />
        <scope name="find_files" ilk="function" />
        <scope name="gunzip" ilk="function" />
        <scope name="gzip" ilk="function" />
        <scope name="inflate" ilk="function" />
        <scope name="latest_load_paths" ilk="function" />
        <scope name="load_path_insert_index" ilk="function" />
        <scope name="load_plugins" ilk="function" />
        <scope name="loaded_specs" ilk="function" />
        <scope name="location_of_caller" ilk="function" />
        <scope name="marshal_version" ilk="function" />
        <scope name="path" ilk="function" />
        <scope name="platforms" ilk="function" />
        <scope name="platforms=" ilk="function" />
        <scope name="post_install" ilk="function" />
        <scope name="post_install_hooks" ilk="function" />
        <scope name="post_uninstall" ilk="function" />
        <scope name="post_uninstall_hooks" ilk="function" />
        <scope name="pre_install" ilk="function" />
        <scope name="pre_install_hooks" ilk="function" />
        <scope name="pre_uninstall" ilk="function" />
        <scope name="pre_uninstall_hooks" ilk="function" />
        <scope name="prefix" ilk="function" />
        <scope name="promote_load_path" ilk="function" />
        <scope name="read_binary" ilk="function" />
        <scope name="refresh" ilk="function" />
        <scope name="remove_prelude_paths" ilk="function" />
        <scope name="required_location" ilk="function" />
        <scope name="ruby" ilk="function" />
        <scope name="ruby_engine" ilk="function" />
        <scope name="ruby_version" ilk="function" />
        <scope name="searcher" ilk="function" />
        <scope name="source_index" ilk="function" />
        <scope name="sources" ilk="function" />
        <scope name="sources=" ilk="function" />
        <scope name="suffix_pattern" ilk="function" />
        <scope name="suffixes" ilk="function" />
        <scope name="time" ilk="function" />
        <scope name="try_activate" ilk="function" />
        <scope name="ui" ilk="function" />
        <scope name="use_paths" ilk="function" />
        <scope name="user_dir" ilk="function" />
        <scope name="user_home" ilk="function" />
        <scope name="win_platform?" ilk="function" />
        <scope name="Builder" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="build" ilk="function" />
          <scope name="success" ilk="function" />
        </scope>
        <scope name="Cache" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <import symbol="Enumerable" />
          <scope name="add_spec" ilk="function" />
          <scope name="add_specs" ilk="function" />
          <scope name="all_gems" ilk="function" />
          <scope name="dump" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="find_name" ilk="function" />
          <scope name="gem_signature" ilk="function" />
          <scope name="gems" ilk="function" />
          <scope name="index_signature" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="length" ilk="function" />
          <scope name="load_gems_in" ilk="function" />
          <scope name="outdated" ilk="function" />
          <scope name="prerelease_gems" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="refresh!" ilk="function" />
          <scope name="released_gems" ilk="function" />
          <scope name="released_specs" ilk="function" />
          <scope name="remove_spec" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="spec_dirs" ilk="function" />
          <scope name="spec_dirs=" ilk="function" />
          <scope name="specification" ilk="function" />
          <scope name="update" ilk="function" />
          <scope name="alert" ilk="function" attributes="__classmethod__" />
          <scope name="alert_error" ilk="function" attributes="__classmethod__" />
          <scope name="alert_warning" ilk="function" attributes="__classmethod__" />
          <scope name="ask" ilk="function" attributes="__classmethod__" />
          <scope name="ask_for_password" ilk="function" attributes="__classmethod__" />
          <scope name="ask_yes_no" ilk="function" attributes="__classmethod__" />
          <scope name="choose_from_list" ilk="function" attributes="__classmethod__" />
          <scope name="from_gems_in" ilk="function" attributes="__classmethod__" />
          <scope name="from_installed_gems" ilk="function" attributes="__classmethod__" />
          <scope name="installed_spec_directories" ilk="function" attributes="__classmethod__" />
          <scope name="load_specification" ilk="function" attributes="__classmethod__" />
          <scope name="say" ilk="function" attributes="__classmethod__" />
          <scope name="terminate_interaction" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="CommandLineError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="ConfigFile" ilk="class" classrefs="Object" >
          <scope name="args" ilk="function" />
          <scope name="backtrace" ilk="function" />
          <scope name="backtrace=" ilk="function" />
          <scope name="benchmark" ilk="function" />
          <scope name="benchmark=" ilk="function" />
          <scope name="bulk_threshold" ilk="function" />
          <scope name="bulk_threshold=" ilk="function" />
          <scope name="config_file_name" ilk="function" />
          <scope name="credentials_path" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="handle_arguments" ilk="function" />
          <scope name="home" ilk="function" />
          <scope name="home=" ilk="function" />
          <scope name="load_file" ilk="function" />
          <scope name="load_rubygems_api_key" ilk="function" />
          <scope name="path" ilk="function" />
          <scope name="path=" ilk="function" />
          <scope name="really_verbose" ilk="function" />
          <scope name="rubygems_api_key" ilk="function" />
          <scope name="rubygems_api_key=" ilk="function" />
          <scope name="update_sources" ilk="function" />
          <scope name="update_sources=" ilk="function" />
          <scope name="verbose" ilk="function" />
          <scope name="verbose=" ilk="function" />
          <scope name="write" ilk="function" />
          <variable name="DEFAULT_BACKTRACE" attributes="__const__" citdl="FalseClass" />
          <variable name="DEFAULT_BENCHMARK" attributes="__const__" citdl="FalseClass" />
          <variable name="DEFAULT_BULK_THRESHOLD" attributes="__const__" citdl="Fixnum" />
          <variable name="DEFAULT_UPDATE_SOURCES" attributes="__const__" citdl="TrueClass" />
          <variable name="DEFAULT_VERBOSITY" attributes="__const__" citdl="TrueClass" />
          <variable name="OPERATING_SYSTEM_DEFAULTS" attributes="__const__" citdl="Hash" />
          <variable name="PLATFORM_DEFAULTS" attributes="__const__" citdl="Hash" />
          <variable name="SYSTEM_WIDE_CONFIG_FILE" attributes="__const__" citdl="String" />
        </scope>
        <variable name="ConfigMap" attributes="__const__" citdl="Hash" />
        <scope name="ConsoleUI" ilk="class" classrefs="Gem::StreamUI" >
          <scope name="SilentProgressReporter" ilk="class" classrefs="Object" >
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="SimpleProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="VerboseProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
        </scope>
        <variable name="DIRECTORIES" attributes="__const__" citdl="Array" />
        <scope name="DefaultUserInteraction" ilk="namespace" >
          <scope name="ui" ilk="function" />
          <scope name="ui" ilk="function" />
          <scope name="ui=" ilk="function" />
          <scope name="ui=" ilk="function" />
          <scope name="use_ui" ilk="function" />
          <scope name="use_ui" ilk="function" />
        </scope>
        <scope name="Dependency" ilk="class" classrefs="Object" >
          <scope name="__requirement" ilk="function" />
          <scope name="match?" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="prerelease=" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="requirement" ilk="function" />
          <scope name="requirements_list" ilk="function" />
          <scope name="type" ilk="function" />
          <scope name="version_requirement" ilk="function" />
          <scope name="version_requirements" ilk="function" />
          <scope name="version_requirements=" ilk="function" />
          <scope name="warned_version_requirement" ilk="function" attributes="__classmethod__" />
          <scope name="warned_version_requirement=" ilk="function" attributes="__classmethod__" />
          <variable name="TYPES" attributes="__const__" citdl="Array" />
        </scope>
        <scope name="DependencyError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="DependencyRemovalException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="DocumentError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="EndOfYAMLException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Exception" ilk="class" classrefs="RuntimeError" >
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Construct a new Exception object, optionally passing in a message." />
        </scope>
        <scope name="FilePermissionError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="FormatException" ilk="class" classrefs="Gem::Exception" >
          <scope name="file_path" ilk="function" />
          <scope name="file_path=" ilk="function" />
        </scope>
        <variable name="GEM_PRELUDE_METHODS" attributes="__const__" citdl="Array" />
        <scope name="GemNotFoundException" ilk="class" classrefs="Gem::Exception" >
          <scope name="errors" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="version" ilk="function" />
        </scope>
        <scope name="GemNotInHomeException" ilk="class" classrefs="Gem::Exception" >
          <scope name="spec" ilk="function" />
          <scope name="spec=" ilk="function" />
        </scope>
        <scope name="GemPathSearcher" ilk="class" classrefs="Object" >
          <scope name="find" ilk="function" />
          <scope name="find_all" ilk="function" />
          <scope name="init_gemspecs" ilk="function" />
          <scope name="lib_dirs_for" ilk="function" />
          <scope name="matching_file?" ilk="function" />
          <scope name="matching_files" ilk="function" />
        </scope>
        <scope name="InstallError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="InvalidSpecificationException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="LoadError" ilk="class" classrefs="LoadError" >
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="version_requirement" ilk="function" />
          <scope name="version_requirement=" ilk="function" />
        </scope>
        <variable name="MARSHAL_SPEC_DIR" attributes="__const__" citdl="String" />
        <variable name="MUTEX" attributes="__const__" citdl="Mutex" />
        <scope name="OperationNotSupportedError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Platform" ilk="class" classrefs="Object" >
          <scope name="cpu" ilk="function" />
          <scope name="cpu=" ilk="function" />
          <scope name="empty?" ilk="function" />
          <scope name="os" ilk="function" />
          <scope name="os=" ilk="function" />
          <scope name="to_a" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="version=" ilk="function" />
          <scope name="local" ilk="function" attributes="__classmethod__" />
          <scope name="match" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" attributes="__classmethod__" />
          <variable name="CURRENT" attributes="__const__" citdl="String" />
          <variable name="RUBY" attributes="__const__" citdl="String" />
        </scope>
        <scope name="QuickLoader" ilk="namespace" >
          <scope name="load_full_rubygems_library" ilk="function" />
          <scope name="path_to_full_rubygems_library" ilk="function" />
          <scope name="remove" ilk="function" />
        </scope>
        <scope name="RemoteError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteInstallationCancelled" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteInstallationSkipped" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteSourceException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Requirement" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="as_list" ilk="function" />
          <scope name="marshal_dump" ilk="function" />
          <scope name="marshal_load" ilk="function" />
          <scope name="none?" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="requirements" ilk="function" />
          <scope name="satisfied_by?" ilk="function" />
          <scope name="create" ilk="function" attributes="__classmethod__" />
          <scope name="default" ilk="function" attributes="__classmethod__" />
          <scope name="parse" ilk="function" attributes="__classmethod__" />
          <variable name="OPS" attributes="__const__" citdl="Hash" />
          <variable name="PATTERN" attributes="__const__" citdl="Regexp" />
        </scope>
        <variable name="RubyGemsPackageVersion" attributes="__const__" citdl="String" />
        <variable name="RubyGemsVersion" attributes="__const__" citdl="String" />
        <scope name="SilentUI" ilk="class" classrefs="Object" >
          <scope name="method_missing" ilk="function" />
        </scope>
        <scope name="SourceIndex" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <import symbol="Enumerable" />
          <scope name="add_spec" ilk="function" />
          <scope name="add_specs" ilk="function" />
          <scope name="all_gems" ilk="function" />
          <scope name="dump" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="find_name" ilk="function" />
          <scope name="gem_signature" ilk="function" />
          <scope name="gems" ilk="function" />
          <scope name="index_signature" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="length" ilk="function" />
          <scope name="load_gems_in" ilk="function" />
          <scope name="outdated" ilk="function" />
          <scope name="prerelease_gems" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="refresh!" ilk="function" />
          <scope name="released_gems" ilk="function" />
          <scope name="released_specs" ilk="function" />
          <scope name="remove_spec" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="spec_dirs" ilk="function" />
          <scope name="spec_dirs=" ilk="function" />
          <scope name="specification" ilk="function" />
          <scope name="update" ilk="function" />
          <scope name="alert" ilk="function" attributes="__classmethod__" />
          <scope name="alert_error" ilk="function" attributes="__classmethod__" />
          <scope name="alert_warning" ilk="function" attributes="__classmethod__" />
          <scope name="ask" ilk="function" attributes="__classmethod__" />
          <scope name="ask_for_password" ilk="function" attributes="__classmethod__" />
          <scope name="ask_yes_no" ilk="function" attributes="__classmethod__" />
          <scope name="choose_from_list" ilk="function" attributes="__classmethod__" />
          <scope name="from_gems_in" ilk="function" attributes="__classmethod__" />
          <scope name="from_installed_gems" ilk="function" attributes="__classmethod__" />
          <scope name="installed_spec_directories" ilk="function" attributes="__classmethod__" />
          <scope name="load_specification" ilk="function" attributes="__classmethod__" />
          <scope name="say" ilk="function" attributes="__classmethod__" />
          <scope name="terminate_interaction" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="SpecFetcher" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="cache_dir" ilk="function" />
          <scope name="dir" ilk="function" />
          <scope name="fetch" ilk="function" />
          <scope name="fetch_spec" ilk="function" />
          <scope name="fetch_with_errors" ilk="function" />
          <scope name="find_matching" ilk="function" />
          <scope name="find_matching_with_errors" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="legacy_repos" ilk="function" />
          <scope name="list" ilk="function" />
          <scope name="load_specs" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="specs" ilk="function" />
          <scope name="warn_legacy" ilk="function" />
          <scope name="fetcher" ilk="function" attributes="__classmethod__" />
          <scope name="fetcher=" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Specification" ilk="class" classrefs="Object" >
          <scope name="_dump" ilk="function" />
          <scope name="add_bindir" ilk="function" />
          <scope name="add_dependency" ilk="function" />
          <scope name="add_development_dependency" ilk="function" />
          <scope name="add_runtime_dependency" ilk="function" />
          <scope name="assign_defaults" ilk="function" />
          <scope name="author" ilk="function" />
          <scope name="author=" ilk="function" />
          <scope name="authors" ilk="function" />
          <scope name="authors=" ilk="function" />
          <scope name="autorequire" ilk="function" />
          <scope name="autorequire=" ilk="function" />
          <scope name="bindir" ilk="function" />
          <scope name="bindir=" ilk="function" />
          <scope name="cert_chain" ilk="function" />
          <scope name="cert_chain=" ilk="function" />
          <scope name="date" ilk="function" />
          <scope name="date=" ilk="function" />
          <scope name="default_executable" ilk="function" />
          <scope name="default_executable=" ilk="function" />
          <scope name="dependencies" ilk="function" />
          <scope name="dependent_gems" ilk="function" />
          <scope name="description" ilk="function" />
          <scope name="description=" ilk="function" />
          <scope name="development_dependencies" ilk="function" />
          <scope name="email" ilk="function" />
          <scope name="email=" ilk="function" />
          <scope name="encode_with" ilk="function" />
          <scope name="executable" ilk="function" />
          <scope name="executable=" ilk="function" />
          <scope name="executables" ilk="function" />
          <scope name="executables=" ilk="function" />
          <scope name="extensions" ilk="function" />
          <scope name="extensions=" ilk="function" />
          <scope name="extra_rdoc_files" ilk="function" />
          <scope name="extra_rdoc_files=" ilk="function" />
          <scope name="file_name" ilk="function" />
          <scope name="files" ilk="function" />
          <scope name="files=" ilk="function" />
          <scope name="full_gem_path" ilk="function" />
          <scope name="full_name" ilk="function" />
          <scope name="has_rdoc" ilk="function" />
          <scope name="has_rdoc=" ilk="function" />
          <scope name="has_rdoc?" ilk="function" />
          <scope name="has_test_suite?" ilk="function" />
          <scope name="has_unit_tests?" ilk="function" />
          <scope name="homepage" ilk="function" />
          <scope name="homepage=" ilk="function" />
          <scope name="init_with" ilk="function" />
          <scope name="installation_path" ilk="function" />
          <scope name="lib_files" ilk="function" />
          <scope name="license" ilk="function" />
          <scope name="license=" ilk="function" />
          <scope name="licenses" ilk="function" />
          <scope name="licenses=" ilk="function" />
          <scope name="loaded" ilk="function" />
          <scope name="loaded=" ilk="function" />
          <scope name="loaded?" ilk="function" />
          <scope name="loaded_from" ilk="function" />
          <scope name="loaded_from=" ilk="function" />
          <scope name="mark_version" ilk="function" />
          <scope name="method_missing" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="normalize" ilk="function" />
          <scope name="original_name" ilk="function" />
          <scope name="original_platform" ilk="function" />
          <scope name="original_platform=" ilk="function" />
          <scope name="platform" ilk="function" />
          <scope name="platform=" ilk="function" />
          <scope name="post_install_message" ilk="function" />
          <scope name="post_install_message=" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="rdoc_options" ilk="function" />
          <scope name="rdoc_options=" ilk="function" />
          <scope name="require_path" ilk="function" />
          <scope name="require_path=" ilk="function" />
          <scope name="require_paths" ilk="function" />
          <scope name="require_paths=" ilk="function" />
          <scope name="required_ruby_version" ilk="function" />
          <scope name="required_ruby_version=" ilk="function" />
          <scope name="required_rubygems_version" ilk="function" />
          <scope name="required_rubygems_version=" ilk="function" />
          <scope name="requirements" ilk="function" />
          <scope name="requirements=" ilk="function" />
          <scope name="rubyforge_project" ilk="function" />
          <scope name="rubyforge_project=" ilk="function" />
          <scope name="rubygems_version" ilk="function" />
          <scope name="rubygems_version=" ilk="function" />
          <scope name="runtime_dependencies" ilk="function" />
          <scope name="satisfies_requirement?" ilk="function" />
          <scope name="signing_key" ilk="function" />
          <scope name="signing_key=" ilk="function" />
          <scope name="sort_obj" ilk="function" />
          <scope name="spec_name" ilk="function" />
          <scope name="specification_version" ilk="function" />
          <scope name="specification_version=" ilk="function" />
          <scope name="summary" ilk="function" />
          <scope name="summary=" ilk="function" />
          <scope name="test_file" ilk="function" />
          <scope name="test_file=" ilk="function" />
          <scope name="test_files" ilk="function" />
          <scope name="test_files=" ilk="function" />
          <scope name="test_suite_file" ilk="function" />
          <scope name="test_suite_file=" ilk="function" />
          <scope name="to_ruby" ilk="function" />
          <scope name="validate" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="version=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="_load" ilk="function" attributes="__classmethod__" />
          <scope name="array_attribute" ilk="function" attributes="__classmethod__" />
          <scope name="array_attributes" ilk="function" attributes="__classmethod__" />
          <scope name="attribute" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_alias_singular" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_defaults" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_names" ilk="function" attributes="__classmethod__" />
          <scope name="attributes" ilk="function" attributes="__classmethod__" />
          <scope name="default_value" ilk="function" attributes="__classmethod__" />
          <scope name="from_yaml" ilk="function" attributes="__classmethod__" />
          <scope name="load" ilk="function" attributes="__classmethod__" />
          <scope name="normalize_yaml_input" ilk="function" attributes="__classmethod__" />
          <scope name="overwrite_accessor" ilk="function" attributes="__classmethod__" />
          <scope name="read_only" ilk="function" attributes="__classmethod__" />
          <scope name="required_attribute" ilk="function" attributes="__classmethod__" />
          <scope name="required_attribute?" ilk="function" attributes="__classmethod__" />
          <scope name="required_attributes" ilk="function" attributes="__classmethod__" />
          <variable name="CURRENT_SPECIFICATION_VERSION" attributes="__const__" citdl="Fixnum" />
          <variable name="MARSHAL_FIELDS" attributes="__const__" citdl="Hash" />
          <variable name="NONEXISTENT_SPECIFICATION_VERSION" attributes="__const__" citdl="Fixnum" />
          <variable name="SPECIFICATION_VERSION_HISTORY" attributes="__const__" citdl="Hash" />
          <variable name="TODAY" attributes="__const__" citdl="Time" />
        </scope>
        <scope name="StreamUI" ilk="class" classrefs="Object" >
          <scope name="alert" ilk="function" />
          <scope name="alert_error" ilk="function" />
          <scope name="alert_warning" ilk="function" />
          <scope name="ask" ilk="function" />
          <scope name="ask_for_password" ilk="function" />
          <scope name="ask_for_password_on_unix" ilk="function" />
          <scope name="ask_for_password_on_windows" ilk="function" />
          <scope name="ask_yes_no" ilk="function" />
          <scope name="choose_from_list" ilk="function" />
          <scope name="debug" ilk="function" />
          <scope name="errs" ilk="function" />
          <scope name="ins" ilk="function" />
          <scope name="outs" ilk="function" />
          <scope name="progress_reporter" ilk="function" />
          <scope name="say" ilk="function" />
          <scope name="terminate_interaction" ilk="function" />
          <scope name="SilentProgressReporter" ilk="class" classrefs="Object" >
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="SimpleProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="VerboseProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
        </scope>
        <scope name="SystemExitException" ilk="class" classrefs="SystemExit" >
          <scope name="exit_code" ilk="function" />
          <scope name="exit_code=" ilk="function" />
        </scope>
        <scope name="UserInteraction" ilk="namespace" >
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="alert" ilk="function" />
          <scope name="alert_error" ilk="function" />
          <scope name="alert_warning" ilk="function" />
          <scope name="ask" ilk="function" />
          <scope name="ask_for_password" ilk="function" />
          <scope name="ask_yes_no" ilk="function" />
          <scope name="choose_from_list" ilk="function" />
          <scope name="say" ilk="function" />
          <scope name="terminate_interaction" ilk="function" />
        </scope>
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <scope name="VerificationError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Version" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="bump" ilk="function" />
          <scope name="marshal_dump" ilk="function" />
          <scope name="marshal_load" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="release" ilk="function" />
          <scope name="segments" ilk="function" />
          <scope name="spermy_recommendation" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="correct?" ilk="function" attributes="__classmethod__" />
          <scope name="create" ilk="function" attributes="__classmethod__" />
          <variable name="ANCHORED_VERSION_PATTERN" attributes="__const__" citdl="Regexp" />
          <scope name="Requirement" ilk="class" classrefs="Object" >
            <import symbol="Comparable" />
            <scope name="as_list" ilk="function" />
            <scope name="marshal_dump" ilk="function" />
            <scope name="marshal_load" ilk="function" />
            <scope name="none?" ilk="function" />
            <scope name="prerelease?" ilk="function" />
            <scope name="pretty_print" ilk="function" />
            <scope name="requirements" ilk="function" />
            <scope name="satisfied_by?" ilk="function" />
            <scope name="create" ilk="function" attributes="__classmethod__" />
            <scope name="default" ilk="function" attributes="__classmethod__" />
            <scope name="parse" ilk="function" attributes="__classmethod__" />
            <variable name="OPS" attributes="__const__" citdl="Hash" />
            <variable name="PATTERN" attributes="__const__" citdl="Regexp" />
          </scope>
          <variable name="VERSION_PATTERN" attributes="__const__" citdl="String" />
        </scope>
        <variable name="WIN_PATTERNS" attributes="__const__" citdl="Array" />
        <variable name="YAML_SPEC_DIR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="StringScanner" ilk="class" classrefs="Object" >
        <scope name="beginning_of_line?" ilk="function" signature="beginning_of_line?()" doc="Returns +true+ iff the scan pointer is at the beginning of the line. &#xA;   s = StringScanner.new(&quot;test\ntest\n&quot;)&#xA;  s.bol?           # =&gt; true&#xA;  s.scan(/te/)&#xA;  s.bol?           # =&gt; false&#xA;  s.scan(/st\n/)&#xA;  s.bol?           # =&gt; true&#xA;  s.terminate&#xA;  s.bol?           # =&gt; true" />
        <scope name="bol?" ilk="function" />
        <scope name="check" ilk="function" signature="check(p1)" doc="This returns the value that #scan would return, without advancing the scan pointer.  The match register is affected, though. &#xA;   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;  s.check /Fri/               # -&gt; &quot;Fri&quot;&#xA;  s.pos                       # -&gt; 0&#xA;  s.matched                   # -&gt; &quot;Fri&quot;&#xA;  s.check /12/                # -&gt; nil&#xA;  s.matched                   # -&gt; nil&#xA; Mnemonic: it &quot;checks&quot; to see whether a #scan will return a value." />
        <scope name="check_until" ilk="function" signature="check_until(p1)" doc="This returns the value that #scan_until would return, without advancing the scan pointer.  The match register is affected, though. &#xA;   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;  s.check_until /12/          # -&gt; &quot;Fri Dec 12&quot;&#xA;  s.pos                       # -&gt; 0&#xA;  s.matched                   # -&gt; 12&#xA; Mnemonic: it &quot;checks&quot; to see whether a #scan_until will return a value." />
        <scope name="clear" ilk="function" signature="clear()" doc="Equivalent to #terminate. This method is obsolete; use #terminate instead." />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Appends +str+ to the string being scanned. This method does not affect scan pointer. &#xA;   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;  s.scan(/Fri /)&#xA;  s &lt;&lt; &quot; +1000 GMT&quot;&#xA;  s.string            # -&gt; &quot;Fri Dec 12 1975 14:39 +1000 GMT&quot;&#xA;  s.scan(/Dec/)       # -&gt; &quot;Dec&quot;" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Equivalent to #eos?. This method is obsolete, use #eos? instead." />
        <scope name="eos?" ilk="function" signature="eos?()" doc="Returns +true+ if the scan pointer is at the end of the string. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  p s.eos?          # =&gt; false&#xA;  s.scan(/test/)&#xA;  p s.eos?          # =&gt; false&#xA;  s.terminate&#xA;  p s.eos?          # =&gt; true" />
        <scope name="exist?" ilk="function" signature="exist?(p1)" doc="Looks _ahead_ to see if the +pattern+ exists _anywhere_ in the string, without advancing the scan pointer.  This predicates whether a #scan_until will return a value. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.exist? /s/            # -&gt; 3&#xA;  s.scan /test/           # -&gt; &quot;test&quot;&#xA;  s.exist? /s/            # -&gt; 2&#xA;  s.exist? /e/            # -&gt; nil" />
        <scope name="get_byte" ilk="function" signature="get_byte()" doc="Scans one byte and returns it. This method is not multibyte character sensitive. See also: #getch. &#xA;   s = StringScanner.new(&apos;ab&apos;)&#xA;  s.get_byte         # =&gt; &quot;a&quot;&#xA;  s.get_byte         # =&gt; &quot;b&quot;&#xA;  s.get_byte         # =&gt; nil&#xA;&#xA;  $KCODE = &apos;EUC&apos;&#xA;  s = StringScanner.new(&quot;\244\242&quot;)&#xA;  s.get_byte         # =&gt; &quot;\244&quot;&#xA;  s.get_byte         # =&gt; &quot;\242&quot;&#xA;  s.get_byte         # =&gt; nil" />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="Equivalent to #get_byte. This method is obsolete; use #get_byte instead." />
        <scope name="getch" ilk="function" signature="getch()" doc="Scans one character and returns it. This method is multibyte character sensitive. &#xA;   s = StringScanner.new(&quot;ab&quot;)&#xA;  s.getch           # =&gt; &quot;a&quot;&#xA;  s.getch           # =&gt; &quot;b&quot;&#xA;  s.getch           # =&gt; nil&#xA;&#xA;  $KCODE = &apos;EUC&apos;&#xA;  s = StringScanner.new(&quot;\244\242&quot;)&#xA;  s.getch           # =&gt; &quot;\244\242&quot;   # Japanese hira-kana &quot;A&quot; in EUC-JP&#xA;  s.getch           # =&gt; nil" />
        <scope name="match?" ilk="function" signature="match?(p1)" doc="Tests whether the given +pattern+ is matched from the current scan pointer. Returns the length of the match, or +nil+.  The scan pointer is not advanced. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  p s.match?(/\w+/)   # -&gt; 4&#xA;  p s.match?(/\w+/)   # -&gt; 4&#xA;  p s.match?(/\s+/)   # -&gt; nil" />
        <scope name="matched" ilk="function" signature="matched()" doc="Returns the last matched string. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.match?(/\w+/)     # -&gt; 4&#xA;  s.matched           # -&gt; &quot;test&quot;" />
        <scope name="matched?" ilk="function" signature="matched?()" doc="Returns +true+ iff the last match was successful. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.match?(/\w+/)     # =&gt; 4&#xA;  s.matched?          # =&gt; true&#xA;  s.match?(/\d+/)     # =&gt; nil&#xA;  s.matched?          # =&gt; false" />
        <scope name="matched_size" ilk="function" signature="matched_size()" doc="Returns the size of the most recent match (see #matched), or +nil+ if there was no recent match. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.check /\w+/           # -&gt; &quot;test&quot;&#xA;  s.matched_size          # -&gt; 4&#xA;  s.check /\d+/           # -&gt; nil&#xA;  s.matched_size          # -&gt; nil" />
        <scope name="peek" ilk="function" signature="peek(p1)" doc="Extracts a string corresponding to string[pos,len], without advancing the scan pointer. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.peek(7)          # =&gt; &quot;test st&quot;&#xA;  s.peek(7)          # =&gt; &quot;test st&quot;" />
        <scope name="peep" ilk="function" signature="peep(p1)" doc="Equivalent to #peek. This method is obsolete; use #peek instead." />
        <scope name="pointer" ilk="function" signature="pointer()" doc="Returns the byte position of the scan pointer.  In the &apos;reset&apos; position, this value is zero.  In the &apos;terminated&apos; position (i.e. the string is exhausted), this value is the bytesize of the string. &#xA; In short, it&apos;s a 0-based index into the string. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.pos               # -&gt; 0&#xA;  s.scan_until /str/  # -&gt; &quot;test str&quot;&#xA;  s.pos               # -&gt; 8&#xA;  s.terminate         # -&gt; #&lt;StringScanner fin&gt;&#xA;  s.pos               # -&gt; 11" />
        <scope name="pointer=" ilk="function" signature="pointer=(p1)" doc="Set the byte position of the scan pointer. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.pos = 7            # -&gt; 7&#xA;  s.rest               # -&gt; &quot;ring&quot;" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the byte position of the scan pointer.  In the &apos;reset&apos; position, this value is zero.  In the &apos;terminated&apos; position (i.e. the string is exhausted), this value is the bytesize of the string. &#xA; In short, it&apos;s a 0-based index into the string. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.pos               # -&gt; 0&#xA;  s.scan_until /str/  # -&gt; &quot;test str&quot;&#xA;  s.pos               # -&gt; 8&#xA;  s.terminate         # -&gt; #&lt;StringScanner fin&gt;&#xA;  s.pos               # -&gt; 11" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Set the byte position of the scan pointer. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.pos = 7            # -&gt; 7&#xA;  s.rest               # -&gt; &quot;ring&quot;" />
        <scope name="post_match" ilk="function" signature="post_match()" doc="Return the &lt;b&gt;post&lt;/b&gt;-match (in the regular expression sense) of the last scan. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.scan(/\w+/)           # -&gt; &quot;test&quot;&#xA;  s.scan(/\s+/)           # -&gt; &quot; &quot;&#xA;  s.pre_match             # -&gt; &quot;test&quot;&#xA;  s.post_match            # -&gt; &quot;string&quot;" />
        <scope name="pre_match" ilk="function" signature="pre_match()" doc="Return the &lt;b&gt;pre&lt;/b&gt;-match (in the regular expression sense) of the last scan. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.scan(/\w+/)           # -&gt; &quot;test&quot;&#xA;  s.scan(/\s+/)           # -&gt; &quot; &quot;&#xA;  s.pre_match             # -&gt; &quot;test&quot;&#xA;  s.post_match            # -&gt; &quot;string&quot;" />
        <scope name="reset" ilk="function" signature="reset()" doc="Reset the scan pointer (index 0) and clear matching data." />
        <scope name="rest" ilk="function" signature="rest()" doc="Returns the &quot;rest&quot; of the string (i.e. everything after the scan pointer). If there is no more data (eos? = true), it returns &quot;&quot;." />
        <scope name="rest?" ilk="function" signature="rest?()" doc="Returns true iff there is more data in the string.  See #eos?. This method is obsolete; use #eos? instead. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.eos?              # These two&#xA;  s.rest?             # are opposites." />
        <scope name="rest_size" ilk="function" signature="rest_size()" doc="s.rest_size is equivalent to s.rest.size." />
        <scope name="restsize" ilk="function" signature="restsize()" doc="s.restsize is equivalent to s.rest_size. This method is obsolete; use #rest_size instead." />
        <scope name="scan" ilk="function" signature="scan(p1)" doc="Tries to match with +pattern+ at the current position. If there&apos;s a match, the scanner advances the &quot;scan pointer&quot; and returns the matched string. Otherwise, the scanner returns +nil+. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  p s.scan(/\w+/)   # -&gt; &quot;test&quot;&#xA;  p s.scan(/\w+/)   # -&gt; nil&#xA;  p s.scan(/\s+/)   # -&gt; &quot; &quot;&#xA;  p s.scan(/\w+/)   # -&gt; &quot;string&quot;&#xA;  p s.scan(/./)     # -&gt; nil" />
        <scope name="scan_full" ilk="function" signature="scan_full(p1, p2, p3)" doc="Tests whether the given +pattern+ is matched from the current scan pointer. Advances the scan pointer if +advance_pointer_p+ is true. Returns the matched string if +return_string_p+ is true. The match register is affected. &#xA; &quot;full&quot; means &quot;#scan with full parameters&quot;." />
        <scope name="scan_until" ilk="function" signature="scan_until(p1)" doc="Scans the string _until_ the +pattern+ is matched.  Returns the substring up to and including the end of the match, advancing the scan pointer to that location. If there is no match, +nil+ is returned. &#xA;   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;  s.scan_until(/1/)        # -&gt; &quot;Fri Dec 1&quot;&#xA;  s.pre_match              # -&gt; &quot;Fri Dec &quot;&#xA;  s.scan_until(/XYZ/)      # -&gt; nil" />
        <scope name="search_full" ilk="function" signature="search_full(p1, p2, p3)" doc="Scans the string _until_ the +pattern+ is matched. Advances the scan pointer if +advance_pointer_p+, otherwise not. Returns the matched string if +return_string_p+ is true, otherwise returns the number of bytes advanced. This method does affect the match register." />
        <scope name="skip" ilk="function" signature="skip(p1)" doc="Attempts to skip over the given +pattern+ beginning with the scan pointer. If it matches, the scan pointer is advanced to the end of the match, and the length of the match is returned.  Otherwise, +nil+ is returned. &#xA; It&apos;s similar to #scan, but without returning the matched string. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  p s.skip(/\w+/)   # -&gt; 4&#xA;  p s.skip(/\w+/)   # -&gt; nil&#xA;  p s.skip(/\s+/)   # -&gt; 1&#xA;  p s.skip(/\w+/)   # -&gt; 6&#xA;  p s.skip(/./)     # -&gt; nil" />
        <scope name="skip_until" ilk="function" signature="skip_until(p1)" doc="Advances the scan pointer until +pattern+ is matched and consumed.  Returns the number of bytes advanced, or +nil+ if no match was found. &#xA; Look ahead to match +pattern+, and advance the scan pointer to the _end_ of the match.  Return the number of characters advanced, or +nil+ if the match was unsuccessful. &#xA; It&apos;s similar to #scan_until, but without returning the intervening string. &#xA;   s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;  s.skip_until /12/           # -&gt; 10&#xA;  s                           #" />
        <scope name="string" ilk="function" signature="string()" doc="Returns the string being scanned." />
        <scope name="string=" ilk="function" signature="string=(p1)" doc="Changes the string being scanned to +str+ and resets the scanner. Returns +str+." />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Set the scan pointer to the end of the string and clear matching data." />
        <scope name="unscan" ilk="function" signature="unscan()" doc="Set the scan pointer to the previous position.  Only one previous position is remembered, and it changes with each scanning operation. &#xA;   s = StringScanner.new(&apos;test string&apos;)&#xA;  s.scan(/\w+/)        # =&gt; &quot;test&quot;&#xA;  s.unscan&#xA;  s.scan(/../)         # =&gt; &quot;te&quot;&#xA;  s.scan(/\d/)         # =&gt; nil&#xA;  s.unscan             # ScanError: unscan failed: previous match record not exist" />
        <scope name="must_C_version" ilk="function" attributes="__classmethod__" signature="must_C_version()" doc="This method is defined for backward compatibility." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates a new StringScanner object to scan over the given +string+. +dup+ argument is obsolete and not used now." />
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="Id" attributes="__const__" citdl="String" />
        <variable name="Version" attributes="__const__" citdl="String" />
      </scope>
      <scope name="ScanError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ConditionVariable" ilk="class" classrefs="Object" >
        <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
        <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
        <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
      </scope>
      <scope name="Queue" ilk="class" classrefs="Object" >
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all objects from the queue." />
        <scope name="deq" ilk="function" signature="deq(non_block=false)" doc="Alias of pop" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if the queue is empty." />
        <scope name="enq" ilk="function" signature="enq(obj)" doc="Alias of push" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the length of the queue." />
        <scope name="num_waiting" ilk="function" signature="num_waiting()" doc="Returns the number of threads waiting on the queue." />
        <scope name="pop" ilk="function" signature="pop(non_block=false)" doc="Retrieves data from the queue.  If the queue is empty, the calling thread is suspended until data is pushed onto the queue.  If +non_block+ is true, the thread isn&apos;t suspended, and an exception is raised." />
        <scope name="push" ilk="function" signature="push(obj)" doc="Pushes +obj+ to the queue." />
        <scope name="shift" ilk="function" signature="shift(non_block=false)" doc="Alias of pop" />
        <scope name="size" ilk="function" signature="size()" doc="Alias of length." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new queue." />
      </scope>
      <scope name="SizedQueue" ilk="class" classrefs="Queue" >
        <scope name="max" ilk="function" signature="max()" doc="Returns the maximum size of the queue." />
        <scope name="max=" ilk="function" signature="max=(max)" doc="Sets the maximum size of the queue." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(max)" doc="Creates a fixed-length queue with a maximum size of +max+." />
      </scope>
      <scope name="RbConfig" ilk="namespace" >
        <scope name="datadir" ilk="function" />
        <scope name="expand" ilk="function" />
        <scope name="ruby" ilk="function" />
        <variable name="CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="DESTDIR" attributes="__const__" citdl="String" />
        <variable name="MAKEFILE_CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="TOPDIR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Config" ilk="namespace" >
        <scope name="datadir" ilk="function" />
        <scope name="expand" ilk="function" />
        <scope name="ruby" ilk="function" />
        <variable name="CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="DESTDIR" attributes="__const__" citdl="String" />
        <variable name="MAKEFILE_CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="TOPDIR" attributes="__const__" citdl="String" />
      </scope>
      <variable name="CROSS_COMPILING" attributes="__const__" citdl="NilClass" />
      <scope name="Date" ilk="class" classrefs="Object" >
        <scope name="ajd" ilk="function" signature="ajd()" doc="Get the date as an Astronomical Julian Day Number." />
        <scope name="amjd" ilk="function" signature="amjd()" doc="Get the date as an Astronomical Modified Julian Day Number." />
        <scope name="asctime" ilk="function" signature="asctime()" doc="alias_method :format, :strftime" />
        <scope name="ctime" ilk="function" signature="ctime()" />
        <scope name="cwday" ilk="function" signature="cwday()" doc="Get the commercial day of the week of this date.  Monday is commercial day-of-week 1; Sunday is commercial day-of-week 7." />
        <scope name="cweek" ilk="function" signature="cweek()" doc="Get the commercial week of the year of this date." />
        <scope name="cwyear" ilk="function" signature="cwyear()" doc="Get the commercial year of this date.  See *Commercial* *Date* in the introduction for how this differs from the normal year." />
        <scope name="day" ilk="function" signature="day()" />
        <scope name="day_fraction" ilk="function" signature="day_fraction()" doc="Get any fractional day part of the date." />
        <scope name="downto" ilk="function" signature="downto(min)" doc="Step backward one day at a time until we reach +min+ (inclusive), yielding each date as we go." />
        <scope name="england" ilk="function" signature="england()" doc="Create a copy of this Date object that uses the English/Colonial Day of Calendar Reform." />
        <scope name="friday?" ilk="function" />
        <scope name="gregorian" ilk="function" signature="gregorian()" doc="Create a copy of this Date object that always uses the Gregorian Calendar." />
        <scope name="gregorian?" ilk="function" signature="gregorian?()" doc="Is the current date new-style (Gregorian Calendar)?" />
        <scope name="httpdate" ilk="function" signature="httpdate()" />
        <scope name="iso8601" ilk="function" signature="iso8601()" />
        <scope name="italy" ilk="function" signature="italy()" doc="Create a copy of this Date object that uses the Italian/Catholic Day of Calendar Reform." />
        <scope name="jd" ilk="function" signature="jd()" doc="Get the date as a Julian Day Number." />
        <scope name="jisx0301" ilk="function" signature="jisx0301()" />
        <scope name="julian" ilk="function" signature="julian()" doc="Create a copy of this Date object that always uses the Julian Calendar." />
        <scope name="julian?" ilk="function" signature="julian?()" doc="Is the current date old-style (Julian Calendar)?" />
        <scope name="ld" ilk="function" signature="ld()" doc="Get the date as the number of days since the Day of Calendar Reform (in Italy and the Catholic countries)." />
        <scope name="leap?" ilk="function" signature="leap?()" doc="Is this a leap year?" />
        <scope name="marshal_dump" ilk="function" signature="marshal_dump()" />
        <scope name="marshal_load" ilk="function" signature="marshal_load(a)" />
        <scope name="mday" ilk="function" signature="mday()" doc="Get the day-of-the-month of this date." />
        <scope name="mjd" ilk="function" signature="mjd()" doc="Get the date as a Modified Julian Day Number." />
        <scope name="mon" ilk="function" signature="mon()" doc="Get the month of this date. &#xA; January is month 1." />
        <scope name="monday?" ilk="function" />
        <scope name="month" ilk="function" signature="month()" />
        <scope name="new_start" ilk="function" signature="new_start(sg=self.class::ITALY)" doc="Create a copy of this Date object using a new Day of Calendar Reform." />
        <scope name="next" ilk="function" signature="next()" doc="Return a new Date one day after this one." />
        <scope name="next_day" ilk="function" signature="next_day(n=1)" />
        <scope name="next_month" ilk="function" signature="next_month(n=1)" />
        <scope name="next_year" ilk="function" signature="next_year(n=1)" />
        <scope name="prev_day" ilk="function" signature="prev_day(n=1)" />
        <scope name="prev_month" ilk="function" signature="prev_month(n=1)" />
        <scope name="prev_year" ilk="function" signature="prev_year(n=1)" />
        <scope name="rfc2822" ilk="function" signature="rfc2822()" />
        <scope name="rfc3339" ilk="function" signature="rfc3339()" />
        <scope name="rfc822" ilk="function" signature="rfc822()" />
        <scope name="saturday?" ilk="function" />
        <scope name="start" ilk="function" signature="start()" doc="When is the Day of Calendar Reform for this Date object?" />
        <scope name="step" ilk="function" signature="step(limit, step=1)" doc="Step the current date forward +step+ days at a time (or backward, if +step+ is negative) until we reach +limit+ (inclusive), yielding the resultant date at each step." />
        <scope name="strftime" ilk="function" signature="strftime(fmt=&apos;%F&apos;)" />
        <scope name="succ" ilk="function" signature="succ()" />
        <scope name="sunday?" ilk="function" />
        <scope name="thursday?" ilk="function" />
        <scope name="to_date" ilk="function" signature="to_date()" />
        <scope name="to_datetime" ilk="function" signature="to_datetime()" />
        <scope name="to_time" ilk="function" signature="to_time()" />
        <scope name="tuesday?" ilk="function" />
        <scope name="upto" ilk="function" signature="upto(max)" doc="Step forward one day at a time until we reach +max+ (inclusive), yielding each date as we go." />
        <scope name="wday" ilk="function" signature="wday()" doc="Get the week day of this date.  Sunday is day-of-week 0; Saturday is day-of-week 6." />
        <scope name="wednesday?" ilk="function" />
        <scope name="xmlschema" ilk="function" signature="xmlschema()" />
        <scope name="yday" ilk="function" signature="yday()" doc="Get the day-of-the-year of this date. &#xA; January 1 is day-of-the-year 1" />
        <scope name="year" ilk="function" signature="year()" doc="Get the year of this date." />
        <scope name="_httpdate" ilk="function" attributes="__classmethod__" />
        <scope name="_iso8601" ilk="function" attributes="__classmethod__" />
        <scope name="_jisx0301" ilk="function" attributes="__classmethod__" />
        <scope name="_parse" ilk="function" attributes="__classmethod__" signature="_parse(str, comp=true)" />
        <scope name="_rfc2822" ilk="function" attributes="__classmethod__" />
        <scope name="_rfc3339" ilk="function" attributes="__classmethod__" />
        <scope name="_rfc822" ilk="function" attributes="__classmethod__" />
        <scope name="_strptime" ilk="function" attributes="__classmethod__" signature="_strptime(str, fmt=&apos;%F&apos;)" />
        <scope name="_xmlschema" ilk="function" attributes="__classmethod__" />
        <scope name="civil" ilk="function" attributes="__classmethod__" signature="civil(y=-4712, m=1, d=1, sg=ITALY)" doc="Create a new Date object for the Civil Date specified by year +y+, month +m+, and day-of-month +d+. &#xA; +m+ and +d+ can be negative, in which case they count backwards from the end of the year and the end of the month respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. can be negative &#xA; +y+ defaults to -4712, +m+ to 1, and +d+ to 1; this is Julian Day Number day 0. &#xA; +sg+ specifies the Day of Calendar Reform." />
        <scope name="commercial" ilk="function" attributes="__classmethod__" signature="commercial(y=-4712, w=1, d=1, sg=ITALY)" doc="Create a new Date object for the Commercial Date specified by year +y+, week-of-year +w+, and day-of-week +d+. &#xA; Monday is day-of-week 1; Sunday is day-of-week 7. &#xA; +w+ and +d+ can be negative, in which case they count backwards from the end of the year and the end of the week respectively.  No wraparound is performed, however, and invalid values cause an ArgumentError to be raised. &#xA; +y+ defaults to -4712, +w+ to 1, and +d+ to 1; this is Julian Day Number day 0. &#xA; +sg+ specifies the Day of Calendar Reform." />
        <scope name="gregorian_leap?" ilk="function" attributes="__classmethod__" signature="gregorian_leap?(y)" doc="Is a year a leap year in the Gregorian calendar? &#xA; All years divisible by 4 are leap years in the Gregorian calendar, except for years divisible by 100 and not by 400." />
        <scope name="httpdate" ilk="function" attributes="__classmethod__" />
        <scope name="iso8601" ilk="function" attributes="__classmethod__" />
        <scope name="jd" ilk="function" attributes="__classmethod__" signature="jd(jd=0, sg=ITALY)" doc="Create a new Date object from a Julian Day Number. &#xA; +jd+ is the Julian Day Number; if not specified, it defaults to 0. +sg+ specifies the Day of Calendar Reform." />
        <scope name="jisx0301" ilk="function" attributes="__classmethod__" />
        <scope name="julian_leap?" ilk="function" attributes="__classmethod__" signature="julian_leap?(y)" doc="Is a year a leap year in the Julian calendar? &#xA; All years divisible by 4 are leap years in the Julian calendar." />
        <scope name="leap?" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(ajd=0, of=0, sg=ITALY)" doc="*NOTE* this is the documentation for the method new!().  If you are reading this as the documentation for new(), that is because rdoc doesn&apos;t fully support the aliasing of the initialize() method. new() is in fact an alias for #civil(): read the documentation for that method instead. &#xA; Create a new Date object. &#xA; +ajd+ is the Astronomical Julian Day Number. +of+ is the offset from UTC as a fraction of a day. Both default to 0. &#xA; +sg+ specifies the Day of Calendar Reform to use for this Date object. &#xA; Using one of the factory methods such as Date::civil is generally easier and safer." />
        <scope name="new!" ilk="function" attributes="__classmethod__" />
        <scope name="ordinal" ilk="function" attributes="__classmethod__" signature="ordinal(y=-4712, d=1, sg=ITALY)" doc="Create a new Date object from an Ordinal Date, specified by year +y+ and day-of-year +d+. +d+ can be negative, in which it counts backwards from the end of the year. No year wraparound is performed, however.  An invalid value for +d+ results in an ArgumentError being raised. &#xA; +y+ defaults to -4712, and +d+ to 1; this is Julian Day Number day 0. &#xA; +sg+ specifies the Day of Calendar Reform." />
        <scope name="parse" ilk="function" attributes="__classmethod__" signature="parse(str=&apos;-4712-01-01&apos;, comp=true, sg=ITALY)" doc="Create a new Date object by parsing from a String, without specifying the format. &#xA; +str+ is a String holding a date representation. +comp+ specifies whether to interpret 2-digit years as 19XX (&gt;= 69) or 20XX (&lt; 69); the default is not to. The method will attempt to parse a date from the String using various heuristics; see #_parse in date/format.rb for more details.  If parsing fails, an ArgumentError will be raised. &#xA; The default +str+ is &apos;-4712-01-01&apos;; this is Julian Day Number day 0. &#xA; +sg+ specifies the Day of Calendar Reform." />
        <scope name="rfc2822" ilk="function" attributes="__classmethod__" />
        <scope name="rfc3339" ilk="function" attributes="__classmethod__" />
        <scope name="rfc822" ilk="function" attributes="__classmethod__" />
        <scope name="strptime" ilk="function" attributes="__classmethod__" signature="strptime(str=&apos;-4712-01-01&apos;, fmt=&apos;%F&apos;, sg=ITALY)" doc="Create a new Date object by parsing from a String according to a specified format. &#xA; +str+ is a String holding a date representation. +fmt+ is the format that the date is in.  See date/format.rb for details on supported formats. &#xA; The default +str+ is &apos;-4712-01-01&apos;, and the default +fmt+ is &apos;%F&apos;, which means Year-Month-Day_of_Month. This gives Julian Day Number day 0. &#xA; +sg+ specifies the Day of Calendar Reform. &#xA; An ArgumentError will be raised if +str+ cannot be parsed." />
        <scope name="today" ilk="function" attributes="__classmethod__" signature="today(sg=ITALY)" doc="Create a new Date object representing today. &#xA; +sg+ specifies the Day of Calendar Reform." />
        <scope name="valid_civil?" ilk="function" attributes="__classmethod__" signature="valid_civil?(y, m, d, sg=ITALY)" />
        <scope name="valid_commercial?" ilk="function" attributes="__classmethod__" signature="valid_commercial?(y, w, d, sg=ITALY)" />
        <scope name="valid_date?" ilk="function" attributes="__classmethod__" />
        <scope name="valid_jd?" ilk="function" attributes="__classmethod__" signature="valid_jd?(jd, sg=ITALY)" />
        <scope name="valid_ordinal?" ilk="function" attributes="__classmethod__" signature="valid_ordinal?(y, d, sg=ITALY)" />
        <scope name="xmlschema" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(ajd=0, of=0, sg=ITALY)" doc="*NOTE* this is the documentation for the method new!().  If you are reading this as the documentation for new(), that is because rdoc doesn&apos;t fully support the aliasing of the initialize() method. new() is in fact an alias for #civil(): read the documentation for that method instead. &#xA; Create a new Date object. &#xA; +ajd+ is the Astronomical Julian Day Number. +of+ is the offset from UTC as a fraction of a day. Both default to 0. &#xA; +sg+ specifies the Day of Calendar Reform to use for this Date object. &#xA; Using one of the factory methods such as Date::civil is generally easier and safer." />
        <variable name="ABBR_DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ABBR_MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ENGLAND" attributes="__const__" citdl="Fixnum" />
        <scope name="Format" ilk="namespace" >
          <variable name="ABBR_DAYS" attributes="__const__" citdl="Hash" />
          <variable name="ABBR_MONTHS" attributes="__const__" citdl="Hash" />
          <scope name="Bag" ilk="class" classrefs="Object" >
            <scope name="method_missing" ilk="function" />
            <scope name="to_hash" ilk="function" />
          </scope>
          <variable name="DAYS" attributes="__const__" citdl="Hash" />
          <variable name="MONTHS" attributes="__const__" citdl="Hash" />
          <variable name="ZONES" attributes="__const__" citdl="Hash" />
        </scope>
        <variable name="GREGORIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="HALF_DAYS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="HOURS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="ITALY" attributes="__const__" citdl="Fixnum" />
        <scope name="Infinity" ilk="class" classrefs="Numeric" >
          <import symbol="Comparable" />
          <scope name="d" ilk="function" />
          <scope name="finite?" ilk="function" />
          <scope name="infinite?" ilk="function" />
          <scope name="nan?" ilk="function" />
        </scope>
        <variable name="JULIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="LD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MILLISECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MILLISECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="MINUTES_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="NANOSECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="NANOSECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="SECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Syck" ilk="namespace" >
        <scope name="add_builtin_type" ilk="function" />
        <scope name="add_domain_type" ilk="function" />
        <scope name="add_private_type" ilk="function" />
        <scope name="add_ruby_type" ilk="function" />
        <scope name="compile" ilk="function" />
        <scope name="detect_implicit" ilk="function" />
        <scope name="dump" ilk="function" />
        <scope name="dump_stream" ilk="function" />
        <scope name="each_document" ilk="function" />
        <scope name="each_node" ilk="function" />
        <scope name="emitter" ilk="function" />
        <scope name="generic_parser" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="load_documents" ilk="function" />
        <scope name="load_file" ilk="function" />
        <scope name="load_stream" ilk="function" />
        <scope name="object_maker" ilk="function" />
        <scope name="parse" ilk="function" />
        <scope name="parse_documents" ilk="function" />
        <scope name="parse_file" ilk="function" />
        <scope name="parser" ilk="function" />
        <scope name="quick_emit" ilk="function" />
        <scope name="read_type_class" ilk="function" />
        <scope name="resolver" ilk="function" />
        <scope name="tag_class" ilk="function" />
        <scope name="tagged_classes" ilk="function" />
        <scope name="tagurize" ilk="function" />
        <scope name="transfer" ilk="function" />
        <scope name="try_implicit" ilk="function" />
        <scope name="BadAlias" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
        </scope>
        <scope name="BaseNode" ilk="namespace" >
          <scope name="at" ilk="function" />
          <scope name="children" ilk="function" />
          <scope name="children_with_index" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="match_path" ilk="function" />
          <scope name="match_segment" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="select" ilk="function" />
          <scope name="select!" ilk="function" />
        </scope>
        <variable name="DEFAULTS" attributes="__const__" citdl="Hash" />
        <variable name="DNS_COMP_RE" attributes="__const__" citdl="String" />
        <variable name="DNS_NAME_RE" attributes="__const__" citdl="String" />
        <scope name="DefaultKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="DefaultResolver" attributes="__const__" citdl="Syck::Resolver" />
        <scope name="DomainType" ilk="class" classrefs="Object" >
          <scope name="domain" ilk="function" />
          <scope name="domain=" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
        <variable name="ERROR_ANCHOR_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_IMPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_NEED_HEADER" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_HEADER_NODE" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_ENCODING" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_VERSION" attributes="__const__" citdl="String" />
        <variable name="ERROR_ZERO_INDENT" attributes="__const__" citdl="String" />
        <variable name="ESCAPES" attributes="__const__" citdl="Array" />
        <variable name="ESCAPE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Emitter" ilk="class" classrefs="Object" >
          <scope name="emit" ilk="function" />
          <scope name="level" ilk="function" />
          <scope name="level=" ilk="function" />
          <scope name="node_export" ilk="function" />
          <scope name="reset" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="GenericResolver" attributes="__const__" citdl="Syck::Resolver" />
        <variable name="INDICATOR_CHAR" attributes="__const__" citdl="String" />
        <scope name="Map" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="MergeKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="NOT_PLAIN_CHAR" attributes="__const__" citdl="String" />
        <scope name="Node" ilk="class" classrefs="Object" >
          <import symbol="Syck::BaseNode" />
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="kind" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="transform" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
        </scope>
        <scope name="Object" ilk="class" >
          <scope name="class=" ilk="function" />
          <scope name="ivars" ilk="function" />
          <scope name="ivars=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Omap" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="Out" ilk="class" classrefs="Object" >
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="map" ilk="function" />
          <scope name="scalar" ilk="function" />
          <scope name="seq" ilk="function" />
        </scope>
        <variable name="PRINTABLE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Pairs" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="ParseError" ilk="class" classrefs="Syck::Error" >
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object" >
          <scope name="bufsize" ilk="function" />
          <scope name="bufsize=" ilk="function" />
          <scope name="input" ilk="function" />
          <scope name="input=" ilk="function" />
          <scope name="load" ilk="function" />
          <scope name="load_documents" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="PrivateType" ilk="class" classrefs="Object" >
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="RESTRICTED_INDICATORS" attributes="__const__" citdl="String" />
        <scope name="Resolver" ilk="class" classrefs="Object" >
          <scope name="add_type" ilk="function" />
          <scope name="detect_implicit" ilk="function" />
          <scope name="node_import" ilk="function" />
          <scope name="tags" ilk="function" />
          <scope name="tags=" ilk="function" />
          <scope name="tagurize" ilk="function" />
          <scope name="transfer" ilk="function" />
          <scope name="use_types_at" ilk="function" />
        </scope>
        <variable name="SPACE_INDICATORS" attributes="__const__" citdl="String" />
        <variable name="SUPPORTED_YAML_VERSIONS" attributes="__const__" citdl="Array" />
        <scope name="Scalar" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Seq" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Set" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(enum = nil)" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        </scope>
        <scope name="SpecialHash" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
        </scope>
        <scope name="Stream" ilk="class" classrefs="Object" >
          <scope name="add" ilk="function" />
          <scope name="documents" ilk="function" />
          <scope name="documents=" ilk="function" />
          <scope name="edit" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
        </scope>
        <scope name="TypeError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="UNESCAPES" attributes="__const__" citdl="Hash" />
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <variable name="WORD_CHAR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Psych" ilk="namespace" >
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
      </scope>
      <scope name="StringIO" ilk="class" classrefs="Data" >
        <import symbol="Enumerable" />
        <scope name="binmode" ilk="function" signature="binmode()" doc="Returns *strio* itself.  Just for compatibility to IO." />
        <scope name="bytes" ilk="function" signature="bytes()" doc="  strio.each_byte {|byte| block }  -&gt; strio&#xA;  strio.each_byte                  -&gt; anEnumerator&#xA; See IO#each_byte." />
        <scope name="chars" ilk="function" signature="chars()" doc="  strio.each_char {|char| block }  -&gt; strio&#xA;  strio.each_char                  -&gt; anEnumerator&#xA; See IO#each_char." />
        <scope name="close" ilk="function" signature="close()" doc="Closes strio.  The *strio* is unavailable for any further data operations; an +IOError+ is raised if such an attempt is made." />
        <scope name="close_read" ilk="function" signature="close_read()" doc="Closes the read end of a StringIO.  Will raise an +IOError+ if the *strio* is not readable." />
        <scope name="close_write" ilk="function" signature="close_write()" doc="Closes the write end of a StringIO.  Will raise an  +IOError+ if the *strio* is not writeable." />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns +true+ if *strio* is completely closed, +false+ otherwise." />
        <scope name="closed_read?" ilk="function" signature="closed_read?()" doc="Returns +true+ if *strio* is not readable, +false+ otherwise." />
        <scope name="closed_write?" ilk="function" signature="closed_write?()" doc="Returns +true+ if *strio* is not writable, +false+ otherwise." />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="  strio.each_codepoint {|c| block }  -&gt; strio&#xA;  strio.each_codepoint               -&gt; anEnumerator&#xA; See IO#each_codepoint." />
        <scope name="each" ilk="function" signature="each(...)" doc="  strio.each_line(sep=$/) {|line| block }    -&gt; strio&#xA;  strio.each_line(limit) {|line| block }     -&gt; strio&#xA;  strio.each_line(sep,limit) {|line| block } -&gt; strio&#xA;  strio.each_line(...)                       -&gt; anEnumerator&#xA;&#xA;  strio.lines(sep=$/) {|line| block }        -&gt; strio&#xA;  strio.lines(limit) {|line| block }         -&gt; strio&#xA;  strio.lines(sep,limit) {|line| block }     -&gt; strio&#xA;  strio.lines(...)                           -&gt; anEnumerator&#xA; See IO#each." />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="  strio.each_byte {|byte| block }  -&gt; strio&#xA;  strio.each_byte                  -&gt; anEnumerator&#xA; See IO#each_byte." />
        <scope name="each_char" ilk="function" signature="each_char()" doc="  strio.each_char {|char| block }  -&gt; strio&#xA;  strio.each_char                  -&gt; anEnumerator&#xA; See IO#each_char." />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="  strio.each_codepoint {|c| block }  -&gt; strio&#xA;  strio.each_codepoint               -&gt; anEnumerator&#xA; See IO#each_codepoint." />
        <scope name="each_line" ilk="function" signature="each_line(...)" doc="  strio.each_line(sep=$/) {|line| block }    -&gt; strio&#xA;  strio.each_line(limit) {|line| block }     -&gt; strio&#xA;  strio.each_line(sep,limit) {|line| block } -&gt; strio&#xA;  strio.each_line(...)                       -&gt; anEnumerator&#xA;&#xA;  strio.lines(sep=$/) {|line| block }        -&gt; strio&#xA;  strio.lines(limit) {|line| block }         -&gt; strio&#xA;  strio.lines(sep,limit) {|line| block }     -&gt; strio&#xA;  strio.lines(...)                           -&gt; anEnumerator&#xA; See IO#each." />
        <scope name="eof" ilk="function" signature="eof()" doc="Returns true if *strio* is at end of file. The stringio must be opened for reading or an +IOError+ will be raised." />
        <scope name="eof?" ilk="function" signature="eof?()" doc="Returns true if *strio* is at end of file. The stringio must be opened for reading or an +IOError+ will be raised." />
        <scope name="external_encoding" ilk="function" signature="external_encoding()" doc="Returns the Encoding object that represents the encoding of the file. If strio is write mode and no encoding is specified, returns nil." />
        <scope name="fcntl" ilk="function" signature="fcntl(...)" doc="Raises NotImplementedError." />
        <scope name="fileno" ilk="function" signature="fileno()" doc="Returns +nil+.  Just for compatibility to IO." />
        <scope name="flush" ilk="function" signature="flush()" doc="Returns *strio* itself.  Just for compatibility to IO." />
        <scope name="fsync" ilk="function" signature="fsync()" doc="Returns 0.  Just for compatibility to IO." />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="See IO#getbyte." />
        <scope name="getc" ilk="function" signature="getc()" doc="See IO#getc." />
        <scope name="gets" ilk="function" signature="gets(...)" doc="See IO#gets." />
        <scope name="internal_encoding" ilk="function" signature="internal_encoding()" doc="Returns the Encoding of the internal string if conversion is specified.  Otherwise returns nil." />
        <scope name="isatty" ilk="function" signature="isatty()" doc="  &#xA;   &#xA;   &#xA; Returns +false+.  Just for compatibility to IO." />
        <scope name="length" ilk="function" signature="length()" doc="Returns the size of the buffer string." />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Returns the current line number in *strio*. The stringio must be opened for reading. +lineno+ counts the number of times  +gets+ is called, rather than the number of newlines  encountered. The two values will differ if +gets+ is  called with a separator other than newline.  See also the  $. variable." />
        <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="Manually sets the current line number to the given value. $. is updated only on the next read." />
        <scope name="lines" ilk="function" signature="lines(...)" doc="  strio.each_line(sep=$/) {|line| block }    -&gt; strio&#xA;  strio.each_line(limit) {|line| block }     -&gt; strio&#xA;  strio.each_line(sep,limit) {|line| block } -&gt; strio&#xA;  strio.each_line(...)                       -&gt; anEnumerator&#xA;&#xA;  strio.lines(sep=$/) {|line| block }        -&gt; strio&#xA;  strio.lines(limit) {|line| block }         -&gt; strio&#xA;  strio.lines(sep,limit) {|line| block }     -&gt; strio&#xA;  strio.lines(...)                           -&gt; anEnumerator&#xA; See IO#each." />
        <scope name="pid" ilk="function" signature="pid()" doc="Returns +nil+.  Just for compatibility to IO." />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current offset (in bytes) of *strio*." />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Seeks to the given position (in bytes) in *strio*." />
        <scope name="print" ilk="function" signature="print(...)" doc="See IO#print." />
        <scope name="printf" ilk="function" signature="printf(...)" doc="See IO#printf." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc="See IO#putc." />
        <scope name="puts" ilk="function" signature="puts(...)" doc="See IO#puts." />
        <scope name="read" ilk="function" signature="read(...)" doc="See IO#read." />
        <scope name="read_nonblock" ilk="function" signature="read_nonblock(...)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="readbyte" ilk="function" signature="readbyte()" doc="See IO#readbyte." />
        <scope name="readchar" ilk="function" signature="readchar()" doc="See IO#readchar." />
        <scope name="readline" ilk="function" signature="readline(...)" doc="See IO#readline." />
        <scope name="readlines" ilk="function" signature="readlines(...)" doc="See IO#readlines." />
        <scope name="readpartial" ilk="function" signature="readpartial(...)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="reopen" ilk="function" signature="reopen(...)" doc="Reinitializes *strio* with the given other_StrIO or _string_ and _mode_ (see StringIO#new)." />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Positions *strio* to the beginning of input, resetting +lineno+ to zero." />
        <scope name="seek" ilk="function" signature="seek(...)" doc="Seeks to a given offset _amount_ in the stream according to the value of _whence_ (see IO#seek)." />
        <scope name="set_encoding" ilk="function" signature="set_encoding(p1)" doc="Tagged with the encoding specified." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of the buffer string." />
        <scope name="string" ilk="function" signature="string()" doc="Returns underlying String object, the subject of IO." />
        <scope name="string=" ilk="function" signature="string=(p1)" doc="Changes underlying String object, the subject of IO." />
        <scope name="sync" ilk="function" signature="sync()" doc="Returns +true+ always." />
        <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Returns the argument unchanged.  Just for compatibility to IO." />
        <scope name="sysread" ilk="function" signature="sysread(...)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="syswrite" ilk="function" signature="syswrite(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current offset (in bytes) of *strio*." />
        <scope name="truncate" ilk="function" signature="truncate(p1)" doc="Truncates the buffer string to at most _integer_ bytes. The *strio* must be opened for writing." />
        <scope name="tty?" ilk="function" signature="tty?()" doc="  &#xA;   &#xA;   &#xA; Returns +false+.  Just for compatibility to IO." />
        <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="See IO#ungetbyte" />
        <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="Pushes back one character (passed as a parameter) onto *strio* such that a subsequent buffered read will return it.  There is no limitation for multiple pushbacks including pushing back behind the beginning of the buffer string." />
        <scope name="write" ilk="function" signature="write(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="write_nonblock" ilk="function" signature="write_nonblock(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(...)" doc="Equivalent to StringIO.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(...)" doc="Creates new StringIO instance from with _string_ and _mode_." />
      </scope>
      <scope name="DateTime" ilk="class" classrefs="Date" >
        <scope name="hour" ilk="function" />
        <scope name="min" ilk="function" />
        <scope name="minute" ilk="function" />
        <scope name="new_offset" ilk="function" />
        <scope name="offset" ilk="function" />
        <scope name="sec" ilk="function" />
        <scope name="sec_fraction" ilk="function" />
        <scope name="second" ilk="function" />
        <scope name="second_fraction" ilk="function" />
        <scope name="zone" ilk="function" />
        <scope name="now" ilk="function" attributes="__classmethod__" />
        <variable name="ABBR_DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ABBR_MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ENGLAND" attributes="__const__" citdl="Fixnum" />
        <scope name="Format" ilk="namespace" >
          <variable name="ABBR_DAYS" attributes="__const__" citdl="Hash" />
          <variable name="ABBR_MONTHS" attributes="__const__" citdl="Hash" />
          <scope name="Bag" ilk="class" classrefs="Object" >
            <scope name="method_missing" ilk="function" />
            <scope name="to_hash" ilk="function" />
          </scope>
          <variable name="DAYS" attributes="__const__" citdl="Hash" />
          <variable name="MONTHS" attributes="__const__" citdl="Hash" />
          <variable name="ZONES" attributes="__const__" citdl="Hash" />
        </scope>
        <variable name="GREGORIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="HALF_DAYS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="HOURS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="ITALY" attributes="__const__" citdl="Fixnum" />
        <scope name="Infinity" ilk="class" classrefs="Numeric" >
          <import symbol="Comparable" />
          <scope name="d" ilk="function" />
          <scope name="finite?" ilk="function" />
          <scope name="infinite?" ilk="function" />
          <scope name="nan?" ilk="function" />
        </scope>
        <variable name="JULIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="LD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MILLISECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MILLISECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="MINUTES_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="NANOSECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="NANOSECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="SECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="YAML" ilk="namespace" >
        <scope name="add_builtin_type" ilk="function" />
        <scope name="add_domain_type" ilk="function" />
        <scope name="add_private_type" ilk="function" />
        <scope name="add_ruby_type" ilk="function" />
        <scope name="compile" ilk="function" />
        <scope name="detect_implicit" ilk="function" />
        <scope name="dump" ilk="function" />
        <scope name="dump_stream" ilk="function" />
        <scope name="each_document" ilk="function" />
        <scope name="each_node" ilk="function" />
        <scope name="emitter" ilk="function" />
        <scope name="generic_parser" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="load_documents" ilk="function" />
        <scope name="load_file" ilk="function" />
        <scope name="load_stream" ilk="function" />
        <scope name="object_maker" ilk="function" />
        <scope name="parse" ilk="function" />
        <scope name="parse_documents" ilk="function" />
        <scope name="parse_file" ilk="function" />
        <scope name="parser" ilk="function" />
        <scope name="quick_emit" ilk="function" />
        <scope name="read_type_class" ilk="function" />
        <scope name="resolver" ilk="function" />
        <scope name="tag_class" ilk="function" />
        <scope name="tagged_classes" ilk="function" />
        <scope name="tagurize" ilk="function" />
        <scope name="transfer" ilk="function" />
        <scope name="try_implicit" ilk="function" />
        <scope name="BadAlias" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
        </scope>
        <scope name="BaseNode" ilk="namespace" >
          <scope name="at" ilk="function" />
          <scope name="children" ilk="function" />
          <scope name="children_with_index" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="match_path" ilk="function" />
          <scope name="match_segment" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="select" ilk="function" />
          <scope name="select!" ilk="function" />
        </scope>
        <variable name="DEFAULTS" attributes="__const__" citdl="Hash" />
        <variable name="DNS_COMP_RE" attributes="__const__" citdl="String" />
        <variable name="DNS_NAME_RE" attributes="__const__" citdl="String" />
        <scope name="DefaultKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="DefaultResolver" attributes="__const__" citdl="Syck::Resolver" />
        <scope name="DomainType" ilk="class" classrefs="Object" >
          <scope name="domain" ilk="function" />
          <scope name="domain=" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
        <variable name="ERROR_ANCHOR_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_IMPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_NEED_HEADER" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_HEADER_NODE" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_ENCODING" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_VERSION" attributes="__const__" citdl="String" />
        <variable name="ERROR_ZERO_INDENT" attributes="__const__" citdl="String" />
        <variable name="ESCAPES" attributes="__const__" citdl="Array" />
        <variable name="ESCAPE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Emitter" ilk="class" classrefs="Object" >
          <scope name="emit" ilk="function" />
          <scope name="level" ilk="function" />
          <scope name="level=" ilk="function" />
          <scope name="node_export" ilk="function" />
          <scope name="reset" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="GenericResolver" attributes="__const__" citdl="Syck::Resolver" />
        <variable name="INDICATOR_CHAR" attributes="__const__" citdl="String" />
        <scope name="Map" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="MergeKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="NOT_PLAIN_CHAR" attributes="__const__" citdl="String" />
        <scope name="Node" ilk="class" classrefs="Object" >
          <import symbol="Syck::BaseNode" />
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="kind" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="transform" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
        </scope>
        <scope name="Object" ilk="class" >
          <scope name="class=" ilk="function" />
          <scope name="ivars" ilk="function" />
          <scope name="ivars=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Omap" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="Out" ilk="class" classrefs="Object" >
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="map" ilk="function" />
          <scope name="scalar" ilk="function" />
          <scope name="seq" ilk="function" />
        </scope>
        <variable name="PRINTABLE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Pairs" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="ParseError" ilk="class" classrefs="Syck::Error" >
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object" >
          <scope name="bufsize" ilk="function" />
          <scope name="bufsize=" ilk="function" />
          <scope name="input" ilk="function" />
          <scope name="input=" ilk="function" />
          <scope name="load" ilk="function" />
          <scope name="load_documents" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="PrivateType" ilk="class" classrefs="Object" >
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="RESTRICTED_INDICATORS" attributes="__const__" citdl="String" />
        <scope name="Resolver" ilk="class" classrefs="Object" >
          <scope name="add_type" ilk="function" />
          <scope name="detect_implicit" ilk="function" />
          <scope name="node_import" ilk="function" />
          <scope name="tags" ilk="function" />
          <scope name="tags=" ilk="function" />
          <scope name="tagurize" ilk="function" />
          <scope name="transfer" ilk="function" />
          <scope name="use_types_at" ilk="function" />
        </scope>
        <variable name="SPACE_INDICATORS" attributes="__const__" citdl="String" />
        <variable name="SUPPORTED_YAML_VERSIONS" attributes="__const__" citdl="Array" />
        <scope name="Scalar" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Seq" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Set" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(enum = nil)" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        </scope>
        <scope name="SpecialHash" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
        </scope>
        <scope name="Stream" ilk="class" classrefs="Object" >
          <scope name="add" ilk="function" />
          <scope name="documents" ilk="function" />
          <scope name="documents=" ilk="function" />
          <scope name="edit" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
        </scope>
        <scope name="TypeError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="UNESCAPES" attributes="__const__" citdl="Hash" />
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <variable name="WORD_CHAR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Monitor" ilk="class" classrefs="Object" >
        <import symbol="MonitorMixin" />
        <scope name="enter" ilk="function" />
        <scope name="exit" ilk="function" />
        <scope name="try_enter" ilk="function" />
        <scope name="ConditionVariable" ilk="class" classrefs="Object" >
          <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
          <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
          <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
          <scope name="wait_until" ilk="function" />
          <scope name="wait_while" ilk="function" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
          <scope name="Timeout" ilk="class" classrefs="Exception" >
          </scope>
        </scope>
      </scope>
      <scope name="MonitorMixin" ilk="namespace" >
        <scope name="extend_object" ilk="function" />
        <scope name="mon_enter" ilk="function" signature="mon_enter()" doc="Enters exclusive section." />
        <scope name="mon_exit" ilk="function" signature="mon_exit()" doc="Leaves exclusive section." />
        <scope name="mon_synchronize" ilk="function" signature="mon_synchronize()" doc="Enters exclusive section and executes the block.  Leaves the exclusive section automatically when the block exits.  See example under +MonitorMixin+." />
        <scope name="mon_try_enter" ilk="function" signature="mon_try_enter()" doc="Attempts to enter exclusive section.  Returns +false+ if lock fails." />
        <scope name="new_cond" ilk="function" signature="new_cond()" doc="Creates a new MonitorMixin::ConditionVariable associated with the receiver." />
        <scope name="synchronize" ilk="function" signature="synchronize()" />
        <scope name="try_mon_enter" ilk="function" signature="try_mon_enter()" doc="For backward compatibility" />
        <scope name="ConditionVariable" ilk="class" classrefs="Object" >
          <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
          <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
          <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
          <scope name="wait_until" ilk="function" />
          <scope name="wait_while" ilk="function" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
          <scope name="Timeout" ilk="class" classrefs="Exception" >
          </scope>
        </scope>
      </scope>
      <scope name="Array" ilk="function" signature="Array(p1)" doc="Returns arg as an Array. First tries to call arg.to_ary, then arg.to_a. &#xA;    Array(1..5)   =&gt; [1, 2, 3, 4, 5]" />
      <scope name="Complex" ilk="function" signature="Complex(...)" doc="Returns x+i*y;" />
      <scope name="Float" ilk="function" signature="Float(p1)" doc="Returns arg converted to a float. Numeric types are converted directly, the rest are converted using arg.to_f. As of Ruby 1.8, converting nil generates a TypeError. &#xA;    Float(1)           =&gt; 1.0&#xA;   Float(&quot;123.456&quot;)   =&gt; 123.456" />
      <scope name="Integer" ilk="function" signature="Integer(...)" doc="Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating point numbers being truncated).    base (0, or between 2 and 36) is a base for integer string representation.  If arg is a String, when base is omitted or equals to zero, radix indicators (0, 0b, and 0x) are honored. In any case, strings should be strictly conformed to numeric representation. This behavior is different from that of String#to_i.  Non string values will be converted using to_int, and to_i. &#xA;    Integer(123.999)    =&gt; 123&#xA;   Integer(&quot;0x1a&quot;)     =&gt; 26&#xA;   Integer(Time.new)   =&gt; 1204973019" />
      <scope name="Rational" ilk="function" signature="Rational(...)" doc="Returns x/y;" />
      <scope name="String" ilk="function" signature="String(p1)" doc="Converts arg to a String by calling its to_s method. &#xA;    String(self)        =&gt; &quot;main&quot;&#xA;   String(self.class)  =&gt; &quot;Object&quot;&#xA;   String(123456)      =&gt; &quot;123456&quot;" />
      <scope name="URI" ilk="function" signature="URI(uri_str)" doc="alias for URI.parse. &#xA; This method is introduced at 1.8.2." />
      <scope name="__callee__" ilk="function" signature="__callee__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
      <scope name="__method__" ilk="function" signature="__method__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
      <scope name="`" ilk="function" signature="`(p1)" doc="Returns the standard output of running _cmd_ in a subshell. The built-in syntax %x{...} uses this method. Sets $? to the process status. &#xA;    `date`                   =&gt; &quot;Wed Apr  9 08:56:30 CDT 2003\n&quot;&#xA;   `ls testdir`.split[1]    =&gt; &quot;main.rb&quot;&#xA;   `echo oops &amp;&amp; exit 99`   =&gt; &quot;oops\n&quot;&#xA;   $?.exitstatus            =&gt; 99" />
      <scope name="abort" ilk="function" signature="abort(...)" doc="Terminate execution immediately, effectively by calling Kernel.exit(false). If _msg_ is given, it is written to STDERR prior to terminating." />
      <scope name="at_exit" ilk="function" signature="at_exit()" doc="Converts _block_ to a +Proc+ object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration. &#xA;    def do_at_exit(str1)&#xA;     at_exit { print str1 }&#xA;   end&#xA;   at_exit { puts &quot;cruel world&quot; }&#xA;   do_at_exit(&quot;goodbye &quot;)&#xA;   exit&#xA; produces: &#xA;    goodbye cruel world" />
      <scope name="binding" ilk="function" signature="binding()" doc="Returns a +Binding+ object, describing the variable and method bindings at the point of call. This object can be used when calling +eval+ to execute the evaluated command in this environment. Also see the description of class +Binding+. &#xA;    def getBinding(param)&#xA;     return binding&#xA;   end&#xA;   b = getBinding(&quot;hello&quot;)&#xA;   eval(&quot;param&quot;, b)   =&gt; &quot;hello&quot;" />
      <scope name="block_given?" ilk="function" signature="block_given?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA;    def try&#xA;     if block_given?&#xA;       yield&#xA;     else&#xA;       &quot;no block&quot;&#xA;     end&#xA;   end&#xA;   try                  =&gt; &quot;no block&quot;&#xA;   try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;   try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
      <scope name="caller" ilk="function" signature="caller(...)" doc="Returns the current execution stack---an array containing strings in the form ``file:line&apos;&apos; or ``file:line: in `method&apos;&apos;&apos;. The optional _start_ parameter determines the number of initial stack entries to omit from the result. &#xA; Returns +nil+ if _start_ is greater than the size of current execution stack. &#xA;    def a(skip)&#xA;     caller(skip)&#xA;   end&#xA;   def b(skip)&#xA;     a(skip)&#xA;   end&#xA;   def c(skip)&#xA;     b(skip)&#xA;   end&#xA;   c(0)   =&gt; [&quot;prog:2:in `a&apos;&quot;, &quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:10:in `&lt;main&gt;&apos;&quot;]&#xA;   c(1)   =&gt; [&quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:11:in `&lt;main&gt;&apos;&quot;]" />
      <scope name="catch" ilk="function" signature="catch(...)" doc="+catch+ executes its block. If a +throw+ is executed, Ruby searches up its stack for a +catch+ block with a tag corresponding to the +throw+&apos;s _tag_. If found, that block is terminated, and +catch+ returns the value given to +throw+. If +throw+ is not called, the block terminates normally, and the value of +catch+ is the value of the last expression evaluated. +catch+ expressions may be nested, and the +throw+ call need not be in lexical scope. &#xA;    def routine(n)&#xA;     puts n&#xA;     throw :done if n &lt;= 0&#xA;     routine(n-1)&#xA;   end&#xA;   catch(:done) { routine(3) }&#xA; produces: &#xA;    3&#xA;   2&#xA;   1&#xA;   0&#xA; when _arg_ is given, +catch+ yields it as is, or when no _arg_ is given, +catch+ assigns a new unique object to +throw+.  this is useful for nested +catch+.  _arg_ can be an arbitrary object, not only Symbol." />
      <scope name="eval" ilk="function" signature="eval(...)" doc="Evaluates the Ruby expression(s) in string. If binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA;    def getBinding(str)&#xA;     return binding&#xA;   end&#xA;   str = &quot;hello&quot;&#xA;   eval &quot;str + &apos; Fred&apos;&quot;                      =&gt; &quot;hello Fred&quot;&#xA;   eval &quot;str + &apos; Fred&apos;&quot;, getBinding(&quot;bye&quot;)   =&gt; &quot;bye Fred&quot;" />
      <scope name="exec" ilk="function" signature="exec(...)" doc="Replaces the current process by running the given external _command_. _command..._ is one of following forms. &#xA;   commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; If single string is given as the command, it is taken as a command line that is subject to shell expansion before being executed. &#xA; The standard shell means always &quot;/bin/sh&quot; on Unix-like systems, ENV[&quot;RUBYSHELL&quot;] or ENV[&quot;COMSPEC&quot;] on Windows NT series, and similar. &#xA; If two or more +string+ given, the first is taken as a command name and the rest are passed as parameters to command with no shell expansion. &#xA; If a two-element array at the beginning of the command, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. &#xA; In order to execute the command, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors). This behavior is modified by env and options. See spawn for details. &#xA; Raises SystemCallError if the command couldn&apos;t execute (typically Errno::ENOENT when it was not found). &#xA;    exec &quot;echo *&quot;       # echoes list of files in current directory&#xA;   # never get here&#xA;   exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk" />
      <scope name="exit" ilk="function" signature="exit(...)" doc="Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment. +true+ and +FALSE+ of _status_ means success and failure respectively.  The interpretation of other integer values are system dependent. &#xA;    begin&#xA;     exit&#xA;     puts &quot;never get here&quot;&#xA;   rescue SystemExit&#xA;     puts &quot;rescued a SystemExit exception&quot;&#xA;   end&#xA;   puts &quot;after begin block&quot;&#xA; produces: &#xA;    rescued a SystemExit exception&#xA;   after begin block&#xA; Just prior to termination, Ruby executes any at_exit functions (see Kernel::at_exit) and runs any object finalizers (see ObjectSpace::define_finalizer). &#xA;    at_exit { puts &quot;at_exit function&quot; }" />
      <scope name="exit!" ilk="function" signature="exit!(...)" doc="Exits the process immediately. No exit handlers are run. status is returned to the underlying system as the exit status. &#xA;    Process.exit!(true)" />
      <scope name="fail" ilk="function" signature="fail(...)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA;    raise &quot;Failed to create socket&quot;&#xA;   raise ArgumentError, &quot;No parameters&quot;, caller" />
      <scope name="fork" ilk="function" signature="fork()" doc="Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the +fork+ call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning _nil_. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; The thread calling fork is the only thread in the created child process. fork doesn&apos;t copy other threads. &#xA; If fork is not usable, Process.respond_to?(:fork) returns false." />
      <scope name="format" ilk="function" signature="format(...)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA;   %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA;     Field |  Integer Format&#xA;    ------+--------------------------------------------------------------&#xA;      b   | Convert argument as a binary number.&#xA;          | Negative numbers will be displayed as a two&apos;s complement&#xA;          | prefixed with `..1&apos;.&#xA;      B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;          | in the alternative format by #.&#xA;      d   | Convert argument as a decimal number." />
      <scope name="gets" ilk="function" signature="gets(...)" doc="Returns (and assigns to $_) the next line from the list of files in +ARGV+ (or $*), or from standard input if no files are present on the command line. Returns +nil+ at end of file. The optional argument specifies the record separator. The separator is included with the contents of each record. A separator of +nil+ reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes.  If multiple filenames are present in +ARGV+, +gets(nil)+ will read the contents one file at a time. &#xA;    ARGV &lt;&lt; &quot;testfile&quot;&#xA;   print while gets&#xA; produces: &#xA;    This is line one&#xA;   This is line two&#xA;   This is line three&#xA;   And so on...&#xA; The style of programming using $_ as an implicit parameter is gradually losing favor in the Ruby community." />
      <scope name="global_variables" ilk="function" signature="global_variables()" doc="Returns an array of the names of global variables. &#xA;    global_variables.grep /std/   =&gt; [:$stdin, :$stdout, :$stderr]" />
      <scope name="iterator?" ilk="function" signature="iterator?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA;    def try&#xA;     if block_given?&#xA;       yield&#xA;     else&#xA;       &quot;no block&quot;&#xA;     end&#xA;   end&#xA;   try                  =&gt; &quot;no block&quot;&#xA;   try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;   try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
      <scope name="lambda" ilk="function" signature="lambda()" doc="Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called." />
      <scope name="load" ilk="function" signature="load(...)" doc="Loads and executes the Ruby program in the file _filename_. If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. If the optional _wrap_ parameter is +true+, the loaded script will be executed under an anonymous module, protecting the calling program&apos;s global namespace. In no circumstance will any local variables in the loaded file be propagated to the loading environment." />
      <scope name="local_variables" ilk="function" signature="local_variables()" doc="Returns the names of the current local variables. &#xA;    fred = 1&#xA;   for i in 1..10&#xA;      # ...&#xA;   end&#xA;   local_variables   =&gt; [:fred, :i]" />
      <scope name="loop" ilk="function" signature="loop()" doc="Repeatedly executes the block. &#xA; If no block is given, an enumerator is returned instead. &#xA;    loop do&#xA;     print &quot;Input: &quot;&#xA;     line = gets&#xA;     break if !line or line =~ /^qQ/&#xA;     # ...&#xA;   end&#xA; StopIteration raised in the block breaks the loop." />
      <scope name="open" ilk="function" signature="open(...)" doc="Creates an IO object connected to the given stream, file, or subprocess. &#xA; If path does not start with a pipe character (``|&apos;&apos;), treat it as the name of a file to open using the specified mode (defaulting to ``r&apos;&apos;). &#xA; The mode_enc is either a string or an integer.  If it is an integer, it must be bitwise-or of open(2) flags, such as File::RDWR or File::EXCL. If it is a string, it is either &quot;mode&quot;, &quot;mode:ext_enc&quot;, or &quot;mode:ext_enc:int_enc&quot;. The mode is one of the following: &#xA;  r: read (default)&#xA; w: write&#xA; a: append&#xA; The mode can be followed by &quot;b&quot; (means binary-mode), or &quot;+&quot; (means both reading and writing allowed) or both. If ext_enc (external encoding) is specified, read string will be tagged by the encoding in reading, and output string will be converted to the specified encoding in writing. If ext_enc starts with &apos;BOM|&apos;, check whether the input has a BOM. If there is a BOM, strip it and set external encoding as what the BOM tells. If there is no BOM, use ext_enc without &apos;BOM|&apos;. If two encoding names, ext_enc and int_enc (external encoding and internal encoding), are specified, the read string is converted from ext_enc to int_enc then tagged with the int_enc in read mode, and in write mode, the output string will be converted from int_enc to ext_enc before writing. &#xA; If a file is being created, its initial permissions may be set using the integer third parameter. &#xA; If a block is specified, it will be invoked with the File object as a parameter, and the file will be automatically closed when the block terminates. The call returns the value of the block. &#xA; If path starts with a pipe character, a subprocess is created, connected to the caller by a pair of pipes. The returned IO object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the ``|&apos;&apos; is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the open call returns nil. If the command is not ``-&apos;&apos;, the subprocess runs the command. If a block is associated with an open(&quot;|-&quot;) call, that block will be run twice---once in the parent and once in the child. The block parameter will be an IO object in the parent and nil in the child. The parent&apos;s IO object will be connected to the child&apos;s $stdin and $stdout. The subprocess will be terminated at the end of the block. &#xA;    open(&quot;testfile&quot;) do |f|&#xA;     print f.gets&#xA;   end" />
      <scope name="p" ilk="function" signature="p(...)" doc="For each object, directly writes _obj_.+inspect+ followed by the current output record separator to the program&apos;s standard output. &#xA;    S = Struct.new(:name, :state)&#xA;   s = S[&apos;dave&apos;, &apos;TX&apos;]&#xA;   p s&#xA; produces: &#xA;    #&lt;S name=&quot;dave&quot;, state=&quot;TX&quot;&gt;" />
      <scope name="print" ilk="function" signature="print(...)" doc="Prints each object in turn to $stdout. If the output field separator ($,) is not +nil+, its contents will appear between each field. If the output record separator ($\\) is not +nil+, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. &#xA;    print &quot;cat&quot;, [1,2,3], 99, &quot;\n&quot;&#xA;   $, = &quot;, &quot;&#xA;   $\ = &quot;\n&quot;&#xA;   print &quot;cat&quot;, [1,2,3], 99&#xA; produces: &#xA;    cat12399&#xA;   cat, 1, 2, 3, 99" />
      <scope name="printf" ilk="function" signature="printf(...)" doc="Equivalent to:    io.write(sprintf(string, obj, ...)&#xA; or    $stdout.write(sprintf(string, obj, ...)" />
      <scope name="proc" ilk="function" signature="proc()" doc="Equivalent to Proc.new." />
      <scope name="putc" ilk="function" signature="putc(p1)" doc=" &#xA; Equivalent to:&#xA;&#xA;   $stdout.putc(int)&#xA; Refer to the documentation for IO#putc for important information regarding multi-byte characters." />
      <scope name="puts" ilk="function" signature="puts(...)" doc="Equivalent to &#xA;     $stdout.puts(obj, ...)" />
      <scope name="raise" ilk="function" signature="raise(...)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA;    raise &quot;Failed to create socket&quot;&#xA;   raise ArgumentError, &quot;No parameters&quot;, caller" />
      <scope name="rand" ilk="function" signature="rand(...)" doc="Converts max to an integer using max1 = max.to_i.abs. If _max_ is +nil+ the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1. &#xA;    srand 1234                 =&gt; 0&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]&#xA;   [ rand(10), rand(1000) ]   =&gt; [6, 817]&#xA;   srand 1234                 =&gt; 1234&#xA;   [ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]" />
      <scope name="readline" ilk="function" signature="readline(...)" doc="Equivalent to Kernel::gets, except +readline+ raises +EOFError+ at end of file." />
      <scope name="readlines" ilk="function" signature="readlines(...)" doc="Returns an array containing the lines returned by calling Kernel.gets(sep) until the end of file." />
      <scope name="require" ilk="function" signature="require(p1)" doc="Ruby tries to load the library named _string_, returning +true+ if successful. If the filename does not resolve to an absolute path, it will be searched for in the directories listed in $:. If the file has the extension ``.rb&apos;&apos;, it is loaded as a source file; if the extension is ``.so&apos;&apos;, ``.o&apos;&apos;, or ``.dll&apos;&apos;, or whatever the default shared library extension is on the current platform, Ruby loads the shared library as a Ruby extension. Otherwise, Ruby tries adding ``.rb&apos;&apos;, ``.so&apos;&apos;, and so on to the name. The name of the loaded feature is added to the array in $&quot;. A feature will not be loaded if its name already appears in $&quot;. The file name is converted to an absolute path, so ``require &apos;a&apos;; require &apos;./a&apos;&apos;&apos; will not load a.rb twice. &#xA;    require &quot;my-library.rb&quot;&#xA;   require &quot;db-driver&quot;" />
      <scope name="require_relative" ilk="function" />
      <scope name="select" ilk="function" signature="select(...)" doc="See Kernel#select." />
      <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ as the handler for tracing, or disables tracing if the parameter is +nil+. _proc_ takes up to six parameters: an event name, a filename, a line number, an object id, a binding, and the name of a class. _proc_ is invoked whenever an event occurs. Events are: c-call (call a C-language routine), c-return (return from a C-language routine), call (call a Ruby method), class (start a class or module definition), end (finish a class or module definition), line (execute code on a new line), raise (raise an exception), and return (return from a Ruby method). Tracing is disabled within the context of _proc_. &#xA;     class Test&#xA;    def test&#xA;      a = 1&#xA;      b = 2&#xA;    end&#xA;    end&#xA;    set_trace_func proc { |event, file, line, id, binding, classname|&#xA;       printf &quot;%8s %s:%-2d %10s %8s\n&quot;, event, file, line, id, classname&#xA;    }&#xA;    t = Test.new&#xA;    t.test&#xA;      line prog.rb:11               false" />
      <scope name="sleep" ilk="function" signature="sleep(...)" doc="Suspends the current thread for _duration_ seconds (which may be any number, including a +Float+ with fractional seconds). Returns the actual number of seconds slept (rounded), which may be less than that asked for if another thread calls Thread#run. Called without an argument, sleep() will sleep forever. &#xA;    Time.new    =&gt; 2008-03-08 19:56:19 +0900&#xA;   sleep 1.2   =&gt; 1&#xA;   Time.new    =&gt; 2008-03-08 19:56:20 +0900&#xA;   sleep 1.9   =&gt; 2&#xA;   Time.new    =&gt; 2008-03-08 19:56:22 +0900" />
      <scope name="spawn" ilk="function" signature="spawn(...)" doc="spawn executes specified command and return its pid. &#xA; This method doesn&apos;t wait for end of the command. The parent process should use Process.wait to collect the termination status of its child or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; spawn has bunch of options to specify process attributes: &#xA;   env: hash&#xA;    name =&gt; val : set the environment variable&#xA;    name =&gt; nil : unset the environment variable&#xA;  command...:&#xA;    commandline                 : command line string which is passed to the standard shell&#xA;    cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;    [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA;  options: hash&#xA;    clearing environment variables:&#xA;      :unsetenv_others =&gt; true   : clear environment variables except specified by env" />
      <scope name="sprintf" ilk="function" signature="sprintf(...)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA;   %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA;     Field |  Integer Format&#xA;    ------+--------------------------------------------------------------&#xA;      b   | Convert argument as a binary number.&#xA;          | Negative numbers will be displayed as a two&apos;s complement&#xA;          | prefixed with `..1&apos;.&#xA;      B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;          | in the alternative format by #.&#xA;      d   | Convert argument as a decimal number." />
      <scope name="srand" ilk="function" signature="srand(...)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted or zero, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
      <scope name="syscall" ilk="function" signature="syscall(...)" doc="Calls the operating system function identified by _fixnum_, passing in the arguments, which must be either +String+ objects, or +Integer+ objects that ultimately fit within a native +long+. Up to nine parameters may be passed (14 on the Atari-ST). The function identified by _fixnum_ is system dependent. On some Unix systems, the numbers may be obtained from a header file called syscall.h. &#xA;    syscall 4, 1, &quot;hello\n&quot;, 6   # &apos;4&apos; is write(2) on our box&#xA; produces: &#xA;    hello" />
      <scope name="system" ilk="function" signature="system(...)" doc="Executes _command..._ in a subshell. _command..._ is one of following forms. &#xA;   commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; system returns +true+ if the command gives zero exit status, +false+ for non zero exit status. Returns +nil+ if command execution fails. An error status is available in $?. The arguments are processed in the same way as for Kernel.spawn. &#xA; The hash arguments, env and options, are same as exec and spawn. See Kernel.spawn for details. &#xA;    system(&quot;echo *&quot;)&#xA;   system(&quot;echo&quot;, &quot;*&quot;)&#xA; produces: &#xA;    config.h main.rb&#xA;   *  See Kernel.exec for the standard shell." />
      <scope name="test" ilk="function" signature="test(...)" doc=" &#xA; Uses the integer aCmd to perform various tests on&#xA; file1 (first table below) or on file1 and&#xA; file2 (second table).&#xA; File tests on a single file:&#xA;   Test   Returns   Meaning&#xA;   &quot;A&quot;  | Time    | Last access time for file1&#xA;   &quot;b&quot;  | boolean | True if file1 is a block device&#xA;   &quot;c&quot;  | boolean | True if file1 is a character device&#xA;   &quot;C&quot;  | Time    | Last change time for file1&#xA;   &quot;d&quot;  | boolean | True if file1 exists and is a directory&#xA;   &quot;e&quot;  | boolean | True if file1 exists&#xA;   &quot;f&quot;  | boolean | True if file1 exists and is a regular file" />
      <scope name="throw" ilk="function" signature="throw(...)" doc="Transfers control to the end of the active +catch+ block waiting for _tag_. Raises +ArgumentError+ if there is no +catch+ block for the _tag_. The optional second parameter supplies a return value for the +catch+ block, which otherwise defaults to +nil+. For examples, see Kernel::catch." />
      <scope name="trace_var" ilk="function" signature="trace_var(...)" doc="Controls tracing of assignments to global variables. The parameter +symbol_ identifies the variable (as either a string name or a symbol identifier). _cmd_ (which may be a string or a +Proc+ object) or block is executed whenever the variable is assigned. The block or +Proc+ object receives the variable&apos;s new value as a parameter. Also see Kernel::untrace_var. &#xA;    trace_var :$_, proc {|v| puts &quot;$_ is now &apos;#{v}&apos;&quot; }&#xA;   $_ = &quot;hello&quot;&#xA;   $_ = &apos; there&apos;&#xA; produces: &#xA;    $_ is now &apos;hello&apos;&#xA;   $_ is now &apos; there&apos;" />
      <scope name="trap" ilk="function" signature="trap(...)" doc="Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM&apos;&apos;, ``SIGUSR1&apos;&apos;, and so on) or a signal number. The characters ``SIG&apos;&apos; may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE&apos;&apos; or ``SIG_IGN&apos;&apos;, the signal will be ignored. If the command is ``DEFAULT&apos;&apos; or ``SIG_DFL&apos;&apos;, the Ruby&apos;s default handler will be invoked. If the command is ``EXIT&apos;&apos;, the script will be terminated by the signal. If the command is ``SYSTEM_DEFAULT&apos;&apos;, the operating system&apos;s default handler will be invoked. Otherwise, the given command or block will be run. The special signal name ``EXIT&apos;&apos; or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal. &#xA;     Signal.trap(0, proc { puts &quot;Terminating: #{$$}&quot; })&#xA;    Signal.trap(&quot;CLD&quot;)  { puts &quot;Child died&quot; }&#xA;    fork &amp;&amp; Process.wait&#xA; produces:     Terminating: 27461&#xA;    Child died&#xA;    Terminating: 27460" />
      <scope name="untrace_var" ilk="function" signature="untrace_var(...)" doc="Removes tracing for the specified command on the given global variable and returns +nil+. If no command is specified, removes all tracing for that variable and returns an array containing the commands actually removed." />
      <scope name="warn" ilk="function" signature="warn(p1)" doc="Display the given message (followed by a newline) on STDERR unless warnings are disabled (for example with the -W0 flag)." />
    </scope>
    <scope name="abbrev" ilk="blob" lang="Ruby">
      <scope name="Abbrev" ilk="namespace">
        <scope name="abbrev" ilk="function" signature="abbrev(words, pattern = nil)" attributes="__classmethod__" doc="Given a set of strings, calculate the set of unambiguous abbreviations for those strings, and return a hash where the keys are all the possible abbreviations and the values are the full strings. Thus, given input of &quot;car&quot; and &quot;cone&quot;, the keys pointing to &quot;car&quot; would be &quot;ca&quot; and &quot;car&quot;, while those pointing to &quot;cone&quot; would be &quot;co&quot;, &quot;con&quot;, and &quot;cone&quot;. &#xA; The optional +pattern+ parameter is a pattern or a string. Only those input strings matching the pattern, or begging the string, are considered for inclusion in the output hash" />
      </scope>
    </scope>
    <scope name="base64" ilk="blob" lang="Ruby">
      <scope name="Base64" ilk="namespace">
        <scope name="decode64" ilk="function" signature="decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with RFC 2045. Characters outside the base alphabet are ignored. &#xA;   require &apos;base64&apos;&#xA;  str = &apos;VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG&apos; +&#xA;        &apos;lzIGxpbmUgdHdvClRoaXMgaXMgbGlu&apos; +&#xA;        &apos;ZSB0aHJlZQpBbmQgc28gb24uLi4K&apos;&#xA;  puts Base64.decode64(str)&#xA; Generates: &#xA;    This is line one&#xA;   This is line two&#xA;   This is line three&#xA;   And so on..." />
        <scope name="encode64" ilk="function" signature="encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with RFC 2045. Line feeds are added to every 60 encoded charactors. &#xA;    require &apos;base64&apos;&#xA;   Base64.encode64(&quot;Now is the time for all good coders\nto learn Ruby&quot;)&#xA; Generates: &#xA;    Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g&#xA;   UnVieQ==" />
        <scope name="strict_decode64" ilk="function" signature="strict_decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with RFC 4648. ArgumentError is raised if +str+ is incorrectly padded or contains non-alphabet characters.  Note that CR or LF are also rejected." />
        <scope name="strict_encode64" ilk="function" signature="strict_encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with RFC 4648. No line feeds are added." />
        <scope name="urlsafe_decode64" ilk="function" signature="urlsafe_decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with ``Base 64 Encoding with URL and Filename Safe Alphabet&apos;&apos; in RFC 4648. The alphabet uses &apos;-&apos; instead of &apos;+&apos; and &apos;_&apos; instead of &apos;/&apos;." />
        <scope name="urlsafe_encode64" ilk="function" signature="urlsafe_encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with ``Base 64 Encoding with URL and Filename Safe Alphabet&apos;&apos; in RFC 4648. The alphabet uses &apos;-&apos; instead of &apos;+&apos; and &apos;_&apos; instead of &apos;/&apos;." />
      </scope>
    </scope>
    <scope name="benchmark" ilk="blob" lang="Ruby">
      <scope name="Benchmark" ilk="namespace">
        <scope name="benchmark" ilk="function" signature="benchmark(caption = &quot;&quot;, label_width = nil, fmtstr = nil, *labels)" attributes="__classmethod__" doc="Invokes the block with a Benchmark::Report object, which may be used to collect and report on the results of individual benchmark tests. Reserves label_width leading spaces for labels on each line. Prints _caption_ at the top of the report, and uses _fmt_ to format each line. If the block returns an array of Benchmark::Tms objects, these will be used to format additional lines of output. If _label_ parameters are given, these are used to label these extra lines. &#xA; _Note_: Other methods provide a simpler interface to this one, and are suitable for nearly all benchmarking requirements.  See the examples in Benchmark, and the #bm and #bmbm methods. &#xA; Example: &#xA;     require &apos;benchmark&apos;&#xA;    include Benchmark          # we need the CAPTION and FMTSTR constants&#xA;    n = 50000&#xA;    Benchmark.benchmark(&quot; &quot;*7 + CAPTION, 7, FMTSTR, &quot;&gt;total:&quot;, &quot;&gt;avg:&quot;) do |x|&#xA;      tf = x.report(&quot;for:&quot;)   { for i in 1..n; a = &quot;1&quot;; end }&#xA;      tt = x.report(&quot;times:&quot;) { n.times do   ; a = &quot;1&quot;; end }&#xA;      tu = x.report(&quot;upto:&quot;)  { 1.upto(n) do ; a = &quot;1&quot;; end }&#xA;      [tf+tt+tu, (tf+tt+tu)/3]&#xA;    end&#xA; Generates: " />
        <scope name="bm" ilk="function" signature="bm(label_width = 0, *labels)" attributes="__classmethod__" doc="A simple interface to the #benchmark method, #bm is generates sequential reports with labels.  The parameters have the same meaning as for #benchmark. &#xA;     require &apos;benchmark&apos;&#xA;    n = 50000&#xA;    Benchmark.bm(7) do |x|&#xA;      x.report(&quot;for:&quot;)   { for i in 1..n; a = &quot;1&quot;; end }&#xA;      x.report(&quot;times:&quot;) { n.times do   ; a = &quot;1&quot;; end }&#xA;      x.report(&quot;upto:&quot;)  { 1.upto(n) do ; a = &quot;1&quot;; end }&#xA;    end&#xA; Generates: &#xA;                     user     system      total        real&#xA;       for:     1.050000   0.000000   1.050000 (  0.503462)&#xA;       times:   1.533333   0.016667   1.550000 (  0.735473)&#xA;       upto:    1.500000   0.016667   1.516667 (  0.711239)" />
        <scope name="bmbm" ilk="function" signature="bmbm(width = 0)" attributes="__classmethod__" doc="Sometimes benchmark results are skewed because code executed earlier encounters different garbage collection overheads than that run later. #bmbm attempts to minimize this effect by running the tests twice, the first time as a rehearsal in order to get the runtime environment stable, the second time for real. GC.start is executed before the start of each of the real timings; the cost of this is not included in the timings. In reality, though, there&apos;s only so much that #bmbm can do, and the results are not guaranteed to be isolated from garbage collection and other effects. &#xA; Because #bmbm takes two passes through the tests, it can calculate the required label width. &#xA;       require &apos;benchmark&apos;&#xA;      array = (1..1000000).map { rand }&#xA;      Benchmark.bmbm do |x|&#xA;        x.report(&quot;sort!&quot;) { array.dup.sort! }&#xA;        x.report(&quot;sort&quot;)  { array.dup.sort  }&#xA;      end&#xA; Generates: &#xA;        Rehearsal -----------------------------------------&#xA;       sort!  11.928000   0.010000  11.938000 ( 12.756000)&#xA;       sort   13.048000   0.020000  13.068000 ( 13.857000)&#xA;       ------------------------------- total: 25.006000sec" />
        <scope name="measure" ilk="function" signature="measure(label = &quot;&quot;)" attributes="__classmethod__" doc="Returns the time used to execute the given block as a Benchmark::Tms object." />
        <scope name="realtime" ilk="function" signature="realtime()" attributes="__classmethod__" doc="Returns the elapsed real time used to execute the given block." />
        <variable name="BENCHMARK_VERSION" attributes="__const__" citdl="Object" />
        <variable name="CAPTION" attributes="__const__" citdl="Object" />
        <variable name="FMTSTR" attributes="__const__" citdl="Object" />
        <scope name="Job" ilk="class" classrefs="Object">
        </scope>
        <scope name="Report" ilk="class" classrefs="Object">
        </scope>
        <scope name="Tms" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(u = 0.0, s = 0.0, cu = 0.0, cs = 0.0, real = 0.0, l = nil)" attributes="__classmethod__ __ctor__" doc="Returns an initialized Tms object which has _u_ as the user CPU time, _s_ as the system CPU time, _cu_ as the children&apos;s user CPU time, _cs_ as the children&apos;s system CPU time, _real_ as the elapsed real time and _l_ as the label." />
          <scope name="add" ilk="function" signature="add()" doc="Returns a new Tms object whose times are the sum of the times for this Tms object, plus the time required to execute the code block (_blk_)." />
          <scope name="add!" ilk="function" signature="add!(&amp;blk)" doc="An in-place version of #add." />
          <scope name="format" ilk="function" signature="format(arg0 = nil, *args)" doc="Returns the contents of this Tms object as a formatted string, according to a format string like that passed to Kernel.format. In addition, #format accepts the following extensions: &#xA; Replaced by the user CPU time, as reported by Tms#utime.&#xA;Replaced by the system CPU time, as reported by #stime (Mnemonic: y of &quot;s*y*stem&quot;)&#xA;Replaced by the children&apos;s user CPU time, as reported by Tms#cutime&#xA;Replaced by the children&apos;s system CPU time, as reported by Tms#cstime&#xA;Replaced by the total CPU time, as reported by Tms#total&#xA;Replaced by the elapsed real time, as reported by Tms#real&#xA;Replaced by the label string, as reported by Tms#label (Mnemonic: n of &quot;*n*ame&quot;) &#xA; If _fmtstr_ is not given, FMTSTR is used as default value, detailing the user, system and real elapsed time." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Returns a new 6-element array, consisting of the label, user CPU time, system CPU time, children&apos;s user CPU time, children&apos;s system CPU time and elapsed real time." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Same as #format." />
          <scope ilk="function" name="cstime" />
          <scope ilk="function" name="cutime" />
          <scope ilk="function" name="label" />
          <scope ilk="function" name="real" />
          <scope ilk="function" name="stime" />
          <scope ilk="function" name="total" />
          <scope ilk="function" name="utime" />
          <variable name="CAPTION" attributes="__const__" citdl="Object" />
          <variable name="FMTSTR" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="bigdecimal" ilk="blob" lang="Ruby">
      <scope name="BigDecimal" ilk="class" classrefs="Numeric">
        <scope name="_load" ilk="function" signature="_load(p1)" attributes="__classmethod__" doc="Internal method used to provide marshalling support. See the Marshal module." />
        <scope name="double_fig" ilk="function" signature="double_fig()" attributes="__classmethod__" doc="The BigDecimal.double_fig class method returns the number of digits a Float number is allowed to have. The result depends upon the CPU and OS in use." />
        <scope name="limit" ilk="function" signature="limit(...)" attributes="__classmethod__" doc="Limit the number of significant digits in newly created BigDecimal numbers to the specified value. Rounding is performed as necessary, as specified by BigDecimal.mode. &#xA; A limit of 0, the default, means no upper limit. &#xA; The limit specified by this method takes less priority over any limit specified to instance methods such as ceil, floor, truncate, or round." />
        <scope name="mode" ilk="function" signature="mode(...)" attributes="__classmethod__" doc="Controls handling of arithmetic exceptions and rounding. If no value is supplied, the current value is returned. &#xA; Six values of the mode parameter control the handling of arithmetic exceptions: &#xA; BigDecimal::EXCEPTION_NaN BigDecimal::EXCEPTION_INFINITY BigDecimal::EXCEPTION_UNDERFLOW BigDecimal::EXCEPTION_OVERFLOW BigDecimal::EXCEPTION_ZERODIVIDE BigDecimal::EXCEPTION_ALL &#xA; For each mode parameter above, if the value set is false, computation continues after an arithmetic exception of the appropriate type. When computation continues, results are as follows: &#xA; NaN&#xA;+infinity or -infinity&#xA;0&#xA;+infinity or -infinity&#xA;+infinity or -infinity &#xA; One value of the mode parameter controls the rounding of numeric values: BigDecimal::ROUND_MODE. The values it can take are: &#xA; round away from zero&#xA;round towards zero (truncate)&#xA;round up if the appropriate digit &gt;= 5, otherwise truncate (default)" />
        <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Create a new BigDecimal object. &#xA; The initial value, as a String. Spaces are ignored, unrecognized characters terminate the value. &#xA;&#xA;The number of significant digits, as a Fixnum. If omitted or 0, the number of significant digits is determined from the initial value. &#xA; The actual number of significant digits used in computation is usually larger than the specified number." />
        <scope name="ver" ilk="function" signature="ver()" attributes="__classmethod__" doc="Returns the BigDecimal version number. &#xA; Ruby 1.8.0 returns 1.0.0. Ruby 1.8.1 thru 1.8.3 return 1.0.1." />
        <scope name="abs" ilk="function" signature="abs()" doc="Returns the absolute value. &#xA; BigDecimal(&apos;5&apos;).abs -&gt; 5 &#xA; BigDecimal(&apos;-3&apos;).abs -&gt; 3" />
        <scope name="ceil" ilk="function" signature="ceil(...)" doc="Return the smallest integer greater than or equal to the value, as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).ceil -&gt; 4 &#xA; BigDecimal(&apos;-9.1&apos;).ceil -&gt; -9 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).ceil(3) -&gt; 3.142 &#xA; BigDecimal(&apos;13345.234&apos;).ceil(-2) -&gt; 13400.0" />
        <scope name="coerce" ilk="function" signature="coerce(p1)" doc="The coerce method provides support for Ruby type coercion. It is not enabled by default. &#xA; This means that binary operations like + * / or - can often be performed on a BigDecimal and an object of another type, if the other object can be coerced into a BigDecimal value. &#xA; e.g. a = BigDecimal.new(&quot;1.0&quot;) b = a / 2.0  -&gt; 0.5 &#xA; Note that coercing a String to a BigDecimal is not supported by default; it requires a special compile-time option when building Ruby." />
        <scope name="divmod" ilk="function" signature="divmod(p1)" doc="Divides by the specified value, and returns the quotient and modulus as BigDecimal numbers. The quotient is rounded towards negative infinity. &#xA; For example: &#xA; require &apos;bigdecimal&apos; &#xA; a = BigDecimal.new(&quot;42&quot;) b = BigDecimal.new(&quot;9&quot;) &#xA; q,m = a.divmod(b) &#xA; c = q * b + m &#xA; a == c  -&gt; true &#xA; The quotient q is (a/b).floor, and the modulus is the amount that must be added to q * b to get a." />
        <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Tests for value equality; returns true if the values are equal. &#xA; The == and === operators and the eql? method have the same implementation for BigDecimal. &#xA; Values may be coerced to perform the comparison: &#xA; BigDecimal.new(&apos;1.0&apos;) == 1.0  -&gt; true" />
        <scope name="exponent" ilk="function" signature="exponent()" doc="Returns the exponent of the BigDecimal number, as an Integer. &#xA; If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of digits with no leading zeros, then n is the exponent." />
        <scope name="finite?" ilk="function" signature="finite?()" doc="Returns True if the value is finite (not NaN or infinite)   " />
        <scope name="fix" ilk="function" signature="fix()" doc="Return the integer part of the number." />
        <scope name="floor" ilk="function" signature="floor(...)" doc="Return the largest integer less than or equal to the value, as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).floor -&gt; 3 &#xA; BigDecimal(&apos;-9.1&apos;).floor -&gt; -10 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).floor(3) -&gt; 3.141 &#xA; BigDecimal(&apos;13345.234&apos;).floor(-2) -&gt; 13300.0" />
        <scope name="frac" ilk="function" signature="frac()" doc="Return the fractional part of the number." />
        <scope name="infinite?" ilk="function" signature="infinite?()" doc="Returns nil, -1, or +1 depending on whether the value is finite, -infinity, or +infinity." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns debugging information about the value as a string of comma-separated values in angle brackets with a leading #: &#xA; BigDecimal.new(&quot;1234.5678&quot;).inspect -&gt; &quot;#&lt;BigDecimal:b7ea1130,&apos;0.12345678E4&apos;,8(12)&gt;&quot; &#xA; The first part is the address, the second is the value as a string, and the final part ss(mm) is the current number of significant digits and the maximum number of significant digits, respectively." />
        <scope name="modulo" ilk="function" signature="modulo(p1)" doc="Returns the modulus from dividing by b. See divmod." />
        <scope name="nan?" ilk="function" signature="nan?()" doc="Returns True if the value is Not a Number   " />
        <scope name="nonzero?" ilk="function" signature="nonzero?()" doc="Returns self if the value is non-zero, nil otherwise.   " />
        <scope name="power" ilk="function" signature="power(p1)" doc="Returns the value raised to the power of n. Note that n must be an Integer. &#xA; Also available as the operator **" />
        <scope name="precs" ilk="function" signature="precs()" doc="Returns an Array of two Integer values. &#xA; The first value is the current number of significant digits in the BigDecimal. The second value is the maximum number of significant digits for the BigDecimal." />
        <scope name="quo" ilk="function" signature="quo(p1)" doc="Divide by the specified value. &#xA; e.g.   c = a.div(b,n)&#xA; If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode. &#xA; If digits is 0, the result is the same as the / operator. If not, the result is an integer BigDecimal, by analogy with Float#div. &#xA; The alias quo is provided since div(value, 0) is the same as computing the quotient; see divmod." />
        <scope name="remainder" ilk="function" signature="remainder(p1)" doc="Returns the remainder from dividing by the value. &#xA; x.remainder(y) means x-y*(x/y).truncate" />
        <scope name="round" ilk="function" signature="round(...)" doc="Round to the nearest 1 (by default), returning the result as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).round -&gt; 3 &#xA; BigDecimal(&apos;8.7&apos;).round -&gt; 9 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).round(3) -&gt; 3.142 &#xA; BigDecimal(&apos;13345.234&apos;).round(-2) -&gt; 13300.0 &#xA; The value of the optional mode argument can be used to determine how rounding is performed; see BigDecimal.mode." />
        <scope name="sign" ilk="function" signature="sign()" doc="Returns the sign of the value. &#xA; Returns a positive value if &gt; 0, a negative value if &lt; 0, and a zero if == 0. &#xA; The specific value returned indicates the type and sign of the BigDecimal, as follows: &#xA; value is Not a Number&#xA;value is +0&#xA;value is -0&#xA;value is +infinity&#xA;value is -infinity&#xA;value is positive&#xA;value is negative" />
        <scope name="split" ilk="function" signature="split()" doc="Splits a BigDecimal number into four parts, returned as an array of values. &#xA; The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if the BigDecimal is Not a Number. &#xA; The second value is a string representing the significant digits of the BigDecimal, with no leading zeros. &#xA; The third value is the base used for arithmetic (currently always 10) as an Integer. &#xA; The fourth value is an Integer exponent. &#xA; If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the string of significant digits with no leading zeros, and n is the exponent. &#xA; From these values, you can translate a BigDecimal to a float as follows: &#xA;   sign, significant_digits, base, exponent = a.split&#xA;  f = sign * &quot;0.#{significant_digits}&quot;.to_f * (base ** exponent)&#xA; (Note that the to_f method is provided as a more convenient way to translate a BigDecimal to a Float.)" />
        <scope name="sqrt" ilk="function" signature="sqrt(p1)" doc="Returns the square root of the value. &#xA; If n is specified, returns at least that many significant digits." />
        <scope name="to_digits" ilk="function" signature="to_digits()" doc="Converts a BigDecimal to a String of the form &quot;nnnnnn.mmm&quot;. This method is deprecated; use BigDecimal#to_s(&quot;F&quot;) instead." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns a new Float object having approximately the same value as the BigDecimal number. Normal accuracy limits and built-in errors of binary Float arithmetic apply." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value as an integer (Fixnum or Bignum). &#xA; If the BigNumber is infinity or NaN, raises FloatDomainError." />
        <scope name="to_int" ilk="function" signature="to_int()" doc="Returns the value as an integer (Fixnum or Bignum). &#xA; If the BigNumber is infinity or NaN, raises FloatDomainError." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Converts a BigDecimal to a Rational." />
        <scope name="to_s" ilk="function" signature="to_s(...)" doc="Converts the value to a string. &#xA; The default format looks like  0.xxxxEnn. &#xA; The optional parameter s consists of either an integer; or an optional &apos;+&apos; or &apos; &apos;, followed by an optional number, followed by an optional &apos;E&apos; or &apos;F&apos;. &#xA; If there is a &apos;+&apos; at the start of s, positive values are returned with a leading &apos;+&apos;. &#xA; A space at the start of s returns positive values with a leading space. &#xA; If s contains a number, a space is inserted after each group of that many fractional digits. &#xA; If s ends with an &apos;E&apos;, engineering notation (0.xxxxEnn) is used. &#xA; If s ends with an &apos;F&apos;, conventional floating point notation is used. &#xA; Examples: &#xA; BigDecimal.new(&apos;-123.45678901234567890&apos;).to_s(&apos;5F&apos;) -&gt; &apos;-123.45678 90123 45678 9&apos; &#xA; BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos;+8F&apos;) -&gt; &apos;+123.45678901 23456789&apos; &#xA; BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos; F&apos;) -&gt; &apos; 123.4567890123456789&apos;" />
        <scope name="truncate" ilk="function" signature="truncate(...)" doc="Truncate to the nearest 1, returning the result as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).truncate -&gt; 3 &#xA; BigDecimal(&apos;8.7&apos;).truncate -&gt; 8 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).truncate(3) -&gt; 3.141 &#xA; BigDecimal(&apos;13345.234&apos;).truncate(-2) -&gt; 13300.0" />
        <scope name="zero?" ilk="function" signature="zero?()" doc="Returns True if the value is zero.   " />
        <variable name="BASE" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_ALL" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_INFINITY" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_UNDERFLOW" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_OVERFLOW" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_ZERODIVIDE" attributes="__const__" citdl="Object" />
        <variable name="ROUND_MODE" attributes="__const__" citdl="Object" />
        <variable name="ROUND_UP" attributes="__const__" citdl="Object" />
        <variable name="ROUND_DOWN" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_UP" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_DOWN" attributes="__const__" citdl="Object" />
        <variable name="ROUND_CEILING" attributes="__const__" citdl="Object" />
        <variable name="ROUND_FLOOR" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_EVEN" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_ZERO" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_ZERO" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_FINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_FINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_INFINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_INFINITE" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="cgi" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="class" classrefs="Object">
      </scope>
    </scope>
    <scope name="cgi/session" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="Session" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(request, option={})" attributes="__classmethod__ __ctor__" doc="Create a new CGI::Session object for +request+. &#xA; +request+ is an instance of the +CGI+ class (see cgi.rb). +option+ is a hash of options for initialising this CGI::Session instance.  The following options are recognised: &#xA; the parameter name used for the session id. Defaults to &apos;_session_id&apos;.&#xA;the session id to use.  If not provided, then it is retrieved from the +session_key+ parameter of the request, or automatically generated for a new session.&#xA;if true, force creation of a new session.  If not set, a new session is only created if none currently exists.  If false, a new session is never created, and if none currently exists and the +session_id+ option is not set, an ArgumentError is raised.&#xA;the name of the class providing storage facilities for session state persistence.  Built-in support is provided for +FileStore+ (the default), +MemoryStore+, and +PStore+ (from cgi/session/pstore.rb).  See the documentation for these classes for more details. &#xA; The following options are also recognised, but only apply if the session id is stored in a cookie. &#xA; the time the current session expires, as a +Time+ object.  If not set, the session will terminate when the user&apos;s browser is closed.&#xA;the hostname domain for which this session is valid. If not set, defaults to the hostname of the server.&#xA;if +true+, this session will only work over HTTPS.&#xA;the path for which this session applies.  Defaults to the directory of the CGI script. &#xA; +option+ is also passed on to the session storage class initializer; see the documentation for each session storage class for the options they support. &#xA; The retrieved or created session is automatically added to +request+ as a cookie, and also to its +output_hidden+ table, which is used to add hidden input elements to forms. " />
          <scope name="close" ilk="function" signature="close()" doc="Store session data on the server and close the session storage. For some session storage types, this is a no-op." />
          <scope name="delete" ilk="function" signature="delete()" doc="Delete the session from storage.  Also closes the storage. &#xA; Note that the session&apos;s data is _not_ automatically deleted upon the session expiring." />
          <scope name="update" ilk="function" signature="update()" doc="Store session data on the server.  For some session storage types, this is a no-op." />
          <scope ilk="function" name="new_session" />
          <scope ilk="function" name="session_id" />
          <scope name="FileStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option={})" attributes="__classmethod__ __ctor__" doc="Create a new FileStore instance. &#xA; This constructor is used internally by CGI::Session.  The user does not generally need to call it directly. &#xA; +session+ is the session for which this instance is being created.  The session id must only contain alphanumeric characters; automatically generated session ids observe this requirement. &#xA; +option+ is a hash of options for the initializer.  The following options are recognised: &#xA; the directory to use for storing the FileStore file.  Defaults to Dir::tmpdir (generally &quot;/tmp&quot; on Unix systems).&#xA;the prefix to add to the session id when generating the filename for this session&apos;s FileStore file. Defaults to &quot;cgi_sid_&quot;.&#xA;the prefix to add to the session id when generating the filename for this session&apos;s FileStore file. Defaults to the empty string. &#xA; This session&apos;s FileStore file will be created if it does not exist, or opened if it does." />
            <scope name="close" ilk="function" signature="close()" doc="Update and close the session&apos;s FileStore file." />
            <scope name="delete" ilk="function" signature="delete()" doc="Close and delete the session&apos;s FileStore file." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore session state from the session&apos;s FileStore file. &#xA; Returns the session state as a hash." />
            <scope name="update" ilk="function" signature="update()" doc="Save session state to the session&apos;s FileStore file." />
          </scope>
          <scope name="MemoryStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option=nil)" attributes="__classmethod__ __ctor__" doc="Create a new MemoryStore instance. &#xA; +session+ is the session this instance is associated with. +option+ is a list of initialisation options.  None are currently recognised." />
            <scope name="close" ilk="function" signature="close()" doc="Close session storage. &#xA; A no-op." />
            <scope name="delete" ilk="function" signature="delete()" doc="Delete the session state." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore session state. &#xA; Returns session data as a hash." />
            <scope name="update" ilk="function" signature="update()" doc="Update session state. &#xA; A no-op." />
          </scope>
          <scope name="NoSession" ilk="class" classrefs="RuntimeError">
          </scope>
          <scope name="NullStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option=nil)" attributes="__classmethod__ __ctor__" doc="Create a new NullStore instance. &#xA; +session+ is the session this instance is associated with. +option+ is a list of initialisation options.  None are currently recognised." />
            <scope name="close" ilk="function" signature="close()" doc="Close session storage. &#xA; A no-op." />
            <scope name="delete" ilk="function" signature="delete()" doc="Delete the session state. &#xA; A no-op." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore (empty) session state." />
            <scope name="update" ilk="function" signature="update()" doc="Update session state. &#xA; A no-op." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="continuation" ilk="blob" lang="Ruby">
      <scope name="Continuation" ilk="class" classrefs="Object">
        <scope name="call" ilk="function" signature="call(...)" doc="Invokes the continuation. The program continues from the end of the callcc block. If no arguments are given, the original callcc returns nil. If one argument is given, callcc returns it. Otherwise, an array containing args is returned. &#xA;    callcc {|cont|  cont.call }           =&gt; nil&#xA;   callcc {|cont|  cont.call 1 }         =&gt; 1&#xA;   callcc {|cont|  cont.call 1, 2, 3 }   =&gt; [1, 2, 3]" />
      </scope>
    </scope>
    <scope name="coverage" ilk="blob" lang="Ruby">
      <scope name="Coverage" ilk="namespace">
        <scope name="result" ilk="function" signature="result()" attributes="__classmethod__" doc=" &#xA; Returns a hash that contains filename as key and coverage array as value and disables coverage measurement." />
        <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" doc="Enables coverage measurement." />
      </scope>
    </scope>
    <scope name="csv" ilk="blob" lang="Ruby">
      <scope name="CSV" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="dump" ilk="function" signature="dump(ary_of_objs, io = &quot;&quot;, options = Hash.new)" attributes="__classmethod__" doc="This method allows you to serialize an Array of Ruby objects to a String or File of CSV data.  This is not as powerful as Marshal or YAML, but perhaps useful for spreadsheet and database interaction. &#xA; Out of the box, this method is intended to work with simple data objects or Structs.  It will serialize a list of instance variables and/or Struct.members(). &#xA; If you need need more complicated serialization, you can control the process by adding methods to the class to be serialized. &#xA; A class method csv_meta() is responsible for returning the first row of the document (as an Array).  This row is considered to be a Hash of the form key_1,value_1,key_2,value_2,...  CSV::load() expects to find a class key with a value of the stringified class name and CSV::dump() will create this, if you do not define this method.  This method is only called on the first object of the Array. &#xA; The next method you can provide is an instance method called csv_headers(). This method is expected to return the second line of the document (again as an Array), which is to be used to give each column a header.  By default, CSV::load() will set an instance variable if the field header starts with an @ character or call send() passing the header as the method name and the field value as an argument.  This method is only called on the first object of the Array. &#xA; Finally, you can provide an instance method called csv_dump(), which will be passed the headers.  This should return an Array of fields that can be serialized for this object.  This method is called once for every object in the Array. &#xA; The +io+ parameter can be used to serialize to a File, and +options+ can be anything CSV::new() accepts." />
        <scope name="filter" ilk="function" signature="filter(*args)" attributes="__classmethod__" doc="This method is a convenience for building Unix-like filters for CSV data. Each row is yielded to the provided block which can alter it as needed. After the block returns, the row is appended to +output+ altered or not. &#xA; The +input+ and +output+ arguments can be anything CSV::new() accepts (generally String or IO objects).  If not given, they default to ARGF and $stdout. &#xA; The +options+ parameter is also filtered down to CSV::new() after some clever key parsing.  Any key beginning with :in_ or :input_ will have that leading identifier stripped and will only be used in the +options+ Hash for the +input+ object.  Keys starting with :out_ or :output_ affect only +output+.  All other keys are assigned to both objects. &#xA; The :output_row_sep +option+ defaults to $INPUT_RECORD_SEPARATOR ($/)." />
        <scope name="foreach" ilk="function" signature="foreach(path, options = Hash.new, &amp;block)" attributes="__classmethod__" doc="This method is intended as the primary interface for reading CSV files.  You pass a +path+ and any +options+ you wish to set for the read.  Each row of file will be passed to the provided +block+ in turn. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method also understands an additional :encoding parameter that you can use to specify the Encoding of the data in the file to be read. You must provide this unless your data is in Encoding::default_external().  CSV will use this to determine how to parse the data.  You may provide a second Encoding to have the data transcoded as it is read.  For example, encoding: &quot;UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it." />
        <scope name="generate" ilk="function" signature="generate(*args)" attributes="__classmethod__" doc="This method wraps a String you provide, or an empty default String, in a CSV object which is passed to the provided block.  You can use the block to append CSV rows to the String and when the block exits, the final String will be returned. &#xA; Note that a passed String *is* modfied by this method.  Call dup() before passing if you need a new String. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method understands an additional :encoding parameter when not passed a String to set the base Encoding for the output.  CSV needs this hint if you plan to output non-ASCII compatible data." />
        <scope name="generate_line" ilk="function" signature="generate_line(row, options = Hash.new)" attributes="__classmethod__" doc="This method is a shortcut for converting a single row (Array) into a CSV String. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method understands an additional :encoding parameter to set the base Encoding for the output.  This method will try to guess your Encoding from the first non-+nil+ field in +row+, if possible, but you may need to use this parameter as a backup plan. &#xA; The :row_sep +option+ defaults to $INPUT_RECORD_SEPARATOR ($/) when calling this method." />
        <scope name="instance" ilk="function" signature="instance(data = $stdout, options = Hash.new)" attributes="__classmethod__" doc="This method will return a CSV instance, just like CSV::new(), but the instance will be cached and returned for all future calls to this method for the same +data+ object (tested by Object#object_id()) with the same +options+. &#xA; If a block is given, the instance is passed to the block and the return value becomes the return value of the block." />
        <scope name="load" ilk="function" signature="load(io_or_str, options = Hash.new)" attributes="__classmethod__" doc="This method is the reading counterpart to CSV::dump().  See that method for a detailed description of the process. &#xA; You can customize loading by adding a class method called csv_load() which will be passed a Hash of meta information, an Array of headers, and an Array of fields for the object the method is expected to return. &#xA; Remember that all fields will be Strings after this load.  If you need something else, use +options+ to setup converters or provide a custom csv_load() implementation." />
        <scope name="new" ilk="function" signature="new(data, options = Hash.new)" attributes="__classmethod__ __ctor__" doc="This constructor will wrap either a String or IO object passed in +data+ for reading and/or writing.  In addition to the CSV instance methods, several IO methods are delegated.  (See CSV::open() for a complete list.)  If you pass a String for +data+, you can later retrieve it (after writing to it, for example) with CSV.string(). &#xA; Note that a wrapped String will be positioned at at the beginning (for reading).  If you want it at the end (for writing), use CSV::generate(). If you want any other positioning, pass a preset StringIO object instead. &#xA; You may set any reading and/or writing preferences in the +options+ Hash. Available options are: &#xA; The String placed between each field. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;The String appended to the end of each row.  This can be set to the special :auto setting, which requests that CSV automatically discover this from the data.  Auto-discovery reads ahead in the data looking for the next &quot;\r\n&quot;, &quot;\n&quot;, or &quot;\r&quot; sequence.  A sequence will be selected even if it occurs in a quoted field, assuming that you would have the same line endings there.  If none of those sequences is found, +data+ is ARGF, STDIN, STDOUT, or STDERR, or the stream is only available for output, the default $INPUT_RECORD_SEPARATOR ($/) is used.  Obviously, discovery takes a little time.  Set manually if speed is important.  Also note that IO objects should be opened in binary mode on Windows if this feature will be used as the line-ending translation can cause problems with resetting the document position to where it was before the read ahead. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;The character used to quote fields. This has to be a single character String.  This is useful for application that incorrectly use &apos; as the quote character instead of the correct &quot;. CSV will always consider a double sequence this character to be an escaped quote. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;This is a maximum size CSV will read ahead looking for the closing quote for a field.  (In truth, it reads to the first line ending beyond this size.)  If a quote cannot be found within the limit CSV will raise a MalformedCSVError, assuming the data is faulty.  You can use this limit to prevent what are effectively DoS attacks on the parser.  However, this limit can cause a legitimate parse to fail and thus is set to +nil+, or off, by default.&#xA;An Array of names from the Converters Hash and/or lambdas that handle custom conversion.  A single converter doesn&apos;t have to be in an Array.  All built-in converters try to transcode fields to UTF-8 before converting. The conversion will fail if the data cannot be transcoded, leaving the field unchanged.&#xA;If set to +true+, an unconverted_fields() method will be added to all returned rows (Array or CSV::Row) that will return the fields as they were before conversion.  Note that :headers supplied by Array or String were not fields of the document and thus will have an empty Array attached.&#xA;If set to :first_row or +true+, the initial row of the CSV file will be treated as a row of headers.  If set to an Array, the contents will be used as the headers. If set to a String, the String is run through a call of CSV::parse_line() with the same :col_sep, :row_sep, and :quote_char as this instance to produce an Array of headers.  This setting causes CSV#shift() to return rows as CSV::Row objects instead of Arrays and CSV#read() to return CSV::Table objects instead of an Array of Arrays.&#xA;When +false+, header rows are silently swallowed.  If set to +true+, header rows are returned in a CSV::Row object with identical headers and fields (save that the fields do not go through the converters).&#xA;When +true+ and :headers is set, a header row will be added to the output.&#xA;Identical in functionality to :converters save that the conversions are only made to header rows.  All built-in converters try to transcode headers to UTF-8 before converting.  The conversion will fail if the data cannot be transcoded, leaving the header unchanged." />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="This method opens an IO object, and wraps that with CSV.  This is intended as the primary interface for writing a CSV file. &#xA; You must pass a +filename+ and may optionally add a +mode+ for Ruby&apos;s open().  You may also pass an optional Hash containing any +options+ CSV::new() understands as the final argument. &#xA; This method works like Ruby&apos;s open() call, in that it will pass a CSV object to a provided block and close it when the block terminates, or it will return the CSV object when no block is provided.  (*Note*: This is different from the Ruby 1.8 CSV library which passed rows to the block.  Use CSV::foreach() for that behavior.) &#xA; You must provide a +mode+ with an embedded Encoding designator unless your data is in Encoding::default_external().  CSV will check the Encoding of the underlying IO object (set by the +mode+ you pass) to determine how to parse the data.   You may provide a second Encoding to have the data transcoded as it is read just as you can with a normal call to IO::open().  For example, &quot;rb:UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it. &#xA; An opened CSV object will delegate to many IO methods for convenience.  You may call: &#xA; binmode()&#xA;binmode?()&#xA;close()&#xA;close_read()&#xA;close_write()&#xA;closed?()&#xA;eof()&#xA;eof?()" />
        <scope name="parse" ilk="function" signature="parse(*args, &amp;block)" attributes="__classmethod__" doc="This method can be used to easily parse CSV out of a String.  You may either provide a +block+ which will be called with each row of the String in turn, or just use the returned Array of Arrays (when no +block+ is given). &#xA; You pass your +str+ to read from, and an optional +options+ Hash containing anything CSV::new() understands." />
        <scope name="parse_line" ilk="function" signature="parse_line(line, options = Hash.new)" attributes="__classmethod__" doc="This method is a shortcut for converting a single line of a CSV String into a into an Array.  Note that if +line+ contains multiple rows, anything beyond the first row is ignored. &#xA; The +options+ parameter can be anything CSV::new() understands." />
        <scope name="read" ilk="function" signature="read(path, options = Hash.new)" attributes="__classmethod__" doc="Use to slurp a CSV file into an Array of Arrays.  Pass the +path+ to the file and any +options+ CSV::new() understands.  This method also understands an additional :encoding parameter that you can use to specify the Encoding of the data in the file to be read. You must provide this unless your data is in Encoding::default_external().  CSV will use this to determine how to parse the data.  You may provide a second Encoding to have the data transcoded as it is read.  For example, encoding: &quot;UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" attributes="__classmethod__" doc="Alias for CSV::read()." />
        <scope name="table" ilk="function" signature="table(path, options = Hash.new)" attributes="__classmethod__" doc="A shortcut for: &#xA;   CSV.read( path, { headers:           true,&#xA;                    converters:        :numeric,&#xA;                    header_converters: :symbol }.merge(options) )" />
        <scope name="add_row" ilk="function" signature="add_row(row)" />
        <scope name="convert" ilk="function" signature="convert(name = nil, &amp;converter)" doc="You can use this method to install a CSV::Converters built-in, or provide a block that handles a custom conversion. &#xA; If you provide a block that takes one argument, it will be passed the field and is expected to return the converted value or the field itself.  If your block takes two arguments, it will also be passed a CSV::FieldInfo Struct, containing details about the field.  Again, the block should return a converted field or the field itself." />
        <scope name="converters" ilk="function" signature="converters()" doc="Returns the current list of converters in effect.  See CSV::new for details. Built-in converters will be returned by name, while others will be returned as is." />
        <scope name="each" ilk="function" signature="each()" doc="Yields each row of the data source in turn. &#xA; Support for Enumerable. &#xA; The data source must be open for reading." />
        <scope name="force_quotes?" ilk="function" signature="force_quotes?()" doc="Returns +true+ if all output fields are quoted. See CSV::new for details." />
        <scope name="gets" ilk="function" signature="gets()" />
        <scope name="header_convert" ilk="function" signature="header_convert(name = nil, &amp;converter)" doc="Identical to CSV#convert(), but for header rows. &#xA; Note that this method must be called before header rows are read to have any effect." />
        <scope name="header_converters" ilk="function" signature="header_converters()" doc="Returns the current list of converters in effect for headers.  See CSV::new for details.  Built-in converters will be returned by name, while others will be returned as is." />
        <scope name="header_row?" ilk="function" signature="header_row?()" doc="Returns +true+ if the next row read will be a header row." />
        <scope name="headers" ilk="function" signature="headers()" doc="Returns +nil+ if headers will not be used, +true+ if they will but have not yet been read, or the actual headers after they have been read.  See CSV::new for details." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a simplified description of the key CSV attributes in an ASCII compatible String." />
        <scope name="puts" ilk="function" signature="puts(row)" />
        <scope name="read" ilk="function" signature="read()" doc="Slurps the remaining rows and returns an Array of Arrays. &#xA; The data source must be open for reading." />
        <scope name="readline" ilk="function" signature="readline()" />
        <scope name="readlines" ilk="function" signature="readlines()" />
        <scope name="return_headers?" ilk="function" signature="return_headers?()" doc="Returns +true+ if headers will be returned as a row of results. See CSV::new for details." />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the underlying IO object and resets CSV&apos;s lineno() counter." />
        <scope name="shift" ilk="function" signature="shift()" doc="The primary read method for wrapped Strings and IOs, a single row is pulled from the data source, parsed and returned as an Array of fields (if header rows are not used) or a CSV::Row (when header rows are used). &#xA; The data source must be open for reading." />
        <scope name="skip_blanks?" ilk="function" signature="skip_blanks?()" doc="Returns +true+ blank lines are skipped by the parser. See CSV::new for details." />
        <scope name="unconverted_fields?" ilk="function" signature="unconverted_fields?()" doc="Returns +true+ if unconverted_fields() to parsed results.  See CSV::new for details." />
        <scope name="write_headers?" ilk="function" signature="write_headers?()" doc="Returns +true+ if headers are written in output. See CSV::new for details." />
        <scope ilk="function" name="col_sep" />
        <scope ilk="function" name="encoding" />
        <scope ilk="function" name="field_size_limit" />
        <scope ilk="function" name="lineno" />
        <scope ilk="function" name="quote_char" />
        <scope ilk="function" name="row_sep" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_OPTIONS" attributes="__const__" citdl="Object" />
        <scope name="MalformedCSVError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="Row" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(headers, fields, header_row = false)" attributes="__classmethod__ __ctor__" doc="Construct a new CSV::Row from +headers+ and +fields+, which are expected to be Arrays.  If one Array is shorter than the other, it will be padded with +nil+ objects. &#xA; The optional +header_row+ parameter can be set to +true+ to indicate, via CSV::Row.header_row?() and CSV::Row.field_row?(), that this is a header row.  Otherwise, the row is assumes to be a field row. &#xA; A CSV::Row object supports the following Array methods through delegation: &#xA; empty?()&#xA;length()&#xA;size()" />
          <scope name="delete" ilk="function" signature="delete(header_or_index, minimum_index = 0)" doc="Used to remove a pair from the row by +header+ or +index+.  The pair is located as described in CSV::Row.field().  The deleted pair is returned, or +nil+ if a pair could not be found." />
          <scope name="delete_if" ilk="function" signature="delete_if(&amp;block)" doc="The provided +block+ is passed a header and field for each pair in the row and expected to return +true+ or +false+, depending on whether the pair should be deleted. &#xA; This method returns the row for chaining." />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Yields each pair of the row as header and field tuples (much like iterating over a Hash). &#xA; Support for Enumerable. &#xA; This method returns the row for chaining." />
          <scope name="field" ilk="function" signature="field(header_or_index, minimum_index = 0)" doc="This method will fetch the field value by +header+ or +index+.  If a field is not found, +nil+ is returned. &#xA; When provided, +offset+ ensures that a header match occurrs on or later than the +offset+ index.  You can use this to find duplicate headers, without resorting to hard-coding exact indices." />
          <scope name="field?" ilk="function" signature="field?(data)" doc="Returns +true+ if +data+ matches a field in this row, and +false+ otherwise." />
          <scope name="field_row?" ilk="function" signature="field_row?()" doc="Returns +true+ if this is a field row." />
          <scope name="fields" ilk="function" signature="fields(*headers_and_or_indices)" doc="This method accepts any number of arguments which can be headers, indices, Ranges of either, or two-element Arrays containing a header and offset. Each argument will be replaced with a field lookup as described in CSV::Row.field(). &#xA; If called with no arguments, all fields are returned." />
          <scope name="header?" ilk="function" signature="header?(name)" doc="Returns +true+ if +name+ is a header for this row, and +false+ otherwise." />
          <scope name="header_row?" ilk="function" signature="header_row?()" doc="Returns +true+ if this is a header row." />
          <scope name="headers" ilk="function" signature="headers()" doc="Returns the headers of this row." />
          <scope name="include?" ilk="function" signature="include?(name)" />
          <scope name="index" ilk="function" signature="index(header, minimum_index = 0)" doc="This method will return the index of a field with the provided +header+. The +offset+ can be used to locate duplicate header names, as described in CSV::Row.field()." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="A summary of fields, by header, in an ASCII compatible String." />
          <scope name="push" ilk="function" signature="push(*args)" doc="A shortcut for appending multiple fields.  Equivalent to: &#xA;   args.each { |arg| csv_row &lt;&lt; arg }&#xA; This method returns the row for chaining." />
          <scope name="to_csv" ilk="function" signature="to_csv(options = Hash.new)" doc="Returns the row as a CSV String.  Headers are not used.  Equivalent to: &#xA;   csv_row.fields.to_csv( options )" />
          <scope name="to_hash" ilk="function" signature="to_hash()" doc="Collapses the row into a simple Hash.  Be warning that this discards field order and clobbers duplicate fields." />
          <scope name="to_s" ilk="function" signature="to_s(options = Hash.new)" />
          <scope name="values_at" ilk="function" signature="values_at(*headers_and_or_indices)" />
          <scope ilk="function" name="row" />
        </scope>
        <scope name="Table" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(array_of_rows)" attributes="__classmethod__ __ctor__" doc="Construct a new CSV::Table from +array_of_rows+, which are expected to be CSV::Row objects.  All rows are assumed to have the same headers. &#xA; A CSV::Table object supports the following Array methods through delegation: &#xA; empty?()&#xA;length()&#xA;size()" />
          <scope name="by_col" ilk="function" signature="by_col()" doc="Returns a duplicate table object, in column mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_col!" ilk="function" signature="by_col!()" doc="Switches the mode of this table to column mode.  All calls to indexing and iteration methods will work with columns until the mode is changed again. &#xA; This method returns the table and is safe to chain." />
          <scope name="by_col_or_row" ilk="function" signature="by_col_or_row()" doc="Returns a duplicate table object, in mixed mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_col_or_row!" ilk="function" signature="by_col_or_row!()" doc="Switches the mode of this table to mixed mode.  All calls to indexing and iteration methods will use the default intelligent indexing system until the mode is changed again.  In mixed mode an index is assumed to be a row reference while anything else is assumed to be column access by headers. &#xA; This method returns the table and is safe to chain." />
          <scope name="by_row" ilk="function" signature="by_row()" doc="Returns a duplicate table object, in row mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_row!" ilk="function" signature="by_row!()" doc="Switches the mode of this table to row mode.  All calls to indexing and iteration methods will work with rows until the mode is changed again. &#xA; This method returns the table and is safe to chain." />
          <scope name="delete" ilk="function" signature="delete(index_or_header)" doc="Removes and returns the indicated column or row.  In the default mixed mode indices refer to rows and everything else is assumed to be a column header.  Use by_col!() or by_row!() to force the lookup." />
          <scope name="delete_if" ilk="function" signature="delete_if(&amp;block)" doc="Removes any column or row for which the block returns +true+.  In the default mixed mode or row mode, iteration is the standard row major walking of rows.  In column mode, interation will +yield+ two element tuples containing the column name and an Array of values for that column. &#xA; This method returns the table for chaining." />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="In the default mixed mode or row mode, iteration is the standard row major walking of rows.  In column mode, interation will +yield+ two element tuples containing the column name and an Array of values for that column. &#xA; This method returns the table for chaining." />
          <scope name="headers" ilk="function" signature="headers()" doc="Returns the headers for the first row of this table (assumed to match all other rows).  An empty Array is returned for empty tables." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Shows the mode and size of this table in a US-ASCII String." />
          <scope name="push" ilk="function" signature="push(*rows)" doc="A shortcut for appending multiple rows.  Equivalent to: &#xA;   rows.each { |row| self &lt;&lt; row }&#xA; This method returns the table for chaining." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Returns the table as an Array of Arrays.  Headers will be the first row, then all of the field rows will follow." />
          <scope name="to_csv" ilk="function" signature="to_csv(options = Hash.new)" doc="Returns the table as a complete CSV String.  Headers will be listed first, then all of the field rows. &#xA; This method assumes you want the Table.headers(), unless you explicitly pass :write_headers =&gt; false." />
          <scope name="to_s" ilk="function" signature="to_s(options = Hash.new)" />
          <scope name="values_at" ilk="function" signature="values_at(*indices_or_headers)" doc="The mixed mode default is to treat a list of indices as row access, returning the rows indicated.  Anything else is considered columnar access.  For columnar access, the return set has an Array for each row with the values indicated by the headers in each Array.  You can force column or row mode using by_col!() or by_row!(). &#xA; You cannot mix column and row access." />
          <scope ilk="function" name="mode" />
          <scope ilk="function" name="table" />
        </scope>
      </scope>
    </scope>
    <scope name="digest" ilk="blob" lang="Ruby">
      <scope name="Digest" ilk="namespace">
        <scope name="hexencode" ilk="function" signature="hexencode(p1)" attributes="__classmethod__" doc="Generates a hex-encoded version of a given _string_." />
        <scope name="Base" ilk="class" classrefs="Digest::Class">
        </scope>
        <scope name="Class" ilk="class" classrefs="Object">
          <import symbol="Digest::Instance" />
          <scope name="digest" ilk="function" signature="digest(...)" attributes="__classmethod__" doc="Returns the hash value of a given _string_.  This is equivalent to Digest::Class.new(*parameters).digest(string), where extra _parameters_, if any, are passed through to the constructor and the _string_ is passed to #digest()." />
          <scope name="hexdigest" ilk="function" signature="hexdigest(...)" attributes="__classmethod__" doc="Returns the hex-encoded hash value of a given _string_.  This is almost equivalent to Digest.hexencode(Digest::Class.new(*parameters).digest(string))." />
        </scope>
        <scope name="Instance" ilk="namespace">
          <scope name="block_length" ilk="function" signature="block_length()" doc="Returns the block length of the digest. &#xA; This method is overridden by each implementation subclass." />
          <scope name="digest" ilk="function" signature="digest(...)" doc="If none is given, returns the resulting hash value of the digest, keeping the digest&apos;s state. &#xA; If a _string_ is given, returns the hash value for the given _string_, resetting the digest to the initial state before and after the process." />
          <scope name="digest!" ilk="function" signature="digest!()" doc="Returns the resulting hash value and resets the digest to the initial state." />
          <scope name="digest_length" ilk="function" signature="digest_length()" doc="Returns the length of the hash value of the digest. &#xA; This method should be overridden by each implementation subclass. If not, digest_obj.digest().length() is returned." />
          <scope name="hexdigest" ilk="function" signature="hexdigest(...)" doc="If none is given, returns the resulting hash value of the digest in a hex-encoded form, keeping the digest&apos;s state. &#xA; If a _string_ is given, returns the hash value for the given _string_ in a hex-encoded form, resetting the digest to the initial state before and after the process." />
          <scope name="hexdigest!" ilk="function" signature="hexdigest!()" doc="Returns the resulting hash value in a hex-encoded form and resets the digest to the initial state." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Creates a printable version of the digest object." />
          <scope name="length" ilk="function" signature="length()" doc="Returns digest_obj.digest_length()." />
          <scope name="new" ilk="function" signature="new()" doc="Returns a new, initialized copy of the digest object.  Equivalent to digest_obj.clone().reset()." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the digest to the initial state and returns self. &#xA; This method is overridden by each implementation subclass." />
          <scope name="size" ilk="function" signature="size()" doc="Returns digest_obj.digest_length()." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns digest_obj.hexdigest()." />
          <scope name="update" ilk="function" signature="update(p1)" doc="Updates the digest using a given _string_ and returns self. &#xA; The update() method and the left-shift operator are overridden by each implementation subclass. (One should be an alias for the other)" />
        </scope>
      </scope>
    </scope>
    <scope name="drb" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="config" ilk="function" signature="config()" attributes="__classmethod__" doc="Get the configuration of the current server. &#xA; If there is no current server, this returns the default configuration. See #current_server and DRbServer::make_config." />
        <scope name="current_server" ilk="function" signature="current_server()" attributes="__classmethod__" doc="Get the &apos;current&apos; server. &#xA; In the context of execution taking place within the main thread of a dRuby server (typically, as a result of a remote call on the server or one of its objects), the current server is that server.  Otherwise, the current server is the primary server. &#xA; If the above rule fails to find a server, a DRbServerNotFound error is raised." />
        <scope name="fetch_server" ilk="function" signature="fetch_server(uri)" attributes="__classmethod__" />
        <scope name="front" ilk="function" signature="front()" attributes="__classmethod__" doc="Get the front object of the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="here?" ilk="function" signature="here?(uri)" attributes="__classmethod__" doc="Is +uri+ the URI for the current local server?" />
        <scope name="install_acl" ilk="function" signature="install_acl(acl)" attributes="__classmethod__" doc="Set the default acl. &#xA; See DRb::DRbServer.default_acl." />
        <scope name="install_id_conv" ilk="function" signature="install_id_conv(idconv)" attributes="__classmethod__" doc="Set the default id conv object. &#xA; See DRbServer#default_id_conv." />
        <scope name="mutex" ilk="function" signature="mutex()" attributes="__classmethod__" />
        <scope name="regist_server" ilk="function" signature="regist_server(server)" attributes="__classmethod__" />
        <scope name="remove_server" ilk="function" signature="remove_server(server)" attributes="__classmethod__" />
        <scope name="start_service" ilk="function" signature="start_service(uri=nil, front=nil, config=nil)" attributes="__classmethod__" doc="Start a dRuby server locally. &#xA; The new dRuby server will become the primary server, even if another server is currently the primary server. &#xA; +uri+ is the URI for the server to bind to.  If nil, the server will bind to random port on the default local host name and use the default dRuby protocol. &#xA; +front+ is the server&apos;s front object.  This may be nil. &#xA; +config+ is the configuration for the new server.  This may be nil. &#xA; See DRbServer::new." />
        <scope name="stop_service" ilk="function" signature="stop_service()" attributes="__classmethod__" doc="Stop the local dRuby server. &#xA; This operates on the primary server.  If there is no primary server currently running, it is a noop." />
        <scope name="thread" ilk="function" signature="thread()" attributes="__classmethod__" doc="Get the thread of the primary server. &#xA; This returns nil if there is no primary server.  See #primary_server." />
        <scope name="to_id" ilk="function" signature="to_id(obj)" attributes="__classmethod__" doc="Get a reference id for an object using the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="to_obj" ilk="function" signature="to_obj(ref)" attributes="__classmethod__" doc="Convert a reference into an object using the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="uri" ilk="function" signature="uri()" attributes="__classmethod__" doc="Get the URI defining the local dRuby space. &#xA; This is the URI of the current server.  See #current_server." />
        <scope ilk="function" name="primary_server" />
        <scope ilk="function" name="primary_server=" />
        <scope ilk="function" name="primary_server" />
        <scope ilk="function" name="primary_server=" />
      </scope>
    </scope>
    <scope name="drb/drb" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbArray" ilk="class" classrefs="Object">
          <scope name="_load" ilk="function" signature="_load(s)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(ary)" attributes="__classmethod__ __ctor__" />
          <scope name="_dump" ilk="function" signature="_dump(lv)" />
        </scope>
        <scope name="DRbBadScheme" ilk="class" classrefs="DRbError">
        </scope>
        <scope name="DRbBadURI" ilk="class" classrefs="DRbError">
        </scope>
        <scope name="DRbConn" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbConnError" ilk="class" classrefs="DRbError">
        </scope>
        <scope name="DRbError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="DRbIdConv" ilk="class" classrefs="Object">
          <scope name="to_id" ilk="function" signature="to_id(obj)" doc="Convert an object into a reference id. &#xA; This implementation returns the object&apos;s __id__ in the local object space." />
          <scope name="to_obj" ilk="function" />
        </scope>
        <scope name="DRbMessage" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbProtocol" ilk="namespace">
          <scope name="add_protocol" ilk="function" signature="add_protocol(prot)" attributes="__classmethod__" doc="Add a new protocol to the DRbProtocol module." />
          <scope name="open" ilk="function" signature="open(uri, config, first=true)" attributes="__classmethod__" doc="Open a client connection to +uri+ with the configuration +config+. &#xA; The DRbProtocol module asks each registered protocol in turn to try to open the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised.  If a protocol accepts the URI, but an error occurs in opening it, a DRbConnError is raised." />
          <scope name="open_server" ilk="function" signature="open_server(uri, config, first=true)" attributes="__classmethod__" doc="Open a server listening for connections at +uri+ with configuration +config+. &#xA; The DRbProtocol module asks each registered protocol in turn to try to open a server at the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised.  If a protocol accepts the URI, but an error occurs in opening it, the underlying error is passed on to the caller." />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config, first=true)" attributes="__classmethod__" doc="Parse +uri+ into a [uri, option] pair. &#xA; The DRbProtocol module asks each registered protocol in turn to try to parse the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised." />
        </scope>
        <scope name="DRbRemoteError" ilk="class" classrefs="DRbError">
          <scope name="new" ilk="function" signature="new(error)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="reason" />
        </scope>
        <scope name="DRbServer" ilk="namespace">
          <scope name="InvokeMethod" ilk="class" classrefs="Object">
          </scope>
        </scope>
        <scope name="DRbServerNotFound" ilk="class" classrefs="DRbError">
        </scope>
        <scope name="DRbTCPSocket" ilk="class" classrefs="Object">
          <scope name="getservername" ilk="function" signature="getservername()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(uri, soc, config={})" attributes="__classmethod__ __ctor__" doc="Create a new DRbTCPSocket instance. &#xA; +uri+ is the URI we are connected to. +soc+ is the tcp socket we are bound to.  +config+ is our configuration." />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" doc="Open a client connection to +uri+ using configuration +config+." />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" doc="Open a server listening for connections at +uri+ using configuration +config+." />
          <scope name="open_server_inaddr_any" ilk="function" signature="open_server_inaddr_any(host, port)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" doc="Parse +uri+ into a [uri, option] pair." />
          <scope name="accept" ilk="function" signature="accept()" doc="On the server side, for an instance returned by #open_server, accept a client connection and return a new instance to handle the server&apos;s side of this client-server session." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="Check to see if this connection is alive." />
          <scope name="close" ilk="function" signature="close()" doc="Close the connection. &#xA; If this is an instance returned by #open_server, then this stops listening for new connections altogether.  If this is an instance returned by #open or by #accept, then it closes this particular client-server session." />
          <scope name="peeraddr" ilk="function" signature="peeraddr()" doc="Get the address of our TCP peer (the other end of the socket we are bound to." />
          <scope name="recv_reply" ilk="function" signature="recv_reply()" doc="On the client side, receive a reply from the server." />
          <scope name="recv_request" ilk="function" signature="recv_request()" doc="On the server side, receive a request from the client." />
          <scope name="send_reply" ilk="function" signature="send_reply(succ, result)" doc="On the server side, send a reply to the client." />
          <scope name="send_request" ilk="function" signature="send_request(ref, msg_id, arg, b)" doc="On the client side, send a request to the server." />
          <scope name="stream" ilk="function" signature="stream()" doc="Get the socket." />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="DRbURIOption" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbUndumped" ilk="namespace">
        </scope>
        <scope name="DRbUnknown" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(err, buf)" attributes="__classmethod__ __ctor__" doc="Create a new DRbUnknown object. &#xA; +buf+ is a string containing a marshalled object that could not be unmarshalled.  +err+ is the error message that was raised when the unmarshalling failed.  It is used to determine the name of the unmarshalled object." />
          <scope name="exception" ilk="function" signature="exception()" doc="Create a DRbUnknownError exception containing this object." />
          <scope name="reload" ilk="function" signature="reload()" doc="Attempt to load the wrapped marshalled object again. &#xA; If the class of the object is now known locally, the object will be unmarshalled and returned.  Otherwise, a new but identical DRbUnknown object will be returned." />
          <scope ilk="function" name="buf" />
          <scope ilk="function" name="name" />
        </scope>
        <scope name="DRbUnknownError" ilk="class" classrefs="DRbError">
          <scope name="new" ilk="function" signature="new(unknown)" attributes="__classmethod__ __ctor__" doc="Create a new DRbUnknownError for the DRb::DRbUnknown object +unknown+" />
          <scope ilk="function" name="unknown" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/extserv" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="ExtServ" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(there, name, server=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="alive?" ilk="function" signature="alive?()" />
          <scope name="front" ilk="function" signature="front()" />
          <scope name="stop_service" ilk="function" signature="stop_service()" />
          <scope ilk="function" name="server" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/extservm" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="ExtServManager" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="command" ilk="function" signature="command()" attributes="__classmethod__" />
          <scope name="command=" ilk="function" signature="command=(cmd)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="regist" ilk="function" signature="regist(name, ro)" />
          <scope name="service" ilk="function" signature="service(name)" />
          <scope name="unregist" ilk="function" signature="unregist(name)" />
          <scope ilk="function" name="uri" />
          <scope ilk="function" name="uri=" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/gw" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbObject" ilk="class" classrefs="Object">
          <scope name="_load" ilk="function" signature="_load(s)" attributes="__classmethod__" doc="Unmarshall a marshalled DRbObject. &#xA; If the referenced object is located within the local server, then the object itself is returned.  Otherwise, a new DRbObject is created to act as a stub for the remote referenced object." />
          <scope name="new" ilk="function" signature="new(obj, uri=nil)" attributes="__classmethod__ __ctor__" doc="Create a new remote object stub. &#xA; +obj+ is the (local) object we want to create a stub for.  Normally this is +nil+.  +uri+ is the URI of the remote object that this will be a stub for." />
          <scope name="new_with" ilk="function" signature="new_with(uri, ref)" attributes="__classmethod__" />
          <scope name="new_with_uri" ilk="function" attributes="__classmethod__" />
          <scope name="prepare_backtrace" ilk="function" signature="prepare_backtrace(uri, result)" attributes="__classmethod__" />
          <scope name="with_friend" ilk="function" signature="with_friend(uri)" attributes="__classmethod__" />
          <scope name="__drbref" ilk="function" signature="__drbref()" doc="Get the reference of the object, if local." />
          <scope name="__drburi" ilk="function" />
          <scope name="_dump" ilk="function" signature="_dump(lv)" doc="Marshall this object. &#xA; The URI and ref of the object are marshalled." />
          <scope name="eql?" ilk="function" signature="eql?(other)" />
          <scope name="hash" ilk="function" />
          <scope name="method_missing" ilk="function" signature="method_missing(msg_id, *a, &amp;b)" doc="Routes method calls to the referenced object." />
          <scope name="respond_to?" ilk="function" />
        </scope>
        <scope name="GW" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="GWIdConv" ilk="class" classrefs="DRbIdConv">
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/invokemethod" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbServer" ilk="class" classrefs="Object">
          <scope name="default_acl" ilk="function" signature="default_acl(acl)" attributes="__classmethod__" doc="Set the default value for the :acl option. &#xA; See #new().  The initial default value is nil." />
          <scope name="default_argc_limit" ilk="function" signature="default_argc_limit(argc)" attributes="__classmethod__" doc="Set the default value for the :argc_limit option. &#xA; See #new().  The initial default value is 256." />
          <scope name="default_id_conv" ilk="function" signature="default_id_conv(idconv)" attributes="__classmethod__" doc="Set the default value for the :id_conv option. &#xA; See #new().  The initial default value is a DRbIdConv instance." />
          <scope name="default_load_limit" ilk="function" signature="default_load_limit(sz)" attributes="__classmethod__" doc="Set the default value for the :load_limit option. &#xA; See #new().  The initial default value is 25 MB." />
          <scope name="default_safe_level" ilk="function" signature="default_safe_level(level)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(uri=nil, front=nil, config_or_acl=nil)" attributes="__classmethod__ __ctor__" doc="Create a new DRbServer instance. &#xA; +uri+ is the URI to bind to.  This is normally of the form &apos;druby://&lt;hostname&gt;:&lt;port&gt;&apos; where &lt;hostname&gt; is a hostname of the local machine.  If nil, then the system&apos;s default hostname will be bound to, on a port selected by the system; these value can be retrieved from the +uri+ attribute.  &apos;druby:&apos; specifies the default dRuby transport protocol: another protocol, such as &apos;drbunix:&apos;, can be specified instead. &#xA; +front+ is the front object for the server, that is, the object to which remote method calls on the server will be passed.  If nil, then the server will not accept remote method calls. &#xA; If +config_or_acl+ is a hash, it is the configuration to use for this server.  The following options are recognised: &#xA; an id-to-object conversion object.  This defaults to an instance of the class DRb::DRbIdConv.&#xA;if true, all unsuccessful remote calls on objects in the server will be logged to $stdout. false by default.&#xA;the access control list for this server.  See the ACL class from the main dRuby distribution.&#xA;the maximum message size in bytes accepted by the server.  Defaults to 25 MB (26214400).&#xA;the maximum number of arguments to a remote method accepted by the server.  Defaults to 256. &#xA; The default values of these options can be modified on a class-wide basis by the class methods #default_argc_limit, #default_load_limit, #default_acl, #default_id_conv, and #verbose= &#xA; If +config_or_acl+ is not a hash, but is not nil, it is assumed to be the access control list for this server. See the :tcp_acl option for more details. &#xA; If no other server is currently set as the primary server, this will become the primary server. &#xA; The server will immediately start running in its own thread." />
          <scope name="verbose" ilk="function" signature="verbose()" attributes="__classmethod__" doc="Get the default value of the :verbose option." />
          <scope name="verbose=" ilk="function" signature="verbose=(on)" attributes="__classmethod__" doc="Set the default value of the :verbose option. &#xA; See #new().  The initial default value is false." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="Is this server alive?" />
          <scope name="check_insecure_method" ilk="function" signature="check_insecure_method(obj, msg_id)" doc="Check that a method is callable via dRuby. &#xA; +obj+ is the object we want to invoke the method on. +msg_id+ is the method name, as a Symbol. &#xA; If the method is an insecure method (see #insecure_method?) a SecurityError is thrown.  If the method is private or undefined, a NameError is thrown." />
          <scope name="stop_service" ilk="function" signature="stop_service()" doc="Stop this server." />
          <scope name="to_id" ilk="function" signature="to_id(obj)" doc="Convert a local object to a dRuby reference." />
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" doc="Convert a dRuby reference to the local object it refers to." />
          <scope name="verbose" ilk="function" signature="verbose()" doc="Get whether the server is in verbose mode. &#xA; In verbose mode, failed calls are logged to stdout." />
          <scope name="verbose=" ilk="function" signature="verbose=(v)" doc="Set whether to operate in verbose mode. &#xA; In verbose mode, failed calls are logged to stdout." />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="front" />
          <scope ilk="function" name="safe_level" />
          <scope ilk="function" name="thread" />
          <scope ilk="function" name="uri" />
          <variable name="INSECURE_METHOD" attributes="__const__" citdl="Object" />
          <scope name="InvokeMethod18Mixin" ilk="namespace">
            <scope name="block_yield" ilk="function" signature="block_yield(x)" />
            <scope name="perform_with_block" ilk="function" signature="perform_with_block()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/observer" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbObservable" ilk="namespace">
          <import symbol="Observable" />
          <scope name="notify_observers" ilk="function" signature="notify_observers(*arg)" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/ssl" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbSSLSocket" ilk="class" classrefs="DRbTCPSocket">
          <scope name="new" ilk="function" signature="new(uri, soc, config, is_established)" attributes="__classmethod__ __ctor__" />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" />
          <scope name="parse_uri" ilk="function" signature="parse_uri(uri)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" />
          <scope name="accept" ilk="function" signature="accept()" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="stream" ilk="function" signature="stream()" />
          <scope name="SSLConfig" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" />
            <scope name="accept" ilk="function" signature="accept(tcp)" />
            <scope name="connect" ilk="function" signature="connect(tcp)" />
            <scope name="setup_certificate" ilk="function" signature="setup_certificate()" />
            <scope name="setup_ssl_context" ilk="function" signature="setup_ssl_context()" />
            <variable name="DEFAULT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/timeridconv" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="TimerIdConv" ilk="class" classrefs="DRbIdConv">
          <scope name="new" ilk="function" signature="new(timeout=600)" attributes="__classmethod__ __ctor__" />
          <scope name="to_id" ilk="function" signature="to_id(obj)" />
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" />
          <scope name="TimerHolder2" ilk="class" classrefs="Object">
            <import symbol="MonitorMixin" />
            <scope name="new" ilk="function" signature="new(timeout=600)" attributes="__classmethod__ __ctor__" />
            <scope name="add" ilk="function" signature="add(obj)" />
            <scope name="fetch" ilk="function" signature="fetch(key, dv=@sentinel)" />
            <scope name="include?" ilk="function" signature="include?(key)" />
            <scope name="peek" ilk="function" signature="peek(key)" />
            <scope name="InvalidIndexError" ilk="class" classrefs="RuntimeError">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/unix" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbUNIXSocket" ilk="class" classrefs="DRbTCPSocket">
          <scope name="new" ilk="function" signature="new(uri, soc, config={}, server_mode = false)" attributes="__classmethod__ __ctor__" />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" />
          <scope name="parse_uri" ilk="function" signature="parse_uri(uri)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" />
          <scope name="accept" ilk="function" signature="accept()" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="set_sockopt" ilk="function" signature="set_sockopt(soc)" />
        </scope>
      </scope>
    </scope>
    <scope name="erb" ilk="blob" lang="Ruby">
      <scope name="ERB" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(str, safe_level=nil, trim_mode=nil, eoutvar=&apos;_erbout&apos;)" attributes="__classmethod__ __ctor__" doc="Constructs a new ERB object with the template specified in _str_. &#xA; An ERB object works by building a chunk of Ruby code that will output the completed template when run. If _safe_level_ is set to a non-nil value, ERB code will be run in a separate thread with &lt;b&gt;$SAFE&lt;/b&gt; set to the provided level. &#xA; If _trim_mode_ is passed a String containing one or more of the following modifiers, ERB will adjust its code generation as listed: &#xA;     %  enables Ruby code processing for lines beginning with %&#xA;    &lt;&gt; omit newline for lines starting with &lt;% and ending in %&gt;&#xA;    &gt;  omit newline for lines ending in %&gt;&#xA; _eoutvar_ can be used to set the name of the variable ERB will build up its output in.  This is useful when you need to run multiple ERB templates through the same binding and/or when you want to control where output ends up.  Pass the name of the variable to be used inside a String. &#xA; Example &#xA;  require &quot;erb&quot;&#xA; # build data class&#xA; class Listings&#xA;   PRODUCT = { :name =&gt; &quot;Chicken Fried Steak&quot;,&#xA;               :desc =&gt; &quot;A well messages pattie, breaded and fried.&quot;," />
        <scope name="version" ilk="function" signature="version()" attributes="__classmethod__" doc="Returns revision information for the erb.rb module." />
        <scope name="def_class" ilk="function" signature="def_class(superklass=Object, methodname=&apos;result&apos;)" doc="Define unnamed class which has _methodname_ as instance method, and return it. &#xA; example:   class MyClass_&#xA;    def initialize(arg1, arg2)&#xA;      @arg1 = arg1;  @arg2 = arg2&#xA;    end&#xA;  end&#xA;  filename = &apos;example.rhtml&apos;  # @arg1 and @arg2 are used in example.rhtml&#xA;  erb = ERB.new(File.read(filename))&#xA;  erb.filename = filename&#xA;  MyClass = erb.def_class(MyClass_, &apos;render()&apos;)&#xA;  print MyClass.new(&apos;foo&apos;, 123).render()" />
        <scope name="def_method" ilk="function" signature="def_method(mod, methodname, fname=&apos;(ERB)&apos;)" doc="Define _methodname_ as instance method of _mod_ from compiled ruby source. &#xA; example:   filename = &apos;example.rhtml&apos;   # &apos;arg1&apos; and &apos;arg2&apos; are used in example.rhtml&#xA;  erb = ERB.new(File.read(filename))&#xA;  erb.def_method(MyClass, &apos;render(arg1, arg2)&apos;, filename)&#xA;  print MyClass.new.render(&apos;foo&apos;, 123)" />
        <scope name="def_module" ilk="function" signature="def_module(methodname=&apos;erb&apos;)" doc="Create unnamed module, define _methodname_ as instance method of it, and return it. &#xA; example:   filename = &apos;example.rhtml&apos;   # &apos;arg1&apos; and &apos;arg2&apos; are used in example.rhtml&#xA;  erb = ERB.new(File.read(filename))&#xA;  erb.filename = filename&#xA;  MyModule = erb.def_module(&apos;render(arg1, arg2)&apos;)&#xA;  class MyClass&#xA;    include MyModule&#xA;  end" />
        <scope name="result" ilk="function" signature="result(b=TOPLEVEL_BINDING)" doc="Executes the generated ERB code to produce a completed template, returning the results of that code.  (See ERB#new for details on how this process can be affected by _safe_level_.) &#xA; _b_ accepts a Binding or Proc object which is used to set the context of code evaluation." />
        <scope name="run" ilk="function" signature="run(b=TOPLEVEL_BINDING)" doc="Generate results and print them. (see ERB#result)" />
        <scope name="set_eoutvar" ilk="function" signature="set_eoutvar(compiler, eoutvar = &apos;_erbout&apos;)" doc="Can be used to set _eoutvar_ as described in ERB#new.  It&apos;s probably easier to just use the constructor though, since calling this method requires the setup of an ERB _compiler_ object." />
        <scope ilk="function" name="filename" />
        <scope ilk="function" name="filename=" />
        <scope ilk="function" name="src" />
        <scope name="Compiler" ilk="class" classrefs="Object">
          <scope name="Buffer" ilk="class" classrefs="Object">
          </scope>
          <scope name="ExplicitScanner" ilk="class" classrefs="Scanner">
          </scope>
          <scope name="PercentLine" ilk="class" classrefs="Object">
          </scope>
          <scope name="Scanner" ilk="class" classrefs="Object">
          </scope>
          <scope name="SimpleScanner" ilk="class" classrefs="Scanner">
          </scope>
          <scope name="SimpleScanner2" ilk="class" classrefs="Scanner">
          </scope>
          <scope name="TrimScanner" ilk="class" classrefs="Scanner">
          </scope>
        </scope>
        <scope name="DefMethod" ilk="namespace">
          <scope name="def_erb_method" ilk="function" signature="def_erb_method(methodname, erb_or_fname)" attributes="__classmethod__" doc="define _methodname_ as instance method of current module, using ERB object or eRuby file" />
        </scope>
        <scope name="Util" ilk="namespace">
          <scope name="h" ilk="function" signature="h(s)" attributes="__classmethod__" />
          <scope name="html_escape" ilk="function" signature="html_escape(s)" attributes="__classmethod__" doc="A utility method for escaping HTML tag characters in _s_. &#xA;   require &quot;erb&quot;&#xA;  include ERB::Util&#xA;&#xA;  puts html_escape(&quot;is a &gt; 0 &amp; a &lt; 10?&quot;)&#xA; _Generates_ &#xA;   is a &amp;gt; 0 &amp;amp; a &amp;lt; 10?" />
          <scope name="u" ilk="function" signature="u(s)" attributes="__classmethod__" />
          <scope name="url_encode" ilk="function" signature="url_encode(s)" attributes="__classmethod__" doc="A utility method for encoding the String _s_ as a URL. &#xA;   require &quot;erb&quot;&#xA;  include ERB::Util&#xA;&#xA;  puts url_encode(&quot;Programming Ruby:  The Pragmatic Programmer&apos;s Guide&quot;)&#xA; _Generates_ &#xA;   Programming%20Ruby%3A%20%20The%20Pragmatic%20Programmer%27s%20Guide" />
        </scope>
      </scope>
    </scope>
    <scope name="etc" ilk="blob" lang="Ruby">
      <scope name="Etc" ilk="namespace">
        <scope name="endgrent" ilk="function" signature="endgrent()" attributes="__classmethod__" doc="Ends the process of scanning through the /etc/group file begun by getgrent, and closes the file." />
        <scope name="endpwent" ilk="function" signature="endpwent()" attributes="__classmethod__" doc="Ends the process of scanning through the /etc/passwd file begun with getpwent, and closes the file." />
        <scope name="getgrent" ilk="function" signature="getgrent()" attributes="__classmethod__" doc="Returns an entry from the /etc/group file. The first time it is called it opens the file and returns the first entry; each successive call returns the next entry, or nil if the end of the file has been reached. &#xA; To close the file when processing is complete, call endgrent. &#xA; Each entry is returned as a Struct::Group: &#xA; Group#name contains the name of the group as a String. &#xA;&#xA;Group#passwd contains the encrypted password as a String. An &apos;x&apos; is returned if password access to the group is not available; an empty string is returned if no password is needed to obtain membership of the group. &#xA;&#xA;Group#gid contains the group&apos;s numeric ID as an integer. &#xA;&#xA;Group#mem is an Array of Strings containing the short login names of the members of the group." />
        <scope name="getgrgid" ilk="function" signature="getgrgid(...)" attributes="__classmethod__" doc="Returns information about the group with specified integer group id (gid), as found in /etc/group. &#xA; The information is returned as a Struct::Group; see getgrent above for details. &#xA; e.g.  Etc.getgrgid(100) -&gt; #&lt;struct Struct::Group name=&quot;users&quot;, passwd=&quot;x&quot;, gid=100, mem=[&quot;meta&quot;, &quot;root&quot;]&gt;" />
        <scope name="getgrnam" ilk="function" signature="getgrnam(p1)" attributes="__classmethod__" doc="Returns information about the group with specified String name, as found in /etc/group. &#xA; The information is returned as a Struct::Group; see getgrent above for details. &#xA; e.g.  Etc.getgrnam(&apos;users&apos;) -&gt; #&lt;struct Struct::Group name=&quot;users&quot;, passwd=&quot;x&quot;, gid=100, mem=[&quot;meta&quot;, &quot;root&quot;]&gt;" />
        <scope name="getlogin" ilk="function" signature="getlogin()" attributes="__classmethod__" doc="Returns the short user name of the currently logged in user. Unfortunately, it is often rather easy to fool getlogin(). Avoid getlogin() for security-related purposes. &#xA; e.g.   Etc.getlogin -&gt; &apos;guest&apos;" />
        <scope name="getpwent" ilk="function" signature="getpwent()" attributes="__classmethod__" doc="Returns an entry from the /etc/passwd file. The first time it is called it opens the file and returns the first entry; each successive call returns the next entry, or nil if the end of the file has been reached. &#xA; To close the file when processing is complete, call endpwent. &#xA; Each entry is returned as a Struct::Passwd: &#xA; Passwd#name contains the short login name of the user as a String. &#xA;&#xA;Passwd#passwd contains the encrypted password of the user as a String. an &apos;x&apos; is returned if shadow passwords are in use. An &apos;*&apos; is returned if the user cannot log in using a password. &#xA;&#xA;Passwd#uid contains the integer user ID (uid) of the user. &#xA;&#xA;Passwd#gid contains the integer group ID (gid) of the user&apos;s primary group. &#xA;&#xA;Passwd#gecos contains a longer String description of the user, such as a full name. Some Unix systems provide structured information in the gecos field, but this is system-dependent. &#xA;&#xA;Passwd#dir contains the path to the home directory of the user as a String. &#xA;&#xA;Passwd#shell contains the path to the login shell of the user as a String." />
        <scope name="getpwnam" ilk="function" signature="getpwnam(p1)" attributes="__classmethod__" doc="Returns the /etc/passwd information for the user with specified login name. &#xA; The information is returned as a Struct::Passwd; see getpwent above for details. &#xA; e.g.  * Etc.getpwnam(&apos;root&apos;) -&gt; #&lt;struct Struct::Passwd name=&quot;root&quot;, passwd=&quot;x&quot;, uid=0, gid=0, gecos=&quot;root&quot;,dir=&quot;/root&quot;, shell=&quot;/bin/bash&quot;&gt;" />
        <scope name="getpwuid" ilk="function" signature="getpwuid(...)" attributes="__classmethod__" doc="Returns the /etc/passwd information for the user with specified integer user id (uid). &#xA; The information is returned as a Struct::Passwd; see getpwent above for details. &#xA; e.g.  * Etc.getpwuid(0) -&gt; #&lt;struct Struct::Passwd name=&quot;root&quot;, passwd=&quot;x&quot;, uid=0, gid=0, gecos=&quot;root&quot;,dir=&quot;/root&quot;, shell=&quot;/bin/bash&quot;&gt;" />
        <scope name="group" ilk="function" signature="group()" attributes="__classmethod__" doc="Provides a convenient Ruby iterator which executes a block for each entry in the /etc/group file. &#xA; The code block is passed an Struct::Group struct; see getgrent above for details. &#xA; Example: &#xA;     require &apos;etc&apos;&#xA;&#xA;    Etc.group {|g|&#xA;      puts g.name + &quot;: &quot; + g.mem.join(&apos;, &apos;)&#xA;    }" />
        <scope name="passwd" ilk="function" signature="passwd()" attributes="__classmethod__" doc="Provides a convenient Ruby iterator which executes a block for each entry in the /etc/passwd file. &#xA; The code block is passed an Struct::Passwd struct; see getpwent above for details. &#xA; Example: &#xA;     require &apos;etc&apos;&#xA;&#xA;    Etc.passwd {|u|&#xA;      puts u.name + &quot; = &quot; + u.gecos&#xA;    }" />
        <scope name="setgrent" ilk="function" signature="setgrent()" attributes="__classmethod__" doc="Resets the process of reading the /etc/group file, so that the next call to getgrent will return the first entry again." />
        <scope name="setpwent" ilk="function" signature="setpwent()" attributes="__classmethod__" doc="Resets the process of reading the /etc/passwd file, so that the next call to getpwent will return the first entry again." />
        <scope name="sysconfdir" ilk="function" signature="sysconfdir()" attributes="__classmethod__" doc="Returns system configuration directory." />
        <scope name="systmpdir" ilk="function" signature="systmpdir()" attributes="__classmethod__" doc="Returns system temporary directory." />
      </scope>
    </scope>
    <scope name="fcntl" ilk="blob" lang="Ruby">
      <scope name="Fcntl" ilk="namespace">
        <variable name="F_DUPFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETLK" attributes="__const__" citdl="Object" />
        <variable name="F_SETFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETFL" attributes="__const__" citdl="Object" />
        <variable name="F_SETFL" attributes="__const__" citdl="Object" />
        <variable name="F_SETLK" attributes="__const__" citdl="Object" />
        <variable name="F_SETLKW" attributes="__const__" citdl="Object" />
        <variable name="FD_CLOEXEC" attributes="__const__" citdl="Object" />
        <variable name="F_RDLCK" attributes="__const__" citdl="Object" />
        <variable name="F_UNLCK" attributes="__const__" citdl="Object" />
        <variable name="F_WRLCK" attributes="__const__" citdl="Object" />
        <variable name="O_CREAT" attributes="__const__" citdl="Object" />
        <variable name="O_EXCL" attributes="__const__" citdl="Object" />
        <variable name="O_NOCTTY" attributes="__const__" citdl="Object" />
        <variable name="O_TRUNC" attributes="__const__" citdl="Object" />
        <variable name="O_APPEND" attributes="__const__" citdl="Object" />
        <variable name="O_NONBLOCK" attributes="__const__" citdl="Object" />
        <variable name="O_NDELAY" attributes="__const__" citdl="Object" />
        <variable name="O_RDONLY" attributes="__const__" citdl="Object" />
        <variable name="O_RDWR" attributes="__const__" citdl="Object" />
        <variable name="O_WRONLY" attributes="__const__" citdl="Object" />
        <variable name="O_ACCMODE" attributes="__const__" citdl="Object" />
        <variable name="O_ACCMODE" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="fileutils" ilk="blob" lang="Ruby">
      <scope name="FileUtils" ilk="namespace">
        <import symbol="StreamUtils_" />
        <scope name="cd" ilk="function" signature="cd(dir, options = {})" attributes="__classmethod__" doc="Options: verbose &#xA; Changes the current directory to the directory +dir+. &#xA; If this method is called with block, resumes to the old working directory after the block execution finished. &#xA;   FileUtils.cd(&apos;/&apos;, :verbose =&gt; true)   # chdir and report it" />
        <scope name="chdir" ilk="function" signature="chdir(dir, options = {})" attributes="__classmethod__" />
        <scope name="chmod" ilk="function" signature="chmod(mode, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Changes permission bits on the named files (in +list+) to the bit pattern represented by +mode+. &#xA;   FileUtils.chmod 0755, &apos;somecommand&apos;&#xA;  FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)&#xA;  FileUtils.chmod 0755, &apos;/usr/bin/ruby&apos;, :verbose =&gt; true" />
        <scope name="chmod_R" ilk="function" signature="chmod_R(mode, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose force &#xA; Changes permission bits on the named files (in +list+) to the bit pattern represented by +mode+. &#xA;   FileUtils.chmod_R 0700, &quot;/tmp/app.#{$$}&quot;" />
        <scope name="chown" ilk="function" signature="chown(user, group, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Changes owner and group on the named files (in +list+) to the user +user+ and the group +group+.  +user+ and +group+ may be an ID (Integer/String) or a name (String). If +user+ or +group+ is nil, this method does not change the attribute. &#xA;   FileUtils.chown &apos;root&apos;, &apos;staff&apos;, &apos;/usr/local/bin/ruby&apos;&#xA;  FileUtils.chown nil, &apos;bin&apos;, Dir.glob(&apos;/usr/bin/*&apos;), :verbose =&gt; true" />
        <scope name="chown_R" ilk="function" signature="chown_R(user, group, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose force &#xA; Changes owner and group on the named files (in +list+) to the user +user+ and the group +group+ recursively. +user+ and +group+ may be an ID (Integer/String) or a name (String).  If +user+ or +group+ is nil, this method does not change the attribute. &#xA;   FileUtils.chown_R &apos;www&apos;, &apos;www&apos;, &apos;/var/www/htdocs&apos;&#xA;  FileUtils.chown_R &apos;cvs&apos;, &apos;cvs&apos;, &apos;/var/cvs&apos;, :verbose =&gt; true" />
        <scope name="cmp" ilk="function" signature="cmp(a, b)" attributes="__classmethod__" />
        <scope name="compare_file" ilk="function" signature="compare_file(a, b)" attributes="__classmethod__" doc="Returns true if the contents of a file A and a file B are identical. &#xA;   FileUtils.compare_file(&apos;somefile&apos;, &apos;somefile&apos;)  =&gt; true&#xA;  FileUtils.compare_file(&apos;/bin/cp&apos;, &apos;/bin/mv&apos;)    =&gt; maybe false" />
        <scope name="compare_stream" ilk="function" signature="compare_stream(a, b)" attributes="__classmethod__" doc="Returns true if the contents of a stream +a+ and +b+ are identical." />
        <scope name="copy" ilk="function" signature="copy(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="copy_entry" ilk="function" signature="copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)" attributes="__classmethod__" doc="Copies a file system entry +src+ to +dest+. If +src+ is a directory, this method copies its contents recursively. This method preserves file types, c.f. symlink, directory... (FIFO, device files and etc. are not supported yet) &#xA; Both of +src+ and +dest+ must be a path name. +src+ must exist, +dest+ must not exist. &#xA; If +preserve+ is true, this method preserves owner, group, permissions and modified time. &#xA; If +dereference_root+ is true, this method dereference tree root. &#xA; If +remove_destination+ is true, this method removes each destination file before copy." />
        <scope name="copy_file" ilk="function" signature="copy_file(src, dest, preserve = false, dereference = true)" attributes="__classmethod__" doc="Copies file contents of +src+ to +dest+. Both of +src+ and +dest+ must be a path name." />
        <scope name="copy_stream" ilk="function" signature="copy_stream(src, dest)" attributes="__classmethod__" doc="Copies stream +src+ to +dest+. +src+ must respond to #read(n) and +dest+ must respond to #write(str)." />
        <scope name="cp" ilk="function" signature="cp(src, dest, options = {})" attributes="__classmethod__" doc="Options: preserve noop verbose &#xA; Copies a file content +src+ to +dest+.  If +dest+ is a directory, copies +src+ to +dest/src+. &#xA; If +src+ is a list of files, then +dest+ must be a directory. &#xA;   FileUtils.cp &apos;eval.c&apos;, &apos;eval.c.org&apos;&#xA;  FileUtils.cp %w(cgi.rb complex.rb date.rb), &apos;/usr/lib/ruby/1.6&apos;&#xA;  FileUtils.cp %w(cgi.rb complex.rb date.rb), &apos;/usr/lib/ruby/1.6&apos;, :verbose =&gt; true&#xA;  FileUtils.cp &apos;symlink&apos;, &apos;dest&apos;   # copy content, &quot;dest&quot; is not a symlink" />
        <scope name="cp_r" ilk="function" signature="cp_r(src, dest, options = {})" attributes="__classmethod__" doc="Options: preserve noop verbose dereference_root remove_destination &#xA; Copies +src+ to +dest+. If +src+ is a directory, this method copies all its contents recursively. If +dest+ is a directory, copies +src+ to +dest/src+. &#xA; +src+ can be a list of files. &#xA;   # Installing ruby library &quot;mylib&quot; under the site_ruby&#xA;  FileUtils.rm_r site_ruby + &apos;/mylib&apos;, :force&#xA;  FileUtils.cp_r &apos;lib/&apos;, site_ruby + &apos;/mylib&apos;&#xA;  # Examples of copying several files to target directory.&#xA;  FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + &apos;/tmail&apos;&#xA;  FileUtils.cp_r Dir.glob(&apos;*.rb&apos;), &apos;/home/aamine/lib/ruby&apos;, :noop =&gt; true, :verbose =&gt; true&#xA;  # If you want to copy all contents of a directory instead of the&#xA;  # directory itself, c.f. src/x -&gt; dest/x, src/y -&gt; dest/y,&#xA;  # use following code.&#xA;  FileUtils.cp_r &apos;src/.&apos;, &apos;dest&apos;     # cp_r(&apos;src&apos;, &apos;dest&apos;) makes src/dest," />
        <scope name="getwd" ilk="function" signature="getwd()" attributes="__classmethod__" />
        <scope name="identical?" ilk="function" signature="identical?(a, b)" attributes="__classmethod__" />
        <scope name="install" ilk="function" signature="install(src, dest, options = {})" attributes="__classmethod__" doc="Options: mode preserve noop verbose &#xA; If +src+ is not same as +dest+, copies it and changes the permission mode to +mode+.  If +dest+ is a directory, destination is +dest+/+src+. This method removes destination before copy. &#xA;   FileUtils.install &apos;ruby&apos;, &apos;/usr/local/bin/ruby&apos;, :mode =&gt; 0755, :verbose =&gt; true&#xA;  FileUtils.install &apos;lib.rb&apos;, &apos;/usr/local/lib/ruby/site_ruby&apos;, :verbose =&gt; true" />
        <scope name="link" ilk="function" signature="link(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="ln" ilk="function" signature="ln(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; &lt;b&gt;ln(old, new, options = {})&lt;/b&gt; &#xA; Creates a hard link +new+ which points to +old+. If +new+ already exists and it is a directory, creates a link +new/old+. If +new+ already exists and it is not a directory, raises Errno::EEXIST. But if :force option is set, overwrite +new+. &#xA;   FileUtils.ln &apos;gcc&apos;, &apos;cc&apos;, :verbose =&gt; true&#xA;  FileUtils.ln &apos;/usr/bin/emacs21&apos;, &apos;/usr/bin/emacs&apos;&#xA; &lt;b&gt;ln(list, destdir, options = {})&lt;/b&gt; &#xA; Creates several hard links in a directory, with each one pointing to the item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA;   include FileUtils&#xA;  cd &apos;/sbin&apos;&#xA;  FileUtils.ln %w(cp mv mkdir), &apos;/bin&apos;   # Now /sbin/cp and /bin/cp are linked." />
        <scope name="ln_s" ilk="function" signature="ln_s(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; &lt;b&gt;ln_s(old, new, options = {})&lt;/b&gt; &#xA; Creates a symbolic link +new+ which points to +old+.  If +new+ already exists and it is a directory, creates a symbolic link +new/old+.  If +new+ already exists and it is not a directory, raises Errno::EEXIST.  But if :force option is set, overwrite +new+. &#xA;   FileUtils.ln_s &apos;/usr/bin/ruby&apos;, &apos;/usr/local/bin/ruby&apos;&#xA;  FileUtils.ln_s &apos;verylongsourcefilename.c&apos;, &apos;c&apos;, :force =&gt; true&#xA; &lt;b&gt;ln_s(list, destdir, options = {})&lt;/b&gt; &#xA; Creates several symbolic links in a directory, with each one pointing to the item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA; If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA;   FileUtils.ln_s Dir.glob(&apos;bin/*.rb&apos;), &apos;/home/aamine/bin&apos;" />
        <scope name="ln_sf" ilk="function" signature="ln_sf(src, dest, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Same as   #ln_s(src, dest, :force)" />
        <scope name="makedirs" ilk="function" signature="makedirs(list, options = {})" attributes="__classmethod__" />
        <scope name="mkdir" ilk="function" signature="mkdir(list, options = {})" attributes="__classmethod__" doc="Options: mode noop verbose &#xA; Creates one or more directories. &#xA;   FileUtils.mkdir &apos;test&apos;&#xA;  FileUtils.mkdir %w( tmp data )&#xA;  FileUtils.mkdir &apos;notexist&apos;, :noop =&gt; true  # Does not really create.&#xA;  FileUtils.mkdir &apos;tmp&apos;, :mode =&gt; 0700" />
        <scope name="mkdir_p" ilk="function" signature="mkdir_p(list, options = {})" attributes="__classmethod__" doc="Options: mode noop verbose &#xA; Creates a directory and all its parent directories. For example, &#xA;   FileUtils.mkdir_p &apos;/usr/local/lib/ruby&apos;&#xA; causes to make following directories, if it does not exist.     * /usr&#xA;    * /usr/local&#xA;    * /usr/local/lib&#xA;    * /usr/local/lib/ruby&#xA; You can pass several directories at a time in a list." />
        <scope name="mkpath" ilk="function" signature="mkpath(list, options = {})" attributes="__classmethod__" />
        <scope name="move" ilk="function" signature="move(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="mv" ilk="function" signature="mv(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; Moves file(s) +src+ to +dest+.  If +file+ and +dest+ exist on the different disk partition, the file is copied then the original file is removed. &#xA;   FileUtils.mv &apos;badname.rb&apos;, &apos;goodname.rb&apos;&#xA;  FileUtils.mv &apos;stuff.rb&apos;, &apos;/notexist/lib/ruby&apos;, :force =&gt; true  # no error&#xA;&#xA;  FileUtils.mv %w(junk.txt dust.txt), &apos;/home/aamine/.trash/&apos;&#xA;  FileUtils.mv Dir.glob(&apos;test*.rb&apos;), &apos;test&apos;, :noop =&gt; true, :verbose =&gt; true" />
        <scope name="pwd" ilk="function" signature="pwd()" attributes="__classmethod__" doc="Options: (none) &#xA; Returns the name of the current directory." />
        <scope name="remove" ilk="function" signature="remove(list, options = {})" attributes="__classmethod__" />
        <scope name="remove_dir" ilk="function" signature="remove_dir(path, force = false)" attributes="__classmethod__" doc="Removes a directory +dir+ and its contents recursively. This method ignores StandardError if +force+ is true." />
        <scope name="remove_entry" ilk="function" signature="remove_entry(path, force = false)" attributes="__classmethod__" doc="This method removes a file system entry +path+. +path+ might be a regular file, a directory, or something. If +path+ is a directory, remove it recursively. &#xA; See also #remove_entry_secure." />
        <scope name="remove_entry_secure" ilk="function" signature="remove_entry_secure(path, force = false)" attributes="__classmethod__" doc="This method removes a file system entry +path+.  +path+ shall be a regular file, a directory, or something.  If +path+ is a directory, remove it recursively.  This method is required to avoid TOCTTOU (time-of-check-to-time-of-use) local security vulnerability of #rm_r. #rm_r causes security hole when: &#xA;   * Parent directory is world writable (including /tmp).&#xA;  * Removing directory tree includes world writable directory.&#xA;  * The system has symbolic link.&#xA; To avoid this security hole, this method applies special preprocess. If +path+ is a directory, this method chown(2) and chmod(2) all removing directories.  This requires the current process is the owner of the removing whole directory tree, or is the super user (root). &#xA; WARNING: You must ensure that *ALL* parent directories are not world writable.  Otherwise this method does not work. Only exception is temporary directory like /tmp and /var/tmp, whose permission is 1777. &#xA; WARNING: Only the owner of the removing directory tree, or Unix super user (root) should invoke this method.  Otherwise this method does not work. &#xA; For details of this security vulnerability, see Perl&apos;s case: &#xA;   http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448&#xA;  http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452&#xA; For fileutils.rb, this vulnerability is reported in [ruby-dev:26100]." />
        <scope name="remove_file" ilk="function" signature="remove_file(path, force = false)" attributes="__classmethod__" doc="Removes a file +path+. This method ignores StandardError if +force+ is true." />
        <scope name="rm" ilk="function" signature="rm(list, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; Remove file(s) specified in +list+.  This method cannot remove directories. All StandardErrors are ignored when the :force option is set. &#xA;   FileUtils.rm %w( junk.txt dust.txt )&#xA;  FileUtils.rm Dir.glob(&apos;*.so&apos;)&#xA;  FileUtils.rm &apos;NotExistFile&apos;, :force =&gt; true   # never raises exception" />
        <scope name="rm_f" ilk="function" signature="rm_f(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Equivalent to &#xA;   #rm(list, :force =&gt; true)" />
        <scope name="rm_r" ilk="function" signature="rm_r(list, options = {})" attributes="__classmethod__" doc="Options: force noop verbose secure &#xA; remove files +list+[0] +list+[1]... If +list+[n] is a directory, removes its all contents recursively. This method ignores StandardError when :force option is set. &#xA;   FileUtils.rm_r Dir.glob(&apos;/tmp/*&apos;)&#xA;  FileUtils.rm_r &apos;/&apos;, :force =&gt; true          #  :-)&#xA; WARNING: This method causes local vulnerability if one of parent directories or removing directory tree are world writable (including /tmp, whose permission is 1777), and the current process has strong privilege such as Unix super user (root), and the system has symbolic link.  For secure removing, read the documentation of #remove_entry_secure carefully, and set :secure option to true. Default is :secure=&gt;false. &#xA; NOTE: This method calls #remove_entry_secure if :secure option is set. See also #remove_entry_secure." />
        <scope name="rm_rf" ilk="function" signature="rm_rf(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose secure &#xA; Equivalent to &#xA;   #rm_r(list, :force =&gt; true)&#xA; WARNING: This method causes local vulnerability. Read the documentation of #rm_r first." />
        <scope name="rmdir" ilk="function" signature="rmdir(list, options = {})" attributes="__classmethod__" doc="Options: noop, verbose &#xA; Removes one or more directories. &#xA;   FileUtils.rmdir &apos;somedir&apos;&#xA;  FileUtils.rmdir %w(somedir anydir otherdir)&#xA;  # Does not really remove directory; outputs message.&#xA;  FileUtils.rmdir &apos;somedir&apos;, :verbose =&gt; true, :noop =&gt; true" />
        <scope name="rmtree" ilk="function" signature="rmtree(list, options = {})" attributes="__classmethod__" />
        <scope name="safe_unlink" ilk="function" signature="safe_unlink(list, options = {})" attributes="__classmethod__" />
        <scope name="symlink" ilk="function" signature="symlink(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="touch" ilk="function" signature="touch(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Updates modification time (mtime) and access time (atime) of file(s) in +list+.  Files are created if they don&apos;t exist. &#xA;   FileUtils.touch &apos;timestamp&apos;&#xA;  FileUtils.touch Dir.glob(&apos;*.c&apos;);  system &apos;make&apos;" />
        <scope name="uptodate?" ilk="function" signature="uptodate?(new, old_list, options = nil)" attributes="__classmethod__" doc="Options: (none) &#xA; Returns true if +newer+ is newer than all +old_list+. Non-existent files are older than any file. &#xA;   FileUtils.uptodate?(&apos;hello.o&apos;, %w(hello.c hello.h)) or \&#xA;      system &apos;make hello.o&apos;" />
        <scope name="fu_have_symlink?" ilk="function" signature="fu_have_symlink?()" />
        <variable name="METHODS" attributes="__const__" citdl="Object" />
        <scope name="DryRun" ilk="namespace">
          <import symbol="FileUtils" />
        </scope>
        <scope name="Entry_" ilk="class" classrefs="Object">
        </scope>
        <scope name="NoWrite" ilk="namespace">
          <import symbol="FileUtils" />
        </scope>
        <scope name="StreamUtils_" ilk="namespace">
        </scope>
        <scope name="Verbose" ilk="namespace">
          <import symbol="FileUtils" />
        </scope>
      </scope>
    </scope>
    <scope name="find" ilk="blob" lang="Ruby">
      <scope name="Find" ilk="namespace">
        <scope name="find" ilk="function" signature="find(*paths)" attributes="__classmethod__" doc="Calls the associated block with the name of every file and directory listed as arguments, then recursively on their subdirectories, and so on. &#xA; See the +Find+ module documentation for an example." />
        <scope name="prune" ilk="function" signature="prune()" attributes="__classmethod__" doc="Skips the current file or directory, restarting the loop with the next entry. If the current file is a directory, that directory will not be recursively entered. Meaningful only within the block associated with Find::find. &#xA; See the +Find+ module documentation for an example." />
      </scope>
    </scope>
    <scope name="forwardable" ilk="blob" lang="Ruby">
      <scope name="Forwardable" ilk="namespace">
        <scope name="def_delegator" ilk="function" signature="def_delegator(accessor, method, ali = method)" />
        <scope name="def_delegators" ilk="function" signature="def_delegators(accessor, *methods)" />
        <scope name="def_instance_delegator" ilk="function" signature="def_instance_delegator(accessor, method, ali = method)" />
        <scope name="def_instance_delegators" ilk="function" signature="def_instance_delegators(accessor, *methods)" doc="Shortcut for defining multiple delegator methods, but with no provision for using a different name.  The following two code samples have the same effect: &#xA;   def_delegators :@records, :size, :&lt;&lt;, :map&#xA;&#xA;  def_delegator :@records, :size&#xA;  def_delegator :@records, :&lt;&lt;&#xA;  def_delegator :@records, :map" />
        <scope name="delegate" ilk="function" signature="delegate(hash)" />
        <scope name="instance_delegate" ilk="function" signature="instance_delegate(hash)" doc="Takes a hash as its argument.  The key is a symbol or an array of symbols.  These symbols correspond to method names.  The value is the accessor to which the methods will be delegated." />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <variable name="FORWARDABLE_VERSION" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="gdbm" ilk="blob" lang="Ruby">
      <scope name="GDBM" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a new GDBM instance by opening a gdbm file named _filename_. If the file does not exist, a new file with file mode _mode_ will be created. _flags_ may be one of the following: *READER*  - open as a reader&#xA;*WRITER*  - open as a writer&#xA;*WRCREAT* - open as a writer; if the database does not exist, create a new one&#xA;*NEWDB*   - open as a writer; overwrite any existing databases &#xA; The values *WRITER*, *WRCREAT* and *NEWDB* may be combined with the following values by bitwise or: *SYNC*    - cause all database operations to be synchronized to the disk&#xA;*NOLOCK*  - do not lock the database file &#xA; If no _flags_ are specified, the GDBM object will try to open the database file as a writer and will create it if it does not already exist (cf. flag WRCREAT). If this fails (for instance, if another process has already opened the database as a reader), it will try to open the database file as a reader (cf. flag READER)." />
        <scope name="open" ilk="function" signature="open(...)" attributes="__classmethod__" doc="If called without a block, this is synonymous to GDBM::new. If a block is given, the new GDBM instance will be passed to the block as a parameter, and the corresponding database file will be closed after the execution of the block code has been finished. &#xA; Example for an open call with a block: &#xA;   require &apos;gdbm&apos;&#xA;  GDBM.open(&quot;fruitstore.db&quot;) do |gdbm|&#xA;    gdbm.each_pair do |key, value|&#xA;      print &quot;#{key}: #{value}\n&quot;&#xA;    end&#xA;  end" />
        <scope name="cachesize=" ilk="function" signature="cachesize=(p1)" doc="Sets the size of the internal bucket cache to _size_." />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all the key-value pairs within _gdbm_." />
        <scope name="close" ilk="function" signature="close()" doc="Closes the associated database file." />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if the associated database file has been closed." />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Removes the key-value-pair with the specified _key_ from this database and returns the corresponding _value_. Returns nil if the database is empty." />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every key-value pair from _gdbm_ for which _block_ evaluates to true." />
        <scope name="each" ilk="function" signature="each()" doc="Executes _block_ for each key in the database, passing the _key_ and the correspoding _value_ as a parameter." />
        <scope name="each_key" ilk="function" signature="each_key()" doc="Executes _block_ for each key in the database, passing the _key_ as a parameter." />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Executes _block_ for each key in the database, passing the _key_ and the correspoding _value_ as a parameter." />
        <scope name="each_value" ilk="function" signature="each_value()" doc="Executes _block_ for each key in the database, passing the corresponding _value_ as a parameter." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if the database is empty." />
        <scope name="fastmode=" ilk="function" signature="fastmode=(p1)" doc="Turns the database&apos;s fast mode on or off. If fast mode is turned on, gdbm does not wait for writes to be flushed to the disk before continuing. &#xA; This option is obsolete for gdbm &gt;= 1.8 since fast mode is turned on by default. See also: #syncmode=" />
        <scope name="fetch" ilk="function" signature="fetch(...)" doc="Retrieves the _value_ corresponding to _key_. If there is no value associated with _key_, _default_ will be returned instead." />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" doc="Returns true if the given value _v_ exists within the database. Returns false otherwise." />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="invert" ilk="function" signature="invert()" doc="Returns a hash created by using _gdbm_&apos;s values as keys, and the keys as values." />
        <scope name="key" ilk="function" signature="key(p1)" doc="Returns the _key_ for a given _value_. If several keys may map to the same value, the key that is found first will be returned." />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns an array of all keys of this database." />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of key-value pairs in this database." />
        <scope name="member?" ilk="function" signature="member?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="reject" ilk="function" signature="reject()" doc="Returns a hash copy of _gdbm_ where all key-value pairs from _gdbm_ for which _block_ evaluates to true are removed. See also: #delete_if" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Deletes every key-value pair from _gdbm_ for which _block_ evaluates to true." />
        <scope name="reorganize" ilk="function" signature="reorganize()" doc="Reorganizes the database file. This operation removes reserved space of elements that have already been deleted. It is only useful after a lot of deletions in the database." />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the content of _gdbm_ with the key-value pairs of _other_. _other_ must have an each_pair method." />
        <scope name="select" ilk="function" signature="select()" doc="Returns a new array of all key-value pairs of the database for which _block_ evaluates to true." />
        <scope name="shift" ilk="function" signature="shift()" doc="Removes a key-value-pair from this database and returns it as a two-item array [ _key_, _value_ ]. Returns nil if the database is empty." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of key-value pairs in this database." />
        <scope name="store" ilk="function" signature="store(p1, p2)" doc="Associates the value _value_ with the specified _key_." />
        <scope name="sync" ilk="function" signature="sync()" doc="Unless the _gdbm_ object has been opened with the *SYNC* flag, it is not guarenteed that database modification operations are immediately applied to the database file. This method ensures that all recent modifications to the database are written to the file. Blocks until all writing operations to the disk have been finished." />
        <scope name="syncmode=" ilk="function" signature="syncmode=(p1)" doc="Turns the database&apos;s synchronization mode on or off. If the synchronization mode is turned on, the database&apos;s in-memory state will be synchronized to disk after every database modification operation. If the synchronization mode is turned off, GDBM does not wait for writes to be flushed to the disk before continuing. &#xA; This option is only available for gdbm &gt;= 1.8 where syncmode is turned off by default. See also: #fastmode=" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns an array of all key-value pairs contained in the database." />
        <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns a hash of all key-value pairs contained in the database." />
        <scope name="update" ilk="function" signature="update(p1)" doc="Adds the key-value pairs of _other_ to _gdbm_, overwriting entries with duplicate keys with those from _other_. _other_ must have an each_pair method." />
        <scope name="value?" ilk="function" signature="value?(p1)" doc="Returns true if the given value _v_ exists within the database. Returns false otherwise." />
        <scope name="values" ilk="function" signature="values()" doc="Returns an array of all values of this database." />
        <scope name="values_at" ilk="function" signature="values_at(...)" doc="Returns an array of the values associated with each specified _key_." />
        <variable name="READER" attributes="__const__" citdl="Object" />
        <variable name="WRITER" attributes="__const__" citdl="Object" />
        <variable name="WRCREAT" attributes="__const__" citdl="Object" />
        <variable name="NEWDB" attributes="__const__" citdl="Object" />
        <variable name="FAST" attributes="__const__" citdl="Object" />
        <variable name="SYNC" attributes="__const__" citdl="Object" />
        <variable name="NOLOCK" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="getoptlong" ilk="blob" lang="Ruby">
      <scope name="GetoptLong" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(*arguments)" attributes="__classmethod__ __ctor__" doc="Set up option processing. &#xA; The options to support are passed to new() as an array of arrays. Each sub-array contains any number of String option names which carry the same meaning, and one of the following flags: &#xA; Option does not take an argument. &#xA;&#xA;Option always takes an argument. &#xA;&#xA;Option may or may not take an argument. &#xA; The first option name is considered to be the preferred (canonical) name. Other than that, the elements of each sub-array can be in any order." />
        <scope name="each" ilk="function" signature="each()" doc="Iterator version of `get&apos;. &#xA; The block is called repeatedly with two arguments: The first is the option name. The second is the argument which followed it (if any). Example: (&apos;--opt&apos;, &apos;value&apos;) &#xA; The option name is always converted to the first (preferred) name given in the original options to GetoptLong.new." />
        <scope name="each_option" ilk="function" signature="each_option()" doc="`each_option&apos; is an alias of `each&apos;." />
        <scope name="error_message" ilk="function" signature="error_message()" doc="Return the appropriate error message in POSIX-defined format. If no error has occurred, returns nil." />
        <scope name="get" ilk="function" signature="get()" doc="Get next option name and its argument, as an Array of two elements. &#xA; The option name is always converted to the first (preferred) name given in the original options to GetoptLong.new. &#xA; Example: [&apos;--option&apos;, &apos;value&apos;] &#xA; Returns nil if the processing is complete (as determined by STATUS_TERMINATED)." />
        <scope name="get_option" ilk="function" signature="get_option()" doc="`get_option&apos; is an alias of `get&apos;." />
        <scope name="ordering=" ilk="function" signature="ordering=(ordering)" doc="Set the handling of the ordering of options and arguments. A RuntimeError is raised if option processing has already started. &#xA; The supplied value must be a member of GetoptLong::ORDERINGS. It alters the processing of options as follows: &#xA; &lt;b&gt;REQUIRE_ORDER&lt;/b&gt; : &#xA; Options are required to occur before non-options. &#xA; Processing of options ends as soon as a word is encountered that has not been preceded by an appropriate option flag. &#xA; For example, if -a and -b are options which do not take arguments, parsing command line arguments of &apos;-a one -b two&apos; would result in &apos;one&apos;, &apos;-b&apos;, &apos;two&apos; being left in ARGV, and only (&apos;-a&apos;, &apos;&apos;) being processed as an option/arg pair. &#xA; This is the default ordering, if the environment variable POSIXLY_CORRECT is set. (This is for compatibility with GNU getopt_long.) &#xA; &lt;b&gt;PERMUTE&lt;/b&gt; : &#xA; Options can occur anywhere in the command line parsed. This is the default behavior. &#xA; Every sequence of words which can be interpreted as an option (with or without argument) is treated as an option; non-option words are skipped. &#xA; For example, if -a does not require an argument and -b optionally takes an argument, parsing &apos;-a one -b two three&apos; would result in (&apos;-a&apos;,&apos;&apos;) and (&apos;-b&apos;, &apos;two&apos;) being processed as option/arg pairs, and &apos;one&apos;,&apos;three&apos; being left in ARGV. &#xA; If the ordering is set to PERMUTE but the environment variable POSIXLY_CORRECT is set, REQUIRE_ORDER is used instead. This is for compatibility with GNU getopt_long. &#xA; &lt;b&gt;RETURN_IN_ORDER&lt;/b&gt; : " />
        <scope name="set_options" ilk="function" signature="set_options(*arguments)" doc="Set options. Takes the same argument as GetoptLong.new. &#xA; Raises a RuntimeError if option processing has already started." />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Explicitly terminate option processing." />
        <scope name="terminated?" ilk="function" signature="terminated?()" doc="Returns true if option processing has terminated, false otherwise." />
        <scope ilk="function" name="error" />
        <scope ilk="function" name="ordering" />
        <scope ilk="function" name="quiet=" />
        <scope ilk="function" name="quiet" />
        <variable name="ORDERINGS" attributes="__const__" citdl="Object" />
        <variable name="ARGUMENT_FLAGS" attributes="__const__" citdl="Object" />
        <variable name="STATUS_TERMINATED" attributes="__const__" citdl="Object" />
        <scope name="AmbiguousOption" ilk="class" classrefs="Error">
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="InvalidOption" ilk="class" classrefs="Error">
        </scope>
        <scope name="MissingArgument" ilk="class" classrefs="Error">
        </scope>
        <scope name="NeedlessArgument" ilk="class" classrefs="Error">
        </scope>
      </scope>
    </scope>
    <scope name="gserver" ilk="blob" lang="Ruby">
      <scope name="GServer" ilk="class" classrefs="Object">
        <scope name="in_service?" ilk="function" signature="in_service?(port, host = DEFAULT_HOST)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(port, host = DEFAULT_HOST, maxConnections = 4, stdlog = $stderr, audit = false, debug = false)" attributes="__classmethod__ __ctor__" />
        <scope name="stop" ilk="function" signature="stop(port, host = DEFAULT_HOST)" attributes="__classmethod__" />
        <scope name="connections" ilk="function" signature="connections()" />
        <scope name="join" ilk="function" signature="join()" />
        <scope name="serve" ilk="function" signature="serve(io)" />
        <scope name="shutdown" ilk="function" signature="shutdown()" />
        <scope name="start" ilk="function" signature="start(maxConnections = -1)" />
        <scope name="stop" ilk="function" signature="stop()" />
        <scope name="stopped?" ilk="function" signature="stopped?()" />
        <scope ilk="function" name="audit" />
        <scope ilk="function" name="audit=" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="host" />
        <scope ilk="function" name="maxConnections" />
        <scope ilk="function" name="port" />
        <scope ilk="function" name="stdlog" />
        <scope ilk="function" name="stdlog=" />
        <variable name="DEFAULT_HOST" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="iconv" ilk="blob" lang="Ruby">
      <scope name="Iconv" ilk="class" classrefs="Data">
        <scope name="charset_map" ilk="function" signature="charset_map()" attributes="__classmethod__" doc="Returns the map from canonical name to system dependent name." />
        <scope name="conv" ilk="function" signature="conv(p1, p2, p3)" attributes="__classmethod__" doc="Shorthand for   Iconv.iconv(to, from, str).join&#xA; See Iconv.iconv." />
        <scope name="ctlmethods" ilk="function" signature="ctlmethods()" attributes="__classmethod__" doc="Returns available iconvctl() method list." />
        <scope name="iconv" ilk="function" signature="iconv(...)" attributes="__classmethod__" doc="Shorthand for   Iconv.open(to, from) { |cd|&#xA;    (strs + [nil]).collect { |s| cd.iconv(s) }&#xA;  }&#xA; Parameters &#xA; see Iconv.new&#xA;strings to be converted &#xA; Exceptions &#xA; Exceptions thrown by Iconv.new, Iconv.open and Iconv#iconv." />
        <scope name="list" ilk="function" signature="list()" attributes="__classmethod__" doc="Iterates each alias sets." />
        <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates new code converter from a coding-system designated with +from+ to another one designated with +to+. &#xA; Parameters &#xA; encoding name for destination&#xA;encoding name for source&#xA;options for converter &#xA; Exceptions &#xA; if +to+ or +from+ aren&apos;t String&#xA;if designated converter couldn&apos;t find out&#xA;if iconv_open(3) fails" />
        <scope name="open" ilk="function" signature="open(...)" attributes="__classmethod__" doc="Equivalent to Iconv.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block." />
        <scope name="close" ilk="function" signature="close()" doc="Finishes conversion. &#xA; After calling this, calling Iconv#iconv will cause an exception, but multiple calls of #close are guaranteed to end successfully. &#xA; Returns a string containing the byte sequence to change the output buffer to its initial shift state." />
        <scope name="conv" ilk="function" signature="conv(...)" doc="Shorthand for   Iconv.iconv(to, from, str).join&#xA; See Iconv.iconv." />
        <scope name="discard_ilseq=" ilk="function" signature="discard_ilseq=(p1)" doc="Sets discard_ilseq flag." />
        <scope name="discard_ilseq?" ilk="function" signature="discard_ilseq?()" doc="Returns discard_ilseq flag." />
        <scope name="iconv" ilk="function" signature="iconv(...)" doc="Shorthand for   Iconv.open(to, from) { |cd|&#xA;    (strs + [nil]).collect { |s| cd.iconv(s) }&#xA;  }&#xA; Parameters &#xA; see Iconv.new&#xA;strings to be converted &#xA; Exceptions &#xA; Exceptions thrown by Iconv.new, Iconv.open and Iconv#iconv." />
        <scope name="transliterate=" ilk="function" signature="transliterate=(p1)" doc="Sets transliterate flag." />
        <scope name="transliterate?" ilk="function" signature="transliterate?()" doc="Returns transliterate flag." />
        <scope name="trivial?" ilk="function" signature="trivial?()" doc="Returns trivial flag." />
        <scope name="BrokenLibrary" ilk="class" classrefs="RuntimeError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="Failure" ilk="namespace">
          <scope name="new" ilk="function" signature="new(p1, p2, p3)" attributes="__classmethod__ __ctor__" doc="Creates new code converter from a coding-system designated with +from+ to another one designated with +to+. &#xA; Parameters &#xA; encoding name for destination&#xA;encoding name for source&#xA;options for converter &#xA; Exceptions &#xA; if +to+ or +from+ aren&apos;t String&#xA;if designated converter couldn&apos;t find out&#xA;if iconv_open(3) fails" />
          <scope name="failed" ilk="function" signature="failed()" doc="Returns substring of the original string passed to Iconv that starts at the character caused the exception." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns inspected string like as: #&lt;_class_: _success_, _failed_&gt;" />
          <scope name="success" ilk="function" signature="success()" doc="Returns string(s) translated successfully until the exception occurred. In the case of failure occurred within Iconv.iconv, returned value is an array of strings translated successfully preceding failure and the last element is string on the way." />
        </scope>
        <scope name="IllegalSequence" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="InvalidCharacter" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="InvalidEncoding" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="OutOfRange" ilk="class" classrefs="RuntimeError">
          <import symbol="Iconv::Failure" />
        </scope>
      </scope>
    </scope>
    <scope name="ipaddr" ilk="blob" lang="Ruby">
      <scope name="IPAddr" ilk="class" classrefs="Object">
        <import symbol="Comparable" />
        <scope name="new" ilk="function" signature="new(addr = &apos;::&apos;, family = Socket::AF_UNSPEC)" attributes="__classmethod__ __ctor__" doc="Creates a new ipaddr object either from a human readable IP address representation in string, or from a packed in_addr value followed by an address family. &#xA; In the former case, the following are the valid formats that will be recognized: &quot;address&quot;, &quot;address/prefixlen&quot; and &quot;address/mask&quot;, where IPv6 address may be enclosed in square brackets (`[&apos; and `]&apos;).  If a prefixlen or a mask is specified, it returns a masked IP address.  Although the address family is determined automatically from a specified string, you can specify one explicitly by the optional second argument. &#xA; Otherwise an IP address is generated from a packed in_addr value and an address family. &#xA; The IPAddr class defines many methods and operators, and some of those, such as &amp;, |, include? and ==, accept a string, or a packed in_addr value instead of an IPAddr object." />
        <scope name="new_ntoh" ilk="function" signature="new_ntoh(addr)" attributes="__classmethod__" doc="Creates a new ipaddr containing the given network byte ordered string form of an IP address." />
        <scope name="ntop" ilk="function" signature="ntop(addr)" attributes="__classmethod__" doc="Convert a network byte ordered string form of an IP address into human readable form." />
        <scope name="eql?" ilk="function" signature="eql?(other)" doc="Checks equality used by Hash." />
        <scope name="hash" ilk="function" signature="hash()" doc="Returns a hash value used by Hash, Set, and Array classes" />
        <scope name="hton" ilk="function" signature="hton()" doc="Returns a network byte ordered string form of the IP address." />
        <scope name="include?" ilk="function" signature="include?(other)" doc="Returns true if the given ipaddr is in the range. &#xA; e.g.:   require &apos;ipaddr&apos;&#xA;  net1 = IPAddr.new(&quot;192.168.2.0/24&quot;)&#xA;  net2 = IPAddr.new(&quot;192.168.2.100&quot;)&#xA;  net3 = IPAddr.new(&quot;192.168.3.0&quot;)&#xA;  p net1.include?(net2)     =&gt; true&#xA;  p net1.include?(net3)     =&gt; false" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a human-readable representation of the ipaddr. (&quot;#&lt;IPAddr: family:address/mask&gt;&quot;)" />
        <scope name="ip6_arpa" ilk="function" signature="ip6_arpa()" doc="Returns a string for DNS reverse lookup compatible with RFC3172." />
        <scope name="ip6_int" ilk="function" signature="ip6_int()" doc="Returns a string for DNS reverse lookup compatible with RFC1886." />
        <scope name="ipv4?" ilk="function" signature="ipv4?()" doc="Returns true if the ipaddr is an IPv4 address." />
        <scope name="ipv4_compat" ilk="function" signature="ipv4_compat()" doc="Returns a new ipaddr built by converting the native IPv4 address into an IPv4-compatible IPv6 address." />
        <scope name="ipv4_compat?" ilk="function" signature="ipv4_compat?()" doc="Returns true if the ipaddr is an IPv4-compatible IPv6 address." />
        <scope name="ipv4_mapped" ilk="function" signature="ipv4_mapped()" doc="Returns a new ipaddr built by converting the native IPv4 address into an IPv4-mapped IPv6 address." />
        <scope name="ipv4_mapped?" ilk="function" signature="ipv4_mapped?()" doc="Returns true if the ipaddr is an IPv4-mapped IPv6 address." />
        <scope name="ipv6?" ilk="function" signature="ipv6?()" doc="Returns true if the ipaddr is an IPv6 address." />
        <scope name="mask" ilk="function" signature="mask(prefixlen)" doc="Returns a new ipaddr built by masking IP address with the given prefixlen/netmask. (e.g. 8, 64, &quot;255.255.255.0&quot;, etc.)" />
        <scope name="native" ilk="function" signature="native()" doc="Returns a new ipaddr built by converting the IPv6 address into a native IPv4 address.  If the IP address is not an IPv4-mapped or IPv4-compatible IPv6 address, returns self." />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a string for DNS reverse lookup.  It returns a string in RFC3172 form for an IPv6 address." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns the successor to the ipaddr." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the integer representation of the ipaddr." />
        <scope name="to_range" ilk="function" signature="to_range()" doc="Creates a Range object for the network address." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Returns a string containing the IP address representation." />
        <scope name="to_string" ilk="function" signature="to_string()" doc="Returns a string containing the IP address representation in canonical form." />
        <scope ilk="function" name="family" />
      </scope>
    </scope>
    <scope name="irb" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="CurrentContext" ilk="function" signature="CurrentContext()" attributes="__classmethod__" />
        <scope name="Inspector" ilk="function" signature="Inspector(inspect, init = nil)" attributes="__classmethod__" />
        <scope name="JobManager" ilk="function" signature="JobManager()" attributes="__classmethod__" />
        <scope name="conf" ilk="function" signature="conf()" attributes="__classmethod__" />
        <scope name="delete_caller" ilk="function" signature="delete_caller()" attributes="__classmethod__" />
        <scope name="init_config" ilk="function" signature="init_config(ap_path)" attributes="__classmethod__" doc="@CONF default setting" />
        <scope name="init_error" ilk="function" signature="init_error()" attributes="__classmethod__" />
        <scope name="initialize_tracer" ilk="function" signature="initialize_tracer()" attributes="__classmethod__" doc="initialize tracing function" />
        <scope name="irb" ilk="function" signature="irb(file = nil, *main)" attributes="__classmethod__" doc="invoke multi-irb" />
        <scope name="irb_abort" ilk="function" signature="irb_abort(irb, exception = Abort)" attributes="__classmethod__" />
        <scope name="irb_at_exit" ilk="function" signature="irb_at_exit()" attributes="__classmethod__" />
        <scope name="irb_exit" ilk="function" signature="irb_exit(irb, ret)" attributes="__classmethod__" />
        <scope name="load_modules" ilk="function" signature="load_modules()" attributes="__classmethod__" doc="loading modules" />
        <scope name="parse_opts" ilk="function" signature="parse_opts()" attributes="__classmethod__" doc="option analyzing" />
        <scope name="print_usage" ilk="function" signature="print_usage()" attributes="__classmethod__" />
        <scope name="rc_file" ilk="function" signature="rc_file(ext = IRBRC_EXT)" attributes="__classmethod__" />
        <scope name="rc_file_generators" ilk="function" signature="rc_file_generators()" attributes="__classmethod__" doc="enumerate possible rc-file base name generators" />
        <scope name="run_config" ilk="function" signature="run_config()" attributes="__classmethod__" doc="running config" />
        <scope name="setup" ilk="function" signature="setup(ap_path)" attributes="__classmethod__" doc="initialize config" />
        <scope name="start" ilk="function" signature="start(ap_path = nil)" attributes="__classmethod__" doc="initialize IRB and start TOP_LEVEL irb" />
        <scope name="version" ilk="function" signature="version()" attributes="__classmethod__" doc="IRB version method" />
        <scope name="history_file" ilk="function" signature="history_file()" />
        <scope name="history_file=" ilk="function" signature="history_file=(hist)" />
        <scope name="open" ilk="function" signature="open(path)" />
        <scope name="pop_workspace" ilk="function" signature="pop_workspace()" />
        <scope name="save_history" ilk="function" signature="save_history()" />
        <scope name="save_history=" ilk="function" signature="save_history=(val)" />
        <variable name="FEATURE_IOPT_CHANGE_VERSION" attributes="__const__" citdl="Object" />
        <variable name="IRBRC_EXT" attributes="__const__" citdl="Object" />
        <variable name="STDIN_FILE_NAME" attributes="__const__" citdl="Object" />
        <variable name="ENCODING_SPEC_RE" attributes="__const__" citdl="Object" />
        <variable name="INSPECTORS" attributes="__const__" citdl="Object" />
        <scope name="Abort" ilk="class" classrefs="Exception">
        </scope>
        <scope name="History" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(size = 16)" attributes="__classmethod__ __ctor__" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="push" ilk="function" signature="push(no, val)" />
          <scope name="real_inspect" ilk="function" signature="real_inspect()" />
          <scope name="size" ilk="function" signature="size(size)" />
        </scope>
        <scope name="HistorySavingAbility" ilk="namespace">
        </scope>
        <scope name="INSPECTORS" ilk="namespace">
          <scope name="def_inspector" ilk="function" signature="def_inspector(key, arg=nil, &amp;block)" attributes="__classmethod__" doc="ex) INSPECTORS.def_inspector(key, init_p=nil){|v| v.inspect} INSPECTORS.def_inspector([key1,..], init_p=nil){|v| v.inspect} INSPECTORS.def_inspector(key, inspector) INSPECTORS.def_inspector([key1,...], inspector)" />
          <scope name="keys_with_inspector" ilk="function" signature="keys_with_inspector(inspector)" attributes="__classmethod__" />
        </scope>
        <scope name="Irb" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(workspace = nil, input_method = nil, output_method = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="eval_input" ilk="function" signature="eval_input()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="output_value" ilk="function" signature="output_value()" />
          <scope name="prompt" ilk="function" signature="prompt(prompt, ltype, indent, line_no)" />
          <scope name="signal_handle" ilk="function" signature="signal_handle()" />
          <scope name="signal_status" ilk="function" signature="signal_status(status)" />
          <scope name="suspend_context" ilk="function" signature="suspend_context(context)" />
          <scope name="suspend_input_method" ilk="function" signature="suspend_input_method(input_method)" />
          <scope name="suspend_name" ilk="function" signature="suspend_name(path = nil, name = nil)" />
          <scope name="suspend_workspace" ilk="function" signature="suspend_workspace(workspace)" />
          <scope ilk="function" name="context" />
          <scope ilk="function" name="scanner" />
          <scope ilk="function" name="scanner=" />
        </scope>
        <scope name="IrbLoader" ilk="namespace">
          <scope name="irb_load" ilk="function" signature="irb_load(fn, priv = nil)" />
          <scope name="load_file" ilk="function" signature="load_file(path, priv = nil)" />
          <scope name="old" ilk="function" signature="old()" />
          <scope name="search_file_from_ruby_path" ilk="function" signature="search_file_from_ruby_path(fn)" />
          <scope name="source_file" ilk="function" signature="source_file(path)" />
        </scope>
        <scope name="JobManager" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="delete" ilk="function" signature="delete(key)" />
          <scope name="insert" ilk="function" signature="insert(irb)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="irb" ilk="function" signature="irb(key)" />
          <scope name="kill" ilk="function" signature="kill(*keys)" />
          <scope name="main_irb" ilk="function" signature="main_irb()" />
          <scope name="main_thread" ilk="function" signature="main_thread()" />
          <scope name="n_jobs" ilk="function" signature="n_jobs()" />
          <scope name="search" ilk="function" signature="search(key)" />
          <scope name="switch" ilk="function" signature="switch(key)" />
          <scope name="thread" ilk="function" signature="thread(key)" />
          <scope ilk="function" name="current_job" />
          <scope ilk="function" name="current_job=" />
        </scope>
        <scope name="LoadAbort" ilk="class" classrefs="Exception">
        </scope>
      </scope>
    </scope>
    <scope name="irb/completion" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="InputCompletor" ilk="namespace">
          <scope name="select_message" ilk="function" signature="select_message(receiver, message, candidates)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/context" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Context" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(irb, workspace = nil, input_method = nil, output_method = nil)" attributes="__classmethod__ __ctor__" doc="Arguments:   input_method: nil -- stdin or readline&#xA;                String -- File&#xA;                other -- using this as InputMethod" />
          <scope name="__exit__" ilk="function" signature="__exit__(ret = 0)" />
          <scope name="__inspect__" ilk="function" signature="__inspect__()" />
          <scope name="__to_s__" ilk="function" signature="__to_s__()" />
          <scope name="_set_last_value" ilk="function" signature="_set_last_value(value)" />
          <scope name="change_workspace" ilk="function" signature="change_workspace(*_main)" />
          <scope name="debug?" ilk="function" signature="debug?()" />
          <scope name="debug_level=" ilk="function" signature="debug_level=(value)" />
          <scope name="eval_history=" ilk="function" signature="eval_history=(no)" />
          <scope name="evaluate" ilk="function" signature="evaluate(line, line_no)" />
          <scope name="exit" ilk="function" signature="exit(ret = 0)" />
          <scope name="file_input?" ilk="function" signature="file_input?()" />
          <scope name="home_workspace" ilk="function" signature="home_workspace()" />
          <scope name="init_save_history" ilk="function" signature="init_save_history()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="inspect?" ilk="function" signature="inspect?()" />
          <scope name="inspect_last_value" ilk="function" signature="inspect_last_value()" />
          <scope name="inspect_mode=" ilk="function" signature="inspect_mode=(opt)" />
          <scope name="irb_level" ilk="function" signature="irb_level()" />
          <scope name="main" ilk="function" signature="main()" />
          <scope name="math_mode=" ilk="function" signature="math_mode=(opt)" />
          <scope name="prompt_mode=" ilk="function" signature="prompt_mode=(mode)" />
          <scope name="prompting?" ilk="function" signature="prompting?()" />
          <scope name="push_workspace" ilk="function" signature="push_workspace(*_main)" />
          <scope name="set_last_value" ilk="function" signature="set_last_value(value)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="use_loader" ilk="function" signature="use_loader()" />
          <scope name="use_loader=" ilk="function" signature="use_loader=(opt)" />
          <scope name="use_loader?" ilk="function" signature="use_loader?()" />
          <scope name="use_readline=" ilk="function" signature="use_readline=(opt)" />
          <scope name="use_tracer=" ilk="function" signature="use_tracer=(opt)" />
          <scope name="verbose?" ilk="function" signature="verbose?()" />
          <scope name="workspaces" ilk="function" signature="workspaces()" />
          <scope ilk="function" name="ap_name" />
          <scope ilk="function" name="ap_name=" />
          <scope ilk="function" name="auto_indent_mode" />
          <scope ilk="function" name="auto_indent_mode=" />
          <scope ilk="function" name="back_trace_limit" />
          <scope ilk="function" name="back_trace_limit=" />
          <scope ilk="function" name="debug_level" />
          <scope ilk="function" name="echo" />
          <scope ilk="function" name="echo=" />
          <scope ilk="function" name="eval_history" />
          <scope ilk="function" name="ignore_eof" />
          <scope ilk="function" name="ignore_eof=" />
          <scope ilk="function" name="ignore_sigint" />
          <scope ilk="function" name="ignore_sigint=" />
          <scope ilk="function" name="inspect_mode" />
          <scope ilk="function" name="io" />
          <scope ilk="function" name="io=" />
          <scope ilk="function" name="irb" />
          <scope ilk="function" name="irb=" />
          <scope ilk="function" name="irb_name" />
          <scope ilk="function" name="irb_name=" />
          <scope ilk="function" name="irb_path" />
          <scope ilk="function" name="irb_path=" />
          <scope ilk="function" name="last_value" />
          <scope ilk="function" name="load_modules" />
          <scope ilk="function" name="load_modules=" />
          <scope ilk="function" name="math_mode" />
          <scope ilk="function" name="prompt_c" />
          <scope ilk="function" name="prompt_c=" />
          <scope ilk="function" name="prompt_i" />
          <scope ilk="function" name="prompt_i=" />
          <scope ilk="function" name="prompt_mode" />
          <scope ilk="function" name="prompt_n" />
          <scope ilk="function" name="prompt_n=" />
          <scope ilk="function" name="prompt_s" />
          <scope ilk="function" name="prompt_s=" />
          <scope ilk="function" name="rc" />
          <scope ilk="function" name="rc=" />
          <scope ilk="function" name="return_format" />
          <scope ilk="function" name="return_format=" />
          <scope ilk="function" name="thread" />
          <scope ilk="function" name="use_readline" />
          <scope ilk="function" name="use_tracer" />
          <scope ilk="function" name="verbose" />
          <scope ilk="function" name="verbose=" />
          <scope ilk="function" name="workspace" />
          <scope ilk="function" name="workspace=" />
          <scope ilk="function" name="workspace_home" />
          <variable name="NOPRINTING_IVARS" attributes="__const__" citdl="Object" />
          <variable name="NO_INSPECTING_IVARS" attributes="__const__" citdl="Object" />
          <variable name="IDNAME_IVARS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/extend-command" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="ExtendCommand" ilk="namespace">
          <scope name="ChangeWorkspace" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="CurrentWorkingWorkspace" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Foreground" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(key)" />
          </scope>
          <scope name="Fork" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(&amp;block)" />
          </scope>
          <scope name="Help" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*names)" />
          </scope>
          <scope name="IrbCommand" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Jobs" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute()" />
          </scope>
          <scope name="Kill" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*keys)" />
          </scope>
          <scope name="Load" ilk="class" classrefs="Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name, priv = nil)" />
          </scope>
          <scope name="Nop" ilk="class" classrefs="Object">
            <scope name="execute" ilk="function" signature="execute(conf, *opts)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(conf)" attributes="__classmethod__ __ctor__" />
            <scope name="execute" ilk="function" signature="execute(*opts)" />
            <scope name="irb" ilk="function" signature="irb()" />
            <scope ilk="function" name="irb_context" />
          </scope>
          <scope name="PopWorkspace" ilk="class" classrefs="Workspaces">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="PushWorkspace" ilk="class" classrefs="Workspaces">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Require" ilk="class" classrefs="Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name)" />
          </scope>
          <scope name="Source" ilk="class" classrefs="Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name)" />
          </scope>
          <scope name="Workspaces" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
        </scope>
        <scope name="ExtendCommandBundle" ilk="namespace">
          <scope name="def_extend_command" ilk="function" signature="def_extend_command(cmd_name, cmd_class, load_file = nil, *aliases)" attributes="__classmethod__" doc="aliases = [commands_alias, flag], ..." />
          <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" />
          <scope name="install_extend_commands" ilk="function" signature="install_extend_commands()" attributes="__classmethod__" />
          <scope name="irb_original_method_name" ilk="function" attributes="__classmethod__" />
          <scope name="install_alias_method" ilk="function" signature="install_alias_method(to, from, override = NO_OVERRIDE)" doc="override = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}" />
          <scope name="irb_context" ilk="function" />
          <scope name="irb_exit" ilk="function" />
          <scope name="irb_load" ilk="function" />
          <scope name="irb_require" ilk="function" />
          <variable name="EXCB" attributes="__const__" citdl="Object" />
          <variable name="NO_OVERRIDE" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_PRIVATE_ONLY" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_ALL" attributes="__const__" citdl="Object" />
          <variable name="EXCB" attributes="__const__" citdl="Object" />
          <variable name="NO_OVERRIDE" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_PRIVATE_ONLY" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_ALL" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/frame" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Frame" ilk="class" classrefs="Object">
          <scope name="bottom" ilk="function" signature="bottom(n = 0)" attributes="__classmethod__" doc="singleton functions" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="sender" ilk="function" signature="sender()" attributes="__classmethod__" />
          <scope name="top" ilk="function" signature="top(n = 0)" attributes="__classmethod__" />
          <scope name="bottom" ilk="function" signature="bottom(n = 0)" />
          <scope name="top" ilk="function" signature="top(n = 0)" />
          <scope name="trace_func" ilk="function" signature="trace_func(event, file, line, id, binding)" />
          <variable name="INIT_STACK_TIMES" attributes="__const__" citdl="Object" />
          <variable name="CALL_STACK_OFFSET" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/input-method" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="FileInputMethod" ilk="class" classrefs="InputMethod">
          <scope name="new" ilk="function" signature="new(file)" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope ilk="function" name="file_name" />
        </scope>
        <scope name="InputMethod" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(file = STDIN_FILE_NAME)" attributes="__classmethod__ __ctor__" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
          <scope ilk="function" name="file_name" />
          <scope ilk="function" name="prompt" />
          <scope ilk="function" name="prompt=" />
        </scope>
        <scope name="ReadlineInputMethod" ilk="class" classrefs="InputMethod">
          <import symbol="Readline" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="line" ilk="function" signature="line(line_no)" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
        </scope>
        <scope name="StdioInputMethod" ilk="class" classrefs="InputMethod">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="line" ilk="function" signature="line(line_no)" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/inspector" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Inspector" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(inspect_proc, init_proc = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="init" ilk="function" signature="init()" />
          <scope name="inspect_value" ilk="function" signature="inspect_value(v)" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/locale" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Locale" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(locale = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="String" ilk="function" signature="String(mes)" />
          <scope name="find" ilk="function" signature="find(file , paths = $:)" />
          <scope name="format" ilk="function" signature="format(*opts)" />
          <scope name="gets" ilk="function" signature="gets(*rs)" />
          <scope name="load" ilk="function" signature="load(file, priv=nil)" />
          <scope name="print" ilk="function" signature="print(*opts)" />
          <scope name="printf" ilk="function" signature="printf(*opts)" />
          <scope name="puts" ilk="function" signature="puts(*opts)" />
          <scope name="readline" ilk="function" signature="readline(*rs)" />
          <scope name="require" ilk="function" signature="require(file, priv = nil)" />
          <scope name="toplevel_load" ilk="function" signature="toplevel_load(file, priv=nil)" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="lang" />
          <scope ilk="function" name="modifieer" />
          <scope ilk="function" name="territory" />
          <variable name="LOCALE_NAME_RE" attributes="__const__" citdl="Object" />
          <variable name="LOCALE_DIR" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/notifier" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Notifier" ilk="namespace">
          <scope name="def_notifier" ilk="function" signature="def_notifier(prefix = &quot;&quot;, output_method = StdioOutputMethod.new)" attributes="__classmethod__" />
          <variable name="D_NOMSG" attributes="__const__" citdl="Object" />
          <scope name="AbstractNotifier" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(prefix, base_notifier)" attributes="__classmethod__ __ctor__" />
            <scope name="exec_if" ilk="function" signature="exec_if()" />
            <scope name="notify?" ilk="function" signature="notify?()" />
            <scope name="pp" ilk="function" signature="pp(*objs)" />
            <scope name="ppx" ilk="function" signature="ppx(prefix, *objs)" />
            <scope name="print" ilk="function" signature="print(*opts)" />
            <scope name="printf" ilk="function" signature="printf(format, *opts)" />
            <scope name="printn" ilk="function" signature="printn(*opts)" />
            <scope name="puts" ilk="function" signature="puts(*objs)" />
            <scope ilk="function" name="prefix" />
          </scope>
          <scope name="CompositeNotifier" ilk="class" classrefs="AbstractNotifier">
            <scope name="new" ilk="function" signature="new(prefix, base_notifier)" attributes="__classmethod__ __ctor__" />
            <scope name="def_notifier" ilk="function" signature="def_notifier(level, prefix = &quot;&quot;)" />
            <scope name="level=" ilk="function" signature="level=(value)" />
            <scope name="level_notifier=" ilk="function" signature="level_notifier=(value)" />
            <scope ilk="function" name="level_notifier" />
            <scope ilk="function" name="notifiers" />
          </scope>
          <scope name="LeveledNotifier" ilk="class" classrefs="AbstractNotifier">
            <import symbol="Comparable" />
            <scope name="new" ilk="function" signature="new(base, level, prefix)" attributes="__classmethod__ __ctor__" />
            <scope name="notify?" ilk="function" signature="notify?()" />
            <scope ilk="function" name="level" />
          </scope>
          <scope name="NoMsgNotifier" ilk="class" classrefs="LeveledNotifier">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="notify?" ilk="function" signature="notify?()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="irb/output-method" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="OutputMethod" ilk="class" classrefs="Object">
          <scope name="parse_printf_format" ilk="function" signature="parse_printf_format(format, opts)" doc="% &lt;flag&gt;  [#0- +] &lt;minimum field width&gt; (\*|\*[1-9][0-9]*\$|[1-9][0-9]*) &lt;precision&gt;.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)? #&lt;length modifier&gt;(hh|h|l|ll|L|q|j|z|t) &lt;conversion specifier&gt;[diouxXeEfgGcsb%]" />
          <scope name="pp" ilk="function" signature="pp(*objs)" />
          <scope name="ppx" ilk="function" signature="ppx(prefix, *objs)" />
          <scope name="print" ilk="function" signature="print(*opts)" />
          <scope name="printf" ilk="function" signature="printf(format, *opts)" doc="extend printf" />
          <scope name="printn" ilk="function" signature="printn(*opts)" />
          <scope name="puts" ilk="function" signature="puts(*objs)" />
        </scope>
        <scope name="StdioOutputMethod" ilk="class" classrefs="OutputMethod">
          <scope name="print" ilk="function" signature="print(*opts)" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/slex" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="SLex" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="create" ilk="function" signature="create(token, preproc = nil, postproc = nil)" />
          <scope name="def_rule" ilk="function" signature="def_rule(token, preproc = nil, postproc = nil, &amp;block)" />
          <scope name="def_rules" ilk="function" signature="def_rules(*tokens, &amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="match" ilk="function" signature="match(token)" />
          <scope name="postproc" ilk="function" signature="postproc(token)" doc="$BMW%A%&apos;%C%/(B?" />
          <scope name="preproc" ilk="function" signature="preproc(token, proc)" />
          <scope name="search" ilk="function" signature="search(token)" />
          <variable name="DOUT" attributes="__const__" citdl="Object" />
          <variable name="D_WARN" attributes="__const__" citdl="Object" />
          <variable name="D_DEBUG" attributes="__const__" citdl="Object" />
          <variable name="D_DETAIL" attributes="__const__" citdl="Object" />
          <scope name="Node" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(preproc = nil, postproc = nil)" attributes="__classmethod__ __ctor__" doc="if postproc is nil, this node is an abstract node. if postproc is non-nil, this node is a real node." />
            <scope name="create_subnode" ilk="function" signature="create_subnode(chrs, preproc = nil, postproc = nil)" />
            <scope name="match" ilk="function" signature="match(chrs, op = &quot;&quot;)" doc="chrs: String       character array&#xA;      io must have getc()/ungetc(); and ungetc() must be&#xA;      able to be called arbitrary number of times." />
            <scope name="match_io" ilk="function" signature="match_io(io, op = &quot;&quot;)" />
            <scope name="search" ilk="function" signature="search(chrs, opt = nil)" />
            <scope ilk="function" name="postproc" />
            <scope ilk="function" name="postproc=" />
            <scope ilk="function" name="preproc" />
            <scope ilk="function" name="preproc=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="irb/workspace" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="WorkSpace" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*main)" attributes="__classmethod__ __ctor__" doc="create new workspace. set self to main if specified, otherwise inherit main from TOPLEVEL_BINDING." />
          <scope name="__evaluate__" ilk="function" signature="__evaluate__(context, statements, file = __FILE__, line = __LINE__)" />
          <scope name="evaluate" ilk="function" signature="evaluate(context, statements, file = nil, line = nil)" />
          <scope name="filter_backtrace" ilk="function" signature="filter_backtrace(bt)" doc="error message manipulator" />
          <scope ilk="function" name="binding" />
          <scope ilk="function" name="main" />
        </scope>
      </scope>
    </scope>
    <scope name="json" ilk="blob" lang="Ruby">
      <scope name="JSON" ilk="namespace">
        <scope name="iconv" ilk="function" signature="iconv(to, from, string)" attributes="__classmethod__" doc="Shortuct for iconv." />
        <scope name="restore" ilk="function" signature="restore(source, proc = nil)" attributes="__classmethod__" />
        <scope name="dump" ilk="function" signature="dump(obj, anIO = nil, limit = nil)" doc="Dumps _obj_ as a JSON string, i.e. calls generate on the object and returns the result. &#xA; If anIO (an IO like object or an object that responds to the write method) was given, the resulting JSON is written to it. &#xA; If the number of nested arrays or objects exceeds _limit_ an ArgumentError exception is raised. This argument is similar (but not exactly the same!) to the _limit_ argument in Marshal.dump. &#xA; This method is part of the implementation of the load/dump interface of Marshal and YAML." />
        <scope name="fast_generate" ilk="function" signature="fast_generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. This method disables the checks for circles in Ruby objects. &#xA; *WARNING*: Be careful not to pass any Ruby data structures with circles as _obj_ argument, because this will cause JSON to go into an infinite loop." />
        <scope name="generate" ilk="function" signature="generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. _state_ is * a JSON::State object, or a Hash like object (responding to to_hash),&#xA;an object convertible into a hash by a to_h method, that is used as or to configure a State object. &#xA; It defaults to a state object, that creates the shortest possible JSON text in one line, checks for circular data structures and doesn&apos;t allow NaN, Infinity, and -Infinity. &#xA; A _state_ hash can have the following keys: *indent*: a string used to indent levels (default: &apos;&apos;),&#xA;*space*: a string that is put after, a : or , delimiter (default: &apos;&apos;),&#xA;*space_before*: a string that is put before a : pair delimiter (default: &apos;&apos;),&#xA;*object_nl*: a string that is put at the end of a JSON object (default: &apos;&apos;), &#xA;*array_nl*: a string that is put at the end of a JSON array (default: &apos;&apos;),&#xA;*allow_nan*: true if NaN, Infinity, and -Infinity should be generated, otherwise an exception is thrown, if these values are encountered. This options defaults to false.&#xA;*max_nesting*: The maximum depth of nesting allowed in the data structures from which JSON is to be generated. Disable depth checking with :max_nesting =&gt; false, it defaults to 19. &#xA; See also the fast_generate for the fastest creation method with the least amount of sanity checks, and the pretty_generate method for some defaults for a pretty output." />
        <scope name="load" ilk="function" signature="load(source, proc = nil)" doc="Load a ruby data structure from a JSON _source_ and return it. A source can either be a string-like object, an IO like object, or an object responding to the read method. If _proc_ was given, it will be called with any nested Ruby object as an argument recursively in depth first order. &#xA; This method is part of the implementation of the load/dump interface of Marshal and YAML." />
        <scope name="parse" ilk="function" signature="parse(source, opts = {})" doc="Parse the JSON document _source_ into a Ruby data structure and return it. &#xA; _opts_ can have the following keys: *max_nesting*: The maximum depth of nesting allowed in the parsed data structures. Disable depth checking with :max_nesting =&gt; false, it defaults to 19.&#xA;*allow_nan*: If set to true, allow NaN, Infinity and -Infinity in defiance of RFC 4627 to be parsed by the Parser. This option defaults to false.&#xA;*symbolize_names*: If set to true, returns symbols for the names (keys) in a JSON object. Otherwise strings are returned, which is also the default.&#xA;*create_additions*: If set to false, the Parser doesn&apos;t create additions even if a matchin class and create_id was found. This option defaults to true.&#xA;*object_class*: Defaults to Hash&#xA;*array_class*: Defaults to Array" />
        <scope name="parse!" ilk="function" signature="parse!(source, opts = {})" doc="Parse the JSON document _source_ into a Ruby data structure and return it. The bang version of the parse method, defaults to the more dangerous values for the _opts_ hash, so be sure only to parse trusted _source_ documents. &#xA; _opts_ can have the following keys: *max_nesting*: The maximum depth of nesting allowed in the parsed data structures. Enable depth checking with :max_nesting =&gt; anInteger. The parse! methods defaults to not doing max depth checking: This can be dangerous, if someone wants to fill up your stack.&#xA;*allow_nan*: If set to true, allow NaN, Infinity, and -Infinity in defiance of RFC 4627 to be parsed by the Parser. This option defaults to true.&#xA;*create_additions*: If set to false, the Parser doesn&apos;t create additions even if a matchin class and create_id was found. This option defaults to true." />
        <scope name="pretty_generate" ilk="function" signature="pretty_generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. The returned document is a prettier form of the document returned by #unparse. &#xA; The _opts_ argument can be used to configure the generator, see the generate method for a more detailed explanation." />
        <scope name="recurse_proc" ilk="function" signature="recurse_proc(result, &amp;proc)" />
        <scope ilk="function" name="create_id" />
        <scope ilk="function" name="create_id=" />
        <scope ilk="function" name="generator" />
        <scope ilk="function" name="parser" />
        <scope ilk="function" name="state" />
        <scope ilk="function" name="state=" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="JSON_LOADED" attributes="__const__" citdl="Object" />
        <scope name="Editor" ilk="namespace">
          <import symbol="Gtk" />
          <scope name="data2model" ilk="function" signature="data2model(data, model = nil, parent = nil)" attributes="__classmethod__" doc="Convert the Ruby data structure _data_ into tree model data for Gtk and returns the whole model. If the parameter _model_ wasn&apos;t given a new Gtk::TreeStore is created as the model. The _parent_ parameter specifies the parent node (iter, Gtk:TreeIter instance) to which the data is appended, alternativeley the result of the yielded block is used as iter." />
          <scope name="edit" ilk="function" signature="edit(json, encoding = &apos;utf8&apos;)" attributes="__classmethod__" doc="Edit the string _json_ with encoding _encoding_ in the editor." />
          <scope name="error_dialog" ilk="function" signature="error_dialog(window, text)" attributes="__classmethod__" doc="Opens an error dialog on top of _window_ showing the error message _text_." />
          <scope name="fetch_icon" ilk="function" signature="fetch_icon(name)" attributes="__classmethod__" doc="Returns the Gdk::Pixbuf of the icon named _name_ from the icon cache." />
          <scope name="model2data" ilk="function" signature="model2data(iter)" attributes="__classmethod__" doc="Convert the tree model starting from Gtk::TreeIter _iter_ into a Ruby data structure and return it." />
          <scope name="question_dialog" ilk="function" signature="question_dialog(window, text)" attributes="__classmethod__" doc="Opens a yes/no question dialog on top of _window_ showing the error message _text_. If yes was answered _true_ is returned, otherwise _false_." />
          <scope name="start" ilk="function" signature="start(encoding = &apos;utf8&apos;)" attributes="__classmethod__" doc="Starts a JSON Editor. If a block was given, it yields to the JSON::Editor::MainWindow instance." />
          <scope ilk="function" name="window" />
          <variable name="TITLE" attributes="__const__" citdl="Object" />
          <variable name="CONTENT_COL" attributes="__const__" citdl="Object" />
          <variable name="CONTAINER_TYPES" attributes="__const__" citdl="Object" />
          <variable name="ALL_TYPES" attributes="__const__" citdl="Object" />
          <variable name="ALL_NODES" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_DIALOG_KEY_PRESS_HANDLER" attributes="__const__" citdl="Object" />
          <scope name="EditMenu" ilk="class" classrefs="Object">
            <import symbol="MenuExtension" />
            <scope name="copy" ilk="function" signature="copy(item)" doc="Copy data from model into primary clipboard." />
            <scope name="create" ilk="function" signature="create()" doc="Create the menu." />
            <scope name="find" ilk="function" signature="find(item)" doc="Find a string in all nodes&apos; contents and select the found node in the treeview." />
            <scope name="find_again" ilk="function" signature="find_again(item)" doc="Repeat the last search given by #find." />
            <scope name="paste" ilk="function" signature="paste(item)" doc="Copy json text from primary clipboard into model." />
            <scope name="sort" ilk="function" signature="sort(item)" doc="Sort (Reverse sort) all elements of the selected array by the given expression. _x_ is the element in question." />
          </scope>
          <scope name="FileMenu" ilk="class" classrefs="Object">
            <import symbol="MenuExtension" />
            <scope name="create" ilk="function" signature="create()" doc="Create the menu." />
            <scope name="new" ilk="function" signature="new(item)" doc="Clear the model and filename, but ask to save the JSON document, if unsaved changes have occured." />
            <scope name="open" ilk="function" signature="open(item)" doc="Open a file and load it into the editor. Ask to save the JSON document first, if unsaved changes have occured." />
            <scope name="open_location" ilk="function" signature="open_location(item)" />
            <scope name="quit" ilk="function" signature="quit(item)" doc="Quit the editor, after asking to save any unsaved changes first." />
            <scope name="revert" ilk="function" signature="revert(item)" doc="Revert the current JSON document in the editor to the saved version." />
            <scope name="save" ilk="function" signature="save(item)" doc="Save the current JSON document." />
            <scope name="save_as" ilk="function" signature="save_as(item)" doc="Save the current JSON document under the given filename." />
          </scope>
          <scope name="Gtk" ilk="namespace">
            <scope name="TreeIter" ilk="class" classrefs="Object">
              <import symbol="Enumerable" />
              <scope name="content" ilk="function" signature="content()" doc="Returns the content of this node." />
              <scope name="content=" ilk="function" signature="content=(value)" doc="Sets the content of this node to _value_." />
              <scope name="each" ilk="function" signature="each()" doc="Traverse each of this Gtk::TreeIter instance&apos;s children and yield to them." />
              <scope name="recursive_each" ilk="function" signature="recursive_each(&amp;block)" doc="Recursively traverse all nodes of this Gtk::TreeIter&apos;s subtree (including self) and yield to them." />
              <scope name="remove_subtree" ilk="function" signature="remove_subtree(model)" doc="Remove the subtree of this Gtk::TreeIter instance from the model _model_." />
              <scope name="type" ilk="function" signature="type()" doc="Returns the type of this node." />
              <scope name="type=" ilk="function" signature="type=(value)" doc="Sets the type of this node to _value_. This implies setting the respective icon accordingly." />
            </scope>
          </scope>
          <scope name="JSONTreeView" ilk="class" classrefs="Gtk::TreeView">
            <import symbol="Gtk" />
            <scope name="new" ilk="function" signature="new(window)" attributes="__classmethod__ __ctor__" doc="Creates a JSONTreeView instance, the parameter _window_ is a MainWindow instance and used for self delegation." />
            <scope name="ask_for_element" ilk="function" signature="ask_for_element(parent = nil, default_type = nil, value_text = @content)" doc="Ask for an element to be appended _parent_." />
            <scope name="ask_for_find_term" ilk="function" signature="ask_for_find_term(search = nil)" doc="Ask for a find term to search for in the tree. Returns the term as a string." />
            <scope name="ask_for_hash_pair" ilk="function" signature="ask_for_hash_pair(parent)" doc="Ask for a hash key, value pair to be added to the Hash node _parent_." />
            <scope name="ask_for_order" ilk="function" signature="ask_for_order()" doc="Ask for an order criteria for sorting, using _x_ for the element in question. Returns the order criterium, and true/false for reverse sorting." />
            <scope name="create_node" ilk="function" signature="create_node(parent, type, content)" doc="Create a _type_ node with content _content_, and add it to _parent_ in the model. If _parent_ is nil, create a new model and put it into the editor treeview." />
            <scope name="expand_collapse" ilk="function" signature="expand_collapse(iter)" doc="Expand or collapse row pointed to by _iter_ according to the #expanded attribute." />
            <scope ilk="function" name="expanded" />
            <scope ilk="function" name="expanded=" />
            <scope ilk="function" name="window" />
          </scope>
          <scope name="MainWindow" ilk="class" classrefs="Gtk::Window">
            <import symbol="Gtk" />
            <scope name="new" ilk="function" signature="new(encoding)" attributes="__classmethod__ __ctor__" />
            <scope name="ask_for_location" ilk="function" signature="ask_for_location()" doc="Ask for location URI a to load data from. Returns the URI as a string." />
            <scope name="ask_save" ilk="function" signature="ask_save()" doc="Opens a dialog, asking, if changes should be saved to a file." />
            <scope name="change" ilk="function" signature="change()" doc="Sets editor status to changed, to indicate that the edited data containts unsaved changes." />
            <scope name="clear" ilk="function" signature="clear()" doc="Clear the current model, after asking to save all unsaved changes." />
            <scope name="create_menu_bar" ilk="function" signature="create_menu_bar()" doc="Creates the menu bar with the pulldown menus and returns it." />
            <scope name="display_status" ilk="function" signature="display_status(text)" doc="Displays _text_ in the status bar." />
            <scope name="display_title" ilk="function" signature="display_title()" doc="Display the new title according to the editor&apos;s current state." />
            <scope name="edit" ilk="function" signature="edit(json)" doc="Edit the string _json_ in the editor." />
            <scope name="file_open" ilk="function" signature="file_open(filename = nil)" doc="Open the file _filename_ or call the #select_file method to ask for a filename." />
            <scope name="file_save" ilk="function" signature="file_save()" doc="Save the current file." />
            <scope name="file_save_as" ilk="function" signature="file_save_as()" doc="Save the current file as the filename " />
            <scope name="load_file" ilk="function" signature="load_file(filename)" doc="Load the file named _filename_ into the editor as a JSON document." />
            <scope name="load_location" ilk="function" signature="load_location(uri)" doc="Load the data at location _uri_ into the editor as a JSON document." />
            <scope name="location_open" ilk="function" signature="location_open(uri = nil)" doc="Open the data at the location _uri_, if given. Otherwise open a dialog to ask for the _uri_." />
            <scope name="quit" ilk="function" signature="quit()" doc="Quit this editor, that is, leave this editor&apos;s main loop." />
            <scope name="read_data" ilk="function" signature="read_data(filename)" doc="Read a JSON document from the file named _filename_, parse it into a ruby data structure, and return the data." />
            <scope name="select_file" ilk="function" signature="select_file(message)" doc="Open a file selecton dialog, displaying _message_, and return the selected filename or nil, if no file was selected." />
            <scope name="store_file" ilk="function" signature="store_file(path)" doc="Store the current JSON document to _path_." />
            <scope name="unchange" ilk="function" signature="unchange()" doc="Sets editor status to unchanged, to indicate that the edited data doesn&apos;t containt unsaved changes." />
            <scope name="view_new_model" ilk="function" signature="view_new_model(model)" doc="Puts a new model _model_ into the Gtk::TreeView to be edited." />
          </scope>
          <scope name="MenuExtension" ilk="namespace">
            <import symbol="Gtk" />
            <scope name="new" ilk="function" signature="new(treeview)" attributes="__classmethod__ __ctor__" doc="Creates a Menu, that includes MenuExtension. _treeview_ is the Gtk::TreeView, on which it operates." />
            <scope name="add_item" ilk="function" signature="add_item(label, keyval = nil, klass = MenuItem, &amp;callback)" doc="Adds a Gtk::MenuItem to this instance&apos;s #menu. _label_ is the label string, _klass_ is the item type, and _callback_ is the procedure, that is called if the _item_ is activated." />
            <scope name="add_separator" ilk="function" signature="add_separator()" doc="Adds a Gtk::SeparatorMenuItem to this instance&apos;s #menu." />
            <scope name="create" ilk="function" signature="create()" doc="This method should be implemented in subclasses to create the #menu of this instance. It has to be called after an instance of this class is created, to build the menu." />
            <scope name="method_missing" ilk="function" signature="method_missing(*a, &amp;b)" />
            <scope ilk="function" name="menu" />
            <scope ilk="function" name="treeview" />
          </scope>
          <scope name="OptionsMenu" ilk="class" classrefs="Object">
            <import symbol="MenuExtension" />
            <scope name="collapsed_nodes" ilk="function" signature="collapsed_nodes(item)" doc="Collapse/Expand all nodes by default." />
            <scope name="create" ilk="function" signature="create()" doc="Create the menu." />
            <scope name="pretty_saving" ilk="function" signature="pretty_saving(item)" doc="Toggle pretty saving mode on/off." />
            <scope ilk="function" name="pretty_item" />
          </scope>
          <scope name="PopUpMenu" ilk="class" classrefs="Object">
            <import symbol="MenuExtension" />
            <scope name="append_new_node" ilk="function" signature="append_new_node(item)" doc="Append a new node to the selected Hash or Array." />
            <scope name="change_node" ilk="function" signature="change_node(item)" doc="Change the type or content of the selected node." />
            <scope name="collapse_expand" ilk="function" signature="collapse_expand(item)" doc="Recursively collapse/expand a subtree starting from the selected node." />
            <scope name="copy_node" ilk="function" signature="copy_node(item)" doc="Copy the selected node and its subtree, and save it into the clipboard." />
            <scope name="create" ilk="function" signature="create()" doc="Create the menu." />
            <scope name="cut_node" ilk="function" signature="cut_node(item)" doc="Cut the selected node and its subtree, and save it into the clipboard." />
            <scope name="insert_new_node" ilk="function" signature="insert_new_node(item)" doc="Insert a new node into an Array before the selected element." />
            <scope name="paste_node_appending" ilk="function" signature="paste_node_appending(item)" doc="Paste the data in the clipboard into the selected Array or Hash by appending it." />
            <scope name="paste_node_inserting_before" ilk="function" signature="paste_node_inserting_before(item)" doc="Paste the data in the clipboard into the selected Array inserting it before the selected element." />
          </scope>
        </scope>
        <scope name="Ext" ilk="namespace">
        </scope>
        <scope name="GeneratorError" ilk="class" classrefs="JSONError">
        </scope>
        <scope name="JSONError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="MissingUnicodeSupport" ilk="class" classrefs="JSONError">
        </scope>
        <scope name="NestingError" ilk="class" classrefs="ParserError">
        </scope>
        <scope name="ParserError" ilk="class" classrefs="JSONError">
        </scope>
      </scope>
    </scope>
    <scope name="kconv" ilk="blob" lang="Ruby">
      <scope name="Kconv" ilk="namespace">
        <scope name="guess" ilk="function" signature="guess(str)" attributes="__classmethod__" doc="Guess input encoding by NKF.guess" />
        <scope name="iseuc" ilk="function" signature="iseuc(str)" attributes="__classmethod__" doc="Returns whether input encoding is EUC-JP or not. &#xA; *Note* don&apos;t expect this return value is MatchData." />
        <scope name="isjis" ilk="function" signature="isjis(str)" attributes="__classmethod__" doc="Returns whether input encoding is ISO-2022-JP or not." />
        <scope name="issjis" ilk="function" signature="issjis(str)" attributes="__classmethod__" doc="Returns whether input encoding is Shift_JIS or not." />
        <scope name="isutf8" ilk="function" signature="isutf8(str)" attributes="__classmethod__" doc="Returns whether input encoding is UTF-8 or not." />
        <scope name="kconv" ilk="function" signature="kconv(str, to_enc, from_enc=nil)" attributes="__classmethod__" doc="Convert str to to_enc. to_enc and from_enc are given as constants of Kconv or Encoding objects." />
        <scope name="toeuc" ilk="function" signature="toeuc(str)" attributes="__classmethod__" doc="Convert str to EUC-JP" />
        <scope name="tojis" ilk="function" signature="tojis(str)" attributes="__classmethod__" doc="Convert str to ISO-2022-JP" />
        <scope name="tolocale" ilk="function" signature="tolocale(str)" attributes="__classmethod__" doc="Convert self to locale encoding" />
        <scope name="tosjis" ilk="function" signature="tosjis(str)" attributes="__classmethod__" doc="Convert str to Shift_JIS" />
        <scope name="toutf16" ilk="function" signature="toutf16(str)" attributes="__classmethod__" doc="Convert str to UTF-16" />
        <scope name="toutf32" ilk="function" signature="toutf32(str)" attributes="__classmethod__" doc="Convert str to UTF-32" />
        <scope name="toutf8" ilk="function" signature="toutf8(str)" attributes="__classmethod__" doc="Convert str to UTF-8" />
        <variable name="AUTO" attributes="__const__" citdl="Object" />
        <variable name="JIS" attributes="__const__" citdl="Object" />
        <variable name="EUC" attributes="__const__" citdl="Object" />
        <variable name="SJIS" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="NOCONV" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="logger" ilk="blob" lang="Ruby">
      <scope name="Logger" ilk="class" classrefs="Object">
        <import symbol="Severity" />
        <scope name="new" ilk="function" signature="new(logdev, shift_age = 0, shift_size = 1048576)" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA;   Logger.new(name, shift_age = 7, shift_size = 1048576)&#xA;  Logger.new(name, shift_age = &apos;weekly&apos;)&#xA; Args &#xA; The log device.  This is a filename (String) or IO object (typically +STDOUT+, +STDERR+, or an open file).&#xA;Number of old log files to keep, *or* frequency of rotation (+daily+, +weekly+ or +monthly+).&#xA;Maximum logfile size (only applies when +shift_age+ is a number). &#xA; Description &#xA; Create an instance." />
        <scope name="add" ilk="function" signature="add(severity, message = nil, progname = nil, &amp;block)" doc="Synopsis &#xA;   Logger#add(severity, message = nil, progname = nil) { ... }&#xA; Args &#xA; Severity.  Constants are defined in Logger namespace: +DEBUG+, +INFO+, +WARN+, +ERROR+, +FATAL+, or +UNKNOWN+.&#xA;The log message.  A String or Exception.&#xA;Program name string.  Can be omitted.  Treated as a message if no +message+ and +block+ are given.&#xA;Can be omitted.  Called to get a message string if +message+ is nil. &#xA; Return &#xA; +true+ if successful, +false+ otherwise. &#xA; When the given severity is not high enough (for this particular logger), log no message, and return +true+. &#xA; Description &#xA; Log a message if the given severity is high enough.  This is the generic logging method.  Users will be more inclined to use #debug, #info, #warn, #error, and #fatal. &#xA; &lt;b&gt;Message format&lt;/b&gt;: +message+ can be any object, but it has to be converted to a String in order to log it.  Generally, +inspect+ is used if the given object is not a String. A special case is an +Exception+ object, which will be printed in detail, including message, class, and backtrace.  See #msg2str for the implementation if required. " />
        <scope name="close" ilk="function" signature="close()" doc="Close the logging device." />
        <scope name="datetime_format" ilk="function" signature="datetime_format()" />
        <scope name="datetime_format=" ilk="function" signature="datetime_format=(datetime_format)" doc="Logging date-time format (string passed to +strftime+)." />
        <scope name="debug" ilk="function" signature="debug(progname = nil, &amp;block)" doc="Log a +DEBUG+ message. &#xA; See #info for more information." />
        <scope name="debug?" ilk="function" signature="debug?()" doc="Returns +true+ iff the current severity level allows for the printing of +DEBUG+ messages." />
        <scope name="error" ilk="function" signature="error(progname = nil, &amp;block)" doc="Log an +ERROR+ message. &#xA; See #info for more information." />
        <scope name="error?" ilk="function" signature="error?()" doc="Returns +true+ iff the current severity level allows for the printing of +ERROR+ messages." />
        <scope name="fatal" ilk="function" signature="fatal(progname = nil, &amp;block)" doc="Log a +FATAL+ message. &#xA; See #info for more information." />
        <scope name="fatal?" ilk="function" signature="fatal?()" doc="Returns +true+ iff the current severity level allows for the printing of +FATAL+ messages." />
        <scope name="info" ilk="function" signature="info(progname = nil, &amp;block)" doc="Log an +INFO+ message. &#xA; The message can come either from the +progname+ argument or the +block+.  If both are provided, then the +block+ is used as the message, and +progname+ is used as the program name. &#xA; Examples &#xA;   logger.info(&quot;MainApp&quot;) { &quot;Received connection from #{ip}&quot; }&#xA;  # ...&#xA;  logger.info &quot;Waiting for input from user&quot;&#xA;  # ...&#xA;  logger.info { &quot;User typed #{input}&quot; }&#xA; You&apos;ll probably stick to the second form above, unless you want to provide a program name (which you can do with Logger#progname= as well). &#xA; Return &#xA; See #add." />
        <scope name="info?" ilk="function" signature="info?()" doc="Returns +true+ iff the current severity level allows for the printing of +INFO+ messages." />
        <scope name="log" ilk="function" signature="log(severity, message = nil, progname = nil, &amp;block)" />
        <scope name="unknown" ilk="function" signature="unknown(progname = nil, &amp;block)" doc="Log an +UNKNOWN+ message.  This will be printed no matter what the logger level. &#xA; See #info for more information." />
        <scope name="warn" ilk="function" signature="warn(progname = nil, &amp;block)" doc="Log a +WARN+ message. &#xA; See #info for more information." />
        <scope name="warn?" ilk="function" signature="warn?()" doc="Returns +true+ iff the current severity level allows for the printing of +WARN+ messages." />
        <scope ilk="function" name="formatter" />
        <scope ilk="function" name="formatter=" />
        <scope ilk="function" name="level" />
        <scope ilk="function" name="level=" />
        <scope ilk="function" name="progname" />
        <scope ilk="function" name="progname=" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="SEV_LABEL" attributes="__const__" citdl="Object" />
        <scope name="Application" ilk="class" classrefs="Object">
          <import symbol="Logger::Severity" />
          <scope name="new" ilk="function" signature="new(appname = nil)" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA;   Application.new(appname = &apos;&apos;)&#xA; Args &#xA; Name of the application. &#xA; Description &#xA; Create an instance.  Log device is +STDERR+ by default.  This can be changed with #set_log." />
          <scope name="level=" ilk="function" signature="level=(level)" doc="Set the logging threshold, just like Logger#level=." />
          <scope name="log" ilk="function" signature="log(severity, message = nil, &amp;block)" doc="See Logger#add.  This application&apos;s +appname+ is used." />
          <scope name="log=" ilk="function" signature="log=(logdev)" />
          <scope name="logger" ilk="function" signature="logger()" doc="Logger for this application.  See the class Logger for an explanation." />
          <scope name="logger=" ilk="function" signature="logger=(logger)" doc="Sets the logger for this application.  See the class Logger for an explanation." />
          <scope name="set_log" ilk="function" signature="set_log(logdev, shift_age = 0, shift_size = 1024000)" doc="Sets the log device for this application.  See Logger.new for an explanation of the arguments." />
          <scope name="start" ilk="function" signature="start()" doc="Start the application.  Return the status code." />
          <scope ilk="function" name="appname" />
        </scope>
        <scope name="Error" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="Formatter" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="call" ilk="function" signature="call(severity, time, progname, msg)" />
          <scope ilk="function" name="datetime_format" />
          <scope ilk="function" name="datetime_format=" />
        </scope>
        <scope name="LogDevice" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(log = nil, opt = {})" attributes="__classmethod__ __ctor__" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="write" ilk="function" signature="write(message)" />
          <scope ilk="function" name="dev" />
          <scope ilk="function" name="filename" />
          <scope name="LogDeviceMutex" ilk="class" classrefs="Object">
            <import symbol="MonitorMixin" />
          </scope>
        </scope>
        <scope name="Severity" ilk="namespace">
          <variable name="DEBUG" attributes="__const__" citdl="Object" />
          <variable name="INFO" attributes="__const__" citdl="Object" />
          <variable name="WARN" attributes="__const__" citdl="Object" />
          <variable name="ERROR" attributes="__const__" citdl="Object" />
          <variable name="FATAL" attributes="__const__" citdl="Object" />
          <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ShiftingError" ilk="class" classrefs="Error">
        </scope>
      </scope>
    </scope>
    <scope name="matrix" ilk="blob" lang="Ruby">
      <scope name="Matrix" ilk="class" classrefs="Object">
        <import symbol="CoercionHelper" />
        <import symbol="Enumerable" />
        <import symbol="ExceptionForMatrix" />
        <scope name="build" ilk="function" signature="build(row_size, column_size = row_size)" attributes="__classmethod__" doc="Creates a matrix of size +row_size+ x +column_size+. It fills the values by calling the given block, passing the current row and column. Returns an enumerator if no block is given. &#xA;   m = Matrix.build(2, 4) {|row, col| col - row }&#xA;    =&gt; Matrix[[0, 1, 2, 3], [-1, 0, 1, 2]]&#xA;  m = Matrix.build(3) { rand }&#xA;    =&gt; a 3x3 matrix with random elements" />
        <scope name="column_vector" ilk="function" signature="column_vector(column)" attributes="__classmethod__" doc="Creates a single-column matrix where the values of that column are as given in +column+.   Matrix.column_vector([4,5,6])&#xA;    =&gt; 4&#xA;       5&#xA;       6" />
        <scope name="columns" ilk="function" signature="columns(columns)" attributes="__classmethod__" doc="Creates a matrix using +columns+ as an array of column vectors.   Matrix.columns([[25, 93], [-1, 66]])&#xA;     =&gt;  25 -1&#xA;         93 66" />
        <scope name="diagonal" ilk="function" signature="diagonal(*values)" attributes="__classmethod__" doc="Creates a matrix where the diagonal elements are composed of +values+.   Matrix.diagonal(9, 5, -3)&#xA;    =&gt;  9  0  0&#xA;        0  5  0&#xA;        0  0 -3" />
        <scope name="empty" ilk="function" signature="empty(row_size = 0, column_size = 0)" attributes="__classmethod__" doc="Creates a empty matrix of +row_size+ x +column_size+. At least one of +row_size+ or +column_size+ must be 0. &#xA;   m = Matrix.empty(2, 0)&#xA;  m == Matrix[ [], [] ]&#xA;    =&gt; true&#xA;  n = Matrix.empty(0, 3)&#xA;  n == Matrix.columns([ [], [], [] ])&#xA;    =&gt; true&#xA;  m * n&#xA;    =&gt; Matrix[[0, 0, 0], [0, 0, 0]]" />
        <scope name="identity" ilk="function" signature="identity(n)" attributes="__classmethod__" doc="Creates an +n+ by +n+ identity matrix.   Matrix.identity(2)&#xA;    =&gt; 1 0&#xA;       0 1" />
        <scope name="new" ilk="function" signature="new(rows, column_size = rows[0].size)" attributes="__classmethod__ __ctor__" doc="Matrix.new is private; use Matrix.rows, columns, [], etc... to create." />
        <scope name="row_vector" ilk="function" signature="row_vector(row)" attributes="__classmethod__" doc="Creates a single-row matrix where the values of that row are as given in +row+.   Matrix.row_vector([4,5,6])&#xA;    =&gt; 4 5 6" />
        <scope name="rows" ilk="function" signature="rows(rows, copy = true)" attributes="__classmethod__" doc="Creates a matrix where +rows+ is an array of arrays, each of which is a row of the matrix.  If the optional argument +copy+ is false, use the given arrays as the internal structure of the matrix without copying.   Matrix.rows([[25, 93], [-1, 66]])&#xA;     =&gt;  25 93&#xA;         -1 66" />
        <scope name="scalar" ilk="function" signature="scalar(n, value)" attributes="__classmethod__" doc="Creates an +n+ by +n+ diagonal matrix where each diagonal element is +value+.   Matrix.scalar(2, 5)&#xA;    =&gt; 5 0&#xA;       0 5" />
        <scope name="zero" ilk="function" signature="zero(n)" attributes="__classmethod__" doc="Creates an +n+ by +n+ zero matrix.   Matrix.zero(2)&#xA;    =&gt; 0 0&#xA;       0 0" />
        <scope name="clone" ilk="function" signature="clone()" doc="Returns a clone of the matrix, so that the contents of each do not reference identical objects. There should be no good reason to do this since Matrices are immutable." />
        <scope name="coerce" ilk="function" signature="coerce(other)" doc="The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. See also Numeric#coerce." />
        <scope name="collect" ilk="function" signature="collect()" doc="Returns a matrix that is the result of iteration of the given block over all elements of the matrix.   Matrix[ [1,2], [3,4] ].collect { |e| e**2 }&#xA;    =&gt; 1  4&#xA;       9 16" />
        <scope name="column" ilk="function" signature="column(j)" doc="Returns column vector number +j+ of the matrix as a Vector (starting at 0 like an array).  When a block is given, the elements of that vector are iterated." />
        <scope name="column_vectors" ilk="function" signature="column_vectors()" doc="Returns an array of the column vectors of the matrix.  See Vector." />
        <scope name="component" ilk="function" signature="component(i, j)" />
        <scope name="conj" ilk="function" signature="conj()" />
        <scope name="conjugate" ilk="function" signature="conjugate()" doc="Returns the conjugate of the matrix.   Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;    =&gt; 1+2i   i  0&#xA;          1   2  3&#xA;  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].conjugate&#xA;    =&gt; 1-2i  -i  0&#xA;          1   2  3" />
        <scope name="det" ilk="function" signature="det()" />
        <scope name="det_e" ilk="function" signature="det_e()" />
        <scope name="determinant" ilk="function" signature="determinant()" doc="Returns the determinant of the matrix. &#xA; Beware that using Float values can yield erroneous results because of their lack of precision. Consider using exact types like Rational or BigDecimal instead. &#xA;   Matrix[[7,6], [3,9]].determinant&#xA;    =&gt; 45" />
        <scope name="determinant_e" ilk="function" signature="determinant_e()" doc="deprecated; use Matrix#determinant" />
        <scope name="each" ilk="function" signature="each()" doc="Yields all elements of the matrix, starting with those of the first row, or returns an Enumerator is no block given   Matrix[ [1,2], [3,4] ].each { |e| puts e }&#xA;    # =&gt; prints the numbers 1 to 4" />
        <scope name="each_with_index" ilk="function" signature="each_with_index()" doc="Yields all elements of the matrix, starting with those of the first row, along with the row index and column index, or returns an Enumerator is no block given   Matrix[ [1,2], [3,4] ].each_with_index do |e, row, col|&#xA;    puts &quot;#{e} at #{row}, #{col}&quot;&#xA;  end&#xA;    # =&gt; 1 at 0, 0&#xA;    # =&gt; 2 at 0, 1&#xA;    # =&gt; 3 at 1, 0&#xA;    # =&gt; 4 at 1, 1" />
        <scope name="element" ilk="function" signature="element(i, j)" />
        <scope name="elements_to_f" ilk="function" signature="elements_to_f()" />
        <scope name="elements_to_i" ilk="function" signature="elements_to_i()" />
        <scope name="elements_to_r" ilk="function" signature="elements_to_r()" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if this is an empty matrix, i.e. if the number of rows or the number of columns is 0." />
        <scope name="eql?" ilk="function" signature="eql?(other)" />
        <scope name="hash" ilk="function" signature="hash()" doc="Returns a hash-code for the matrix." />
        <scope name="imag" ilk="function" signature="imag()" />
        <scope name="imaginary" ilk="function" signature="imaginary()" doc="Returns the imaginary part of the matrix.   Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;    =&gt; 1+2i  i  0&#xA;          1  2  3&#xA;  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].imaginary&#xA;    =&gt;   2i  i  0&#xA;          0  0  0" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Overrides Object#inspect" />
        <scope name="inv" ilk="function" signature="inv()" />
        <scope name="inverse" ilk="function" signature="inverse()" doc="Returns the inverse of the matrix.   Matrix[[-1, -1], [0, -1]].inverse&#xA;    =&gt; -1  1&#xA;        0 -1" />
        <scope name="map" ilk="function" signature="map()" />
        <scope name="minor" ilk="function" signature="minor(*param)" doc="Returns a section of the matrix.  The parameters are either: start_row, nrows, start_col, ncols; OR&#xA;row_range, col_range &#xA;   Matrix.diagonal(9, 5, -3).minor(0..1, 0..2)&#xA;    =&gt; 9 0 0&#xA;       0 5 0&#xA; Like Array#[], negative indices count backward from the end of the row or column (-1 is the last element). Returns nil if the starting row or column is greater than row_size or column_size respectively." />
        <scope name="rank" ilk="function" signature="rank()" doc="Returns the rank of the matrix. Beware that using Float values can yield erroneous results because of their lack of precision. Consider using exact types like Rational or BigDecimal instead. &#xA;   Matrix[[7,6], [3,9]].rank&#xA;    =&gt; 2" />
        <scope name="rank_e" ilk="function" signature="rank_e()" doc="deprecated; use Matrix#rank" />
        <scope name="real" ilk="function" signature="real()" doc="Returns the real part of the matrix.   Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;    =&gt; 1+2i  i  0&#xA;          1  2  3&#xA;  Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].real&#xA;    =&gt;    1  0  0&#xA;          1  2  3" />
        <scope name="real?" ilk="function" signature="real?()" doc="Returns +true+ if all entries of the matrix are real." />
        <scope name="rect" ilk="function" signature="rect()" doc="Returns an array containing matrices corresponding to the real and imaginary parts of the matrix &#xA; m.rect == [m.real, m.imag]  # ==&gt; true for all matrices m" />
        <scope name="rectangular" ilk="function" signature="rectangular()" />
        <scope name="regular?" ilk="function" signature="regular?()" doc="Returns +true+ if this is a regular (i.e. non-singular) matrix." />
        <scope name="row" ilk="function" signature="row(i)" doc="Returns row vector number +i+ of the matrix as a Vector (starting at 0 like an array).  When a block is given, the elements of that vector are iterated." />
        <scope name="row_size" ilk="function" signature="row_size()" doc="Returns the number of rows." />
        <scope name="row_vectors" ilk="function" signature="row_vectors()" doc="Returns an array of the row vectors of the matrix.  See Vector." />
        <scope name="singular?" ilk="function" signature="singular?()" doc="Returns +true+ is this is a singular matrix." />
        <scope name="square?" ilk="function" signature="square?()" doc="Returns +true+ is this is a square matrix." />
        <scope name="t" ilk="function" signature="t()" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns an array of arrays that describe the rows of the matrix." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Overrides Object#to_s" />
        <scope name="tr" ilk="function" signature="tr()" />
        <scope name="trace" ilk="function" signature="trace()" doc="Returns the trace (sum of diagonal elements) of the matrix.   Matrix[[7,6], [3,9]].trace&#xA;    =&gt; 16" />
        <scope name="transpose" ilk="function" signature="transpose()" doc="Returns the transpose of the matrix.   Matrix[[1,2], [3,4], [5,6]]&#xA;    =&gt; 1 2&#xA;       3 4&#xA;       5 6&#xA;  Matrix[[1,2], [3,4], [5,6]].transpose&#xA;    =&gt; 1 3 5&#xA;       2 4 6" />
        <scope ilk="function" name="column_size" />
        <scope ilk="function" name="rows" />
        <scope name="CoercionHelper" ilk="namespace">
        </scope>
        <scope name="ConversionHelper" ilk="namespace">
        </scope>
        <scope name="Scalar" ilk="class" classrefs="Numeric">
        </scope>
      </scope>
    </scope>
    <scope name="mutex_m" ilk="blob" lang="Ruby">
      <scope name="Mutex_m" ilk="namespace">
        <scope name="append_features" ilk="function" signature="append_features(cl)" attributes="__classmethod__" />
        <scope name="define_aliases" ilk="function" signature="define_aliases(cl)" attributes="__classmethod__" />
        <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
        <scope name="mu_extended" ilk="function" signature="mu_extended()" />
        <scope name="mu_lock" ilk="function" signature="mu_lock()" />
        <scope name="mu_locked?" ilk="function" signature="mu_locked?()" />
        <scope name="mu_synchronize" ilk="function" signature="mu_synchronize(&amp;block)" doc="locking" />
        <scope name="mu_try_lock" ilk="function" signature="mu_try_lock()" />
        <scope name="mu_unlock" ilk="function" signature="mu_unlock()" />
      </scope>
    </scope>
    <scope name="net/ftp" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="FTP" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(host = nil, user = nil, passwd = nil, acct = nil)" attributes="__classmethod__ __ctor__" doc="Creates and returns a new +FTP+ object. If a +host+ is given, a connection is made. Additionally, if the +user+ is given, the given user name, password, and (optionally) account are used to log in.  See #login." />
          <scope name="open" ilk="function" signature="open(host, user = nil, passwd = nil, acct = nil)" attributes="__classmethod__" doc="A synonym for FTP.new, but with a mandatory host parameter. &#xA; If a block is given, it is passed the +FTP+ object, which will be closed when the block finishes, or when an exception is raised." />
          <scope name="abort" ilk="function" signature="abort()" doc="Aborts the previous command (ABOR command)." />
          <scope name="acct" ilk="function" signature="acct(account)" doc="Sends the ACCT command.  TODO: more info." />
          <scope name="binary=" ilk="function" signature="binary=(newmode)" />
          <scope name="chdir" ilk="function" signature="chdir(dirname)" doc="Changes the (remote) directory." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the connection.  Further operations are impossible until you open a new connection with #connect." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Returns +true+ iff the connection is closed." />
          <scope name="connect" ilk="function" signature="connect(host, port = FTP_PORT)" doc="Establishes an FTP connection to host, optionally overriding the default port. If the environment variable +SOCKS_SERVER+ is set, sets up the connection through a SOCKS proxy. Raises an exception (typically Errno::ECONNREFUSED) if the connection cannot be established." />
          <scope name="delete" ilk="function" signature="delete(filename)" doc="Deletes a file on the server." />
          <scope name="dir" ilk="function" signature="dir(*args)" />
          <scope name="get" ilk="function" signature="get(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE)" doc="Retrieves +remotefile+ in whatever mode the session is set (text or binary).  See #gettextfile and #getbinaryfile." />
          <scope name="getbinaryfile" ilk="function" signature="getbinaryfile(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE)" doc="Retrieves +remotefile+ in binary mode, storing the result in +localfile+. If +localfile+ is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data in +blocksize+ chunks." />
          <scope name="getdir" ilk="function" signature="getdir()" />
          <scope name="gettextfile" ilk="function" signature="gettextfile(remotefile, localfile = File.basename(remotefile))" doc="Retrieves +remotefile+ in ASCII (text) mode, storing the result in +localfile+. If +localfile+ is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data one line at a time." />
          <scope name="help" ilk="function" signature="help(arg = nil)" doc="Issues the HELP command." />
          <scope name="list" ilk="function" signature="list(*args)" doc="Returns an array of file information in the directory (the output is like `ls -l`).  If a block is given, it iterates through the listing." />
          <scope name="login" ilk="function" signature="login(user = &quot;anonymous&quot;, passwd = nil, acct = nil)" doc="Logs in to the remote host. The session must have been previously connected.  If +user+ is the string &quot;anonymous&quot; and the +password+ is +nil+, a password of user@host is synthesized. If the +acct+ parameter is not +nil+, an FTP ACCT command is sent following the successful login.  Raises an exception on error (typically Net::FTPPermError)." />
          <scope name="ls" ilk="function" signature="ls(*args)" />
          <scope name="mdtm" ilk="function" signature="mdtm(filename)" doc="Issues the MDTM command.  TODO: more info." />
          <scope name="mkdir" ilk="function" signature="mkdir(dirname)" doc="Creates a remote directory." />
          <scope name="mtime" ilk="function" signature="mtime(filename, local = false)" doc="Returns the last modification time of the (remote) file.  If +local+ is +true+, it is returned as a local time, otherwise it&apos;s a UTC time." />
          <scope name="nlst" ilk="function" signature="nlst(dir = nil)" doc="Returns an array of filenames in the remote directory." />
          <scope name="noop" ilk="function" signature="noop()" doc="Issues a NOOP command." />
          <scope name="put" ilk="function" signature="put(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE, &amp;block)" doc="Transfers +localfile+ to the server in whatever mode the session is set (text or binary).  See #puttextfile and #putbinaryfile." />
          <scope name="putbinaryfile" ilk="function" signature="putbinaryfile(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE)" doc="Transfers +localfile+ to the server in binary mode, storing the result in +remotefile+. If a block is supplied, calls it, passing in the transmitted data in +blocksize+ chunks." />
          <scope name="puttextfile" ilk="function" signature="puttextfile(localfile, remotefile = File.basename(localfile))" doc="Transfers +localfile+ to the server in ASCII (text) mode, storing the result in +remotefile+. If callback or an associated block is supplied, calls it, passing in the transmitted data one line at a time." />
          <scope name="pwd" ilk="function" signature="pwd()" doc="Returns the current remote directory." />
          <scope name="quit" ilk="function" signature="quit()" doc="Exits the FTP session." />
          <scope name="rename" ilk="function" signature="rename(fromname, toname)" doc="Renames a file on the server." />
          <scope name="retrbinary" ilk="function" signature="retrbinary(cmd, blocksize, rest_offset = nil)" doc="Puts the connection into binary (image) mode, issues the given command, and fetches the data returned, passing it to the associated block in chunks of +blocksize+ characters. Note that +cmd+ is a server command (such as &quot;RETR myfile&quot;)." />
          <scope name="retrlines" ilk="function" signature="retrlines(cmd)" doc="Puts the connection into ASCII (text) mode, issues the given command, and passes the resulting data, one line at a time, to the associated block. If no block is given, prints the lines. Note that +cmd+ is a server command (such as &quot;RETR myfile&quot;)." />
          <scope name="return_code" ilk="function" signature="return_code()" doc="Obsolete" />
          <scope name="return_code=" ilk="function" signature="return_code=(s)" doc="Obsolete" />
          <scope name="rmdir" ilk="function" signature="rmdir(dirname)" doc="Removes a remote directory." />
          <scope name="sendcmd" ilk="function" signature="sendcmd(cmd)" doc="Sends a command and returns the response." />
          <scope name="set_socket" ilk="function" signature="set_socket(sock, get_greeting = true)" doc="WRITEME or make private" />
          <scope name="site" ilk="function" signature="site(arg)" doc="Issues a SITE command." />
          <scope name="size" ilk="function" signature="size(filename)" doc="Returns the size of the given (remote) filename." />
          <scope name="status" ilk="function" signature="status()" doc="Returns the status (STAT command)." />
          <scope name="storbinary" ilk="function" signature="storbinary(cmd, file, blocksize, rest_offset = nil)" doc="Puts the connection into binary (image) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named +file+ to the server. If the optional block is given, it also passes it the data, in chunks of +blocksize+ characters." />
          <scope name="storlines" ilk="function" signature="storlines(cmd, file)" doc="Puts the connection into ASCII (text) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named +file+ to the server, one line at a time. If the optional block is given, it also passes it the lines." />
          <scope name="system" ilk="function" signature="system()" doc="Returns system information." />
          <scope name="voidcmd" ilk="function" signature="voidcmd(cmd)" doc="Sends a command and expect a response beginning with &apos;2&apos;." />
          <scope ilk="function" name="binary" />
          <scope ilk="function" name="debug_mode" />
          <scope ilk="function" name="debug_mode=" />
          <scope ilk="function" name="last_response" />
          <scope ilk="function" name="last_response_code" />
          <scope ilk="function" name="passive" />
          <scope ilk="function" name="passive=" />
          <scope ilk="function" name="resume" />
          <scope ilk="function" name="resume=" />
          <scope ilk="function" name="welcome" />
        </scope>
      </scope>
    </scope>
    <scope name="net/http" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="HTTP" ilk="class" classrefs="Protocol">
          <scope name="Proxy" ilk="function" signature="Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" doc="Creates an HTTP proxy class. Arguments are address/port of proxy host and username/password if authorization on proxy server is required. You can replace the HTTP class with created proxy class. &#xA; If ADDRESS is nil, this method returns self (Net::HTTP). &#xA;     # Example&#xA;    proxy_class = Net::HTTP::Proxy(&apos;proxy.example.com&apos;, 8080)&#xA;                    :&#xA;    proxy_class.start(&apos;www.ruby-lang.org&apos;) {|http|&#xA;      # connecting proxy.foo.org:8080&#xA;                    :&#xA;    }" />
          <scope name="default_port" ilk="function" attributes="__classmethod__" />
          <scope name="get" ilk="function" signature="get(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Send a GET request to the target and return the response as a string.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA;    print Net::HTTP.get(URI.parse(&apos;http://www.example.com/index.html&apos;))&#xA; or: &#xA;    print Net::HTTP.get(&apos;www.example.com&apos;, &apos;/index.html&apos;)" />
          <scope name="get_print" ilk="function" signature="get_print(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Get body from target and output it to +$stdout+.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA;    Net::HTTP.get_print URI.parse(&apos;http://www.example.com/index.html&apos;)&#xA; or: &#xA;    Net::HTTP.get_print &apos;www.example.com&apos;, &apos;/index.html&apos;" />
          <scope name="get_response" ilk="function" signature="get_response(uri_or_host, path = nil, port = nil, &amp;block)" attributes="__classmethod__" doc="Send a GET request to the target and return the response as a Net::HTTPResponse object.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA;    res = Net::HTTP.get_response(URI.parse(&apos;http://www.example.com/index.html&apos;))&#xA;   print res.body&#xA; or: &#xA;    res = Net::HTTP.get_response(&apos;www.example.com&apos;, &apos;/index.html&apos;)&#xA;   print res.body" />
          <scope name="http_default_port" ilk="function" attributes="__classmethod__" />
          <scope name="https_default_port" ilk="function" attributes="__classmethod__" />
          <scope name="is_version_1_1?" ilk="function" attributes="__classmethod__" />
          <scope name="is_version_1_2?" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" attributes="__classmethod__ __ctor__" />
          <scope name="newobj" ilk="function" signature="newobj(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" />
          <scope name="post_form" ilk="function" attributes="__classmethod__" />
          <scope name="proxy_class?" ilk="function" attributes="__classmethod__" />
          <scope name="start" ilk="function" attributes="__classmethod__" />
          <scope name="version_1_1" ilk="function" signature="version_1_1()" attributes="__classmethod__" doc="Turns on net/http 1.1 (ruby 1.6) features. Defaults to OFF in ruby 1.8." />
          <scope name="version_1_1?" ilk="function" signature="version_1_1?()" attributes="__classmethod__" doc="true if net/http is in version 1.1 compatible mode. Defaults to true." />
          <scope name="version_1_2" ilk="function" attributes="__classmethod__" />
          <scope name="version_1_2?" ilk="function" signature="version_1_2?()" attributes="__classmethod__" doc="true if net/http is in version 1.2 mode. Defaults to true." />
          <scope name="D" ilk="function" signature="D(msg)" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="addr_port" ilk="function" />
          <scope name="begin_transport" ilk="function" />
          <scope name="conn_address" ilk="function" />
          <scope name="conn_port" ilk="function" signature="conn_port()" />
          <scope name="connect" ilk="function" signature="connect()" />
          <scope name="copy" ilk="function" />
          <scope name="delete" ilk="function" signature="delete(path, initheader = {&apos;Depth&apos; =&gt; &apos;Infinity&apos;})" doc="Sends a DELETE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="do_finish" ilk="function" />
          <scope name="do_start" ilk="function" />
          <scope name="edit_path" ilk="function" signature="edit_path(path)" />
          <scope name="end_transport" ilk="function" signature="end_transport(req, res)" />
          <scope name="finish" ilk="function" />
          <scope name="get" ilk="function" signature="get(path, initheader = {}, dest = nil)" doc="Gets data from +path+ on the connected-to host. +initheader+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }, and it defaults to an empty hash. If +initheader+ doesn&apos;t have the key &apos;accept-encoding&apos;, then a value of &quot;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&quot; is used, so that gzip compression is used in preference to deflate compression, which is used in preference to no compression. Ruby doesn&apos;t have libraries to support the compress (Lempel-Ziv) compression, so that is not supported.  The intent of this is to reduce bandwidth by default.   If this routine sets up compression, then it does the decompression also, removing the header as well to prevent confusion.  Otherwise it leaves the body as it found it. &#xA; In version 1.1 (ruby 1.6), this method returns a pair of objects, a Net::HTTPResponse object and the entity body string. In version 1.2 (ruby 1.8), this method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it is read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; In version 1.1, this method might raise an exception for 3xx (redirect). In this case you can get a HTTPResponse object by &quot;anException.response&quot;. &#xA; In version 1.2, this method never raises exception. &#xA;     # version 1.1 (bundled with Ruby 1.6)&#xA;    response, body = http.get(&apos;/index.html&apos;)&#xA;    # version 1.2 (bundled with Ruby 1.8 or later)&#xA;    response = http.get(&apos;/index.html&apos;)&#xA;    # using block&#xA;    File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;      http.get(&apos;/~foo/&apos;) do |str|" />
          <scope name="get2" ilk="function" />
          <scope name="head" ilk="function" />
          <scope name="head2" ilk="function" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="keep_alive?" ilk="function" />
          <scope name="lock" ilk="function" />
          <scope name="mkcol" ilk="function" />
          <scope name="move" ilk="function" />
          <scope name="on_connect" ilk="function" />
          <scope name="options" ilk="function" signature="options(path, initheader = nil)" doc="Sends a OPTIONS request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="peer_cert" ilk="function" signature="peer_cert()" doc="return the X.509 certificates the server presented." />
          <scope name="post" ilk="function" signature="post(path, data, initheader = nil, dest = nil)" doc="Posts +data+ (must be a String) to +path+. +header+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }. &#xA; In version 1.1 (ruby 1.6), this method returns a pair of objects, a Net::HTTPResponse object and an entity body string. In version 1.2 (ruby 1.8), this method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it are read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; In version 1.1, this method might raise an exception for 3xx (redirect). In this case you can get an HTTPResponse object by &quot;anException.response&quot;. In version 1.2, this method never raises exception. &#xA;     # version 1.1&#xA;    response, body = http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;)&#xA;    # version 1.2&#xA;    response = http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;)&#xA;    # using block&#xA;    File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;      http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;) do |str|&#xA;        f.write str" />
          <scope name="post2" ilk="function" />
          <scope name="propfind" ilk="function" signature="propfind(path, body = nil, initheader = {&apos;Depth&apos; =&gt; &apos;0&apos;})" doc="Sends a PROPFIND request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="proppatch" ilk="function" />
          <scope name="proxy?" ilk="function" />
          <scope name="proxy_address" ilk="function" />
          <scope name="proxy_pass" ilk="function" />
          <scope name="proxy_port" ilk="function" />
          <scope name="proxy_user" ilk="function" />
          <scope name="proxyaddr" ilk="function" />
          <scope name="proxyport" ilk="function" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Setter for the read_timeout attribute." />
          <scope name="request" ilk="function" signature="request(req, body = nil)" doc="Sends an HTTPRequest object REQUEST to the HTTP server. This method also sends DATA string if REQUEST is a post/put request. Giving DATA for get/head request causes ArgumentError. &#xA; When called with a block, yields an HTTPResponse object. The body of this response will not have been read yet; the caller can process it using HTTPResponse#read_body, if desired. &#xA; Returns a HTTPResponse object. &#xA; This method never raises Net::* exceptions." />
          <scope name="request_get" ilk="function" />
          <scope name="request_head" ilk="function" />
          <scope name="request_post" ilk="function" />
          <scope name="send_request" ilk="function" signature="send_request(name, path, data = nil, header = nil)" doc="Sends an HTTP request to the HTTP server. This method also sends DATA string if DATA is given. &#xA; Returns a HTTPResponse object. &#xA; This method never raises Net::* exceptions. &#xA;    response = http.send_request(&apos;GET&apos;, &apos;/index.html&apos;)&#xA;   puts response.body" />
          <scope name="set_debug_output" ilk="function" />
          <scope name="sspi_auth" ilk="function" />
          <scope name="sspi_auth?" ilk="function" signature="sspi_auth?(res)" />
          <scope name="start" ilk="function" />
          <scope name="started?" ilk="function" />
          <scope name="trace" ilk="function" />
          <scope name="transport_request" ilk="function" signature="transport_request(req)" />
          <scope name="unlock" ilk="function" />
          <scope name="use_ssl=" ilk="function" signature="use_ssl=(flag)" doc="Turn on/off SSL. This flag must be set before starting session. If you change use_ssl value after session started, a Net::HTTP object raises IOError." />
          <scope name="use_ssl?" ilk="function" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="close_on_empty_response" />
          <scope ilk="function" name="close_on_empty_response=" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="proxy_address" />
          <scope ilk="function" name="proxy_pass" />
          <scope ilk="function" name="proxy_port" />
          <scope ilk="function" name="proxy_user" />
          <scope ilk="function" name="read_timeout" />
          <variable name="SSL_ATTRIBUTES" attributes="__const__" citdl="Object" />
          <variable name="SSL_ATTRIBUTES" attributes="__const__" citdl="Object" />
          <scope name="Copy" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Delete" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Get" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Head" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Lock" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Mkcol" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Move" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Options" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Post" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Propfind" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Proppatch" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="ProxyDelta" ilk="namespace">
          </scope>
          <scope name="Put" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Trace" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Unlock" ilk="class" classrefs="HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="HTTPError" ilk="class" classrefs="ProtocolError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPExceptions" ilk="namespace">
          <scope ilk="function" name="response" />
        </scope>
        <scope name="HTTPFatalError" ilk="class" classrefs="ProtoFatalError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPGenericRequest" ilk="class" classrefs="Object">
          <import symbol="HTTPHeader" />
          <scope name="new" ilk="function" signature="new(m, reqbody, resbody, path, initheader = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="body=" ilk="function" signature="body=(str)" />
          <scope name="body_exist?" ilk="function" signature="body_exist?()" />
          <scope name="body_stream=" ilk="function" signature="body_stream=(input)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="request_body_permitted?" ilk="function" signature="request_body_permitted?()" />
          <scope name="response_body_permitted?" ilk="function" signature="response_body_permitted?()" />
          <scope ilk="function" name="body" />
          <scope ilk="function" name="body_stream" />
          <scope ilk="function" name="method" />
          <scope ilk="function" name="path" />
        </scope>
        <scope name="HTTPHeader" ilk="namespace">
          <scope name="add_field" ilk="function" signature="add_field(key, val)" doc="&#xA; Adds header field instead of replace. Second argument +val+ must be a String. See also #[]=, #[] and #get_fields. &#xA;   request.add_field &apos;X-My-Header&apos;, &apos;a&apos;&#xA;  p request[&apos;X-My-Header&apos;]              =&gt; &quot;a&quot;&#xA;  p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;]&#xA;  request.add_field &apos;X-My-Header&apos;, &apos;b&apos;&#xA;  p request[&apos;X-My-Header&apos;]              =&gt; &quot;a, b&quot;&#xA;  p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;, &quot;b&quot;]&#xA;  request.add_field &apos;X-My-Header&apos;, &apos;c&apos;&#xA;  p request[&apos;X-My-Header&apos;]              =&gt; &quot;a, b, c&quot;&#xA;  p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]" />
          <scope name="basic_auth" ilk="function" signature="basic_auth(account, password)" doc="Set the Authorization: header for &quot;Basic&quot; authorization." />
          <scope name="canonical_each" ilk="function" signature="canonical_each()" />
          <scope name="chunked?" ilk="function" signature="chunked?()" doc="Returns &quot;true&quot; if the &quot;transfer-encoding&quot; header is present and set to &quot;chunked&quot;.  This is an HTTP/1.1 feature, allowing the the content to be sent in &quot;chunks&quot; without at the outset stating the entire content length." />
          <scope name="connection_close?" ilk="function" signature="connection_close?()" />
          <scope name="connection_keep_alive?" ilk="function" signature="connection_keep_alive?()" />
          <scope name="content_length" ilk="function" signature="content_length()" doc="Returns an Integer object which represents the Content-Length: header field or +nil+ if that field is not provided." />
          <scope name="content_length=" ilk="function" signature="content_length=(len)" />
          <scope name="content_range" ilk="function" signature="content_range()" doc="Returns a Range object which represents Content-Range: header field. This indicates, for a partial entity body, where this fragment fits inside the full entity body, as range of byte offsets." />
          <scope name="content_type" ilk="function" signature="content_type()" doc="Returns a content type string such as &quot;text/html&quot;. This method returns nil if Content-Type: header field does not exist." />
          <scope name="content_type=" ilk="function" signature="content_type=(type, params = {})" />
          <scope name="delete" ilk="function" signature="delete(key)" doc="Removes a header field." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_capitalized" ilk="function" signature="each_capitalized()" doc="As for #each_header, except the keys are provided in capitalized form." />
          <scope name="each_capitalized_name" ilk="function" signature="each_capitalized_name()" doc="Iterates for each capitalized header names." />
          <scope name="each_header" ilk="function" signature="each_header()" doc="Iterates for each header names and values." />
          <scope name="each_key" ilk="function" signature="each_key()" />
          <scope name="each_name" ilk="function" signature="each_name()" doc="Iterates for each header names." />
          <scope name="each_value" ilk="function" signature="each_value()" doc="Iterates for each header values." />
          <scope name="fetch" ilk="function" signature="fetch(key, *args)" doc="Returns the header field corresponding to the case-insensitive key. Returns the default value +args+, or the result of the block, or raises an IndexErrror if there&apos;s no header field named +key+ See Hash#fetch" />
          <scope name="form_data=" ilk="function" signature="form_data=(params, sep = &apos;&amp;&apos;)" />
          <scope name="get_fields" ilk="function" signature="get_fields(key)" doc="&#xA; Returns an array of header field strings corresponding to the case-insensitive +key+.  This method allows you to get duplicated header fields without any processing.  See also #[]. &#xA;   p response.get_fields(&apos;Set-Cookie&apos;)&#xA;    =&gt; [&quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23&quot;,&#xA;         &quot;query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;]&#xA;  p response[&apos;Set-Cookie&apos;]&#xA;    =&gt; &quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;" />
          <scope name="initialize_http_header" ilk="function" signature="initialize_http_header(initheader)" />
          <scope name="key?" ilk="function" signature="key?(key)" doc="true if +key+ header exists." />
          <scope name="main_type" ilk="function" signature="main_type()" doc="Returns a content type string such as &quot;text&quot;. This method returns nil if Content-Type: header field does not exist." />
          <scope name="proxy_basic_auth" ilk="function" signature="proxy_basic_auth(account, password)" doc="Set Proxy-Authorization: header for &quot;Basic&quot; authorization." />
          <scope name="range" ilk="function" signature="range()" doc="Returns an Array of Range objects which represents Range: header field, or +nil+ if there is no such header." />
          <scope name="range=" ilk="function" signature="range=(r, e = nil)" />
          <scope name="range_length" ilk="function" signature="range_length()" doc="The length of the range represented in Content-Range: header." />
          <scope name="set_content_type" ilk="function" signature="set_content_type(type, params = {})" doc="Set Content-Type: header field by +type+ and +params+. +type+ must be a String, +params+ must be a Hash." />
          <scope name="set_form_data" ilk="function" signature="set_form_data(params, sep = &apos;&amp;&apos;)" doc="Set header fields and a body from HTML form data. +params+ should be a Hash containing HTML form data. Optional argument +sep+ means data record separator. &#xA; This method also set Content-Type: header field to application/x-www-form-urlencoded. &#xA; Example:    http.form_data = {&quot;q&quot; =&gt; &quot;ruby&quot;, &quot;lang&quot; =&gt; &quot;en&quot;}&#xA;   http.form_data = {&quot;q&quot; =&gt; [&quot;ruby&quot;, &quot;perl&quot;], &quot;lang&quot; =&gt; &quot;en&quot;}&#xA;   http.set_form_data({&quot;q&quot; =&gt; &quot;ruby&quot;, &quot;lang&quot; =&gt; &quot;en&quot;}, &apos;;&apos;)" />
          <scope name="set_range" ilk="function" signature="set_range(r, e = nil)" doc="Set Range: header from Range (arg r) or beginning index and length from it (arg idx&amp;len). &#xA;   req.range = (0..1023)&#xA;  req.set_range 0, 1023" />
          <scope name="sub_type" ilk="function" signature="sub_type()" doc="Returns a content type string such as &quot;html&quot;. This method returns nil if Content-Type: header field does not exist or sub-type is not given (e.g. &quot;Content-Type: text&quot;)." />
          <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns a Hash consist of header names and values." />
          <scope name="type_params" ilk="function" signature="type_params()" doc="Returns content type parameters as a Hash as like {&quot;charset&quot; =&gt; &quot;iso-2022-jp&quot;}." />
        </scope>
        <scope name="HTTPRequest" ilk="class" classrefs="HTTPGenericRequest">
          <scope name="new" ilk="function" signature="new(path, initheader = nil)" attributes="__classmethod__ __ctor__" doc="Creates HTTP request object." />
        </scope>
        <scope name="HTTPResponse" ilk="class" classrefs="Object">
          <import symbol="HTTPHeader" />
          <scope name="body_permitted?" ilk="function" signature="body_permitted?()" attributes="__classmethod__" doc="true if the response has body." />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="to_ary" ilk="function" signature="to_ary()" doc="For backward compatibility. To allow Net::HTTP 1.1 style assignment e.g.    response, body = Net::HTTP.get(....)" />
          <scope ilk="function" name="code" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="message" />
          <variable name="CODE_CLASS_TO_OBJ" attributes="__const__" citdl="Object" />
          <variable name="CODE_TO_OBJ" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="HTTPRetriableError" ilk="class" classrefs="ProtoRetriableError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPServerException" ilk="class" classrefs="ProtoServerError">
          <import symbol="HTTPExceptions" />
        </scope>
      </scope>
    </scope>
    <scope name="net/imap" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="IMAP" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <import symbol="OpenSSL" />
          <import symbol="SSL" />
          <scope name="add_authenticator" ilk="function" signature="add_authenticator(auth_type, authenticator)" attributes="__classmethod__" doc="Adds an authenticator for Net::IMAP#authenticate.  +auth_type+ is the type of authentication this authenticator supports (for instance, &quot;LOGIN&quot;).  The +authenticator+ is an object which defines a process() method to handle authentication with the server.  See Net::IMAP::LoginAuthenticator, Net::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator for examples. &#xA; If +auth_type+ refers to an existing authenticator, it will be replaced by the new one." />
          <scope name="debug" ilk="function" signature="debug()" attributes="__classmethod__" doc="Returns the debug mode." />
          <scope name="debug=" ilk="function" signature="debug=(val)" attributes="__classmethod__" doc="Sets the debug mode." />
          <scope name="decode_utf7" ilk="function" signature="decode_utf7(s)" attributes="__classmethod__" doc="Decode a string from modified UTF-7 format to UTF-8. &#xA; UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a slightly modified version of this to encode mailbox names containing non-ASCII characters; see [IMAP] section 5.1.3. &#xA; Net::IMAP does _not_ automatically encode and decode mailbox names to and from utf7." />
          <scope name="encode_utf7" ilk="function" signature="encode_utf7(s)" attributes="__classmethod__" doc="Encode a string from UTF-8 format to modified UTF-7." />
          <scope name="format_date" ilk="function" signature="format_date(time)" attributes="__classmethod__" doc="Formats +time+ as an IMAP-style date." />
          <scope name="format_datetime" ilk="function" signature="format_datetime(time)" attributes="__classmethod__" doc="Formats +time+ as an IMAP-style date-time." />
          <scope name="max_flag_count" ilk="function" signature="max_flag_count()" attributes="__classmethod__" doc="Returns the max number of flags interned to symbols." />
          <scope name="max_flag_count=" ilk="function" signature="max_flag_count=(count)" attributes="__classmethod__" doc="Sets the max number of flags interned to symbols." />
          <scope name="new" ilk="function" signature="new(host, port_or_options = {}, usessl = false, certs = nil, verify = true)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::IMAP object and connects it to the specified +host+. &#xA; +options+ is an option hash, each key of which is a symbol. &#xA; The available options are: &#xA; port number (default value is 143 for imap, or 993 for imaps)&#xA;if options[:ssl] is true, then an attempt will be made to use SSL (now TLS) to connect to the server.  For this to work OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to be installed. if options[:ssl] is a hash, it&apos;s passed to OpenSSL::SSL::SSLContext#set_params as parameters. &#xA; The most common errors are: &#xA; connection refused by +host+ or an intervening firewall.&#xA;connection timed out (possibly due to packets being dropped by an intervening firewall).&#xA;there is no route to that network.&#xA;hostname not known or other socket error.&#xA;we connected to the host, but they immediately said goodbye to us." />
          <scope name="add_response_handler" ilk="function" signature="add_response_handler(handler = Proc.new)" doc="Adds a response handler. For example, to detect when the server sends us a new EXISTS response (which normally indicates new messages being added to the mail box), you could add the following handler after selecting the mailbox. &#xA;   imap.add_response_handler { |resp|&#xA;    if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == &quot;EXISTS&quot;&#xA;      puts &quot;Mailbox now has #{resp.data} messages&quot;&#xA;    end&#xA;  }" />
          <scope name="append" ilk="function" signature="append(mailbox, message, flags = nil, date_time = nil)" doc="Sends a APPEND command to append the +message+ to the end of the +mailbox+. The optional +flags+ argument is an array of flags to initially passing to the new message.  The optional +date_time+ argument specifies the creation time to assign to the new message; it defaults to the current time. For example: &#xA;   imap.append(&quot;inbox&quot;, &lt;&lt;EOF.gsub(/\n/, &quot;\r\n&quot;), [:Seen], Time.now)&#xA;  Subject: hello&#xA;  From: shugo@ruby-lang.org&#xA;  To: shugo@ruby-lang.org&#xA;&#xA;  hello world&#xA;  EOF&#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist (it is not created automatically), or if the flags, date_time, or message arguments contain errors." />
          <scope name="authenticate" ilk="function" signature="authenticate(auth_type, *args)" doc="Sends an AUTHENTICATE command to authenticate the client. The +auth_type+ parameter is a string that represents the authentication mechanism to be used. Currently Net::IMAP supports authentication mechanisms: &#xA;   LOGIN:: login using cleartext user and password.&#xA;  CRAM-MD5:: login with cleartext user and encrypted password&#xA;             (see [RFC-2195] for a full description).  This&#xA;             mechanism requires that the server have the user&apos;s&#xA;             password stored in clear-text password.&#xA; For both these mechanisms, there should be two +args+: username and (cleartext) password.  A server may not support one or other of these mechanisms; check #capability() for a capability of the form &quot;AUTH=LOGIN&quot; or &quot;AUTH=CRAM-MD5&quot;. &#xA; Authentication is done using the appropriate authenticator object: see @@authenticators for more information on plugging in your own authenticator. &#xA; For example: &#xA;    imap.authenticate(&apos;LOGIN&apos;, user, password)&#xA; A Net::IMAP::NoResponseError is raised if authentication fails." />
          <scope name="capability" ilk="function" signature="capability()" doc="Sends a CAPABILITY command, and returns an array of capabilities that the server supports.  Each capability is a string.  See [IMAP] for a list of possible capabilities. &#xA; Note that the Net::IMAP class does not modify its behaviour according to the capabilities of the server; it is up to the user of the class to ensure that a certain capability is supported by a server before using it." />
          <scope name="check" ilk="function" signature="check()" doc="Sends a CHECK command to request a checkpoint of the currently selected mailbox.  This performs implementation-specific housekeeping, for instance, reconciling the mailbox&apos;s in-memory and on-disk state." />
          <scope name="close" ilk="function" signature="close()" doc="Sends a CLOSE command to close the currently selected mailbox. The CLOSE command permanently removes from the mailbox all messages that have the \Deleted flag set." />
          <scope name="copy" ilk="function" signature="copy(set, mailbox)" doc="Sends a COPY command to copy the specified message(s) to the end of the specified destination +mailbox+. The +set+ parameter is a number or an array of numbers or a Range object. The number is a message sequence number." />
          <scope name="create" ilk="function" signature="create(mailbox)" doc="Sends a CREATE command to create a new +mailbox+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be created." />
          <scope name="delete" ilk="function" signature="delete(mailbox)" doc="Sends a DELETE command to remove the +mailbox+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be deleted, either because it does not exist or because the client does not have permission to delete it." />
          <scope name="disconnect" ilk="function" signature="disconnect()" doc="Disconnects from the server." />
          <scope name="disconnected?" ilk="function" signature="disconnected?()" doc="Returns true if disconnected from the server." />
          <scope name="examine" ilk="function" signature="examine(mailbox)" doc="Sends a EXAMINE command to select a +mailbox+ so that messages in the +mailbox+ can be accessed.  Behaves the same as #select(), except that the selected +mailbox+ is identified as read-only. &#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-examinable." />
          <scope name="expunge" ilk="function" signature="expunge()" doc="Sends a EXPUNGE command to permanently remove from the currently selected mailbox all messages that have the \Deleted flag set." />
          <scope name="fetch" ilk="function" signature="fetch(set, attr)" doc="Sends a FETCH command to retrieve data associated with a message in the mailbox. The +set+ parameter is a number or an array of numbers or a Range object. The number is a message sequence number.  +attr+ is a list of attributes to fetch; see the documentation for Net::IMAP::FetchData for a list of valid attributes. The return value is an array of Net::IMAP::FetchData. For example: &#xA;   p imap.fetch(6..8, &quot;UID&quot;)&#xA;  =&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;UID&quot;=&gt;98}&gt;, \\&#xA;       #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;UID&quot;=&gt;99}&gt;, \\&#xA;       #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;UID&quot;=&gt;100}&gt;]&#xA;  p imap.fetch(6, &quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;)&#xA;  =&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;=&gt;&quot;Subject: test\r\n\r\n&quot;}&gt;]&#xA;  data = imap.uid_fetch(98, [&quot;RFC822.SIZE&quot;, &quot;INTERNALDATE&quot;])[0]&#xA;  p data.seqno&#xA;  =&gt; 6&#xA;  p data.attr[&quot;RFC822.SIZE&quot;]&#xA;  =&gt; 611&#xA;  p data.attr[&quot;INTERNALDATE&quot;]" />
          <scope name="getacl" ilk="function" signature="getacl(mailbox)" doc="Send the GETACL command along with specified +mailbox+. If this mailbox exists, an array containing objects of Net::IMAP::MailboxACLItem will be returned." />
          <scope name="getquota" ilk="function" signature="getquota(mailbox)" doc="Sends the GETQUOTA command along with specified +mailbox+. If this mailbox exists, then an array containing a Net::IMAP::MailboxQuota object is returned.  This command generally is only available to server admin." />
          <scope name="getquotaroot" ilk="function" signature="getquotaroot(mailbox)" doc="Sends the GETQUOTAROOT command along with specified +mailbox+. This command is generally available to both admin and user. If mailbox exists, returns an array containing objects of Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota." />
          <scope name="idle" ilk="function" signature="idle(&amp;response_handler)" doc="Sends an IDLE command that waits for notifications of new or expunged messages.  Yields responses from the server during the IDLE. &#xA; Use #idle_done() to leave IDLE." />
          <scope name="idle_done" ilk="function" signature="idle_done()" doc="Leaves IDLE." />
          <scope name="list" ilk="function" signature="list(refname, mailbox)" doc="Sends a LIST command, and returns a subset of names from the complete set of all names available to the client. +refname+ provides a context (for instance, a base directory in a directory-based mailbox hierarchy).  +mailbox+ specifies a mailbox or (via wildcards) mailboxes under that context. Two wildcards may be used in +mailbox+: &apos;*&apos;, which matches all characters *including* the hierarchy delimiter (for instance, &apos;/&apos; on a UNIX-hosted directory-based mailbox hierarchy); and &apos;%&apos;, which matches all characters *except* the hierarchy delimiter. &#xA; If +refname+ is empty, +mailbox+ is used directly to determine which mailboxes to match.  If +mailbox+ is empty, the root name of +refname+ and the hierarchy delimiter are returned. &#xA; The return value is an array of +Net::IMAP::MailboxList+. For example: &#xA;   imap.create(&quot;foo/bar&quot;)&#xA;  imap.create(&quot;foo/baz&quot;)&#xA;  p imap.list(&quot;&quot;, &quot;foo/%&quot;)&#xA;  =&gt; [#&lt;Net::IMAP::MailboxList attr=[:Noselect], delim=&quot;/&quot;, name=&quot;foo/&quot;&gt;, \\&#xA;       #&lt;Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=&quot;/&quot;, name=&quot;foo/bar&quot;&gt;, \\&#xA;       #&lt;Net::IMAP::MailboxList attr=[:Noinferiors], delim=&quot;/&quot;, name=&quot;foo/baz&quot;&gt;]" />
          <scope name="login" ilk="function" signature="login(user, password)" doc="Sends a LOGIN command to identify the client and carries the plaintext +password+ authenticating this +user+.  Note that, unlike calling #authenticate() with an +auth_type+ of &quot;LOGIN&quot;, #login() does *not* use the login authenticator. &#xA; A Net::IMAP::NoResponseError is raised if authentication fails." />
          <scope name="logout" ilk="function" signature="logout()" doc="Sends a LOGOUT command to inform the server that the client is done with the connection." />
          <scope name="lsub" ilk="function" signature="lsub(refname, mailbox)" doc="Sends a LSUB command, and returns a subset of names from the set of names that the user has declared as being &quot;active&quot; or &quot;subscribed&quot;.  +refname+ and +mailbox+ are interpreted as for #list(). The return value is an array of +Net::IMAP::MailboxList+." />
          <scope name="noop" ilk="function" signature="noop()" doc="Sends a NOOP command to the server. It does nothing." />
          <scope name="remove_response_handler" ilk="function" signature="remove_response_handler(handler)" doc="Removes the response handler." />
          <scope name="rename" ilk="function" signature="rename(mailbox, newname)" doc="Sends a RENAME command to change the name of the +mailbox+ to +newname+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with the name +mailbox+ cannot be renamed to +newname+ for whatever reason; for instance, because +mailbox+ does not exist, or because there is already a mailbox with the name +newname+." />
          <scope name="search" ilk="function" signature="search(keys, charset = nil)" doc="Sends a SEARCH command to search the mailbox for messages that match the given searching criteria, and returns message sequence numbers.  +keys+ can either be a string holding the entire search string, or a single-dimension array of search keywords and arguments.  The following are some common search criteria; see [IMAP] section 6.4.4 for a full list. &#xA; a set of message sequence numbers.  &apos;,&apos; indicates an interval, &apos;:&apos; indicates a range.  For instance, &apos;2,10:12,15&apos; means &quot;2,10,11,12,15&quot;. &#xA;messages with an internal date strictly before &lt;date&gt;.  The date argument has a format similar to 8-Aug-2002. &#xA;messages that contain &lt;string&gt; within their body. &#xA;messages containing &lt;string&gt; in their CC field. &#xA;messages that contain &lt;string&gt; in their FROM field. &#xA;messages with the \Recent, but not the \Seen, flag set. &#xA;negate the following search key. &#xA;&quot;or&quot; two search keys together. &#xA;messages with an internal date exactly equal to &lt;date&gt;, which has a format similar to 8-Aug-2002. &#xA;messages with an internal date on or after &lt;date&gt;. &#xA;messages with &lt;string&gt; in their subject. &#xA;messages with &lt;string&gt; in their TO field. " />
          <scope name="select" ilk="function" signature="select(mailbox)" doc="Sends a SELECT command to select a +mailbox+ so that messages in the +mailbox+ can be accessed. &#xA; After you have selected a mailbox, you may retrieve the number of items in that mailbox from @responses[&quot;EXISTS&quot;][-1], and the number of recent messages from @responses[&quot;RECENT&quot;][-1]. Note that these values can change if new messages arrive during a session; see #add_response_handler() for a way of detecting this event. &#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-selectable." />
          <scope name="setacl" ilk="function" signature="setacl(mailbox, user, rights)" doc="Sends the SETACL command along with +mailbox+, +user+ and the +rights+ that user is to have on that mailbox.  If +rights+ is nil, then that user will be stripped of any rights to that mailbox. The IMAP ACL commands are described in [RFC-2086]." />
          <scope name="setquota" ilk="function" signature="setquota(mailbox, quota)" doc="Sends a SETQUOTA command along with the specified +mailbox+ and +quota+.  If +quota+ is nil, then quota will be unset for that mailbox.  Typically one needs to be logged in as server admin for this to work.  The IMAP quota commands are described in [RFC-2087]." />
          <scope name="sort" ilk="function" signature="sort(sort_keys, search_keys, charset)" doc="Sends a SORT command to sort messages in the mailbox. Returns an array of message sequence numbers. For example: &#xA;   p imap.sort([&quot;FROM&quot;], [&quot;ALL&quot;], &quot;US-ASCII&quot;)&#xA;  =&gt; [1, 2, 3, 5, 6, 7, 8, 4, 9]&#xA;  p imap.sort([&quot;DATE&quot;], [&quot;SUBJECT&quot;, &quot;hello&quot;], &quot;US-ASCII&quot;)&#xA;  =&gt; [6, 7, 8, 1]&#xA; See [SORT-THREAD-EXT] for more details." />
          <scope name="starttls" ilk="function" signature="starttls(options = {}, verify = true)" doc="Sends a STARTTLS command to start TLS session." />
          <scope name="status" ilk="function" signature="status(mailbox, attr)" doc="Sends a STATUS command, and returns the status of the indicated +mailbox+. +attr+ is a list of one or more attributes that we are request the status of.  Supported attributes include: &#xA;   MESSAGES:: the number of messages in the mailbox.&#xA;  RECENT:: the number of recent messages in the mailbox.&#xA;  UNSEEN:: the number of unseen messages in the mailbox.&#xA; The return value is a hash of attributes. For example: &#xA;   p imap.status(&quot;inbox&quot;, [&quot;MESSAGES&quot;, &quot;RECENT&quot;])&#xA;  =&gt; {&quot;RECENT&quot;=&gt;0, &quot;MESSAGES&quot;=&gt;44}&#xA; A Net::IMAP::NoResponseError is raised if status values for +mailbox+ cannot be returned, for instance because it does not exist." />
          <scope name="store" ilk="function" signature="store(set, attr, flags)" doc="Sends a STORE command to alter data associated with messages in the mailbox, in particular their flags. The +set+ parameter is a number or an array of numbers or a Range object. Each number is a message sequence number.  +attr+ is the name of a data item to store: &apos;FLAGS&apos; means to replace the message&apos;s flag list with the provided one; &apos;+FLAGS&apos; means to add the provided flags; and &apos;-FLAGS&apos; means to remove them.  +flags+ is a list of flags. &#xA; The return value is an array of Net::IMAP::FetchData. For example: &#xA;   p imap.store(6..8, &quot;+FLAGS&quot;, [:Deleted])&#xA;  =&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \\&#xA;       #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \\&#xA;       #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;]" />
          <scope name="subscribe" ilk="function" signature="subscribe(mailbox)" doc="Sends a SUBSCRIBE command to add the specified +mailbox+ name to the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes as returned by #lsub(). &#xA; A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be subscribed to, for instance because it does not exist." />
          <scope name="thread" ilk="function" signature="thread(algorithm, search_keys, charset)" doc="As for #search(), but returns message sequence numbers in threaded format, as a Net::IMAP::ThreadMember tree.  The supported algorithms are: &#xA; split into single-level threads according to subject, ordered by date.&#xA;split into threads by parent/child relationships determined by which message is a reply to which. &#xA; Unlike #search(), +charset+ is a required argument.  US-ASCII and UTF-8 are sample values. &#xA; See [SORT-THREAD-EXT] for more details." />
          <scope name="uid_copy" ilk="function" signature="uid_copy(set, mailbox)" doc="As for #copy(), but +set+ contains unique identifiers." />
          <scope name="uid_fetch" ilk="function" signature="uid_fetch(set, attr)" doc="As for #fetch(), but +set+ contains unique identifiers." />
          <scope name="uid_search" ilk="function" signature="uid_search(keys, charset = nil)" doc="As for #search(), but returns unique identifiers." />
          <scope name="uid_sort" ilk="function" signature="uid_sort(sort_keys, search_keys, charset)" doc="As for #sort(), but returns an array of unique identifiers." />
          <scope name="uid_store" ilk="function" signature="uid_store(set, attr, flags)" doc="As for #store(), but +set+ contains unique identifiers." />
          <scope name="uid_thread" ilk="function" signature="uid_thread(algorithm, search_keys, charset)" doc="As for #thread(), but returns unique identifiers instead of message sequence numbers." />
          <scope name="unsubscribe" ilk="function" signature="unsubscribe(mailbox)" doc="Sends a UNSUBSCRIBE command to remove the specified +mailbox+ name from the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes. &#xA; A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be unsubscribed from, for instance because the client is not currently subscribed to it." />
          <scope ilk="function" name="client_thread" />
          <scope ilk="function" name="client_thread=" />
          <scope ilk="function" name="greeting" />
          <scope ilk="function" name="response_handlers" />
          <scope ilk="function" name="responses" />
          <variable name="SEEN" attributes="__const__" citdl="Object" />
          <variable name="ANSWERED" attributes="__const__" citdl="Object" />
          <variable name="FLAGGED" attributes="__const__" citdl="Object" />
          <variable name="DELETED" attributes="__const__" citdl="Object" />
          <variable name="DRAFT" attributes="__const__" citdl="Object" />
          <variable name="RECENT" attributes="__const__" citdl="Object" />
          <variable name="NOINFERIORS" attributes="__const__" citdl="Object" />
          <variable name="NOSELECT" attributes="__const__" citdl="Object" />
          <variable name="MARKED" attributes="__const__" citdl="Object" />
          <variable name="UNMARKED" attributes="__const__" citdl="Object" />
          <variable name="DATE_MONTH" attributes="__const__" citdl="Object" />
          <scope name="Atom" ilk="class" classrefs="Object">
          </scope>
          <scope name="BadResponseError" ilk="class" classrefs="ResponseError">
          </scope>
          <scope name="BodyTypeBasic" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                      :param, :content_id,                                      :description, :encoding, :size,                                      :md5, :disposition, :language,                                      :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeMessage" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                        :param, :content_id,                                        :description, :encoding, :size,                                        :envelope, :body, :lines,                                        :md5, :disposition, :language,                                        :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeMultipart" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                          :parts,                                          :param, :disposition, :language,                                          :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeText" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                     :param, :content_id,                                     :description, :encoding, :size,                                     :lines,                                     :md5, :disposition, :language,                                     :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="ByeResponseError" ilk="class" classrefs="ResponseError">
          </scope>
          <scope name="CramMD5Authenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(challenge)" />
          </scope>
          <scope name="DataFormatError" ilk="class" classrefs="Error">
          </scope>
          <scope name="DigestMD5Authenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password, authname = nil)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(challenge)" />
            <variable name="STAGE_ONE" attributes="__const__" citdl="Object" />
            <variable name="STAGE_TWO" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Error" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="FlagCountError" ilk="class" classrefs="Error">
          </scope>
          <scope name="Literal" ilk="class" classrefs="Object">
          </scope>
          <scope name="LoginAuthenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(data)" />
            <variable name="STATE_USER" attributes="__const__" citdl="Object" />
            <variable name="STATE_PASSWORD" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="MessageSet" ilk="class" classrefs="Object">
          </scope>
          <scope name="NoResponseError" ilk="class" classrefs="ResponseError">
          </scope>
          <scope name="PlainAuthenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(data)" />
          </scope>
          <scope name="QuotedString" ilk="class" classrefs="Object">
          </scope>
          <scope name="RawData" ilk="class" classrefs="Object">
          </scope>
          <scope name="ResponseError" ilk="class" classrefs="Error">
            <scope name="new" ilk="function" signature="new(response)" attributes="__classmethod__ __ctor__" />
            <scope ilk="function" name="response" />
            <scope ilk="function" name="response=" />
          </scope>
          <scope name="ResponseParseError" ilk="class" classrefs="Error">
          </scope>
          <scope name="ResponseParser" ilk="class" classrefs="Object">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="net/pop" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="APOP" ilk="class" classrefs="POP3">
          <scope name="apop?" ilk="function" />
        </scope>
        <scope name="POP3" ilk="class" classrefs="Protocol">
          <scope name="APOP" ilk="function" signature="APOP(isapop)" attributes="__classmethod__" doc="Returns the APOP class if +isapop+ is true; otherwise, returns the POP class.  For example: &#xA;     # Example 1&#xA;    pop = Net::POP3::APOP($is_apop).new(addr, port)&#xA;&#xA;    # Example 2&#xA;    Net::POP3::APOP($is_apop).start(addr, port) do |pop|&#xA;      ....&#xA;    end" />
          <scope name="auth_only" ilk="function" attributes="__classmethod__" />
          <scope name="certs" ilk="function" attributes="__classmethod__" />
          <scope name="create_ssl_params" ilk="function" attributes="__classmethod__" />
          <scope name="default_pop3_port" ilk="function" attributes="__classmethod__" />
          <scope name="default_pop3s_port" ilk="function" attributes="__classmethod__" />
          <scope name="default_port" ilk="function" attributes="__classmethod__" />
          <scope name="delete_all" ilk="function" signature="delete_all(address, port = nil, account = nil, password = nil, isapop = false, &amp;block)" attributes="__classmethod__" doc="Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted. &#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA;     Net::POP3.delete_all(&apos;pop.example.com&apos;, 110,&#xA;                         &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;      file.write m.pop&#xA;    end" />
          <scope name="disable_ssl" ilk="function" attributes="__classmethod__" />
          <scope name="enable_ssl" ilk="function" attributes="__classmethod__" />
          <scope name="foreach" ilk="function" signature="foreach(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Starts a POP3 session and iterates over each POPMail object, yielding it to the +block+. This method is equivalent to: &#xA;     Net::POP3.start(address, port, account, password) do |pop|&#xA;      pop.each_mail do |m|&#xA;        yield m&#xA;      end&#xA;    end&#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA;     Net::POP3.foreach(&apos;pop.example.com&apos;, 110,&#xA;                      &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;      file.write m.pop&#xA;      m.delete if $DELETE&#xA;    end" />
          <scope name="new" ilk="function" attributes="__classmethod__ __ctor__" />
          <scope name="ssl_params" ilk="function" signature="ssl_params()" attributes="__classmethod__" />
          <scope name="start" ilk="function" attributes="__classmethod__" />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" attributes="__classmethod__" />
          <scope name="verify" ilk="function" attributes="__classmethod__" />
          <scope name="active?" ilk="function" />
          <scope name="apop?" ilk="function" />
          <scope name="auth_only" ilk="function" />
          <scope name="command" ilk="function" />
          <scope name="delete_all" ilk="function" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" />
          <scope name="do_finish" ilk="function" />
          <scope name="do_start" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="each_mail" ilk="function" />
          <scope name="enable_ssl" ilk="function" />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes a POP3 session and closes TCP connection." />
          <scope name="inspect" ilk="function" />
          <scope name="logging" ilk="function" />
          <scope name="mails" ilk="function" />
          <scope name="n_bytes" ilk="function" signature="n_bytes()" doc="Returns the total size in bytes of all the messages on the POP server." />
          <scope name="n_mails" ilk="function" />
          <scope name="on_connect" ilk="function" />
          <scope name="port" ilk="function" />
          <scope name="read_timeout=" ilk="function" />
          <scope name="reset" ilk="function" />
          <scope name="set_debug_output" ilk="function" />
          <scope name="start" ilk="function" signature="start(account, password)" doc="Starts a POP3 session. &#xA; When called with block, gives a POP3 object to the block and closes the session after block call finishes. &#xA; This method raises a POPAuthenticationError if authentication fails." />
          <scope name="started?" ilk="function" />
          <scope name="use_ssl?" ilk="function" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="read_timeout" />
        </scope>
        <scope name="POP3Command" ilk="class" classrefs="Object">
        </scope>
        <scope name="POPAuthenticationError" ilk="class" classrefs="ProtoAuthError">
        </scope>
        <scope name="POPBadResponse" ilk="class" classrefs="POPError">
        </scope>
        <scope name="POPError" ilk="class" classrefs="ProtocolError">
        </scope>
        <scope name="POPMail" ilk="class" classrefs="Object">
          <scope name="all" ilk="function" signature="all( dest = &apos;&apos; )" />
          <scope name="delete" ilk="function" signature="delete()" doc="Marks a message for deletion on the server.  Deletion does not actually occur until the end of the session; deletion may be cancelled for _all_ marked messages by calling POP3#reset(). &#xA; This method raises a POPError if an error occurs. &#xA; Example &#xA;     POP3.start(&apos;pop.example.com&apos;, 110,&#xA;               &apos;YourAccount, &apos;YourPassword&apos;) do |pop|&#xA;      n = 1&#xA;      pop.mails.each do |popmail|&#xA;        File.open(&quot;inbox/#{n}&quot;, &apos;w&apos;) do |f|&#xA;          f.write popmail.pop&#xA;        end&#xA;        popmail.delete         ####&#xA;        n += 1&#xA;      end" />
          <scope name="delete!" ilk="function" signature="delete!()" />
          <scope name="deleted?" ilk="function" signature="deleted?()" doc="True if the mail has been deleted." />
          <scope name="header" ilk="function" signature="header(dest = &apos;&apos;)" doc="Fetches the message header. &#xA; The optional +dest+ argument is obsolete. &#xA; This method raises a POPError if an error occurs." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="mail" ilk="function" signature="mail( dest = &apos;&apos; )" />
          <scope name="pop" ilk="function" signature="pop( dest = &apos;&apos; )" doc="This method fetches the message.  If called with a block, the message is yielded to the block one chunk at a time.  If called without a block, the message is returned as a String.  The optional +dest+ argument will be prepended to the returned String; this argument is essentially obsolete. &#xA; Example without block &#xA;     POP3.start(&apos;pop.example.com&apos;, 110,&#xA;               &apos;YourAccount, &apos;YourPassword&apos;) do |pop|&#xA;      n = 1&#xA;      pop.mails.each do |popmail|&#xA;        File.open(&quot;inbox/#{n}&quot;, &apos;w&apos;) do |f|&#xA;          f.write popmail.pop&#xA;        end&#xA;        popmail.delete&#xA;        n += 1&#xA;      end&#xA;    end" />
          <scope name="top" ilk="function" signature="top(lines, dest = &apos;&apos;)" doc="Fetches the message header and +lines+ lines of body. &#xA; The optional +dest+ argument is obsolete. &#xA; This method raises a POPError if an error occurs." />
          <scope name="uidl" ilk="function" signature="uidl()" />
          <scope name="unique_id" ilk="function" signature="unique_id()" doc="Returns the unique-id of the message. Normally the unique-id is a hash string of the message. &#xA; This method raises a POPError if an error occurs." />
          <scope ilk="function" name="length" />
          <scope ilk="function" name="number" />
        </scope>
      </scope>
    </scope>
    <scope name="net/smtp" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="SMTP" ilk="class" classrefs="Object">
          <scope name="default_port" ilk="function" attributes="__classmethod__" />
          <scope name="default_ssl_context" ilk="function" attributes="__classmethod__" />
          <scope name="default_ssl_port" ilk="function" attributes="__classmethod__" />
          <scope name="default_submission_port" ilk="function" signature="default_submission_port()" attributes="__classmethod__" doc="The default mail submission port number, 587." />
          <scope name="default_tls_port" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(address, port = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::SMTP object. &#xA; +address+ is the hostname or ip address of your SMTP server.  +port+ is the port to connect to; it defaults to port 25. &#xA; This method does not open the TCP connection.  You can use SMTP.start instead of SMTP.new if you want to do everything at once.  Otherwise, follow SMTP.new with SMTP#start." />
          <scope name="start" ilk="function" attributes="__classmethod__" />
          <scope name="auth_capable?" ilk="function" signature="auth_capable?(type)" />
          <scope name="auth_cram_md5" ilk="function" signature="auth_cram_md5(user, secret)" />
          <scope name="auth_login" ilk="function" />
          <scope name="auth_method" ilk="function" signature="auth_method(type)" />
          <scope name="auth_plain" ilk="function" />
          <scope name="authenticate" ilk="function" signature="authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)" />
          <scope name="base64_encode" ilk="function" />
          <scope name="capable?" ilk="function" />
          <scope name="capable_auth_types" ilk="function" />
          <scope name="capable_cram_md5_auth?" ilk="function" />
          <scope name="capable_login_auth?" ilk="function" />
          <scope name="capable_plain_auth?" ilk="function" />
          <scope name="capable_starttls?" ilk="function" signature="capable_starttls?()" doc="true if server advertises STARTTLS. You cannot get valid value before opening SMTP session." />
          <scope name="check_auth_args" ilk="function" signature="check_auth_args(user, secret, authtype = DEFAULT_AUTH_TYPE)" />
          <scope name="check_auth_continue" ilk="function" signature="check_auth_continue(res)" />
          <scope name="check_auth_method" ilk="function" signature="check_auth_method(type)" />
          <scope name="check_auth_response" ilk="function" signature="check_auth_response(res)" />
          <scope name="check_continue" ilk="function" />
          <scope name="check_response" ilk="function" />
          <scope name="cram_md5_response" ilk="function" signature="cram_md5_response(secret, challenge)" doc="CRAM-MD5: [RFC2195]" />
          <scope name="cram_secret" ilk="function" />
          <scope name="critical" ilk="function" />
          <scope name="data" ilk="function" signature="data(msgstr = nil)" doc="This method sends a message. If +msgstr+ is given, sends it as a message. If block is given, yield a message writer stream. You must write message before the block is closed. &#xA;   # Example 1 (by string)&#xA;  smtp.data(&lt;&lt;EndMessage)&#xA;  From: john@example.com&#xA;  To: betty@example.com&#xA;  Subject: I found a bug&#xA;  Check vm.c:58879.&#xA;  EndMessage&#xA;  # Example 2 (by block)&#xA;  smtp.data {|f|&#xA;    f.puts &quot;From: john@example.com&quot;&#xA;    f.puts &quot;To: betty@example.com&quot;&#xA;    f.puts &quot;Subject: I found a bug&quot;" />
          <scope name="debug_output=" ilk="function" signature="debug_output=(arg)" doc="WARNING: This method causes serious security holes. Use this method for only debugging. &#xA; Set an output stream for debug logging. You must call this before #start. &#xA;   # example&#xA;  smtp = Net::SMTP.new(addr, port)&#xA;  smtp.set_debug_output $stderr&#xA;  smtp.start do |smtp|&#xA;    ....&#xA;  end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" />
          <scope name="disable_starttls" ilk="function" />
          <scope name="disable_tls" ilk="function" />
          <scope name="do_finish" ilk="function" signature="do_finish()" />
          <scope name="do_helo" ilk="function" />
          <scope name="do_start" ilk="function" />
          <scope name="ehlo" ilk="function" />
          <scope name="enable_ssl" ilk="function" />
          <scope name="enable_starttls" ilk="function" />
          <scope name="enable_starttls_auto" ilk="function" signature="enable_starttls_auto(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (STARTTLS) for this object if server accepts. +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="enable_tls" ilk="function" signature="enable_tls(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for this object.  Must be called before the connection is established to have any effect.  +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="esmtp" ilk="function" />
          <scope name="esmtp=" ilk="function" />
          <scope name="esmtp?" ilk="function" />
          <scope name="finish" ilk="function" />
          <scope name="get_response" ilk="function" />
          <scope name="getok" ilk="function" />
          <scope name="helo" ilk="function" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="logging" ilk="function" signature="logging(msg)" />
          <scope name="mailfrom" ilk="function" signature="mailfrom(from_addr)" />
          <scope name="new_internet_message_io" ilk="function" />
          <scope name="open_message_stream" ilk="function" signature="open_message_stream(from_addr, *to_addrs)" doc="Opens a message writer stream and gives it to the block. The stream is valid only in the block, and has these methods: &#xA; outputs STR and CR LF.&#xA;outputs STR.&#xA;outputs sprintf(fmt,*args).&#xA;outputs STR and returns the length of written bytes.&#xA;outputs STR and returns self. &#xA; If a single CR (&quot;\r&quot;) or LF (&quot;\n&quot;) is found in the message, it is converted to the CR LF pair.  You cannot send a binary message with this method. &#xA; Parameters &#xA; +from_addr+ is a String representing the source mail address. &#xA; +to_addr+ is a String or Strings or Array of Strings, representing the destination mail address or addresses. &#xA; Example &#xA;     Net::SMTP.start(&apos;smtp.example.com&apos;, 25) do |smtp|&#xA;      smtp.open_message_stream(&apos;from@example.com&apos;, [&apos;dest@example.com&apos;]) do |f|" />
          <scope name="quit" ilk="function" />
          <scope name="rcptto" ilk="function" />
          <scope name="rcptto_list" ilk="function" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the number of seconds to wait until timing-out a read(2) call." />
          <scope name="ready" ilk="function" />
          <scope name="recv_response" ilk="function" signature="recv_response()" />
          <scope name="send_mail" ilk="function" signature="send_mail(msgstr, from_addr, *to_addrs)" />
          <scope name="send_message" ilk="function" />
          <scope name="sendmail" ilk="function" signature="sendmail(msgstr, from_addr, *to_addrs)" />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" />
          <scope name="ssl?" ilk="function" />
          <scope name="ssl_socket" ilk="function" />
          <scope name="start" ilk="function" signature="start(helo = &apos;localhost&apos;, user = nil, secret = nil, authtype = nil)" doc="Opens a TCP connection and starts the SMTP session. &#xA; Parameters &#xA; +helo+ is the _HELO_ _domain_ that you&apos;ll dispatch mails from; see the discussion in the overview notes. &#xA; If both of +user+ and +secret+ are given, SMTP authentication will be attempted using the AUTH command.  +authtype+ specifies the type of authentication to attempt; it must be one of :login, :plain, and :cram_md5.  See the notes on SMTP Authentication in the overview. &#xA; Block Usage &#xA; When this methods is called with a block, the newly-started SMTP object is yielded to the block, and automatically closed after the block call finishes.  Otherwise, it is the caller&apos;s responsibility to close the session when finished. &#xA; Example &#xA; This is very similar to the class method SMTP.start. &#xA;     require &apos;net/smtp&apos;&#xA;    smtp = Net::SMTP.new(&apos;smtp.mail.server&apos;, 25)&#xA;    smtp.start(helo_domain, account, password, authtype) do |smtp|&#xA;      smtp.send_message msgstr, &apos;from@example.com&apos;, [&apos;dest@example.com&apos;]&#xA;    end" />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the SMTP session has been started." />
          <scope name="starttls" ilk="function" signature="starttls()" doc="SMTP command dispatcher" />
          <scope name="starttls?" ilk="function" />
          <scope name="starttls_always?" ilk="function" signature="starttls_always?()" doc="true if this object uses STARTTLS." />
          <scope name="starttls_auto?" ilk="function" />
          <scope name="tcp_socket" ilk="function" />
          <scope name="tls?" ilk="function" />
          <scope name="tlsconnect" ilk="function" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="read_timeout" />
          <variable name="DEFAULT_AUTH_TYPE" attributes="__const__" citdl="Object" />
          <variable name="IMASK" attributes="__const__" citdl="Object" />
          <variable name="OMASK" attributes="__const__" citdl="Object" />
          <variable name="CRAM_BUFSIZE" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_AUTH_TYPE" attributes="__const__" citdl="Object" />
          <variable name="IMASK" attributes="__const__" citdl="Object" />
          <variable name="OMASK" attributes="__const__" citdl="Object" />
          <variable name="CRAM_BUFSIZE" attributes="__const__" citdl="Object" />
          <scope name="Response" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(status, string)" attributes="__classmethod__ __ctor__" />
            <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" />
            <scope name="capabilities" ilk="function" signature="capabilities()" />
            <scope name="continue?" ilk="function" signature="continue?()" />
            <scope name="cram_md5_challenge" ilk="function" signature="cram_md5_challenge()" />
            <scope name="exception_class" ilk="function" signature="exception_class()" />
            <scope name="message" ilk="function" signature="message()" />
            <scope name="status_type_char" ilk="function" signature="status_type_char()" />
            <scope name="success?" ilk="function" signature="success?()" />
            <scope ilk="function" name="status" />
            <scope ilk="function" name="string" />
          </scope>
        </scope>
        <scope name="SMTPAuthenticationError" ilk="class" classrefs="ProtoAuthError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPError" ilk="namespace">
        </scope>
        <scope name="SMTPFatalError" ilk="class" classrefs="ProtoFatalError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPServerBusy" ilk="class" classrefs="ProtoServerError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPSyntaxError" ilk="class" classrefs="ProtoSyntaxError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPUnknownError" ilk="class" classrefs="ProtoUnknownError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPUnsupportedCommand" ilk="class" classrefs="ProtocolError">
          <import symbol="SMTPError" />
        </scope>
      </scope>
    </scope>
    <scope name="net/telnet" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="body" ilk="function" signature="body()" doc="Returns the entity body. &#xA; Calling this method a second or subsequent time will return the already read string. &#xA;   http.request_get(&apos;/index.html&apos;) {|res|&#xA;    puts res.body&#xA;  }&#xA;&#xA;  http.request_get(&apos;/index.html&apos;) {|res|&#xA;    p res.body.object_id   # 538149362&#xA;    p res.body.object_id   # 538149362&#xA;  }" />
        <scope name="body=" ilk="function" signature="body=(value)" doc="Because it may be necessary to modify the body, Eg, decompression this method facilitates that." />
        <scope name="entity" ilk="function" signature="entity()" />
        <scope name="read_body" ilk="function" signature="read_body(dest = nil, &amp;block)" doc="Gets entity body.  If the block given, yields it to +block+. The body is provided in fragments, as it is read in from the socket. &#xA; Calling this method a second or subsequent time will return the already read string. &#xA;   http.request_get(&apos;/index.html&apos;) {|res|&#xA;    puts res.read_body&#xA;  }&#xA;  http.request_get(&apos;/index.html&apos;) {|res|&#xA;    p res.read_body.object_id   # 538149362&#xA;    p res.read_body.object_id   # 538149362&#xA;  }&#xA;  # using iterator&#xA;  http.request_get(&apos;/index.html&apos;) {|res|&#xA;    res.read_body do |segment|&#xA;      print segment" />
        <scope name="value" ilk="function" signature="value()" doc="Raises HTTP error if the response is not 2xx." />
        <variable name="POP" attributes="__const__" citdl="Object" />
        <scope name="Telnet" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(options)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::Telnet object. &#xA; Attempts to connect to the host (unless the Proxy option is provided: see below).  If a block is provided, it is yielded status messages on the attempt to connect to the server, of the form: &#xA;   Trying localhost...&#xA;  Connected to localhost.&#xA; +options+ is a hash of options.  The following example lists all options and their default values. &#xA;   host = Net::Telnet::new(&#xA;           &quot;Host&quot;       =&gt; &quot;localhost&quot;,  # default: &quot;localhost&quot;&#xA;           &quot;Port&quot;       =&gt; 23,           # default: 23&#xA;           &quot;Binmode&quot;    =&gt; false,        # default: false&#xA;           &quot;Output_log&quot; =&gt; &quot;output_log&quot;, # default: nil (no output)&#xA;           &quot;Dump_log&quot;   =&gt; &quot;dump_log&quot;,   # default: nil (no output)&#xA;           &quot;Prompt&quot;     =&gt; /[$%#&gt;] \z/n, # default: /[$%#&gt;] \z/n&#xA;           &quot;Telnetmode&quot; =&gt; true,         # default: true" />
          <scope name="binmode" ilk="function" signature="binmode(mode = nil)" doc="Turn newline conversion on (+mode+ == false) or off (+mode+ == true), or return the current value (+mode+ is not specified)." />
          <scope name="binmode=" ilk="function" signature="binmode=(mode)" doc="Turn newline conversion on (false) or off (true)." />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="cmd" ilk="function" signature="cmd(options)" doc="Send a command to the host. &#xA; More exactly, sends a string to the host, and reads in all received data until is sees the prompt or other matched sequence. &#xA; If a block is given, the received data will be yielded to it as it is read in.  Whether a block is given or not, the received data will be return as a string.  Note that the received data includes the prompt and in most cases the host&apos;s echo of our command. &#xA; +options+ is either a String, specified the string or command to send to the host; or it is a hash of options.  If a hash, the following options can be specified: &#xA; the command or other string to send to the host.&#xA;a regular expression, the sequence to look for in the received data before returning.  If not specified, the Prompt option value specified when this instance was created will be used, or, failing that, the default prompt of /[$%#&gt;] \z/n.&#xA;the seconds to wait for data from the host before raising a Timeout error.  If not specified, the Timeout option value specified when this instance was created will be used, or, failing that, the default value of 10 seconds. &#xA; The command or other string will have the newline sequence appended to it." />
          <scope name="login" ilk="function" signature="login(options, password = nil)" doc="Login to the host with a given username and password. &#xA; The username and password can either be provided as two string arguments in that order, or as a hash with keys &quot;Name&quot; and &quot;Password&quot;. &#xA; This method looks for the strings &quot;login&quot; and &quot;Password&quot; from the host to determine when to send the username and password.  If the login sequence does not follow this pattern (for instance, you are connecting to a service other than telnet), you will need to handle login yourself. &#xA; The password can be omitted, either by only provided one String argument, which will be used as the username, or by providing a has that has no &quot;Password&quot; key.  In this case, the method will not look for the &quot;Password:&quot; prompt; if it is sent, it will have to be dealt with by later calls. &#xA; The method returns all data received during the login process from the host, including the echoed username but not the password (which the host should not echo).  If a block is passed in, this received data is also yielded to the block as it is received." />
          <scope name="preprocess" ilk="function" signature="preprocess(string)" doc="Preprocess received data from the host. &#xA; Performs newline conversion and detects telnet command sequences. Called automatically by #waitfor().  You should only use this method yourself if you have read input directly using sysread() or similar, and even then only if in telnet mode." />
          <scope name="print" ilk="function" signature="print(string)" doc="Sends a string to the host. &#xA; This does _not_ automatically append a newline to the string.  Embedded newlines may be converted and telnet command sequences escaped depending upon the values of telnetmode, binmode, and telnet options set by the host." />
          <scope name="puts" ilk="function" signature="puts(string)" doc="Sends a string to the host. &#xA; Same as #print(), but appends a newline to the string." />
          <scope name="telnetmode" ilk="function" signature="telnetmode(mode = nil)" doc="Set telnet command interpretation on (+mode+ == true) or off (+mode+ == false), or return the current value (+mode+ not provided).  It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP." />
          <scope name="telnetmode=" ilk="function" signature="telnetmode=(mode)" doc="Turn telnet command interpretation on (true) or off (false).  It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP." />
          <scope name="waitfor" ilk="function" signature="waitfor(options)" doc="Read data from the host until a certain sequence is matched. &#xA; If a block is given, the received data will be yielded as it is read in (not necessarily all in one go), or nil if EOF occurs before any data is received.  Whether a block is given or not, all data read will be returned in a single string, or again nil if EOF occurs before any data is received.  Note that received data includes the matched sequence we were looking for. &#xA; +options+ can be either a regular expression or a hash of options. If a regular expression, this specifies the data to wait for. If a hash, this can specify the following options: &#xA; a regular expression, specifying the data to wait for.&#xA;as for Match; used only if Match is not specified.&#xA;as for Match, except a string that will be converted into a regular expression.  Used only if Match and Prompt are not specified.&#xA;the number of seconds to wait for data from the host before raising a TimeoutError.  If set to false, no timeout will occur.  If not specified, the Timeout option value specified when this instance was created will be used, or, failing that, the default value of 10 seconds.&#xA;the number of seconds to wait after matching against the input data to see if more data arrives.  If more data arrives within this time, we will judge ourselves not to have matched successfully, and will continue trying to match.  If not specified, the Waittime option value specified when this instance was created will be used, or, failing that, the default value of 0 seconds, which means not to wait for more input.&#xA;if true, when the remote end closes the connection then an EOFError will be raised. Otherwise, defaults to the old behaviour that the function will return whatever data has been received already, or nil if nothing was received." />
          <scope name="write" ilk="function" signature="write(string)" doc="Write +string+ to the host. &#xA; Does not perform any conversions on +string+.  Will log +string+ to the dumplog, if the Dump_log option is set." />
          <scope ilk="function" name="sock" />
        </scope>
      </scope>
    </scope>
    <scope name="nkf" ilk="blob" lang="Ruby">
      <scope name="NKF" ilk="namespace">
        <scope name="guess" ilk="function" signature="guess(p1)" attributes="__classmethod__" doc="Returns guessed encoding of _str_ by nkf routine." />
        <scope name="nkf" ilk="function" signature="nkf(p1, p2)" attributes="__classmethod__" doc="Convert _str_ and return converted result. Conversion details are specified by _opt_ as String. &#xA;    require &apos;nkf&apos;&#xA;   output = NKF.nkf(&quot;-s&quot;, input)" />
        <variable name="AUTO" attributes="__const__" citdl="Object" />
        <variable name="NOCONV" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="JIS" attributes="__const__" citdl="Object" />
        <variable name="EUC" attributes="__const__" citdl="Object" />
        <variable name="SJIS" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="NKF_VERSION" attributes="__const__" citdl="Object" />
        <variable name="NKF_RELEASE_DATE" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="open3" ilk="blob" lang="Ruby">
      <scope name="Open3" ilk="namespace">
        <scope name="capture2" ilk="function" signature="capture2(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture2 captures the standard output of a command. &#xA;   stdout_str, status = Open3.capture2([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:stdin_data].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA;   # factor is a command for integer factorization.&#xA;  o, s = Open3.capture2(&quot;factor&quot;, :stdin_data=&gt;&quot;42&quot;)&#xA;  p o =&gt; &quot;42: 2 3 7\n&quot;&#xA;  # generate x**2 graph in png using gnuplot.&#xA;  gnuplot_commands = &lt;&lt;&quot;End&quot;&#xA;    set terminal png&#xA;    plot x**2, &quot;-&quot; with lines" />
        <scope name="capture2e" ilk="function" signature="capture2e(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture2e captures the standard output and the standard error of a command. &#xA;   stdout_and_stderr_str, status = Open3.capture2e([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:stdin_data].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA;   # capture make log&#xA;  make_log, s = Open3.capture2e(&quot;make&quot;)" />
        <scope name="capture3" ilk="function" signature="capture3(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture3 captures the standard output and the standard error of a command. &#xA;   stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:stdin_data].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA;   # dot is a command of graphviz.&#xA;  graph = &lt;&lt;&apos;End&apos;&#xA;    digraph g {&#xA;      a -&gt; b&#xA;    }&#xA;  End&#xA;  layouted_graph, dot_log = Open3.capture3(&quot;dot -v&quot;, :stdin_data=&gt;graph)" />
        <scope name="pipeline" ilk="function" signature="pipeline(*cmds)" attributes="__classmethod__" doc="Open3.pipeline starts a list of commands as a pipeline. It waits the finish of the commands. No pipe made for stdin of the first command and stdout of the last command. &#xA;   status_list = Open3.pipeline(cmd1, cmd2, ... [, opts])&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA;   cmd:&#xA;    commandline                              command line string which is passed to a shell&#xA;    [env, commandline, opts]                 command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)&#xA;  Note that env and opts are optional, as Process.spawn.&#xA; Example: &#xA;   fname = &quot;/usr/share/man/man1/ruby.1.gz&quot;&#xA;  p Open3.pipeline([&quot;zcat&quot;, fname], &quot;nroff -man&quot;, &quot;less&quot;)&#xA;  =&gt; [#&lt;Process::Status: pid 11817 exit 0&gt;," />
        <scope name="pipeline_r" ilk="function" signature="pipeline_r(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_r starts a list of commands as a pipeline with a pipe which connects stdout of the last command. &#xA;   Open3.pipeline_r(cmd1, cmd2, ... [, opts]) {|last_stdout, wait_threads|&#xA;    ...&#xA;  }&#xA;  last_stdout, wait_threads = Open3.pipeline_r(cmd1, cmd2, ... [, opts])&#xA;  ...&#xA;  last_stdout.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA;   cmd:&#xA;    commandline                              command line string which is passed to a shell&#xA;    [env, commandline, opts]                 command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)" />
        <scope name="pipeline_rw" ilk="function" signature="pipeline_rw(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_rw starts a list of commands as a pipeline with pipes which connects stdin of the first command and stdout of the last command. &#xA;   Open3.pipeline_rw(cmd1, cmd2, ... [, opts]) {|first_stdin, last_stdout, wait_threads|&#xA;    ...&#xA;  }&#xA;  first_stdin, last_stdout, wait_threads = Open3.pipeline_rw(cmd1, cmd2, ... [, opts])&#xA;  ...&#xA;  first_stdin.close&#xA;  last_stdout.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA;   cmd:&#xA;    commandline                              command line string which is passed to a shell&#xA;    [env, commandline, opts]                 command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)" />
        <scope name="pipeline_start" ilk="function" signature="pipeline_start(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_start starts a list of commands as a pipeline. No pipe made for stdin of the first command and stdout of the last command. &#xA;   Open3.pipeline_start(cmd1, cmd2, ... [, opts]) {|wait_threads|&#xA;    ...&#xA;  }&#xA;  wait_threads = Open3.pipeline_start(cmd1, cmd2, ... [, opts])&#xA;  ...&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA;   cmd:&#xA;    commandline                              command line string which is passed to a shell&#xA;    [env, commandline, opts]                 command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)&#xA;  Note that env and opts are optional, as Process.spawn." />
        <scope name="pipeline_w" ilk="function" signature="pipeline_w(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_w starts a list of commands as a pipeline with a pipe which connects stdin of the first command. &#xA;   Open3.pipeline_w(cmd1, cmd2, ... [, opts]) {|first_stdin, wait_threads|&#xA;    ...&#xA;  }&#xA;  first_stdin, wait_threads = Open3.pipeline_w(cmd1, cmd2, ... [, opts])&#xA;  ...&#xA;  first_stdin.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA;   cmd:&#xA;    commandline                              command line string which is passed to a shell&#xA;    [env, commandline, opts]                 command line string which is passed to a shell&#xA;    [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;    [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)" />
        <scope name="popen2" ilk="function" signature="popen2(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.popen2 is similer to Open3.popen3 except it doesn&apos;t make a pipe for the standard error stream. &#xA; Block form: &#xA;   Open3.popen2([env,] cmd... [, opts]) {|stdin, stdout, wait_thr|&#xA;    pid = wait_thr.pid # pid of the started process.&#xA;    ...&#xA;    exit_status = wait_thr.value # Process::Status object returned.&#xA;  }&#xA; Non-block form: &#xA;   stdin, stdout, wait_thr = Open3.popen2([env,] cmd... [, opts])&#xA;  ...&#xA;  stdin.close  # stdin and stdout should be closed explicitly in this form.&#xA;  stdout.close&#xA; See Process.spawn for the optional hash arguments _env_ and _opts_. " />
        <scope name="popen2e" ilk="function" signature="popen2e(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.popen2e is similer to Open3.popen3 except it merges the standard output stream and the standard error stream. &#xA; Block form: &#xA;   Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|&#xA;    pid = wait_thr.pid # pid of the started process.&#xA;    ...&#xA;    exit_status = wait_thr.value # Process::Status object returned.&#xA;  }&#xA; Non-block form: &#xA;   stdin, stdout_and_stderr, wait_thr = Open3.popen2e([env,] cmd... [, opts])&#xA;  ...&#xA;  stdin.close  # stdin and stdout_and_stderr should be closed explicitly in this form.&#xA;  stdout_and_stderr.close&#xA; See Process.spawn for the optional hash arguments _env_ and _opts_. " />
        <scope name="popen3" ilk="function" signature="popen3(*cmd, &amp;block)" attributes="__classmethod__" doc="Open stdin, stdout, and stderr streams and start external executable. In addition, a thread for waiting the started process is noticed. The thread has a pid method and thread variable :pid which is the pid of the started process. &#xA; Block form: &#xA;   Open3.popen3([env,] cmd... [, opts]) {|stdin, stdout, stderr, wait_thr|&#xA;    pid = wait_thr.pid # pid of the started process.&#xA;    ...&#xA;    exit_status = wait_thr.value # Process::Status object returned.&#xA;  }&#xA; Non-block form: &#xA;   stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts])&#xA;  pid = wait_thr[:pid]  # pid of the started process.&#xA;  ...&#xA;  stdin.close  # stdin, stdout and stderr should be closed explicitly in this form.&#xA;  stdout.close" />
      </scope>
    </scope>
    <scope name="openssl" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="debug" ilk="function" signature="debug()" attributes="__classmethod__" doc="call-seq:   OpenSSL.debug -&gt; true | false" />
        <scope name="debug=" ilk="function" signature="debug=(p1)" attributes="__classmethod__" doc="Turns on or off CRYPTO_MEM_CHECK. Also shows some debugging message on stderr." />
        <scope name="errors" ilk="function" signature="errors()" attributes="__classmethod__" doc="See any remaining errors held in queue. &#xA; Any errors you see here are probably due to a bug in ruby&apos;s OpenSSL implementation." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="OPENSSL_VERSION" attributes="__const__" citdl="Object" />
        <variable name="OPENSSL_VERSION_NUMBER" attributes="__const__" citdl="Object" />
        <scope name="ASN1" ilk="namespace">
          <variable name="UNIVERSAL_TAG_NAME" attributes="__const__" citdl="Object" />
          <scope name="ASN1Data" ilk="class" classrefs="Object">
          </scope>
          <scope name="ASN1Error" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Constructive" ilk="class" classrefs="OpenSSL::ASN1::ASN1Data">
            <import symbol="Enumerable" />
          </scope>
          <scope name="Primitive" ilk="class" classrefs="OpenSSL::ASN1::ASN1Data">
          </scope>
        </scope>
        <scope name="BN" ilk="class" classrefs="Object">
          <scope name="generate_prime" ilk="function" signature="generate_prime(...)" attributes="__classmethod__" doc="Parameters +bits+ - integer&#xA;+safe+ - boolean&#xA;+add+ - BN&#xA;+rem+ - BN" />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="call-seq:    BN.new =&gt; aBN&#xA;   BN.new(bn) =&gt; aBN&#xA;   BN.new(string) =&gt; aBN&#xA;   BN.new(string, 0 | 2 | 10 | 16) =&gt; aBN" />
          <scope name="bit_set?" ilk="function" signature="bit_set?(p1)" doc="call-seq:    bn.bit_set?(bit) =&gt; true | false" />
          <scope name="prime?" ilk="function" signature="prime?(...)" doc="Parameters +checks+ - integer" />
          <scope name="prime_fasttest?" ilk="function" signature="prime_fasttest?(...)" doc="Parameters +checks+ - integer&#xA;+trial_div+ - boolean" />
          <scope name="to_i" ilk="function" signature="to_i()" doc="call-seq:    bn.to_i =&gt; integer" />
          <scope name="to_int" ilk="function" signature="to_int()" />
          <scope name="to_s" ilk="function" signature="to_s(...)" doc="Parameters +base+ - integer&#xA;Valid values:&#xA;0 - MPI&#xA;2 - binary&#xA;10 - the default&#xA;16 - hex" />
        </scope>
        <scope name="BNError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Buffering" ilk="namespace">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="each" ilk="function" signature="each(eol=$/)" />
          <scope name="each_byte" ilk="function" signature="each_byte()" />
          <scope name="each_line" ilk="function" signature="each_line(eol=$/)" />
          <scope name="eof" ilk="function" signature="eof()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="flush" ilk="function" signature="flush()" />
          <scope name="getc" ilk="function" signature="getc()" />
          <scope name="gets" ilk="function" signature="gets(eol=$/, limit=nil)" />
          <scope name="print" ilk="function" signature="print(*args)" />
          <scope name="printf" ilk="function" signature="printf(s, *args)" />
          <scope name="puts" ilk="function" signature="puts(*args)" />
          <scope name="read" ilk="function" signature="read(size=nil, buf=nil)" />
          <scope name="read_nonblock" ilk="function" signature="read_nonblock(maxlen, buf=nil)" doc="Reads at most _maxlen_ bytes in the non-blocking manner. &#xA; When no data can be read without blocking, It raises OpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable. &#xA; IO::WaitReadable means SSL needs to read internally. So read_nonblock should be called again after underlying IO is readable. &#xA; IO::WaitWritable means SSL needs to write internally. So read_nonblock should be called again after underlying IO is writable. &#xA; So OpenSSL::Buffering#read_nonblock needs two rescue clause as follows. &#xA;  # emulates blocking read (readpartial).&#xA; begin&#xA;   result = ssl.read_nonblock(maxlen)&#xA; rescue IO::WaitReadable&#xA;   IO.select([io])&#xA;   retry&#xA; rescue IO::WaitWritable&#xA;   IO.select(nil, [io])" />
          <scope name="readchar" ilk="function" signature="readchar()" />
          <scope name="readline" ilk="function" signature="readline(eol=$/)" />
          <scope name="readlines" ilk="function" signature="readlines(eol=$/)" />
          <scope name="readpartial" ilk="function" signature="readpartial(maxlen, buf=nil)" />
          <scope name="ungetc" ilk="function" signature="ungetc(c)" />
          <scope name="write" ilk="function" signature="write(s)" />
          <scope name="write_nonblock" ilk="function" signature="write_nonblock(s)" doc="Writes _str_ in the non-blocking manner. &#xA; If there are buffered data, it is flushed at first. This may block. &#xA; write_nonblock returns number of bytes written to the SSL connection. &#xA; When no data can be written without blocking, It raises OpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable. &#xA; IO::WaitReadable means SSL needs to read internally. So write_nonblock should be called again after underlying IO is readable. &#xA; IO::WaitWritable means SSL needs to write internally. So write_nonblock should be called again after underlying IO is writable. &#xA; So OpenSSL::Buffering#write_nonblock needs two rescue clause as follows. &#xA;  # emulates blocking write.&#xA; begin&#xA;   result = ssl.write_nonblock(str)&#xA; rescue IO::WaitReadable&#xA;   IO.select([io])&#xA;   retry" />
          <scope ilk="function" name="sync" />
          <scope ilk="function" name="sync=" />
          <variable name="BLOCK_SIZE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Cipher" ilk="class" classrefs="Object">
          <scope name="ciphers" ilk="function" signature="ciphers()" attributes="__classmethod__" doc="Returns the names of all available ciphers in an array." />
          <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="The string must contain a valid cipher name like &quot;AES-128-CBC&quot; or &quot;3DES&quot;. &#xA; A list of cipher names is available by calling OpenSSL::Cipher.ciphers." />
          <scope name="block_size" ilk="function" signature="block_size()" />
          <scope name="decrypt" ilk="function" signature="decrypt(...)" doc="Make sure to call .encrypt or .decrypt before using any of the following methods: &#xA; Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0)." />
          <scope name="encrypt" ilk="function" signature="encrypt(...)" doc="Make sure to call .encrypt or .decrypt before using any of the following methods: &#xA; Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1)." />
          <scope name="final" ilk="function" signature="final()" doc="Returns the remaining data held in the cipher object.  Further calls to update() or final() will return garbage. &#xA; See EVP_CipherFinal_ex for further information." />
          <scope name="iv=" ilk="function" signature="iv=(p1)" doc="Sets the cipher iv. &#xA; Only call this method after calling cipher.encrypt or cipher.decrypt." />
          <scope name="iv_len" ilk="function" signature="iv_len()" />
          <scope name="key=" ilk="function" signature="key=(p1)" doc="Sets the cipher key. &#xA; Only call this method after calling cipher.encrypt or cipher.decrypt." />
          <scope name="key_len" ilk="function" signature="key_len()" />
          <scope name="key_len=" ilk="function" signature="key_len=(p1)" doc="Sets the key length of the cipher.  If the cipher is a fixed length cipher then attempting to set the key length to any value other than the fixed value is an error. &#xA; Under normal circumstances you do not need to call this method (and probably shouldn&apos;t). &#xA; See EVP_CIPHER_CTX_set_key_length for further information." />
          <scope name="name" ilk="function" signature="name()" doc="Returns the name of the cipher which may differ slightly from the original name provided." />
          <scope name="padding=" ilk="function" signature="padding=(p1)" doc="Enables or disables padding. By default encryption operations are padded using standard block padding and the padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur. &#xA; See EVP_CIPHER_CTX_set_padding for further information." />
          <scope name="pkcs5_keyivgen" ilk="function" signature="pkcs5_keyivgen(...)" doc="Generates and sets the key/iv based on a password. &#xA; WARNING: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40, or DES with MD5 or SHA1.  Using anything else (like AES) will generate the key/iv using an OpenSSL specific method.  Use a PKCS5 v2 key generation method instead. &#xA; Parameters +salt+ must be an 8 byte string if provided. +iterations+ is a integer with a default of 2048. +digest+ is a Digest object that defaults to &apos;MD5&apos; &#xA; A minimum of 1000 iterations is recommended." />
          <scope name="reset" ilk="function" signature="reset()" doc="Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1)." />
          <scope name="update" ilk="function" signature="update(...)" doc="Parameters +data+ is a nonempty string. +buffer+ is an optional string to store the result." />
          <scope name="CipherError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="Config" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <variable name="DEFAULT_CONFIG_FILE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ConfigError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Engine" ilk="class" classrefs="Object">
          <scope name="EngineError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="HMAC" ilk="class" classrefs="Object">
          <scope name="digest" ilk="function" signature="digest(p1, p2, p3)" attributes="__classmethod__" />
          <scope name="hexdigest" ilk="function" signature="hexdigest(p1, p2, p3)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" />
          <scope name="digest" ilk="function" signature="digest()" />
          <scope name="hexdigest" ilk="function" signature="hexdigest()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="reset" ilk="function" signature="reset()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="update" ilk="function" signature="update(p1)" />
        </scope>
        <scope name="HMACError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Netscape" ilk="namespace">
          <scope name="SPKI" ilk="class" classrefs="Object">
            <scope name="verify" ilk="function" signature="verify(p1)" doc="Checks that cert signature is made with PRIVversion of this PUBLIC &apos;key&apos;" />
          </scope>
          <scope name="SPKIError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="OCSP" ilk="namespace">
          <scope name="BasicResponse" ilk="class" classrefs="Object">
          </scope>
          <scope name="CertificateId" ilk="class" classrefs="Object">
          </scope>
          <scope name="OCSPError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Request" ilk="class" classrefs="Object">
            <scope name="check_nonce" ilk="function" signature="check_nonce(p1)" doc="Check nonce validity in a request and response. Return value reflects result:  1: nonces present and equal.&#xA; 2: nonces both absent.&#xA; 3: nonce present in response only.&#xA; 0: nonces both present and not equal.&#xA; -1: nonce in request only. &#xA;  For most responders clients can check return &gt; 0.&#xA; If responder doesn&apos;t handle nonces return != 0 may be&#xA; necessary. return == 0 is always an error." />
          </scope>
          <scope name="Response" ilk="class" classrefs="Object">
            <scope name="create" ilk="function" signature="create(p1, p2)" attributes="__classmethod__" doc="OCSP::Response" />
          </scope>
        </scope>
        <scope name="OpenSSLError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="PKCS12" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(...)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+name+ - A string describing the key.&#xA;+key+ - Any PKey.&#xA;+cert+ - A X509::Certificate.&#xA;The public_key portion of the certificate must contain a valid public key.&#xA;The not_before and not_after fields must be filled in.&#xA;+ca+ - An optional array of X509::Certificate&apos;s.&#xA;+key_pbe+ - string&#xA;+cert_pbe+ - string&#xA;+key_iter+ - integer&#xA;+mac_iter+ - integer&#xA;+keytype+ - An integer representing an MSIE specific extension. &#xA; Any optional arguments may be supplied as nil to preserve the OpenSSL defaults. " />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Parameters +str+ - Must be a DER encoded PKCS12 string.&#xA;+pass+ - string" />
          <scope name="PKCS12Error" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKCS5" ilk="namespace">
          <scope name="pbkdf2_hmac" ilk="function" signature="pbkdf2_hmac(p1, p2, p3, p4, p5)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+salt+ - string&#xA;+iter+ - integer - should be greater than 1000.  2000 is better.&#xA;+keylen+ - integer&#xA;+digest+ - a string or OpenSSL::Digest object. &#xA; Available in OpenSSL 0.9.9?. &#xA; Digests other than SHA1 may not be supported by other cryptography libraries." />
          <scope name="pbkdf2_hmac_sha1" ilk="function" signature="pbkdf2_hmac_sha1(p1, p2, p3, p4)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+salt+ - string&#xA;+iter+ - integer - should be greater than 1000.  2000 is better.&#xA;+keylen+ - integer &#xA; This method is available almost any version OpenSSL. &#xA; Conforms to rfc2898." />
          <scope name="PKCS5Error" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKCS7" ilk="class" classrefs="Object">
          <scope name="encrypt" ilk="function" signature="encrypt(...)" attributes="__classmethod__" doc="call-seq:    PKCS7.encrypt(certs, data, [, cipher [, flags]]) =&gt; pkcs7" />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Many methods in this class aren&apos;t documented." />
          <scope name="read_smime" ilk="function" signature="read_smime(p1)" attributes="__classmethod__" doc="call-seq:    PKCS7.read_smime(string) =&gt; pkcs7" />
          <scope name="sign" ilk="function" signature="sign(...)" attributes="__classmethod__" doc="call-seq:    PKCS7.sign(cert, key, data, [, certs [, flags]]) =&gt; pkcs7" />
          <scope name="write_smime" ilk="function" signature="write_smime(...)" attributes="__classmethod__" doc="call-seq:    PKCS7.write_smime(pkcs7 [, data [, flags]]) =&gt; string" />
          <scope name="type" ilk="function" signature="type()" doc="call-seq:    pkcs7.type =&gt; string or nil" />
          <scope name="type=" ilk="function" signature="type=(p1)" doc="call-seq:    pkcs7.type = type =&gt; type" />
          <scope name="PKCS7Error" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="RecipientInfo" ilk="class" classrefs="Object">
          </scope>
          <scope name="SignerInfo" ilk="class" classrefs="Object">
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="DH" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(...)" attributes="__classmethod__" doc="Parameters +size+ is an integer representing the desired key size.  Keys smaller than 1024 should be considered insecure.&#xA;+generator+ is a small number &gt; 1, typically 2 or 5." />
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Parameters +size+ is an integer representing the desired key size.  Keys smaller than 1024 should be considered insecure.&#xA;+generator+ is a small number &gt; 1, typically 2 or 5.&#xA;+string+ contains the DER or PEM encoded key. &#xA; Examples DH.new -&gt; dh&#xA;DH.new(1024) -&gt; dh&#xA;DH.new(1024, 5) -&gt; dh&#xA;DH.new(File.read(&apos;key.pem&apos;)) -&gt; dh" />
            <scope name="compute_key" ilk="function" signature="compute_key(p1)" doc="Parameters +pub_bn+ is a OpenSSL::BN. &#xA; Returns aString containing a shared secret computed from the other parties public value. &#xA; See DH_compute_key() for further information." />
            <scope name="export" ilk="function" signature="export()" />
            <scope name="generate_key!" ilk="function" signature="generate_key!()" />
            <scope name="params" ilk="function" signature="params()" doc=" &#xA; Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
            <scope name="params_ok?" ilk="function" signature="params_ok?()" />
            <scope name="private?" ilk="function" signature="private?()" />
            <scope name="public?" ilk="function" signature="public?()" />
            <scope name="public_key" ilk="function" signature="public_key()" doc="Makes new instance DH PUBLIC_KEY from PRIVATE_KEY" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" doc=" &#xA; Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
          </scope>
          <scope name="DHError" ilk="class" classrefs="ePKeyError">
          </scope>
          <scope name="DSA" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(p1)" attributes="__classmethod__" doc="Parameters +size+ is an integer representing the desired key size." />
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Parameters +size+ is an integer representing the desired key size.&#xA;+string+ contains a DER or PEM encoded key.&#xA;+pass+ is a string that contains a optional password. &#xA; Examples DSA.new -&gt; dsa&#xA;DSA.new(1024) -&gt; dsa&#xA;DSA.new(File.read(&apos;dsa.pem&apos;)) -&gt; dsa&#xA;DSA.new(File.read(&apos;dsa.pem&apos;), &apos;mypassword&apos;) -&gt; dsa" />
            <scope name="export" ilk="function" signature="export(...)" doc="Parameters +cipher+ is an OpenSSL::Cipher. +password+ is a string containing your password. &#xA; Examples DSA.to_pem -&gt; aString&#xA;DSA.to_pem(cipher, &apos;mypassword&apos;) -&gt; aString" />
            <scope name="params" ilk="function" signature="params()" doc=" &#xA; Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
            <scope name="private?" ilk="function" signature="private?()" />
            <scope name="public?" ilk="function" signature="public?()" />
            <scope name="public_key" ilk="function" signature="public_key()" doc=" &#xA; Makes new instance DSA PUBLIC_KEY from PRIVATE_KEY" />
            <scope name="syssign" ilk="function" signature="syssign(p1)" />
            <scope name="sysverify" ilk="function" signature="sysverify(p1, p2)" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem(...)" />
            <scope name="to_s" ilk="function" signature="to_s(...)" />
            <scope name="to_text" ilk="function" signature="to_text()" doc=" &#xA; Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
          </scope>
          <scope name="DSAError" ilk="class" classrefs="ePKeyError">
          </scope>
          <scope name="EC" ilk="class" classrefs="cPKey">
            <scope name="builtin_curves" ilk="function" signature="builtin_curves()" attributes="__classmethod__" doc="See the OpenSSL documentation for EC_builtin_curves()" />
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for:    EC_KEY_*" />
            <scope name="check_key" ilk="function" signature="check_key()" doc="Raises an exception if the key is invalid. &#xA; See the OpenSSL documentation for EC_KEY_check_key()" />
            <scope name="dh_compute_key" ilk="function" signature="dh_compute_key(p1)" doc="See the OpenSSL documentation for ECDH_compute_key()" />
            <scope name="dsa_sign_asn1" ilk="function" signature="dsa_sign_asn1(p1)" doc="See the OpenSSL documentation for ECDSA_sign()" />
            <scope name="dsa_verify_asn1" ilk="function" signature="dsa_verify_asn1(p1, p2)" doc="See the OpenSSL documentation for ECDSA_verify()" />
            <scope name="generate_key" ilk="function" signature="generate_key()" doc="See the OpenSSL documentation for EC_KEY_generate_key()" />
            <scope name="group" ilk="function" signature="group()" doc="Returns a constant OpenSSL::EC::Group that is tied to the key. Modifying the returned group can make the key invalid." />
            <scope name="group=" ilk="function" signature="group=(p1)" doc="Returns the same object passed, not the group object associated with the key. If you wish to access the group object tied to the key call key.group after setting the group. &#xA; Setting the group will immediately destroy any previously assigned group object. The group is internally copied by OpenSSL.  Modifying the original group after assignment will not effect the internal key structure. (your changes may be lost).  BE CAREFUL. &#xA; EC_KEY_set_group calls EC_GROUP_free(key-&gt;group) then EC_GROUP_dup(), not EC_GROUP_copy. This documentation is accurate for OpenSSL 0.9.8b." />
            <scope name="private_key" ilk="function" signature="private_key()" doc="See the OpenSSL documentation for EC_KEY_get0_private_key()" />
            <scope name="private_key=" ilk="function" signature="private_key=(p1)" doc="See the OpenSSL documentation for EC_KEY_set_private_key()" />
            <scope name="private_key?" ilk="function" signature="private_key?()" doc="Both public_key? and private_key? may return false at the same time unlike other PKey classes." />
            <scope name="public_key" ilk="function" signature="public_key()" doc="See the OpenSSL documentation for EC_KEY_get0_public_key()" />
            <scope name="public_key=" ilk="function" signature="public_key=(p1)" doc="See the OpenSSL documentation for EC_KEY_set_public_key()" />
            <scope name="public_key?" ilk="function" signature="public_key?()" doc="Both public_key? and private_key? may return false at the same time unlike other PKey classes." />
            <scope name="to_der" ilk="function" signature="to_der()" doc="See the OpenSSL documentation for i2d_ECPrivateKey_bio()" />
            <scope name="to_pem" ilk="function" signature="to_pem()" doc="See the OpenSSL documentation for PEM_write_bio_ECPrivateKey()" />
            <scope name="to_text" ilk="function" signature="to_text()" doc="See the OpenSSL documentation for EC_KEY_print()" />
            <variable name="NAMED_CURVE" attributes="__const__" citdl="Object" />
            <scope name="Group" ilk="class" classrefs="Object">
              <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for EC_GROUP_*" />
              <scope name="asn1_flag" ilk="function" signature="asn1_flag()" doc="See the OpenSSL documentation for EC_GROUP_get_asn1_flag()" />
              <scope name="asn1_flag=" ilk="function" signature="asn1_flag=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_asn1_flag()" />
              <scope name="cofactor" ilk="function" signature="cofactor()" doc="See the OpenSSL documentation for EC_GROUP_get_cofactor()" />
              <scope name="curve_name" ilk="function" signature="curve_name()" doc="See the OpenSSL documentation for EC_GROUP_get_curve_name()" />
              <scope name="degree" ilk="function" signature="degree()" doc="See the OpenSSL documentation for EC_GROUP_get_degree()" />
              <scope name="eql?" ilk="function" signature="eql?(p1)" />
              <scope name="generator" ilk="function" signature="generator()" doc="See the OpenSSL documentation for EC_GROUP_get0_generator()" />
              <scope name="order" ilk="function" signature="order()" doc="See the OpenSSL documentation for EC_GROUP_get_order()" />
              <scope name="point_conversion_form" ilk="function" signature="point_conversion_form()" doc="See the OpenSSL documentation for EC_GROUP_get_point_conversion_form()" />
              <scope name="point_conversion_form=" ilk="function" signature="point_conversion_form=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_point_conversion_form()" />
              <scope name="seed" ilk="function" signature="seed()" doc="See the OpenSSL documentation for EC_GROUP_get0_seed()" />
              <scope name="seed=" ilk="function" signature="seed=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_seed()" />
              <scope name="set_generator" ilk="function" signature="set_generator(p1, p2, p3)" doc="See the OpenSSL documentation for EC_GROUP_set_generator()" />
              <scope name="to_der" ilk="function" signature="to_der()" doc="See the OpenSSL documentation for i2d_ECPKParameters_bio()" />
              <scope name="to_pem" ilk="function" signature="to_pem()" doc="See the OpenSSL documentation for PEM_write_bio_ECPKParameters()" />
              <scope name="to_text" ilk="function" signature="to_text()" doc="See the OpenSSL documentation for ECPKParameters_print()" />
              <scope name="Error" ilk="class" classrefs="eOSSLError">
              </scope>
            </scope>
            <scope name="Point" ilk="class" classrefs="Object">
              <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for EC_POINT_*" />
              <scope name="eql?" ilk="function" signature="eql?(p1)" />
              <scope name="infinity?" ilk="function" signature="infinity?()" />
              <scope name="invert!" ilk="function" signature="invert!()" />
              <scope name="make_affine!" ilk="function" signature="make_affine!()" />
              <scope name="on_curve?" ilk="function" signature="on_curve?()" />
              <scope name="set_to_infinity!" ilk="function" signature="set_to_infinity!()" />
              <scope name="to_bn" ilk="function" signature="to_bn()" doc="See the OpenSSL documentation for EC_POINT_point2bn()" />
              <scope name="Error" ilk="class" classrefs="eOSSLError">
              </scope>
            </scope>
          </scope>
          <scope name="ECError" ilk="class" classrefs="ePKeyError">
          </scope>
          <scope name="PKey" ilk="class" classrefs="Object">
          </scope>
          <scope name="PKeyError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="RSA" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(...)" attributes="__classmethod__" doc="Parameters +size+ is an integer representing the desired key size.  Keys smaller than 1024 should be considered insecure.&#xA;+exponent+ is an odd number normally 3, 17, or 65537." />
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Parameters +size+ is an integer representing the desired key size.&#xA;+encoded_key+ is a string containing PEM or DER encoded key.&#xA;+pass+ is an optional string with the password to decrypt the encoded key. &#xA; Examples RSA.new(2048) -&gt; rsa&#xA;RSA.new(File.read(&quot;rsa.pem&quot;)) -&gt; rsa&#xA;RSA.new(File.read(&quot;rsa.pem&quot;), &quot;mypassword&quot;) -&gt; rsa" />
            <scope name="export" ilk="function" signature="export(...)" doc="Parameters +cipher+ is a Cipher object.&#xA;+pass+ is a string. &#xA; Examples rsa.to_pem -&gt; aString&#xA;rsa.to_pem(cipher, pass) -&gt; aString" />
            <scope name="params" ilk="function" signature="params()" doc=" &#xA; Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
            <scope name="private?" ilk="function" signature="private?()" />
            <scope name="private_decrypt" ilk="function" signature="private_decrypt(...)" />
            <scope name="private_encrypt" ilk="function" signature="private_encrypt(...)" />
            <scope name="public?" ilk="function" signature="public?()" doc="The return value is always true since every private key is also a public key." />
            <scope name="public_decrypt" ilk="function" signature="public_decrypt(...)" />
            <scope name="public_encrypt" ilk="function" signature="public_encrypt(...)" />
            <scope name="public_key" ilk="function" signature="public_key()" doc=" &#xA; Makes new instance RSA PUBLIC_KEY from PRIVATE_KEY" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem(...)" />
            <scope name="to_s" ilk="function" signature="to_s(...)" />
            <scope name="to_text" ilk="function" signature="to_text()" doc=" &#xA; Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (It&apos;s up to you)" />
          </scope>
          <scope name="RSAError" ilk="class" classrefs="ePKeyError">
          </scope>
        </scope>
        <scope name="Random" ilk="namespace">
          <scope name="RandomError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="SSL" ilk="namespace">
          <scope name="SSLContext" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="You can get a list of valid methods with OpenSSL::SSL::SSLContext::METHODS" />
            <scope name="ciphers" ilk="function" signature="ciphers()" doc="call-seq:    ctx.ciphers =&gt; [[name, version, bits, alg_bits], ...]" />
            <scope name="ciphers=" ilk="function" signature="ciphers=(p1)" doc="call-seq:    ctx.ciphers = &quot;cipher1:cipher2:...&quot;&#xA;   ctx.ciphers = [name, ...]&#xA;   ctx.ciphers = [[name, version, bits, alg_bits], ...]" />
            <scope name="flush_sessions" ilk="function" signature="flush_sessions(...)" />
            <scope name="session_add" ilk="function" signature="session_add(p1)" />
            <scope name="session_cache_mode" ilk="function" signature="session_cache_mode()" />
            <scope name="session_cache_mode=" ilk="function" signature="session_cache_mode=(p1)" />
            <scope name="session_cache_size" ilk="function" signature="session_cache_size()" />
            <scope name="session_cache_size=" ilk="function" signature="session_cache_size=(p1)" />
            <scope name="session_cache_stats" ilk="function" signature="session_cache_stats()" />
            <scope name="session_remove" ilk="function" signature="session_remove(p1)" />
            <scope name="setup" ilk="function" signature="setup()" doc="This method is called automatically when a new SSLSocket is created. Normally you do not need to call this method (unless you are writing an extension in C)." />
            <variable name="SESSION_CACHE_OFF" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_CLIENT" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_SERVER" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_BOTH" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_NO_AUTO_CLEAR" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_NO_INTERNAL_LOOKUP" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_NO_INTERNAL_STORE" attributes="__const__" citdl="Object" />
            <variable name="SESSION_CACHE_NO_INTERNAL" attributes="__const__" citdl="Object" />
            <variable name="METHODS" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="SSLError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="SSLSocket" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Parameters +io+ is a real ruby IO object.  Not an IO like object that responds to read/write.&#xA;+ctx+ is an OpenSSLSSL::SSLContext. &#xA; The OpenSSL::Buffering module provides additional IO methods. &#xA; This method will freeze the SSLContext if one is provided; however, session management is still allowed in the frozen SSLContext." />
            <scope name="accept" ilk="function" signature="accept()" doc="call-seq:    ssl.accept =&gt; self" />
            <scope name="accept_nonblock" ilk="function" signature="accept_nonblock()" doc="initiate the TLS/SSL handshake as a server in non-blocking manner. &#xA;   # emulates blocking accept&#xA;  begin&#xA;    ssl.accept_nonblock&#xA;  rescue IO::WaitReadable&#xA;    IO.select([s2])&#xA;    retry&#xA;  rescue IO::WaitWritable&#xA;    IO.select(nil, [s2])&#xA;    retry&#xA;  end" />
            <scope name="cert" ilk="function" signature="cert()" doc="call-seq:    ssl.cert =&gt; cert or nil" />
            <scope name="cipher" ilk="function" signature="cipher()" doc="call-seq:    ssl.cipher =&gt; [name, version, bits, alg_bits]" />
            <scope name="connect" ilk="function" signature="connect()" doc="call-seq:    ssl.connect =&gt; self" />
            <scope name="connect_nonblock" ilk="function" signature="connect_nonblock()" doc="initiate the TLS/SSL handshake as a client in non-blocking manner. &#xA;   # emulates blocking connect&#xA;  begin&#xA;    ssl.connect_nonblock&#xA;  rescue IO::WaitReadable&#xA;    IO.select([s2])&#xA;    retry&#xA;  rescue IO::WaitWritable&#xA;    IO.select(nil, [s2])&#xA;    retry&#xA;  end" />
            <scope name="peer_cert" ilk="function" signature="peer_cert()" doc="call-seq:    ssl.peer_cert =&gt; cert or nil" />
            <scope name="peer_cert_chain" ilk="function" signature="peer_cert_chain()" doc="call-seq:    ssl.peer_cert_chain =&gt; [cert, ...] or nil" />
            <scope name="pending" ilk="function" signature="pending()" doc="call-seq:    ssl.pending =&gt; integer" />
            <scope name="session=" ilk="function" signature="session=(p1)" />
            <scope name="session_reused?" ilk="function" signature="session_reused?()" />
            <scope name="state" ilk="function" signature="state()" doc="call-seq:    ssl.state =&gt; string" />
            <scope name="sysclose" ilk="function" signature="sysclose()" doc="call-seq:    ssl.sysclose =&gt; nil" />
            <scope name="sysread" ilk="function" signature="sysread(...)" doc="Parameters +length+ is a positive integer.&#xA;+buffer+ is a string used to store the result." />
            <scope name="syswrite" ilk="function" signature="syswrite(p1)" doc="call-seq:    ssl.syswrite(string) =&gt; integer" />
          </scope>
          <scope name="Session" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="Parameters +SSLSocket+ is an OpenSSL::SSL::SSLSocket +string+ must be a DER or PEM encoded Session." />
            <scope name="id" ilk="function" signature="id()" doc="Returns the Session ID." />
            <scope name="time" ilk="function" signature="time()" />
            <scope name="timeout" ilk="function" signature="timeout()" doc="How long until the session expires in seconds." />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Returns an ASN1 encoded String that contains the Session object." />
            <scope name="to_pem" ilk="function" signature="to_pem()" doc="Returns a PEM encoded String that contains the Session object." />
            <scope name="to_text" ilk="function" signature="to_text()" doc="Shows everything in the Session object." />
            <scope name="SessionError" ilk="class" classrefs="eOSSLError">
            </scope>
          </scope>
        </scope>
        <scope name="X509" ilk="namespace">
          <scope name="Attribute" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="call-seq:    Attribute.new(oid [, value]) =&gt; attr" />
            <scope name="oid" ilk="function" signature="oid()" doc="call-seq:    attr.oid =&gt; string" />
            <scope name="oid=" ilk="function" signature="oid=(p1)" doc="call-seq:    attr.oid = string =&gt; string" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="call-seq:    attr.to_der =&gt; string" />
            <scope name="value" ilk="function" signature="value()" doc="call-seq:    attr.value =&gt; asn1" />
            <scope name="value=" ilk="function" signature="value=(p1)" doc="call-seq:    attr.value = asn1 =&gt; asn1" />
          </scope>
          <scope name="AttributeError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="CRL" ilk="class" classrefs="Object">
            <scope name="extensions" ilk="function" signature="extensions()" doc="Gets X509v3 extensions as array of X509Ext objects" />
            <scope name="extensions=" ilk="function" signature="extensions=(p1)" doc="Sets X509_EXTENSIONs" />
          </scope>
          <scope name="CRLError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Certificate" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="call-seq:    Certificate.new =&gt; cert&#xA;   Certificate.new(string) =&gt; cert" />
            <scope name="add_extension" ilk="function" signature="add_extension(p1)" doc="call-seq:    cert.add_extension(extension) =&gt; extension" />
            <scope name="check_private_key" ilk="function" signature="check_private_key(p1)" doc="Checks if &apos;key&apos; is PRIV key for this cert" />
            <scope name="extensions" ilk="function" signature="extensions()" doc="call-seq:    cert.extensions =&gt; [extension...]" />
            <scope name="extensions=" ilk="function" signature="extensions=(p1)" doc="call-seq:    cert.extensions = [ext...] =&gt; [ext...]" />
            <scope name="issuer" ilk="function" signature="issuer()" doc="call-seq:    cert.issuer =&gt; name" />
            <scope name="issuer=" ilk="function" signature="issuer=(p1)" doc="call-seq:    cert.issuer = name =&gt; name" />
            <scope name="not_after" ilk="function" signature="not_after()" doc="call-seq:    cert.not_after =&gt; time" />
            <scope name="not_after=" ilk="function" signature="not_after=(p1)" doc="call-seq:    cert.not_before = time =&gt; time" />
            <scope name="not_before" ilk="function" signature="not_before()" doc="call-seq:    cert.not_before =&gt; time" />
            <scope name="not_before=" ilk="function" signature="not_before=(p1)" doc="call-seq:    cert.not_before = time =&gt; time" />
            <scope name="public_key" ilk="function" signature="public_key()" doc="call-seq:    cert.public_key =&gt; key" />
            <scope name="public_key=" ilk="function" signature="public_key=(p1)" doc="call-seq:    cert.public_key = key =&gt; key" />
            <scope name="serial" ilk="function" signature="serial()" doc="call-seq:    cert.serial =&gt; integer" />
            <scope name="serial=" ilk="function" signature="serial=(p1)" doc="call-seq:    cert.serial = integer =&gt; integer" />
            <scope name="sign" ilk="function" signature="sign(p1, p2)" doc="call-seq:    cert.sign(key, digest) =&gt; self" />
            <scope name="signature_algorithm" ilk="function" signature="signature_algorithm()" doc="call-seq:    cert.signature_algorithm =&gt; string" />
            <scope name="subject" ilk="function" signature="subject()" doc="call-seq:    cert.subject =&gt; name" />
            <scope name="subject=" ilk="function" signature="subject=(p1)" doc="call-seq:    cert.subject = name =&gt; name" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="call-seq:    cert.to_der =&gt; string" />
            <scope name="to_pem" ilk="function" signature="to_pem()" doc="call-seq:    cert.to_pem =&gt; string" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" doc="call-seq:    cert.to_text =&gt; string" />
            <scope name="verify" ilk="function" signature="verify(p1)" doc="Checks that cert signature is made with PRIVversion of this PUBLIC &apos;key&apos;" />
            <scope name="version" ilk="function" signature="version()" doc="call-seq:    cert.version =&gt; integer" />
            <scope name="version=" ilk="function" signature="version=(p1)" doc="call-seq:    cert.version = integer =&gt; integer" />
          </scope>
          <scope name="CertificateError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Extension" ilk="class" classrefs="Object">
          </scope>
          <scope name="ExtensionError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="ExtensionFactory" ilk="class" classrefs="Object">
            <scope name="create_ext" ilk="function" signature="create_ext(...)" doc="Array to X509_EXTENSION Structure: or&#xA;or&#xA;or the same for sn&#xA;&gt; not critical" />
          </scope>
          <scope name="Name" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="call-seq:    X509::Name.new =&gt; name&#xA;   X509::Name.new(string) =&gt; name&#xA;   X509::Name.new(dn) =&gt; name&#xA;   X509::Name.new(dn, template) =&gt; name" />
            <scope name="add_entry" ilk="function" signature="add_entry(...)" doc="call-seq:    name.add_entry(oid, value [, type]) =&gt; self" />
            <scope name="hash" ilk="function" signature="hash()" doc="call-seq:    name.hash =&gt; integer" />
            <scope name="to_a" ilk="function" signature="to_a()" doc="call-seq:    name.to_a =&gt; [[name, data, type], ...]" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="call-seq:    name.to_der =&gt; string" />
            <scope name="to_s" ilk="function" signature="to_s(...)" doc="call-seq:    name.to_s =&gt; string&#xA;   name.to_s(integer) =&gt; string" />
            <variable name="DEFAULT_OBJECT_TYPE" attributes="__const__" citdl="Object" />
            <variable name="OBJECT_TYPE_TEMPLATE" attributes="__const__" citdl="Object" />
            <variable name="COMPAT" attributes="__const__" citdl="Object" />
            <variable name="ONELINE" attributes="__const__" citdl="Object" />
            <variable name="MULTILINE" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="NameError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Request" ilk="class" classrefs="Object">
            <scope name="verify" ilk="function" signature="verify(p1)" doc="Checks that cert signature is made with PRIVversion of this PUBLIC &apos;key&apos;" />
          </scope>
          <scope name="RequestError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Revoked" ilk="class" classrefs="Object">
            <scope name="extensions" ilk="function" signature="extensions()" doc="Gets X509v3 extensions as array of X509Ext objects" />
            <scope name="extensions=" ilk="function" signature="extensions=(p1)" doc="Sets X509_EXTENSIONs" />
          </scope>
          <scope name="RevokedError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Store" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" />
            <scope name="verify_callback=" ilk="function" signature="verify_callback=(p1)" doc="General callback for OpenSSL verify" />
          </scope>
          <scope name="StoreContext" ilk="class" classrefs="Object">
          </scope>
          <scope name="StoreError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="pathname" ilk="blob" lang="Ruby">
      <scope name="Pathname" ilk="class" classrefs="Object">
        <scope name="getwd" ilk="function" signature="getwd()" attributes="__classmethod__" doc="See Dir.getwd.  Returns the current working directory as a Pathname." />
        <scope name="glob" ilk="function" signature="glob(*args)" attributes="__classmethod__" doc="See Dir.glob.  Returns or yields Pathname objects." />
        <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" doc="Create a Pathname object from the given String (or String-like object). If +path+ contains a NUL character (\0), an ArgumentError is raised." />
        <scope name="TO_PATH" ilk="function" signature="TO_PATH()" doc="to_path is implemented so Pathname objects are usable with File.open, etc." />
        <scope name="absolute?" ilk="function" signature="absolute?()" doc="Predicate method for testing whether a path is absolute. It returns +true+ if the pathname begins with a slash." />
        <scope name="ascend" ilk="function" signature="ascend()" doc="Iterates over and yields a new Pathname object for each element in the given path in ascending order. &#xA;  Pathname.new(&apos;/path/to/some/file.rb&apos;).ascend {|v| p v}&#xA;    #&lt;Pathname:/path/to/some/file.rb&gt;&#xA;    #&lt;Pathname:/path/to/some&gt;&#xA;    #&lt;Pathname:/path/to&gt;&#xA;    #&lt;Pathname:/path&gt;&#xA;    #&lt;Pathname:/&gt;&#xA; Pathname.new(&apos;path/to/some/file.rb&apos;).ascend {|v| p v}&#xA;    #&lt;Pathname:path/to/some/file.rb&gt;&#xA;    #&lt;Pathname:path/to/some&gt;&#xA;    #&lt;Pathname:path/to&gt;&#xA;    #&lt;Pathname:path&gt;&#xA; It doesn&apos;t access actual filesystem. " />
        <scope name="atime" ilk="function" signature="atime()" doc="See File.atime.  Returns last access time." />
        <scope name="basename" ilk="function" signature="basename(*args)" doc="See File.basename.  Returns the last component of the path." />
        <scope name="binread" ilk="function" signature="binread(*args)" doc="See IO.binread.  Returns all the bytes from the file, or the first +N+ if specified." />
        <scope name="blockdev?" ilk="function" signature="blockdev?()" doc="See FileTest.blockdev?." />
        <scope name="chardev?" ilk="function" signature="chardev?()" doc="See FileTest.chardev?." />
        <scope name="children" ilk="function" signature="children(with_directory=true)" doc="Returns the children of the directory (files and subdirectories, not recursive) as an array of Pathname objects.  By default, the returned pathnames will have enough information to access the files.  If you set +with_directory+ to +false+, then the returned pathnames will contain the filename only. &#xA; For example:   pn = Pathname(&quot;/usr/lib/ruby/1.8&quot;)&#xA;  pn.children&#xA;      # -&gt; [ Pathname:/usr/lib/ruby/1.8/English.rb,&#xA;             Pathname:/usr/lib/ruby/1.8/Env.rb,&#xA;             Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]&#xA;  pn.children(false)&#xA;      # -&gt; [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]&#xA; Note that the result never contain the entries . and .. in the directory because they are not children. &#xA; This method has existed since 1.8.1." />
        <scope name="chmod" ilk="function" signature="chmod(mode)" doc="See File.chmod.  Changes permissions." />
        <scope name="chown" ilk="function" signature="chown(owner, group)" doc="See File.chown.  Change owner and group of file." />
        <scope name="cleanpath" ilk="function" signature="cleanpath(consider_symlink=false)" doc="Returns clean pathname of +self+ with consecutive slashes and useless dots removed.  The filesystem is not accessed. &#xA; If +consider_symlink+ is +true+, then a more conservative algorithm is used to avoid breaking symbolic linkages.  This may retain more .. entries than absolutely necessary, but without accessing the filesystem, this can&apos;t be avoided.  See #realpath." />
        <scope name="ctime" ilk="function" signature="ctime()" doc="See File.ctime.  Returns last (directory entry, not file) change time." />
        <scope name="delete" ilk="function" signature="delete()" />
        <scope name="descend" ilk="function" signature="descend()" doc="Iterates over and yields a new Pathname object for each element in the given path in descending order. &#xA;  Pathname.new(&apos;/path/to/some/file.rb&apos;).descend {|v| p v}&#xA;    #&lt;Pathname:/&gt;&#xA;    #&lt;Pathname:/path&gt;&#xA;    #&lt;Pathname:/path/to&gt;&#xA;    #&lt;Pathname:/path/to/some&gt;&#xA;    #&lt;Pathname:/path/to/some/file.rb&gt;&#xA; Pathname.new(&apos;path/to/some/file.rb&apos;).descend {|v| p v}&#xA;    #&lt;Pathname:path&gt;&#xA;    #&lt;Pathname:path/to&gt;&#xA;    #&lt;Pathname:path/to/some&gt;&#xA;    #&lt;Pathname:path/to/some/file.rb&gt;&#xA; It doesn&apos;t access actual filesystem. " />
        <scope name="directory?" ilk="function" signature="directory?()" doc="See FileTest.directory?." />
        <scope name="dirname" ilk="function" signature="dirname()" doc="See File.dirname.  Returns all but the last component of the path." />
        <scope name="each_child" ilk="function" signature="each_child(with_directory=true, &amp;b)" doc="Iterates over the children of the directory (files and subdirectories, not recursive). It yields Pathname object for each child. By default, the yielded pathnames will have enough information to access the files. If you set +with_directory+ to +false+, then the returned pathnames will contain the filename only. &#xA;   Pathname(&quot;/usr/local&quot;).each_child {|f| p f }&#xA;  =&gt; #&lt;Pathname:/usr/local/share&gt;&#xA;  #   #&lt;Pathname:/usr/local/bin&gt;&#xA;  #   #&lt;Pathname:/usr/local/games&gt;&#xA;  #   #&lt;Pathname:/usr/local/lib&gt;&#xA;  #   #&lt;Pathname:/usr/local/include&gt;&#xA;  #   #&lt;Pathname:/usr/local/sbin&gt;&#xA;  #   #&lt;Pathname:/usr/local/src&gt;&#xA;  #   #&lt;Pathname:/usr/local/man&gt;&#xA;  Pathname(&quot;/usr/local&quot;).each_child(false) {|f| p f }&#xA;  =&gt; #&lt;Pathname:share&gt;&#xA;  #   #&lt;Pathname:bin&gt;" />
        <scope name="each_entry" ilk="function" signature="each_entry()" doc="Iterates over the entries (files and subdirectories) in the directory.  It yields a Pathname object for each entry. &#xA; This method has existed since 1.8.1." />
        <scope name="each_filename" ilk="function" signature="each_filename()" doc="Iterates over each component of the path. &#xA;   Pathname.new(&quot;/usr/bin/ruby&quot;).each_filename {|filename| ... }&#xA;    # yields &quot;usr&quot;, &quot;bin&quot;, and &quot;ruby&quot;." />
        <scope name="each_line" ilk="function" signature="each_line(*args)" doc="#each_line iterates over the line in the file.  It yields a String object for each line. &#xA; This method has existed since 1.8.1." />
        <scope name="entries" ilk="function" signature="entries()" doc="Return the entries (files and subdirectories) in the directory, each as a Pathname object." />
        <scope name="eql?" ilk="function" signature="eql?(other)" />
        <scope name="executable?" ilk="function" signature="executable?()" doc="See FileTest.executable?." />
        <scope name="executable_real?" ilk="function" signature="executable_real?()" doc="See FileTest.executable_real?." />
        <scope name="exist?" ilk="function" signature="exist?()" doc="See FileTest.exist?." />
        <scope name="expand_path" ilk="function" signature="expand_path(*args)" doc="See File.expand_path." />
        <scope name="extname" ilk="function" signature="extname()" doc="See File.extname.  Returns the file&apos;s extension." />
        <scope name="file?" ilk="function" signature="file?()" doc="See FileTest.file?." />
        <scope name="find" ilk="function" signature="find()" doc="Pathname#find is an iterator to traverse a directory tree in a depth first manner.  It yields a Pathname for each file under &quot;this&quot; directory. &#xA; Since it is implemented by find.rb, Find.prune can be used to control the traverse. &#xA; If +self+ is ., yielded pathnames begin with a filename in the current directory, not ./." />
        <scope name="fnmatch" ilk="function" signature="fnmatch(pattern, *args)" doc="See File.fnmatch.  Return +true+ if the receiver matches the given pattern." />
        <scope name="fnmatch?" ilk="function" signature="fnmatch?(pattern, *args)" doc="See File.fnmatch? (same as #fnmatch)." />
        <scope name="freeze" ilk="function" signature="freeze()" />
        <scope name="ftype" ilk="function" signature="ftype()" doc="See File.ftype.  Returns &quot;type&quot; of file (&quot;file&quot;, &quot;directory&quot;, etc)." />
        <scope name="grpowned?" ilk="function" signature="grpowned?()" doc="See FileTest.grpowned?." />
        <scope name="join" ilk="function" signature="join(*args)" doc="Pathname#join joins pathnames. &#xA; path0.join(path1, ..., pathN) is the same as path0 + path1 + ... + pathN." />
        <scope name="lchmod" ilk="function" signature="lchmod(mode)" doc="See File.lchmod." />
        <scope name="lchown" ilk="function" signature="lchown(owner, group)" doc="See File.lchown." />
        <scope name="lstat" ilk="function" signature="lstat()" doc="See File.lstat." />
        <scope name="make_link" ilk="function" signature="make_link(old)" doc="See File.link.  Creates a hard link." />
        <scope name="make_symlink" ilk="function" signature="make_symlink(old)" doc="See File.symlink.  Creates a symbolic link." />
        <scope name="mkdir" ilk="function" signature="mkdir(*args)" doc="See Dir.mkdir.  Create the referenced directory." />
        <scope name="mkpath" ilk="function" signature="mkpath()" doc="See FileUtils.mkpath.  Creates a full path, including any intermediate directories that don&apos;t yet exist." />
        <scope name="mountpoint?" ilk="function" signature="mountpoint?()" doc="mountpoint? returns +true+ if self points to a mountpoint." />
        <scope name="mtime" ilk="function" signature="mtime()" doc="See File.mtime.  Returns last modification time." />
        <scope name="open" ilk="function" signature="open(*args)" doc="See File.open.  Opens the file for reading or writing." />
        <scope name="opendir" ilk="function" signature="opendir()" doc="See Dir.open." />
        <scope name="owned?" ilk="function" signature="owned?()" doc="See FileTest.owned?." />
        <scope name="parent" ilk="function" signature="parent()" doc="#parent returns the parent directory. &#xA; This is same as self + &apos;..&apos;." />
        <scope name="pipe?" ilk="function" signature="pipe?()" doc="See FileTest.pipe?." />
        <scope name="read" ilk="function" signature="read(*args)" doc="See IO.read.  Returns all data from the file, or the first +N+ bytes if specified." />
        <scope name="readable?" ilk="function" signature="readable?()" doc="See FileTest.readable?." />
        <scope name="readable_real?" ilk="function" signature="readable_real?()" doc="See FileTest.readable_real?." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" doc="See IO.readlines.  Returns all the lines from the file." />
        <scope name="readlink" ilk="function" signature="readlink()" doc="See File.readlink.  Read symbolic link." />
        <scope name="realdirpath" ilk="function" signature="realdirpath(basedir=nil)" doc="Returns the real (absolute) pathname of +self+ in the actual filesystem. The real pathname doesn&apos;t contain symlinks or useless dots. &#xA; The last component of the real pathname can be nonexistent." />
        <scope name="realpath" ilk="function" signature="realpath(basedir=nil)" doc="Returns the real (absolute) pathname of +self+ in the actual filesystem not containing symlinks or useless dots. &#xA; All components of the pathname must exist when this method is called." />
        <scope name="relative?" ilk="function" signature="relative?()" doc="The opposite of #absolute?" />
        <scope name="relative_path_from" ilk="function" signature="relative_path_from(base_directory)" doc="#relative_path_from returns a relative path from the argument to the receiver.  If +self+ is absolute, the argument must be absolute too.  If +self+ is relative, the argument must be relative too. &#xA; #relative_path_from doesn&apos;t access the filesystem.  It assumes no symlinks. &#xA; ArgumentError is raised when it cannot find a relative path. &#xA; This method has existed since 1.8.1." />
        <scope name="rename" ilk="function" signature="rename(to)" doc="See File.rename.  Rename the file." />
        <scope name="rmdir" ilk="function" signature="rmdir()" doc="See Dir.rmdir.  Remove the referenced directory." />
        <scope name="rmtree" ilk="function" signature="rmtree()" doc="See FileUtils.rm_r.  Deletes a directory and all beneath it." />
        <scope name="root?" ilk="function" signature="root?()" doc="#root? is a predicate for root directories.  I.e. it returns +true+ if the pathname consists of consecutive slashes. &#xA; It doesn&apos;t access actual filesystem.  So it may return +false+ for some pathnames which points to roots such as /usr/..." />
        <scope name="setgid?" ilk="function" signature="setgid?()" doc="See FileTest.setgid?." />
        <scope name="setuid?" ilk="function" signature="setuid?()" doc="See FileTest.setuid?." />
        <scope name="size" ilk="function" signature="size()" doc="See FileTest.size." />
        <scope name="size?" ilk="function" signature="size?()" doc="See FileTest.size?." />
        <scope name="socket?" ilk="function" signature="socket?()" doc="See FileTest.socket?." />
        <scope name="split" ilk="function" signature="split()" doc="See File.split.  Returns the #dirname and the #basename in an Array." />
        <scope name="stat" ilk="function" signature="stat()" doc="See File.stat.  Returns a File::Stat object." />
        <scope name="sticky?" ilk="function" signature="sticky?()" doc="See FileTest.sticky?." />
        <scope name="sub" ilk="function" signature="sub(pattern, *rest, &amp;block)" doc="Return a pathname which is substituted by String#sub." />
        <scope name="sub_ext" ilk="function" signature="sub_ext(repl)" doc="Return a pathname which the extension of the basename is substituted by repl. &#xA; If self has no extension part, repl is appended." />
        <scope name="symlink?" ilk="function" signature="symlink?()" doc="See FileTest.symlink?." />
        <scope name="sysopen" ilk="function" signature="sysopen(*args)" doc="See IO.sysopen." />
        <scope name="taint" ilk="function" signature="taint()" />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Return the path as a String." />
        <scope name="truncate" ilk="function" signature="truncate(length)" doc="See File.truncate.  Truncate the file to +length+ bytes." />
        <scope name="unlink" ilk="function" signature="unlink()" doc="Removes a file or directory, using File.unlink or Dir.unlink as necessary." />
        <scope name="untaint" ilk="function" signature="untaint()" />
        <scope name="utime" ilk="function" signature="utime(atime, mtime)" doc="See File.utime.  Update the access and modification times." />
        <scope name="world_readable?" ilk="function" signature="world_readable?()" doc="See FileTest.world_readable?." />
        <scope name="world_writable?" ilk="function" signature="world_writable?()" doc="See FileTest.world_writable?." />
        <scope name="writable?" ilk="function" signature="writable?()" doc="See FileTest.writable?." />
        <scope name="writable_real?" ilk="function" signature="writable_real?()" doc="See FileTest.writable_real?." />
        <scope name="zero?" ilk="function" signature="zero?()" doc="See FileTest.zero?." />
        <variable name="SEPARATOR_LIST" attributes="__const__" citdl="Object" />
        <variable name="SEPARATOR_PAT" attributes="__const__" citdl="Object" />
        <variable name="SEPARATOR_LIST" attributes="__const__" citdl="Object" />
        <variable name="SEPARATOR_PAT" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="pp" ilk="blob" lang="Ruby">
      <scope name="PP" ilk="class" classrefs="PrettyPrint">
        <import symbol="PPMethods" />
        <scope name="pp" ilk="function" signature="pp(obj, out=$&gt;, width=79)" attributes="__classmethod__" doc="Outputs +obj+ to +out+ in pretty printed format of +width+ columns in width. &#xA; If +out+ is omitted, +$&gt;+ is assumed. If +width+ is omitted, 79 is assumed. &#xA; PP.pp returns +out+." />
        <scope name="singleline_pp" ilk="function" signature="singleline_pp(obj, out=$&gt;)" attributes="__classmethod__" doc="Outputs +obj+ to +out+ like PP.pp but with no indent and newline. &#xA; PP.singleline_pp returns +out+." />
        <scope ilk="function" name="sharing_detection" />
        <scope ilk="function" name="sharing_detection=" />
        <scope name="ObjectMixin" ilk="namespace">
          <scope name="pretty_print" ilk="function" signature="pretty_print(q)" doc="A default pretty printing method for general objects. It calls #pretty_print_instance_variables to list instance variables. &#xA; If +self+ has a customized (redefined) #inspect method, the result of self.inspect is used but it obviously has no line break hints. &#xA; This module provides predefined #pretty_print methods for some of the most commonly used built-in classes for convenience." />
          <scope name="pretty_print_cycle" ilk="function" signature="pretty_print_cycle(q)" doc="A default pretty printing method for general objects that are detected as part of a cycle." />
          <scope name="pretty_print_inspect" ilk="function" signature="pretty_print_inspect()" doc="Is #inspect implementation using #pretty_print. If you implement #pretty_print, it can be used as follows. &#xA;   alias inspect pretty_print_inspect&#xA; However, doing this requires that every class that #inspect is called on implement #pretty_print, or a RuntimeError will be raised." />
          <scope name="pretty_print_instance_variables" ilk="function" signature="pretty_print_instance_variables()" doc="Returns a sorted array of instance variable names. &#xA; This method should return an array of names of instance variables as symbols or strings as: +[:@a, :@b]+." />
        </scope>
        <scope name="PPMethods" ilk="namespace">
          <scope name="check_inspect_key" ilk="function" signature="check_inspect_key(id)" />
          <scope name="comma_breakable" ilk="function" signature="comma_breakable()" doc="A convenience method which is same as follows: &#xA;   text &apos;,&apos;&#xA;  breakable" />
          <scope name="guard_inspect_key" ilk="function" signature="guard_inspect_key()" />
          <scope name="object_address_group" ilk="function" signature="object_address_group(obj, &amp;block)" />
          <scope name="object_group" ilk="function" signature="object_group(obj)" doc="A convenience method which is same as follows: &#xA;   group(1, &apos;#&lt;&apos; + obj.class.name, &apos;&gt;&apos;) { ... }" />
          <scope name="pop_inspect_key" ilk="function" signature="pop_inspect_key(id)" />
          <scope name="pp" ilk="function" signature="pp(obj)" doc="Adds +obj+ to the pretty printing buffer using Object#pretty_print or Object#pretty_print_cycle. &#xA; Object#pretty_print_cycle is used when +obj+ is already printed, a.k.a the object reference chain has a cycle." />
          <scope name="pp_hash" ilk="function" signature="pp_hash(obj)" />
          <scope name="pp_object" ilk="function" signature="pp_object(obj)" />
          <scope name="push_inspect_key" ilk="function" signature="push_inspect_key(id)" />
          <scope name="seplist" ilk="function" signature="seplist(list, sep=nil, iter_method=:each)" doc="Adds a separated list. The list is separated by comma with breakable space, by default. &#xA; #seplist iterates the +list+ using +iter_method+. It yields each object to the block given for #seplist. The procedure +separator_proc+ is called between each yields. &#xA; If the iteration is zero times, +separator_proc+ is not called at all. &#xA; If +separator_proc+ is nil or not given, +lambda { comma_breakable }+ is used. If +iter_method+ is not given, :each is used. &#xA; For example, following 3 code fragments has similar effect. &#xA;   q.seplist([1,2,3]) {|v| xxx v }&#xA;&#xA;  q.seplist([1,2,3], lambda { q.comma_breakable }, :each) {|v| xxx v }&#xA;&#xA;  xxx 1&#xA;  q.comma_breakable&#xA;  xxx 2&#xA;  q.comma_breakable&#xA;  xxx 3" />
        </scope>
        <scope name="SingleLine" ilk="class" classrefs="PrettyPrint::SingleLine">
          <import symbol="PPMethods" />
        </scope>
      </scope>
    </scope>
    <scope name="prettyprint" ilk="blob" lang="Ruby">
      <scope name="PrettyPrint" ilk="class" classrefs="Object">
        <scope name="format" ilk="function" signature="format(output=&apos;&apos;, maxwidth=79, newline=&quot;\n&quot;, genspace=lambda {|n| &apos; &apos; * n}" attributes="__classmethod__" doc="This is a convenience method which is same as follows: &#xA;   begin&#xA;    q = PrettyPrint.new(output, maxwidth, newline, &amp;genspace)&#xA;    ...&#xA;    q.flush&#xA;    output&#xA;  end" />
        <scope name="new" ilk="function" signature="new(output=&apos;&apos;, maxwidth=79, newline=&quot;\n&quot;, &amp;genspace)" attributes="__classmethod__ __ctor__" doc="Creates a buffer for pretty printing. &#xA; +output+ is an output target. If it is not specified, &apos;&apos; is assumed. It should have a &lt;&lt; method which accepts the first argument +obj+ of PrettyPrint#text, the first argument +sep+ of PrettyPrint#breakable, the first argument +newline+ of PrettyPrint.new, and the result of a given block for PrettyPrint.new. &#xA; +maxwidth+ specifies maximum line length. If it is not specified, 79 is assumed. However actual outputs may overflow +maxwidth+ if long non-breakable texts are provided. &#xA; +newline+ is used for line breaks. &quot;\n&quot; is used if it is not specified. &#xA; The block is used to generate spaces. {|width| &apos; &apos; * width} is used if it is not given." />
        <scope name="singleline_format" ilk="function" signature="singleline_format(output=&apos;&apos;, maxwidth=nil, newline=nil, genspace=nil)" attributes="__classmethod__" doc="This is similar to PrettyPrint::format but the result has no breaks. &#xA; +maxwidth+, +newline+ and +genspace+ are ignored. &#xA; The invocation of +breakable+ in the block doesn&apos;t break a line and is treated as just an invocation of +text+." />
        <scope name="break_outmost_groups" ilk="function" signature="break_outmost_groups()" />
        <scope name="breakable" ilk="function" signature="breakable(sep=&apos; &apos;, width=sep.length)" doc="This tells &quot;you can break a line here if necessary&quot;, and a +width+\-column text +sep+ is inserted if a line is not broken at the point. &#xA; If +sep+ is not specified, &quot; &quot; is used. &#xA; If +width+ is not specified, +sep.length+ is used. You will have to specify this when +sep+ is a multibyte character, for example." />
        <scope name="current_group" ilk="function" signature="current_group()" />
        <scope name="fill_breakable" ilk="function" signature="fill_breakable(sep=&apos; &apos;, width=sep.length)" />
        <scope name="first?" ilk="function" signature="first?()" doc="first? is a predicate to test the call is a first call to first? with current group. &#xA; It is useful to format comma separated values as: &#xA;   q.group(1, &apos;[&apos;, &apos;]&apos;) {&#xA;    xxx.each {|yyy|&#xA;      unless q.first?&#xA;        q.text &apos;,&apos;&#xA;        q.breakable&#xA;      end&#xA;      ... pretty printing yyy ...&#xA;    }&#xA;  }&#xA; first? is obsoleted in 1.8.2." />
        <scope name="flush" ilk="function" signature="flush()" doc="outputs buffered data." />
        <scope name="group" ilk="function" signature="group(indent=0, open_obj=&apos;&apos;, close_obj=&apos;&apos;, open_width=open_obj.length, close_width=close_obj.length)" doc="Groups line break hints added in the block. The line break hints are all to be used or not. &#xA; If +indent+ is specified, the method call is regarded as nested by nest(indent) { ... }. &#xA; If +open_obj+ is specified, text open_obj, open_width is called before grouping. If +close_obj+ is specified, text close_obj, close_width is called after grouping." />
        <scope name="group_sub" ilk="function" signature="group_sub()" />
        <scope name="nest" ilk="function" signature="nest(indent)" doc="Increases left margin after newline with +indent+ for line breaks added in the block." />
        <scope name="text" ilk="function" signature="text(obj, width=obj.length)" doc="This adds +obj+ as a text of +width+ columns in width. &#xA; If +width+ is not specified, obj.length is used." />
        <scope ilk="function" name="genspace" />
        <scope ilk="function" name="group_queue" />
        <scope ilk="function" name="indent" />
        <scope ilk="function" name="maxwidth" />
        <scope ilk="function" name="newline" />
        <scope ilk="function" name="output" />
        <scope name="Breakable" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(sep, width, q)" attributes="__classmethod__ __ctor__" />
          <scope name="output" ilk="function" signature="output(out, output_width)" />
          <scope ilk="function" name="indent" />
          <scope ilk="function" name="obj" />
          <scope ilk="function" name="width" />
        </scope>
        <scope name="Group" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(depth)" attributes="__classmethod__ __ctor__" />
          <scope name="break" ilk="function" signature="break()" />
          <scope name="break?" ilk="function" signature="break?()" />
          <scope name="first?" ilk="function" signature="first?()" />
          <scope ilk="function" name="breakables" />
          <scope ilk="function" name="depth" />
        </scope>
        <scope name="GroupQueue" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*groups)" attributes="__classmethod__ __ctor__" />
          <scope name="delete" ilk="function" signature="delete(group)" />
          <scope name="deq" ilk="function" signature="deq()" />
          <scope name="enq" ilk="function" signature="enq(group)" />
        </scope>
        <scope name="SingleLine" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(output, maxwidth=nil, newline=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="breakable" ilk="function" signature="breakable(sep=&apos; &apos;, width=nil)" />
          <scope name="first?" ilk="function" signature="first?()" />
          <scope name="flush" ilk="function" signature="flush()" />
          <scope name="group" ilk="function" signature="group(indent=nil, open_obj=&apos;&apos;, close_obj=&apos;&apos;, open_width=nil, close_width=nil)" />
          <scope name="nest" ilk="function" signature="nest(indent)" />
          <scope name="text" ilk="function" signature="text(obj, width=nil)" />
        </scope>
        <scope name="Text" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="add" ilk="function" signature="add(obj, width)" />
          <scope name="output" ilk="function" signature="output(out, output_width)" />
          <scope ilk="function" name="width" />
        </scope>
      </scope>
    </scope>
    <scope name="prime" ilk="blob" lang="Ruby">
      <scope name="Prime" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <import symbol="Enumerable" />
        <scope name="instance" ilk="function" signature="instance()" attributes="__classmethod__" doc="Returns the default instance of Prime." />
        <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="obsolete. Use +Prime+::+instance+ or class methods of +Prime+." />
        <scope name="each" ilk="function" signature="each(ubound = nil, generator = EratosthenesGenerator.new, &amp;block)" doc="Iterates the given block over all prime numbers. &#xA; Parameters Optional. An arbitrary positive number. The upper bound of enumeration. The method enumerates prime numbers infinitely if +ubound+ is nil.&#xA;Optional. An implementation of pseudo-prime generator. &#xA; Return value An evaluated value of the given block at the last time. Or an enumerator which is compatible to an +Enumerator+ if no block given. &#xA; Description Calls +block+ once for each prime number, passing the prime as a parameter. &#xA; Upper bound of prime numbers. The iterator stops after yields all prime numbers p &lt;= +ubound+. &#xA; Note +Prime+.+new+ returns a object extended by +Prime+::+OldCompatibility+ in order to compatibility to Ruby 1.8, and +Prime+#each is overwritten by +Prime+::+OldCompatibility+#+each+. &#xA; +Prime+.+new+ is now obsolete. Use +Prime+.+instance+.+each+ or simply +Prime+.+each+." />
        <scope name="int_from_prime_division" ilk="function" signature="int_from_prime_division(pd)" doc="Re-composes a prime factorization and returns the product. &#xA; Parameters Array of pairs of integers. The each internal pair consists of a prime number -- a prime factor -- and a natural number -- an exponent. &#xA; Example For [[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]], it returns p_1**e_1 * p_2**e_2 * .... * p_n**e_n. &#xA;  Prime.int_from_prime_division([[2,2], [3,1]])  =&gt; 12" />
        <scope name="prime?" ilk="function" signature="prime?(value, generator = Prime::Generator23.new)" doc="Returns true if +value+ is prime, false for a composite. &#xA; Parameters an arbitrary integer to be checked.&#xA;optional. A pseudo-prime generator." />
        <scope name="prime_division" ilk="function" signature="prime_division(value, generator= Prime::Generator23.new)" doc="Returns the factorization of +value+. &#xA; Parameters An arbitrary integer.&#xA;Optional. A pseudo-prime generator. +generator+.succ must return the next pseudo-prime number in the ascendent order. It must generate all prime numbers, but may generate non prime numbers. &#xA; Exceptions when +value+ is zero. &#xA; Example For an arbitrary integer n = p_1**e_1 * p_2**e_2 * .... * p_n**e_n, prime_division(n) returns [[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]]. &#xA;  Prime.prime_division(12) =&gt; [[2,2], [3,1]]" />
        <scope name="EratosthenesGenerator" ilk="class" classrefs="PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
        <scope name="EratosthenesSieve" ilk="class" classrefs="Object">
          <import symbol="Singleton" />
          <scope name="next_to" ilk="function" signature="next_to(n)" doc="returns the least odd prime number which is greater than +n+." />
          <variable name="BITS_PER_ENTRY" attributes="__const__" citdl="Object" />
          <variable name="NUMS_PER_ENTRY" attributes="__const__" citdl="Object" />
          <variable name="ENTRIES_PER_TABLE" attributes="__const__" citdl="Object" />
          <variable name="NUMS_PER_TABLE" attributes="__const__" citdl="Object" />
          <variable name="FILLED_ENTRY" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Generator23" ilk="class" classrefs="PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
        <scope name="OldCompatibility" ilk="namespace">
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Overwrites Prime#each. &#xA; Iterates the given block over all prime numbers. Note that enumeration starts from the current position of internal pointer, not rewound." />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="succ" ilk="function" signature="succ()" doc="Returns the next prime number and forwards internal pointer." />
        </scope>
        <scope name="PseudoPrimeGenerator" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(ubound = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Iterates the given block for each prime numbers." />
          <scope name="next" ilk="function" signature="next()" doc="alias of +succ+." />
          <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the internal position for enumeration. &#xA; See +Enumerator+#rewind." />
          <scope name="succ" ilk="function" signature="succ()" doc="returns the next pseudo-prime number, and move the internal position forward. &#xA; +PseudoPrimeGenerator+#succ raises +NotImplementedError+." />
          <scope name="upper_bound" ilk="function" signature="upper_bound()" />
          <scope name="upper_bound=" ilk="function" signature="upper_bound=(ubound)" />
          <scope name="with_object" ilk="function" signature="with_object(obj)" doc="see +Enumerator+#with_object." />
        </scope>
        <scope name="TrialDivision" ilk="class" classrefs="Object">
          <import symbol="Singleton" />
          <scope name="cache" ilk="function" signature="cache()" doc="Returns the cached prime numbers." />
          <scope name="primes" ilk="function" signature="primes()" />
          <scope name="primes_so_far" ilk="function" signature="primes_so_far()" />
        </scope>
        <scope name="TrialDivisionGenerator" ilk="class" classrefs="PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
      </scope>
    </scope>
    <scope name="pstore" ilk="blob" lang="Ruby">
      <scope name="PStore" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(file, thread_safe = false)" attributes="__classmethod__ __ctor__" doc="To construct a PStore object, pass in the _file_ path where you would like the data to be stored. &#xA; PStore objects are always reentrant. But if _thread_safe_ is set to true, then it will become thread-safe at the cost of a minor performance hit." />
        <scope name="abort" ilk="function" signature="abort()" doc="Ends the current PStore#transaction, discarding any changes to the data store. &#xA; Example: &#xA;  require &quot;pstore&quot;&#xA;&#xA; store = PStore.new(&quot;data_file.pstore&quot;)&#xA; store.transaction do  # begin transaction&#xA;   store[:one] = 1     # this change is not applied, see below...&#xA;   store[:two] = 2     # this change is not applied, see below...&#xA;&#xA;   store.abort         # end transaction here, discard all changes&#xA;&#xA;   store[:three] = 3   # this change is never reached&#xA; end&#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="commit" ilk="function" signature="commit()" doc="Ends the current PStore#transaction, committing any changes to the data store immediately. &#xA; Example: &#xA;  require &quot;pstore&quot;&#xA;&#xA; store = PStore.new(&quot;data_file.pstore&quot;)&#xA; store.transaction do  # begin transaction&#xA;   # load some data into the store...&#xA;   store[:one] = 1&#xA;   store[:two] = 2&#xA;&#xA;   store.commit        # end transaction here, committing changes&#xA;&#xA;   store[:three] = 3   # this change is never reached&#xA; end&#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="delete" ilk="function" signature="delete(name)" doc="Removes an object hierarchy from the data store, by _name_. &#xA; *WARNING*:  This method is only valid in a PStore#transaction and it cannot be read-only.  It will raise PStore::Error if called at any other time." />
        <scope name="fetch" ilk="function" signature="fetch(name, default=PStore::Error)" doc="This method is just like PStore#[], save that you may also provide a _default_ value for the object.  In the event the specified _name_ is not found in the data store, your _default_ will be returned instead.  If you do not specify a default, PStore::Error will be raised if the object is not found. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="path" ilk="function" signature="path()" doc="Returns the path to the data store file." />
        <scope name="root?" ilk="function" signature="root?(name)" doc="Returns true if the supplied _name_ is currently in the data store. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="roots" ilk="function" signature="roots()" doc="Returns the names of all object hierarchies currently in the store. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="transaction" ilk="function" signature="transaction(read_only = false)" doc="Opens a new transaction for the data store.  Code executed inside a block passed to this method may read and write data to and from the data store file. &#xA; At the end of the block, changes are committed to the data store automatically.  You may exit the transaction early with a call to either PStore#commit or PStore#abort.  See those methods for details about how changes are handled.  Raising an uncaught Exception in the block is equivalent to calling PStore#abort. &#xA; If _read_only_ is set to +true+, you will only be allowed to read from the data store during the transaction and any attempts to change the data will raise a PStore::Error. &#xA; Note that PStore does not support nested transactions." />
        <scope ilk="function" name="ultra_safe" />
        <scope ilk="function" name="ultra_safe=" />
        <variable name="RDWR_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="RD_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="WR_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_STRING" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_MARSHAL_DATA" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_MARSHAL_CHECKSUM" attributes="__const__" citdl="Object" />
        <scope name="DummyMutex" ilk="class" classrefs="Object">
          <scope name="synchronize" ilk="function" signature="synchronize()" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="pty" ilk="blob" lang="Ruby">
      <scope name="PTY" ilk="namespace">
        <scope name="check" ilk="function" signature="check(...)" attributes="__classmethod__" doc="checks the status of the child process specified by _pid_, and returns +nil+ if the process is still alive and active.  Otherwise, returns +Process::Status+ about the process if _raise_ is false, or +PTY::ChildExited+ exception is raised." />
        <scope name="getpty" ilk="function" signature="getpty(...)" attributes="__classmethod__" doc="spawns the specified command on a newly allocated pty. &#xA; The command&apos;s controlling tty is set to the slave device of the pty. Also its standard input/output/error is redirected to the slave device. &#xA; PTY.spawn returns two IO objects and PID. PID is the process ID of the command. The two IO objects are connected to the master device of the pty. The first IO object is opened as read mode and The second is opened as write mode. &#xA; If a block is given, two IO objects and PID is yielded." />
        <scope name="open" ilk="function" signature="open()" attributes="__classmethod__" doc="Allocates a pty (pseudo-terminal). &#xA; It returns an array which contains an IO object and a File object. The former is the master of the pty. The latter is the slave of the pty. &#xA; If a block is given, it yields the array instead of return. The value of the block is returned. master_io and slave_file is closed when return if they are not closed. &#xA; The path name of the terminal device can be gotten by slave_file.path. &#xA;   PTY.open {|m, s|&#xA;    p m      =&gt; #&lt;IO:masterpty:/dev/pts/1&gt;&#xA;    p s      =&gt; #&lt;File:/dev/pts/1&gt;&#xA;    p s.path =&gt; &quot;/dev/pts/1&quot;&#xA;  }&#xA;  # Change the buffering type in factor command,&#xA;  # assuming that factor uses stdio for stdout buffering.&#xA;  # If IO.pipe is used instead of PTY.open,&#xA;  # this code deadlocks because factor&apos;s stdout is fully buffered." />
        <scope name="spawn" ilk="function" signature="spawn(...)" attributes="__classmethod__" doc="spawns the specified command on a newly allocated pty. &#xA; The command&apos;s controlling tty is set to the slave device of the pty. Also its standard input/output/error is redirected to the slave device. &#xA; PTY.spawn returns two IO objects and PID. PID is the process ID of the command. The two IO objects are connected to the master device of the pty. The first IO object is opened as read mode and The second is opened as write mode. &#xA; If a block is given, two IO objects and PID is yielded." />
        <scope name="ChildExited" ilk="class" classrefs="RuntimeError">
        </scope>
      </scope>
    </scope>
    <scope name="racc/parser" ilk="blob" lang="Ruby">
      <scope name="Racc" ilk="namespace">
        <scope name="ParseError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="racc_runtime_type" ilk="function" signature="racc_runtime_type()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="DOT_DOC_FILENAME" attributes="__const__" citdl="Object" />
        <variable name="GENERAL_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="CLASS_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="ATTR_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="CONSTANT_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="METHOD_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="KNOWN_CLASSES" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="rdoc/alias" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Alias" ilk="class" classrefs="RDoc::CodeObject">
          <scope name="new" ilk="function" signature="new(text, old_name, new_name, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new Alias with a token stream of +text+ that aliases +old_name+ to +new_name+ and has +comment+" />
          <scope ilk="function" name="comment=" />
          <scope ilk="function" name="new_name" />
          <scope ilk="function" name="new_name=" />
          <scope ilk="function" name="old_name" />
          <scope ilk="function" name="old_name=" />
          <scope ilk="function" name="text" />
          <scope ilk="function" name="text=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/anon_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="AnonClass" ilk="class" classrefs="RDoc::ClassModule">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/attr" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Attr" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new(text, name, rw, comment)" attributes="__classmethod__ __ctor__" />
          <scope name="arglists" ilk="function" signature="arglists()" doc="Returns nil, for duck typing with RDoc::AnyMethod" />
          <scope name="block_params" ilk="function" signature="block_params()" doc="Returns nil, for duck typing with RDoc::AnyMethod" />
          <scope name="call_seq" ilk="function" signature="call_seq()" doc="Returns nil, for duck typing with RDoc::AnyMethod" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Partially bogus as Attr has no parent.  For duck typing with RDoc::AnyMethod." />
          <scope name="html_name" ilk="function" signature="html_name()" doc="An HTML id-friendly representation of #name" />
          <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Dumps this Attr for use by ri.  See also #marshal_load" />
          <scope name="marshal_load" ilk="function" signature="marshal_load(array)" doc="Loads this AnyMethod from +array+.  For a loaded AnyMethod the following methods will return cached values: &#xA; #full_name&#xA;#parent_name" />
          <scope name="params" ilk="function" signature="params()" doc="For duck typing with RDoc::AnyMethod, returns nil" />
          <scope name="parent_name" ilk="function" signature="parent_name()" doc="Name of our parent with special handling for un-marshaled methods" />
          <scope name="path" ilk="function" signature="path()" doc="URL path for this attribute" />
          <scope name="singleton" ilk="function" signature="singleton()" doc="For duck typing with RDoc::AnyMethod" />
          <scope name="type" ilk="function" signature="type()" doc="Returns attr_reader, attr_writer or attr_accessor as appropriate" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="rw" />
          <scope ilk="function" name="rw=" />
          <scope ilk="function" name="text" />
          <scope ilk="function" name="text=" />
          <scope ilk="function" name="visibility" />
          <scope ilk="function" name="visibility=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/constant" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Constant" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new(name, value, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new constant with +name+, +value+ and +comment+" />
          <scope name="path" ilk="function" signature="path()" doc="Path to this constant" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="value" />
          <scope ilk="function" name="value=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/context" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Context" ilk="namespace">
          <scope name="Section" ilk="class" classrefs="Object">
            <import symbol="RDoc::Generator::Markup" />
            <scope name="new" ilk="function" signature="new(parent, title, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new section with +title+ and +comment+" />
            <scope name="set_comment" ilk="function" signature="set_comment(comment)" doc="Set the comment for this section from the original comment block If the first line contains :section:, strip it and use the rest. Otherwise remove lines up to the line containing :section:, and look for those lines again at the end and remove them. This lets us write &#xA;   # blah blah blah&#xA;  #&#xA;  # :SECTION: The title&#xA;  # The body" />
            <scope ilk="function" name="comment" />
            <scope ilk="function" name="parent" />
            <scope ilk="function" name="sequence" />
            <scope ilk="function" name="title" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/darkfish" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="Darkfish" ilk="class" classrefs="Object">
            <import symbol="ERB::Util" />
            <scope name="for" ilk="function" signature="for( options )" attributes="__classmethod__" doc="Standard generator factory method" />
            <scope name="new" ilk="function" signature="new( options )" attributes="__classmethod__ __ctor__" doc="Initialize a few instance variables before we start" />
            <scope name="class_dir" ilk="function" signature="class_dir()" />
            <scope name="debug_msg" ilk="function" signature="debug_msg( *msg )" doc="Output progress information if debugging is enabled" />
            <scope name="file_dir" ilk="function" signature="file_dir()" />
            <scope name="gen_sub_directories" ilk="function" signature="gen_sub_directories()" doc="Create the directories the generated docs will live in if they don&apos;t already exist." />
            <scope name="generate" ilk="function" signature="generate( top_levels )" doc="Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information." />
            <scope name="write_style_sheet" ilk="function" signature="write_style_sheet()" doc="Copy over the stylesheet into the appropriate place in the output directory." />
            <scope ilk="function" name="outputdir" />
            <variable name="GENERATOR_DIR" attributes="__const__" citdl="Object" />
            <variable name="VERSION" attributes="__const__" citdl="Object" />
            <variable name="CLASS_DIR" attributes="__const__" citdl="Object" />
            <variable name="FILE_DIR" attributes="__const__" citdl="Object" />
            <variable name="SVNID_PATTERN" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/markup" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="Markup" ilk="namespace">
            <scope name="aref_to" ilk="function" signature="aref_to(target_path)" doc="Generates a relative URL from this object&apos;s path to +target_path+" />
            <scope name="as_href" ilk="function" signature="as_href(from_path)" doc="Generates a relative URL from +from_path+ to this object&apos;s path" />
            <scope name="cvs_url" ilk="function" signature="cvs_url(url, full_path)" doc="Build a webcvs URL starting for the given +url+ with +full_path+ appended as the destination path.  If +url+ contains &apos;%s&apos; +full_path+ will be sprintf&apos;d into +url+ instead." />
            <scope name="description" ilk="function" signature="description()" doc="Handy wrapper for marking up this object&apos;s comment" />
            <scope name="formatter" ilk="function" signature="formatter()" doc="Creates an RDoc::Markup::ToHtmlCrossref formatter" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/ri" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="RI" ilk="class" classrefs="Object">
            <scope name="for" ilk="function" signature="for(options)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(options)" attributes="__classmethod__ __ctor__" doc="Set up a new ri generator" />
            <scope name="generate" ilk="function" signature="generate(top_levels)" doc="Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information." />
            <scope name="install_siginfo_handler" ilk="function" signature="install_siginfo_handler()" doc="Installs a siginfo handler that prints the current filename." />
            <scope name="remove_siginfo_handler" ilk="function" signature="remove_siginfo_handler()" doc="Removes a siginfo handler and replaces the previous" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ghost_method" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="GhostMethod" ilk="class" classrefs="RDoc::AnyMethod">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/include" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Include" ilk="class" classrefs="RDoc::CodeObject">
          <scope name="new" ilk="function" signature="new(name, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new Include for +name+ with +comment+" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Full name based on #module" />
          <scope name="module" ilk="function" signature="module()" doc="Attempts to locate the included module object.  Returns the name if not known." />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Take a block of text and use various heuristics to determine it&apos;s structure (paragraphs, lists, and so on).  Invoke an event handler as we identify significant chunks." />
          <scope name="add_html" ilk="function" signature="add_html(tag, name)" doc="Add to the sequences recognized as general markup." />
          <scope name="add_special" ilk="function" signature="add_special(pattern, name)" doc="Add to other inline sequences.  For example, we could add WikiWords using something like: &#xA;    parser.add_special(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)&#xA; Each wiki word will be presented to the output formatter via the accept_special method." />
          <scope name="add_word_pair" ilk="function" signature="add_word_pair(start, stop, name)" doc="Add to the sequences used to add formatting to an individual word (such as *bold*).  Matching entries will generate attributes that the output formatters can recognize by their +name+." />
          <scope name="convert" ilk="function" signature="convert(text, formatter)" doc="We take +text+, parse it then invoke the output +formatter+ using a Visitor to render the result." />
          <scope ilk="function" name="attribute_manager" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/attribute_manager" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="AttributeManager" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new attribute manager that understands bold, emphasized and teletype text." />
            <scope name="add_html" ilk="function" signature="add_html(tag, name)" doc="Adds a markup class with +name+ for words surrounded by HTML tag +tag+. To process emphasis tags: &#xA;   am.add_html &apos;em&apos;, :EM" />
            <scope name="add_special" ilk="function" signature="add_special(pattern, name)" doc="Adds a special handler for +pattern+ with +name+.  A simple URL handler would be: &#xA;   @am.add_special(/((https?:)\S+\w)/, :HYPERLINK)" />
            <scope name="add_word_pair" ilk="function" signature="add_word_pair(start, stop, name)" doc="Adds a markup class with +name+ for words wrapped in the +start+ and +stop+ character.  To make words wrapped with &quot;*&quot; bold: &#xA;   am.add_word_pair &apos;*&apos;, &apos;*&apos;, :BOLD" />
            <scope name="attribute" ilk="function" signature="attribute(turn_on, turn_off)" doc="Return an attribute object with the given turn_on and turn_off bits set" />
            <scope name="change_attribute" ilk="function" signature="change_attribute(current, new)" />
            <scope name="changed_attribute_by_name" ilk="function" signature="changed_attribute_by_name(current_set, new_set)" />
            <scope name="convert_attrs" ilk="function" signature="convert_attrs(str, attrs)" doc="Map attributes like &lt;b&gt;text&lt;/b&gt;to the sequence \001\002&lt;char&gt;\001\003&lt;char&gt;, where &lt;char&gt; is a per-attribute specific character" />
            <scope name="convert_html" ilk="function" signature="convert_html(str, attrs)" doc="Converts HTML tags to RDoc attributes" />
            <scope name="convert_specials" ilk="function" signature="convert_specials(str, attrs)" doc="Converts special sequences to RDoc attributes" />
            <scope name="copy_string" ilk="function" signature="copy_string(start_pos, end_pos)" />
            <scope name="display_attributes" ilk="function" signature="display_attributes()" doc="Debug method that prints a string along with its attributes" />
            <scope name="flow" ilk="function" signature="flow(str)" doc="Processes +str+ converting attributes, HTML and specials" />
            <scope name="mask_protected_sequences" ilk="function" signature="mask_protected_sequences()" doc="Escapes special sequences of text to prevent conversion to RDoc" />
            <scope name="split_into_flow" ilk="function" signature="split_into_flow()" />
            <scope name="unmask_protected_sequences" ilk="function" signature="unmask_protected_sequences()" doc="Unescapes special sequences of text" />
            <scope ilk="function" name="html_tags" />
            <scope ilk="function" name="matching_word_pairs" />
            <scope ilk="function" name="protectable" />
            <scope ilk="function" name="special" />
            <scope ilk="function" name="word_pair_map" />
            <variable name="NULL" attributes="__const__" citdl="Object" />
            <variable name="PROTECT_ATTR" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/blank_line" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="BlankLine" ilk="class" classrefs="Object">
            <scope name="accept" ilk="function" signature="accept(visitor)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/document" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Document" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*parts)" attributes="__classmethod__ __ctor__" doc="Creates a new Document with +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" />
            <scope name="empty?" ilk="function" signature="empty?()" />
            <scope name="push" ilk="function" signature="push(*parts)" doc="Appends +parts+ to the document" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/heading" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Heading" ilk="class" classrefs="Struct.new :level, :text">
            <scope name="accept" ilk="function" signature="accept(visitor)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/inline" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="AttrChanger" ilk="class" classrefs="Object">
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="AttrSpan" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(length)" attributes="__classmethod__ __ctor__" doc="Creates a new AttrSpan for +length+ characters" />
            <scope name="set_attrs" ilk="function" signature="set_attrs(start, length, bits)" doc="Toggles +bits+ from +start+ to +length+" />
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Attribute" ilk="class" classrefs="Object">
            <scope name="as_string" ilk="function" signature="as_string(bitmap)" attributes="__classmethod__" />
            <scope name="bitmap_for" ilk="function" signature="bitmap_for(name)" attributes="__classmethod__" />
            <scope name="each_name_of" ilk="function" signature="each_name_of(bitmap)" attributes="__classmethod__" />
            <variable name="SPECIAL" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Special" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(type, text)" attributes="__classmethod__ __ctor__" doc="Creates a new special sequence of +type+ with +text+" />
            <scope ilk="function" name="text" />
            <scope ilk="function" name="text=" />
            <scope ilk="function" name="type" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/list" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="List" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(type = nil, *items)" attributes="__classmethod__ __ctor__" doc="Creates a new list of +type+ with +items+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Is the list empty?" />
            <scope name="last" ilk="function" signature="last()" doc="Returns the last item in the list" />
            <scope name="push" ilk="function" signature="push(*items)" doc="Appends +items+ to the list" />
            <scope ilk="function" name="items" />
            <scope ilk="function" name="type" />
            <scope ilk="function" name="type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/list_item" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ListItem" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(label = nil, *parts)" attributes="__classmethod__ __ctor__" doc="Creates a new ListItem with an optional +label+ containing +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Is the ListItem empty?" />
            <scope name="length" ilk="function" signature="length()" doc="Length of parts in the ListItem" />
            <scope name="push" ilk="function" signature="push(*parts)" doc="Adds +parts+ to the ListItem" />
            <scope ilk="function" name="label" />
            <scope ilk="function" name="label=" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/paragraph" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Paragraph" ilk="class" classrefs="RDoc::Markup::Raw">
            <scope name="accept" ilk="function" signature="accept(visitor)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/parser" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Parser" ilk="namespace">
            <scope name="ParseError" ilk="class" classrefs="Error">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/pre_process" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="PreProcess" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(input_file_name, include_path)" attributes="__classmethod__ __ctor__" doc="Creates a new pre-processor for +input_file_name+ that will look for included files in +include_path+" />
            <scope name="register" ilk="function" signature="register(directive, &amp;block)" attributes="__classmethod__" doc="Registers +directive+ as one handled by RDoc.  If a block is given the directive will be replaced by the result of the block, otherwise the directive will be removed from the processed text." />
            <scope name="registered" ilk="function" signature="registered()" attributes="__classmethod__" doc="Registered directives" />
            <scope name="find_include_file" ilk="function" signature="find_include_file(name)" doc="Look for the given file in the directory containing the current file, and then in each of the directories specified in the RDOC_INCLUDE path" />
            <scope name="handle" ilk="function" signature="handle(text, code_object = nil)" doc="Look for directives in a chunk of +text+. &#xA; Options that we don&apos;t handle are yielded.  If the block returns false the directive is restored to the text.  If the block returns nil or no block was given the directive is handled according to the registered directives. If a String was returned the directive is replaced with the string. &#xA; If no matching directive was registered the directive is restored to the text. &#xA; If +code_object+ is given and the param is set as metadata on the +code_object+.  See RDoc::CodeObject#metadata" />
            <scope name="include_file" ilk="function" signature="include_file(name, indent)" doc="Include a file, indenting it correctly." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/rule" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Rule" ilk="class" classrefs="Struct.new :weight">
            <scope name="accept" ilk="function" signature="accept(visitor)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/text_formatter_test_case" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="FormatterTestCase" ilk="class" classrefs="MiniTest::Unit::TestCase">
            <scope name="add_visitor_tests" ilk="function" signature="add_visitor_tests()" attributes="__classmethod__" />
            <scope name="setup" ilk="function" signature="setup()" />
            <scope name="test_accept_blank_line" ilk="function" signature="test_accept_blank_line()" />
            <scope name="test_accept_heading" ilk="function" signature="test_accept_heading()" />
            <scope name="test_accept_list_end_bullet" ilk="function" signature="test_accept_list_end_bullet()" />
            <scope name="test_accept_list_end_label" ilk="function" signature="test_accept_list_end_label()" />
            <scope name="test_accept_list_end_lalpha" ilk="function" signature="test_accept_list_end_lalpha()" />
            <scope name="test_accept_list_end_note" ilk="function" signature="test_accept_list_end_note()" />
            <scope name="test_accept_list_end_number" ilk="function" signature="test_accept_list_end_number()" />
            <scope name="test_accept_list_end_ualpha" ilk="function" signature="test_accept_list_end_ualpha()" />
            <scope name="test_accept_list_item_end_bullet" ilk="function" signature="test_accept_list_item_end_bullet()" />
            <scope name="test_accept_list_item_end_label" ilk="function" signature="test_accept_list_item_end_label()" />
            <scope name="test_accept_list_item_end_lalpha" ilk="function" signature="test_accept_list_item_end_lalpha()" />
            <scope name="test_accept_list_item_end_note" ilk="function" signature="test_accept_list_item_end_note()" />
            <scope name="test_accept_list_item_end_number" ilk="function" signature="test_accept_list_item_end_number()" />
            <scope name="test_accept_list_item_end_ualpha" ilk="function" signature="test_accept_list_item_end_ualpha()" />
            <scope name="test_accept_list_item_start_bullet" ilk="function" signature="test_accept_list_item_start_bullet()" />
            <scope name="test_accept_list_item_start_label" ilk="function" signature="test_accept_list_item_start_label()" />
            <scope name="test_accept_list_item_start_lalpha" ilk="function" signature="test_accept_list_item_start_lalpha()" />
            <scope name="test_accept_list_item_start_note" ilk="function" signature="test_accept_list_item_start_note()" />
            <scope name="test_accept_list_item_start_number" ilk="function" signature="test_accept_list_item_start_number()" />
            <scope name="test_accept_list_item_start_ualpha" ilk="function" signature="test_accept_list_item_start_ualpha()" />
            <scope name="test_accept_list_start_bullet" ilk="function" signature="test_accept_list_start_bullet()" />
            <scope name="test_accept_list_start_label" ilk="function" signature="test_accept_list_start_label()" />
            <scope name="test_accept_list_start_lalpha" ilk="function" signature="test_accept_list_start_lalpha()" />
            <scope name="test_accept_list_start_note" ilk="function" signature="test_accept_list_start_note()" />
            <scope name="test_accept_list_start_number" ilk="function" signature="test_accept_list_start_number()" />
            <scope name="test_accept_list_start_ualpha" ilk="function" signature="test_accept_list_start_ualpha()" />
            <scope name="test_accept_paragraph" ilk="function" signature="test_accept_paragraph()" />
            <scope name="test_accept_raw" ilk="function" signature="test_accept_raw()" />
            <scope name="test_accept_rule" ilk="function" signature="test_accept_rule()" />
            <scope name="test_accept_verbatim" ilk="function" signature="test_accept_verbatim()" />
            <scope name="test_end_accepting" ilk="function" signature="test_end_accepting()" />
            <scope name="test_start_accepting" ilk="function" signature="test_start_accepting()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_ansi" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToAnsi" ilk="class" classrefs="RDoc::Markup::ToRdoc">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to ANSI sequences" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_bs" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToBs" ilk="class" classrefs="RDoc::Markup::ToRdoc">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" />
            <scope name="annotate" ilk="function" signature="annotate(tag)" doc="Turns on or off special handling for +convert_string+" />
            <scope name="convert_special" ilk="function" signature="convert_special(special)" doc="Calls convert_string on the result of convert_special" />
            <scope name="convert_string" ilk="function" signature="convert_string(string)" doc="Adds bold or underline mixed with backspaces" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Sets a flag that is picked up by #annotate to do the right thing in #convert_string" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_html" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToHtml" ilk="class" classrefs="RDoc::Markup::Formatter">
            <scope name="gen_relative_url" ilk="function" signature="gen_relative_url(path, target)" attributes="__classmethod__" doc="Converts a target url to one that is relative to a given path" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(blank_line)" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" />
            <scope name="accept_raw" ilk="function" signature="accept_raw(raw)" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(rule)" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(verbatim)" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" />
            <scope name="gen_url" ilk="function" signature="gen_url(url, text)" doc="Generate a hyperlink for url, labeled with text. Handle the special cases for img: and link: described under handle_special_HYPERLINK" />
            <scope name="handle_special_HYPERLINK" ilk="function" signature="handle_special_HYPERLINK(special)" doc="And we&apos;re invoked with a potential external hyperlink mailto: just gets inserted. http: links are checked to see if they reference an image. If so, that image gets inserted using an &lt;img&gt; tag. Otherwise a conventional &lt;a href&gt; is used.  We also support a special type of hyperlink, link:, which is a reference to a local file whose path is relative to the --op directory." />
            <scope name="handle_special_TIDYLINK" ilk="function" signature="handle_special_TIDYLINK(special)" doc="Here&apos;s a hypedlink where the label is different to the URL  &lt;label&gt;[url] or {long label}[url]" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to HTML tags" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" />
            <scope name="wrap" ilk="function" signature="wrap(txt, line_len = 76)" doc="This is a higher speed (if messier) version of wrap" />
            <variable name="LIST_TYPE_TO_HTML" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_html_crossref" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToHtmlCrossref" ilk="class" classrefs="RDoc::Markup::ToHtml">
            <scope name="new" ilk="function" signature="new(from_path, context, show_hash)" attributes="__classmethod__ __ctor__" doc="Creates a new crossref resolver that generates links relative to +context+ which lives at +from_path+ in the generated files.  &apos;#&apos; characters on references are removed unless +show_hash+ is true." />
            <scope name="handle_special_CROSSREF" ilk="function" signature="handle_special_CROSSREF(special)" doc="We&apos;re invoked when any text matches the CROSSREF pattern.  If we find the corresponding reference, generate a hyperlink.  If the name we&apos;re looking for contains no punctuation, we look for it up the module/class chain. prefix, because we look for it in module Generator first." />
            <scope ilk="function" name="context" />
            <scope ilk="function" name="context=" />
            <variable name="CLASS_REGEXP_STR" attributes="__const__" citdl="Object" />
            <variable name="METHOD_REGEXP_STR" attributes="__const__" citdl="Object" />
            <variable name="CROSSREF_REGEXP" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_rdoc" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToRdoc" ilk="class" classrefs="RDoc::Markup::Formatter">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(blank_line)" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" />
            <scope name="accept_raw" ilk="function" signature="accept_raw(raw)" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(rule)" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(verbatim)" doc="Outputs +verbatim+ flush left and indented 2 columns" />
            <scope name="attributes" ilk="function" signature="attributes(text)" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" />
            <scope name="handle_special_SUPPRESSED_CROSSREF" ilk="function" signature="handle_special_SUPPRESSED_CROSSREF(special)" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to ANSI sequences" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" />
            <scope name="use_prefix" ilk="function" signature="use_prefix()" />
            <scope name="wrap" ilk="function" signature="wrap(text)" />
            <scope ilk="function" name="indent" />
            <scope ilk="function" name="indent=" />
            <scope ilk="function" name="list_index" />
            <scope ilk="function" name="list_type" />
            <scope ilk="function" name="list_width" />
            <scope ilk="function" name="prefix" />
            <scope ilk="function" name="res" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_test" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToTest" ilk="class" classrefs="RDoc::Markup::Formatter">
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(blank_line)" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(rule)" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(verbatim)" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_tt_only" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Formatter" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new Formatter" />
            <scope name="add_tag" ilk="function" signature="add_tag(name, start, stop)" doc="Add a new set of tags for an attribute. We allow separate start and end tags for flexibility" />
            <scope name="annotate" ilk="function" signature="annotate(tag)" doc="Allows +tag+ to be decorated with additional information." />
            <scope name="convert" ilk="function" signature="convert(content)" doc="Marks up +content+" />
            <scope name="convert_flow" ilk="function" signature="convert_flow(flow)" doc="Converts flow items +flow+" />
            <scope name="convert_special" ilk="function" signature="convert_special(special)" doc="Converts added specials.  See RDoc::Markup#add_special" />
            <scope name="convert_string" ilk="function" signature="convert_string(string)" doc="Converts a string to be fancier if desired" />
            <scope name="in_tt?" ilk="function" signature="in_tt?()" doc="Are we currently inside tt tags?" />
            <scope name="off_tags" ilk="function" signature="off_tags(res, item)" />
            <scope name="on_tags" ilk="function" signature="on_tags(res, item)" />
            <scope name="tt?" ilk="function" signature="tt?(tag)" doc="Is +tag+ a tt tag?" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/verbatim" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Raw" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*parts)" attributes="__classmethod__ __ctor__" doc="Creates a new Raw containing +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" />
            <scope name="merge" ilk="function" signature="merge(other)" doc="Appends +other+&apos;s parts" />
            <scope name="push" ilk="function" signature="push(*texts)" doc="Appends +texts+ onto this Paragraph" />
            <scope name="text" ilk="function" signature="text()" doc="The raw text" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Verbatim" ilk="class" classrefs="RDoc::Markup::Raw">
            <scope name="accept" ilk="function" signature="accept(visitor)" />
            <scope name="normalize" ilk="function" signature="normalize()" doc="Collapses 3+ newlines into two newlines" />
            <scope name="text" ilk="function" signature="text()" doc="The text of the section" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/meta_method" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="AnyMethod" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="Comparable" />
          <import symbol="RDoc::Generator::Markup" />
          <import symbol="RDoc::TokenStream" />
          <scope name="new" ilk="function" signature="new(text, name)" attributes="__classmethod__ __ctor__" />
          <scope name="add_alias" ilk="function" signature="add_alias(method)" doc="Adds +method+ as an alias for this method" />
          <scope name="add_line_numbers" ilk="function" signature="add_line_numbers(src)" doc="Prepend +src+ with line numbers.  Relies on the first line of a source code listing having: &#xA;    # File xxxxx, line dddd" />
          <scope name="aref" ilk="function" signature="aref()" doc="HTML fragment reference for this method" />
          <scope name="arglists" ilk="function" signature="arglists()" doc="The call_seq or the param_seq with method name, if there is no call_seq. &#xA; Use this for displaying a method&apos;s argument lists." />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Full method name including namespace" />
          <scope name="html_name" ilk="function" signature="html_name()" doc="HTML id-friendly method name" />
          <scope name="markup_code" ilk="function" signature="markup_code()" doc="Turns the method&apos;s token stream into HTML" />
          <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Dumps this AnyMethod for use by ri.  See also #marshal_load" />
          <scope name="marshal_load" ilk="function" signature="marshal_load(array)" doc="Loads this AnyMethod from +array+.  For a loaded AnyMethod the following methods will return cached values: &#xA; #full_name&#xA;#parent_name" />
          <scope name="name" ilk="function" doc="Method name" />
          <scope name="param_seq" ilk="function" signature="param_seq()" doc="Pretty parameter list for this method" />
          <scope name="parent_name" ilk="function" signature="parent_name()" doc="Name of our parent with special handling for un-marshaled methods" />
          <scope name="path" ilk="function" signature="path()" doc="Path to this method" />
          <scope name="pretty_name" ilk="function" signature="pretty_name()" doc="Method name with class/instance indicator" />
          <scope name="type" ilk="function" signature="type()" doc="Type of method (class or instance)" />
          <scope ilk="function" name="aliases" />
          <scope ilk="function" name="block_params" />
          <scope ilk="function" name="block_params=" />
          <scope ilk="function" name="call_seq" />
          <scope ilk="function" name="call_seq=" />
          <scope ilk="function" name="dont_rename_initialize" />
          <scope ilk="function" name="dont_rename_initialize=" />
          <scope ilk="function" name="is_alias_for" />
          <scope ilk="function" name="is_alias_for=" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="params" />
          <scope ilk="function" name="params=" />
          <scope ilk="function" name="singleton" />
          <scope ilk="function" name="singleton=" />
          <scope ilk="function" name="text" />
          <scope ilk="function" name="visibility" />
          <scope ilk="function" name="visibility=" />
        </scope>
        <scope name="MetaMethod" ilk="class" classrefs="RDoc::AnyMethod">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/normal_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="NormalClass" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="ancestors" ilk="function" signature="ancestors()" doc="Ancestor ClassModules" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/normal_module" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="NormalModule" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="module?" ilk="function" signature="module?()" doc="This is a module, returns true" />
          <scope name="superclass" ilk="function" signature="superclass()" doc="Modules don&apos;t have one, raises NoMethodError" />
        </scope>
        <scope name="Stats" ilk="namespace">
          <scope name="Normal" ilk="class" classrefs="Quiet">
            <scope name="print_file" ilk="function" signature="print_file(files_so_far, filename)" doc="Prints a file with a progress bar" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/options" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Options" ilk="class" classrefs="Object">
          <scope name="parse" ilk="function" signature="parse(argv)" doc="Parse command line options." />
          <scope name="quiet" ilk="function" signature="quiet()" doc="Don&apos;t display progress as we process the files" />
          <scope name="quiet=" ilk="function" signature="quiet=(bool)" />
          <scope name="title=" ilk="function" signature="title=(string)" doc="Set the title, but only if not already set. This means that a title set from the command line trumps one set in a source file" />
          <scope ilk="function" name="charset" />
          <scope ilk="function" name="exclude" />
          <scope ilk="function" name="exclude=" />
          <scope ilk="function" name="files" />
          <scope ilk="function" name="files=" />
          <scope ilk="function" name="force_update" />
          <scope ilk="function" name="formatter" />
          <scope ilk="function" name="formatter=" />
          <scope ilk="function" name="generator" />
          <scope ilk="function" name="generator=" />
          <scope ilk="function" name="main_page" />
          <scope ilk="function" name="main_page=" />
          <scope ilk="function" name="op_dir" />
          <scope ilk="function" name="op_dir=" />
          <scope ilk="function" name="pipe" />
          <scope ilk="function" name="pipe=" />
          <scope ilk="function" name="rdoc_include" />
          <scope ilk="function" name="show_all" />
          <scope ilk="function" name="show_all=" />
          <scope ilk="function" name="show_hash" />
          <scope ilk="function" name="tab_width" />
          <scope ilk="function" name="template" />
          <scope ilk="function" name="title" />
          <scope ilk="function" name="verbosity" />
          <scope ilk="function" name="verbosity=" />
          <scope ilk="function" name="webcvs" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Parser" ilk="class" classrefs="Object">
            <import symbol="RDoc::Text" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new Parser.  See also ::parse" />
            <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" doc="Parsers +str+ into a Document" />
            <scope name="tokenize" ilk="function" signature="tokenize(str)" attributes="__classmethod__" doc="Returns a token stream for +str+, for testing" />
            <scope name="build_heading" ilk="function" signature="build_heading(level)" doc="Builds a Heading of +level+" />
            <scope name="build_list" ilk="function" signature="build_list(margin)" doc="Builds a List flush to +margin+" />
            <scope name="build_list_item" ilk="function" signature="build_list_item(indent, item_type = nil)" doc="Builds a ListItem that is flush to +indent+ with type +item_type+" />
            <scope name="build_paragraph" ilk="function" signature="build_paragraph(margin)" doc="Builds a Paragraph that is flush to +margin+" />
            <scope name="build_verbatim" ilk="function" signature="build_verbatim(margin)" doc="Builds a Verbatim that is flush to +margin+" />
            <scope name="get" ilk="function" signature="get()" doc="Pulls the next token from the stream." />
            <scope name="parse" ilk="function" signature="parse(indent = 0)" doc="Parses the tokens into a Document" />
            <scope name="peek_token" ilk="function" signature="peek_token()" doc="Returns the next token on the stream without modifying the stream" />
            <scope name="skip" ilk="function" signature="skip(token_type, error = true)" doc="Skips a token of +token_type+, optionally raising an error." />
            <scope name="text" ilk="function" signature="text()" doc="Consumes tokens until NEWLINE and turns them back into text" />
            <scope name="token_pos" ilk="function" signature="token_pos(offset)" doc="Calculates the column and line of the current token based on +offset+." />
            <scope name="tokenize" ilk="function" signature="tokenize(input)" doc="Turns text +input+ into a stream of tokens" />
            <scope name="unget" ilk="function" signature="unget(token = @current_token)" doc="Returns the current token or +token+ to the token stream" />
            <scope ilk="function" name="debug" />
            <scope ilk="function" name="debug=" />
            <scope ilk="function" name="tokens" />
            <variable name="LIST_TOKENS" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="alias_extension" ilk="function" signature="alias_extension(old_ext, new_ext)" attributes="__classmethod__" doc="Alias an extension to another extension. After this call, files ending &quot;new_ext&quot; will be parsed using the same parser as &quot;old_ext&quot;" />
          <scope name="binary?" ilk="function" signature="binary?(file)" attributes="__classmethod__" doc="Determines if the file is a &quot;binary&quot; file which basically means it has content that an RDoc parser shouldn&apos;t try to consume." />
          <scope name="can_parse" ilk="function" signature="can_parse(file_name)" attributes="__classmethod__" doc="Return a parser that can handle a particular extension" />
          <scope name="for" ilk="function" signature="for(top_level, file_name, body, options, stats)" attributes="__classmethod__" doc="Find the correct parser for a particular file name. Return a SimpleParser for ones that we don&apos;t know" />
          <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" />
          <scope name="parse_files_matching" ilk="function" signature="parse_files_matching(regexp)" attributes="__classmethod__" doc="Record which file types this parser can understand. &#xA; It is ok to call this multiple times." />
          <scope name="zip?" ilk="function" signature="zip?(file)" attributes="__classmethod__" doc="Checks if +file+ is a zip file in disguise.  Signatures from http://www.garykessler.net/library/file_sigs.html" />
          <scope ilk="function" name="parsers" />
          <scope name="PerlPOD" ilk="class" classrefs="RDoc::Parser">
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Prepare to parse a perl file" />
            <scope name="filter" ilk="function" signature="filter(comment)" doc="Filter the perl markup that does the same as the rdoc filtering.  Only basic for now. Will probably need a proper parser to cope with C&lt;&lt;...&gt;&gt; etc" />
            <scope name="scan" ilk="function" signature="scan()" doc="Extract the Pod(-like) comments from the code. At its most basic there will ne no need to distinguish between the different types of header, etc. &#xA; This uses a simple finite state machine, in a very procedural pattern. I could &quot;replace case with polymorphism&quot; but I think it would obscure the intent, scatter the code all over tha place.  This machine is necessary because POD requires that directives be preceded by blank lines, so reading line by line is necessary, and preserving state about what is seen is necesary." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/ruby_tools" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="RubyTools" ilk="namespace">
            <import symbol="RDoc::RubyToken" />
            <scope name="add_token_listener" ilk="function" signature="add_token_listener(obj)" doc="Adds a token listener +obj+, but you should probably use token_listener" />
            <scope name="get_tk" ilk="function" signature="get_tk()" doc="Fetches the next token from the scanner" />
            <scope name="get_tk_until" ilk="function" signature="get_tk_until(*tokens)" />
            <scope name="get_tkread" ilk="function" signature="get_tkread()" doc="Retrieves a String representation of the read tokens" />
            <scope name="peek_read" ilk="function" signature="peek_read()" doc="Peek equivalent for get_tkread" />
            <scope name="peek_tk" ilk="function" signature="peek_tk()" doc="Peek at the next token, but don&apos;t remove it from the stream" />
            <scope name="remove_token_listener" ilk="function" signature="remove_token_listener(obj)" doc="Removes the token listener +obj+" />
            <scope name="reset" ilk="function" signature="reset()" doc="Resets the tools" />
            <scope name="skip_tkspace" ilk="function" signature="skip_tkspace(skip_nl = true)" doc="Skips whitespace tokens including newlines if +skip_nl+ is true" />
            <scope name="token_listener" ilk="function" signature="token_listener(obj)" doc="Has +obj+ listen to tokens" />
            <scope name="unget_tk" ilk="function" signature="unget_tk(tk)" doc="Returns +tk+ to the scanner" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/simple" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="Simple" ilk="class" classrefs="RDoc::Parser">
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Prepare to parse a plain file" />
            <scope name="remove_coding_comment" ilk="function" signature="remove_coding_comment(text)" />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(comment)" />
            <scope name="scan" ilk="function" signature="scan()" doc="Extract the file contents and attach them to the TopLevel as a comment" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/require" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="CodeObject" ilk="class" classrefs="Object">
          <import symbol="RDoc::Text" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new CodeObject that will document itself and its children" />
          <scope name="comment=" ilk="function" signature="comment=(comment)" doc="Replaces our comment with +comment+, unless it is empty." />
          <scope name="document_children=" ilk="function" signature="document_children=(document_children)" doc="Enables or disables documentation of this CodeObject&apos;s children.  Calls remove_classes_and_modules when disabling." />
          <scope name="document_self=" ilk="function" signature="document_self=(document_self)" doc="Enables or disables documentation of this CodeObject.  Calls remove_methods_etc when disabling." />
          <scope name="documented?" ilk="function" signature="documented?()" doc="Does this class have a comment with content or is document_self false." />
          <scope name="parent_file_name" ilk="function" signature="parent_file_name()" doc="File name of our parent" />
          <scope name="parent_name" ilk="function" signature="parent_name()" doc="Name of our parent" />
          <scope name="remove_classes_and_modules" ilk="function" signature="remove_classes_and_modules()" doc="Callback called upon disabling documentation of children.  See #document_children=" />
          <scope name="remove_methods_etc" ilk="function" signature="remove_methods_etc()" doc="Callback called upon disabling documentation of ourself.  See #document_self=" />
          <scope name="start_doc" ilk="function" signature="start_doc()" doc="Enable capture of documentation" />
          <scope name="stop_doc" ilk="function" signature="stop_doc()" doc="Disable capture of documentation" />
          <scope ilk="function" name="comment" />
          <scope ilk="function" name="document_children" />
          <scope ilk="function" name="document_self" />
          <scope ilk="function" name="done_documenting" />
          <scope ilk="function" name="done_documenting=" />
          <scope ilk="function" name="force_documentation" />
          <scope ilk="function" name="force_documentation=" />
          <scope ilk="function" name="metadata" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="parent=" />
          <scope ilk="function" name="section" />
          <scope ilk="function" name="section=" />
          <scope ilk="function" name="viewer" />
          <scope ilk="function" name="viewer=" />
        </scope>
        <scope name="Require" ilk="class" classrefs="RDoc::CodeObject">
          <scope name="new" ilk="function" signature="new(name, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new Require that loads +name+ with +comment+" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Error" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Parser" ilk="namespace">
            <scope name="Error" ilk="class" classrefs="RuntimeError">
            </scope>
          </scope>
        </scope>
        <scope name="RI" ilk="namespace">
          <scope name="Error" ilk="class" classrefs="RDoc::Error">
          </scope>
        </scope>
        <scope name="RI" ilk="namespace">
          <scope name="Driver" ilk="namespace">
            <scope name="Error" ilk="class" classrefs="RDoc::RI::Error">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/driver" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Driver" ilk="class" classrefs="Object">
            <scope name="default_options" ilk="function" signature="default_options()" attributes="__classmethod__" doc="Default options for ri" />
            <scope name="dump" ilk="function" signature="dump(data_path)" attributes="__classmethod__" doc="Dump +data_path+ using pp" />
            <scope name="new" ilk="function" signature="new(initial_options = {})" attributes="__classmethod__ __ctor__" doc="Creates a new driver using +initial_options+ from ::process_args" />
            <scope name="process_args" ilk="function" signature="process_args(argv)" attributes="__classmethod__" doc="Parses +argv+ and returns a Hash of options" />
            <scope name="run" ilk="function" signature="run(argv = ARGV)" attributes="__classmethod__" doc="Runs the ri command line executable using +argv+" />
            <scope name="add_also_in" ilk="function" signature="add_also_in(out, also_in)" doc="Adds paths for undocumented classes +also_in+ to +out+" />
            <scope name="add_class" ilk="function" signature="add_class(out, name, classes)" doc="Adds a class header to +out+ for class +name+ which is described in +classes+." />
            <scope name="add_from" ilk="function" signature="add_from(out, store)" doc="Adds &quot;(from ...)&quot; to +out+ for +store+" />
            <scope name="add_includes" ilk="function" signature="add_includes(out, includes)" doc="Adds +includes+ to +out+" />
            <scope name="add_method_list" ilk="function" signature="add_method_list(out, methods, name)" doc="Adds a list of +methods+ to +out+ with a heading of +name+" />
            <scope name="ancestors_of" ilk="function" signature="ancestors_of(klass)" doc="Returns ancestor classes of +klass+" />
            <scope name="classes" ilk="function" signature="classes()" doc="Hash mapping a known class or module to the stores it can be loaded from" />
            <scope name="complete" ilk="function" signature="complete(name)" doc="Completes +name+ based on the caches.  For Readline" />
            <scope name="display" ilk="function" signature="display(document)" doc="Converts +document+ to text and writes it to the pager" />
            <scope name="display_class" ilk="function" signature="display_class(name)" doc="Outputs formatted RI data for class +name+.  Groups undocumented classes" />
            <scope name="display_method" ilk="function" signature="display_method(name)" doc="Outputs formatted RI data for method +name+" />
            <scope name="display_name" ilk="function" signature="display_name(name)" doc="Outputs formatted RI data for the class or method +name+. &#xA; Returns true if +name+ was found, false if it was not an alternative could be guessed, raises an error if +name+ couldn&apos;t be guessed." />
            <scope name="display_names" ilk="function" signature="display_names(names)" doc="Displays each name in +name+" />
            <scope name="expand_class" ilk="function" signature="expand_class(klass)" doc="Expands abbreviated klass +klass+ into a fully-qualified class.  &quot;Zl::Da&quot; will be expanded to Zlib::DataError." />
            <scope name="expand_name" ilk="function" signature="expand_name(name)" doc="Expands the class portion of +name+ into a fully-qualified class.  See #expand_class." />
            <scope name="find_methods" ilk="function" signature="find_methods(name)" doc="Yields items matching +name+ including the store they were found in, the class being searched for, the class they were found in (an ancestor) the types of methods to look up (from #method_type), and the method name being searched for" />
            <scope name="formatter" ilk="function" signature="formatter(io)" doc="Creates a new RDoc::Markup::Formatter.  If a formatter is given with -f, use it.  If we&apos;re outputting to a pager, use bs, otherwise ansi." />
            <scope name="interactive" ilk="function" signature="interactive()" doc="Runs ri interactively using Readline if it is available." />
            <scope name="list_known_classes" ilk="function" signature="list_known_classes()" doc="Lists classes known to ri" />
            <scope name="list_methods_matching" ilk="function" signature="list_methods_matching(name)" doc="Returns an Array of methods matching +name+" />
            <scope name="load_method" ilk="function" signature="load_method(store, cache, klass, type, name)" doc="Loads RI data for method +name+ on +klass+ from +store+.  +type+ and +cache+ indicate if it is a class or instance method." />
            <scope name="load_methods_matching" ilk="function" signature="load_methods_matching(name)" doc="Returns an Array of RI data for methods matching +name+" />
            <scope name="method_type" ilk="function" signature="method_type(selector)" doc="Returns the type of method (:both, :instance, :class) for +selector+" />
            <scope name="page" ilk="function" signature="page()" doc="Paginates output through a pager program." />
            <scope name="paging?" ilk="function" signature="paging?()" doc="Are we using a pager?" />
            <scope name="parse_name" ilk="function" signature="parse_name(name)" doc="Extract the class, selector and method name parts from +name+ like Foo::Bar#baz. &#xA; NOTE: Given Foo::Bar, Bar is considered a class even though it may be a       method" />
            <scope name="run" ilk="function" signature="run()" doc="Looks up and displays ri data according to the options given." />
            <scope name="setup_pager" ilk="function" signature="setup_pager()" doc="Sets up a pager program to pass output through.  Tries the RI_PAGER and PAGER environment variables followed by pager, less then more." />
            <scope ilk="function" name="stores" />
            <scope ilk="function" name="stores=" />
            <scope ilk="function" name="use_stdout" />
            <scope ilk="function" name="use_stdout=" />
            <scope name="NotFoundError" ilk="class" classrefs="Error">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/formatter" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Formatter" ilk="namespace">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/paths" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Paths" ilk="namespace">
            <scope name="each" ilk="function" signature="each(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Iterates over each selected path yielding the directory and type. &#xA; Yielded types: Where Ruby&apos;s ri data is stored.  Yielded when +system+ is true&#xA;Where ri for installed libraries are stored.  Yielded when +site+ is true.  Normally no ri data is stored here.&#xA;~/.ri.  Yielded when +home+ is true.&#xA;ri data for an installed gem.  Yielded when +gems+ is true.&#xA;ri data directory from the command line.  Yielded for each entry in +extra_dirs+" />
            <scope name="gemdirs" ilk="function" signature="gemdirs()" attributes="__classmethod__" doc="The latest installed gems&apos; ri directories" />
            <scope name="path" ilk="function" signature="path(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Returns existing directories from the selected documentation directories as an Array. &#xA; See also ::each" />
            <scope name="raw_path" ilk="function" signature="raw_path(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Returns selected documentation directories including nonexistent directories. &#xA; See also ::each" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/store" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Store" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(path, type = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Store of +type+ that will load or save to +path+" />
            <scope name="ancestors" ilk="function" signature="ancestors()" doc="Ancestors cache accessor.  Maps a klass name to an Array of its ancestors in this store.  If Foo in this store inherits from Object, Kernel won&apos;t be listed (it will be included from ruby&apos;s ri store)." />
            <scope name="attributes" ilk="function" signature="attributes()" doc="Attributes cache accessor.  Maps a class to an Array of its attributes." />
            <scope name="cache_path" ilk="function" signature="cache_path()" doc="Path to the cache file" />
            <scope name="class_file" ilk="function" signature="class_file(klass_name)" doc="Path to the ri data for +klass_name+" />
            <scope name="class_methods" ilk="function" signature="class_methods()" doc="Class methods cache accessor.  Maps a class to an Array of its class methods (not full name)." />
            <scope name="class_path" ilk="function" signature="class_path(klass_name)" doc="Path where data for +klass_name+ will be stored (methods or class data)" />
            <scope name="friendly_path" ilk="function" signature="friendly_path()" doc="Friendly rendition of #path" />
            <scope name="instance_methods" ilk="function" signature="instance_methods()" doc="Instance methods cache accessor.  Maps a class to an Array of its instance methods (not full name)." />
            <scope name="load_cache" ilk="function" signature="load_cache()" doc="Loads cache file for this store" />
            <scope name="load_class" ilk="function" signature="load_class(klass_name)" doc="Loads ri data for +klass_name+" />
            <scope name="load_method" ilk="function" signature="load_method(klass_name, method_name)" doc="Loads ri data for +method_name+ in +klass_name+" />
            <scope name="method_file" ilk="function" signature="method_file(klass_name, method_name)" doc="Path to the ri data for +method_name+ in +klass_name+" />
            <scope name="modules" ilk="function" signature="modules()" doc="Modules cache accessor.  An Array of all the modules (and classes) in the store." />
            <scope name="save_cache" ilk="function" signature="save_cache()" doc="Writes the cache file for this store" />
            <scope name="save_class" ilk="function" signature="save_class(klass)" doc="Writes the ri data for +klass+" />
            <scope name="save_method" ilk="function" signature="save_method(klass, method)" doc="Writes the ri data for +method+ on +klass+" />
            <scope ilk="function" name="cache" />
            <scope ilk="function" name="path" />
            <scope ilk="function" name="path=" />
            <scope ilk="function" name="type" />
            <scope ilk="function" name="type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ruby_lex" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="Ruby" ilk="class" classrefs="RDoc::Parser">
            <import symbol="RDoc::Parser::RubyTools" />
            <import symbol="RDoc::RubyToken" />
            <import symbol="RDoc::TokenStream" />
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" />
            <scope name="collect_first_comment" ilk="function" signature="collect_first_comment()" doc="Look for the first comment in a file that isn&apos;t a shebang line." />
            <scope name="error" ilk="function" signature="error(msg)" />
            <scope name="extract_call_seq" ilk="function" signature="extract_call_seq(comment, meth)" doc="Look for a &apos;call-seq&apos; in the comment, and override the normal parameter stuff" />
            <scope name="get_bool" ilk="function" signature="get_bool()" />
            <scope name="get_class_or_module" ilk="function" signature="get_class_or_module(container)" doc="or&#xA;separated named) and return the ultimate name and container" />
            <scope name="get_class_specification" ilk="function" signature="get_class_specification()" doc="Return a superclass, which can be either a constant of an expression" />
            <scope name="get_constant" ilk="function" signature="get_constant()" doc="Parse a constant, which might be qualified by one or more class or module names" />
            <scope name="get_constant_with_optional_parens" ilk="function" signature="get_constant_with_optional_parens()" doc="Get a constant that may be surrounded by parens" />
            <scope name="get_symbol_or_name" ilk="function" signature="get_symbol_or_name()" />
            <scope name="look_for_directives_in" ilk="function" signature="look_for_directives_in(context, comment)" doc="Look for directives in a normal comment block: &#xA;   # :stopdoc:&#xA;  # Don&apos;t display comment from this point forward&#xA; This routine modifies it&apos;s parameter" />
            <scope name="make_message" ilk="function" signature="make_message(message)" doc="Adds useful info about the parser to +message+" />
            <scope name="parse_alias" ilk="function" signature="parse_alias(context, single, tk, comment)" />
            <scope name="parse_attr" ilk="function" signature="parse_attr(context, single, tk, comment)" doc="Creates an RDoc::Attr for the name following +tk+, setting the comment to +comment+." />
            <scope name="parse_attr_accessor" ilk="function" signature="parse_attr_accessor(context, single, tk, comment)" doc="Creates an RDoc::Attr for each attribute listed after +tk+, setting the comment for each to +comment+." />
            <scope name="parse_call_parameters" ilk="function" signature="parse_call_parameters(tk)" />
            <scope name="parse_class" ilk="function" signature="parse_class(container, single, tk, comment)" />
            <scope name="parse_comment" ilk="function" signature="parse_comment(container, tk, comment)" doc="Generates an RDoc::Method or RDoc::Attr from +comment+ by looking for :method: or :attr: directives in +comment+." />
            <scope name="parse_constant" ilk="function" signature="parse_constant(container, tk, comment)" />
            <scope name="parse_include" ilk="function" signature="parse_include(context, comment)" />
            <scope name="parse_meta_attr" ilk="function" signature="parse_meta_attr(context, single, tk, comment)" doc="Parses a meta-programmed attribute and creates an RDoc::Attr. &#xA; To create foo and bar attributes on class C with comment &quot;My attributes&quot;: &#xA;   class C&#xA;    ##&#xA;    # :attr:&#xA;    #&#xA;    # My attributes&#xA;    my_attr :foo, :bar&#xA;  end&#xA; To create a foo attribute on class C with comment &quot;My attribute&quot;: &#xA;   class C&#xA;    ##&#xA;    # :attr: foo" />
            <scope name="parse_meta_method" ilk="function" signature="parse_meta_method(container, single, tk, comment)" doc="Parses a meta-programmed method" />
            <scope name="parse_method" ilk="function" signature="parse_method(container, single, tk, comment)" doc="Parses a normal method defined by +def+" />
            <scope name="parse_method_or_yield_parameters" ilk="function" signature="parse_method_or_yield_parameters(method = nil, modifiers = RDoc::METHOD_MODIFIERS)" />
            <scope name="parse_method_parameters" ilk="function" signature="parse_method_parameters(method)" doc="Capture the method&apos;s parameters. Along the way, look for a comment containing: &#xA;    # yields: ....&#xA; and add this as the block_params for the method" />
            <scope name="parse_module" ilk="function" signature="parse_module(container, single, tk, comment)" />
            <scope name="parse_require" ilk="function" signature="parse_require(context, comment)" />
            <scope name="parse_statements" ilk="function" signature="parse_statements(container, single = NORMAL, current_method = nil, comment = &apos;&apos;)" doc="The core of the ruby parser." />
            <scope name="parse_symbol_arg" ilk="function" signature="parse_symbol_arg(no = nil)" />
            <scope name="parse_symbol_in_arg" ilk="function" signature="parse_symbol_in_arg()" />
            <scope name="parse_top_level_statements" ilk="function" signature="parse_top_level_statements(container)" />
            <scope name="parse_visibility" ilk="function" signature="parse_visibility(container, single, tk)" />
            <scope name="parse_yield" ilk="function" signature="parse_yield(context, single, tk, method)" />
            <scope name="read_directive" ilk="function" signature="read_directive(allowed)" doc="Directives are modifier comments that can appear after class, module, or method names. For example: &#xA;   def fred # :yields: a, b&#xA; or: &#xA;   class MyClass # :nodoc:&#xA; We return the directive name and any parameters as a two element array" />
            <scope name="read_documentation_modifiers" ilk="function" signature="read_documentation_modifiers(context, allow)" />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(comment)" />
            <scope name="scan" ilk="function" signature="scan()" />
            <scope name="skip_for_variable" ilk="function" signature="skip_for_variable()" doc="skip the var [in] part of a &apos;for&apos; statement" />
            <scope name="skip_method" ilk="function" signature="skip_method(container)" />
            <scope name="skip_optional_do_after_expression" ilk="function" signature="skip_optional_do_after_expression()" doc="while, until, and for have an optional do" />
            <scope name="skip_tkspace_comment" ilk="function" signature="skip_tkspace_comment(skip_nl = true)" doc="Skip spaces until a comment is found" />
            <scope name="warn" ilk="function" signature="warn(msg)" />
            <variable name="NORMAL" attributes="__const__" citdl="Object" />
            <variable name="SINGLE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="RubyLex" ilk="class" classrefs="Object">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ruby_token" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RubyToken" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/single_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="ClassModule" ilk="class" classrefs="RDoc::Context">
          <scope name="new" ilk="function" signature="new(name, superclass = &apos;Object&apos;)" attributes="__classmethod__ __ctor__" doc="Creates a new ClassModule with +name+ with optional +superclass+" />
          <scope name="ancestors" ilk="function" signature="ancestors()" doc="Ancestors list for this ClassModule (abstract)" />
          <scope name="comment=" ilk="function" signature="comment=(comment)" doc="Appends +comment+ to the current comment, but separated by a rule.  Works more like +=." />
          <scope name="find_class_named" ilk="function" signature="find_class_named(name)" doc="Finds a class or module with +name+ in this namespace or its descendents" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Return the fully qualified name of this class or module" />
          <scope name="merge" ilk="function" signature="merge(class_module)" doc="Merges +class_module+ into this ClassModule" />
          <scope name="module?" ilk="function" signature="module?()" doc="Does this object represent a module?" />
          <scope name="path" ilk="function" signature="path()" doc="Path to this class or module" />
          <scope name="superclass" ilk="function" signature="superclass()" doc="Get the superclass of this class.  Attempts to retrieve the superclass object, returns the name if it is not known." />
          <scope name="superclass=" ilk="function" signature="superclass=(superclass)" doc="Set the superclass of this class to +superclass+" />
          <scope name="type" ilk="function" signature="type()" doc="&apos;module&apos; or &apos;class&apos;" />
          <scope ilk="function" name="diagram" />
          <scope ilk="function" name="diagram=" />
        </scope>
        <scope name="SingleClass" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="ancestors" ilk="function" signature="ancestors()" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(total_files, verbosity = 1)" attributes="__classmethod__ __ctor__" />
          <scope name="add_alias" ilk="function" signature="add_alias(as)" />
          <scope name="add_class" ilk="function" signature="add_class(klass)" />
          <scope name="add_constant" ilk="function" signature="add_constant(constant)" />
          <scope name="add_file" ilk="function" signature="add_file(file)" />
          <scope name="add_method" ilk="function" signature="add_method(method)" />
          <scope name="add_module" ilk="function" signature="add_module(mod)" />
          <scope name="begin_adding" ilk="function" signature="begin_adding()" />
          <scope name="done_adding" ilk="function" signature="done_adding()" />
          <scope name="print" ilk="function" signature="print()" />
          <scope ilk="function" name="nodoc_constants" />
          <scope ilk="function" name="nodoc_methods" />
          <scope ilk="function" name="num_constants" />
          <scope ilk="function" name="num_files" />
          <scope ilk="function" name="num_methods" />
          <scope ilk="function" name="total_files" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats/quiet" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="namespace">
          <scope name="Quiet" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(total_files)" attributes="__classmethod__ __ctor__" />
            <scope name="begin_adding" ilk="function" signature="begin_adding(*)" doc="Prints a message at the beginning of parsing" />
            <scope name="done_adding" ilk="function" signature="done_adding(*)" doc="Prints when RDoc is done" />
            <scope name="print_alias" ilk="function" signature="print_alias(*)" doc="Prints when an alias is added" />
            <scope name="print_class" ilk="function" signature="print_class(*)" doc="Prints when a class is added" />
            <scope name="print_constant" ilk="function" signature="print_constant(*)" doc="Prints when a constant is added" />
            <scope name="print_file" ilk="function" signature="print_file(*)" doc="Prints when a file is added" />
            <scope name="print_method" ilk="function" signature="print_method(*)" doc="Prints when a method is added" />
            <scope name="print_module" ilk="function" signature="print_module(*)" doc="Prints when a module is added" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats/verbose" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="namespace">
          <scope name="Verbose" ilk="class" classrefs="Normal">
            <scope name="nodoc" ilk="function" signature="nodoc(co)" doc="Returns a marker for RDoc::CodeObject +co+ being undocumented" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/text" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Text" ilk="namespace">
          <scope name="expand_tabs" ilk="function" signature="expand_tabs(text)" doc="Expands tab characters in +text+ to eight spaces" />
          <scope name="flush_left" ilk="function" signature="flush_left(text)" doc="Flush +text+ left based on the shortest line" />
          <scope name="markup" ilk="function" signature="markup(text)" doc="Convert a string in markup format into HTML.  Removes the first paragraph tags if +remove_para+ is true. &#xA; Requires the including class to implement #formatter" />
          <scope name="normalize_comment" ilk="function" signature="normalize_comment(text)" doc="Strips hashes, expands tabs then flushes +text+ to the left" />
          <scope name="parse" ilk="function" signature="parse(text)" doc="Normalizes +text+ then builds a RDoc::Markup::Document from it" />
          <scope name="strip_hashes" ilk="function" signature="strip_hashes(text)" doc="Strips leading # characters from +text+" />
          <scope name="strip_newlines" ilk="function" signature="strip_newlines(text)" doc="Strips leading and trailing \n characters from +text+" />
          <scope name="strip_stars" ilk="function" signature="strip_stars(text)" doc="Strips /* */ style comments" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/token_stream" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="TokenStream" ilk="namespace">
          <scope name="add_token" ilk="function" signature="add_token(*tokens)" />
          <scope name="add_tokens" ilk="function" signature="add_tokens(*tokens)" doc="Adds +tokens+ to the collected tokens" />
          <scope name="collect_tokens" ilk="function" signature="collect_tokens()" doc="Starts collecting tokens" />
          <scope name="pop_token" ilk="function" signature="pop_token()" doc="Remove the last token from the collected tokens" />
          <scope name="start_collecting_tokens" ilk="function" signature="start_collecting_tokens()" />
          <scope name="token_stream" ilk="function" signature="token_stream()" doc="Current token stream" />
          <scope name="tokens_to_s" ilk="function" signature="tokens_to_s()" doc="Returns a string representation of the token stream" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/top_level" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Context" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="Comparable" />
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates an unnamed empty context with public visibility" />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias)" doc="Adds +an_alias+ that is automatically resolved" />
          <scope name="add_alias_impl" ilk="function" signature="add_alias_impl(an_alias, meth)" doc="Turns +an_alias+ into an AnyMethod that points to +meth+" />
          <scope name="add_attribute" ilk="function" signature="add_attribute(attribute)" doc="Adds +attribute+" />
          <scope name="add_class" ilk="function" signature="add_class(class_type, name, superclass = &apos;Object&apos;)" doc="Adds a class named +name+ with +superclass+. &#xA; Given class Container::Item RDoc assumes +Container+ is a module unless it later sees class Container.  add_class automatically upgrades +name+ to a class in this case." />
          <scope name="add_class_or_module" ilk="function" signature="add_class_or_module(collection, class_type, name, superclass = nil)" doc="Instantiates a +class_type+ named +name+ and adds it the modules or classes Hash +collection+." />
          <scope name="add_constant" ilk="function" signature="add_constant(constant)" doc="Adds +constant+" />
          <scope name="add_include" ilk="function" signature="add_include(include)" doc="Adds included module +include+" />
          <scope name="add_method" ilk="function" signature="add_method(method)" doc="Adds +method+" />
          <scope name="add_module" ilk="function" signature="add_module(class_type, name)" doc="Adds a module named +name+.  If RDoc already knows +name+ is a class then that class is returned instead.  See also #add_class" />
          <scope name="add_module_alias" ilk="function" signature="add_module_alias(from, name)" doc="Adds an alias from +from+ to +name+" />
          <scope name="add_require" ilk="function" signature="add_require(require)" doc="Adds +require+ to this context&apos;s top level" />
          <scope name="add_to" ilk="function" signature="add_to(array, thing)" doc="Adds +thing+ to the collection +array+" />
          <scope name="child_name" ilk="function" signature="child_name(name)" doc="Creates the full name for a child with +name+" />
          <scope name="classes" ilk="function" signature="classes()" doc="Array of classes in this context" />
          <scope name="classes_and_modules" ilk="function" signature="classes_and_modules()" doc="All classes and modules in this namespace" />
          <scope name="classes_hash" ilk="function" signature="classes_hash()" doc="Hash of classes keyed by class name" />
          <scope name="defined_in?" ilk="function" signature="defined_in?(file)" doc="Is part of this thing was defined in +file+?" />
          <scope name="each_attribute" ilk="function" signature="each_attribute()" doc="Iterator for attributes" />
          <scope name="each_classmodule" ilk="function" signature="each_classmodule()" doc="Iterator for classes and modules" />
          <scope name="each_constant" ilk="function" signature="each_constant()" doc="Iterator for constants" />
          <scope name="each_include" ilk="function" signature="each_include()" doc="Iterator for included modules" />
          <scope name="each_method" ilk="function" signature="each_method()" doc="Iterator for methods" />
          <scope name="find_attribute_named" ilk="function" signature="find_attribute_named(name)" doc="Finds an attribute with +name+ in this context" />
          <scope name="find_class_method_named" ilk="function" signature="find_class_method_named(name)" doc="Finds a class method with +name+ in this context" />
          <scope name="find_constant_named" ilk="function" signature="find_constant_named(name)" doc="Finds a constant with +name+ in this context" />
          <scope name="find_enclosing_module_named" ilk="function" signature="find_enclosing_module_named(name)" doc="Find a module at a higher scope" />
          <scope name="find_file_named" ilk="function" signature="find_file_named(name)" doc="Finds a file with +name+ in this context" />
          <scope name="find_instance_method_named" ilk="function" signature="find_instance_method_named(name)" doc="Finds an instance method with +name+ in this context" />
          <scope name="find_local_symbol" ilk="function" signature="find_local_symbol(symbol)" doc="Finds a method, constant, attribute, module or files named +symbol+ in this context" />
          <scope name="find_method_named" ilk="function" signature="find_method_named(name)" doc="Finds a instance or module method with +name+ in this context" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" doc="Find a module with +name+ using ruby&apos;s scoping rules" />
          <scope name="find_symbol" ilk="function" signature="find_symbol(symbol, method = nil)" doc="Look up +symbol+.  If +method+ is non-nil, then we assume the symbol references a module that contains that method." />
          <scope name="full_name" ilk="function" signature="full_name()" doc="The full name for this context.  This method is overridden by subclasses." />
          <scope name="http_url" ilk="function" signature="http_url(prefix)" doc="URL for this with a +prefix+" />
          <scope name="initialize_classes_and_modules" ilk="function" signature="initialize_classes_and_modules()" doc="Sets the defaults for classes and modules" />
          <scope name="initialize_methods_etc" ilk="function" signature="initialize_methods_etc()" doc="Sets the defaults for methods and so-forth" />
          <scope name="methods_by_type" ilk="function" signature="methods_by_type()" doc="Breaks method_list into a nested hash by type (class or instance) and visibility (public, protected private)" />
          <scope name="methods_matching" ilk="function" signature="methods_matching(methods, singleton = false)" doc="Yields Method and Attr entries matching the list of names in +methods+. Attributes are only returned when +singleton+ is false." />
          <scope name="modules" ilk="function" signature="modules()" doc="Array of modules in this context" />
          <scope name="modules_hash" ilk="function" signature="modules_hash()" doc="Hash of modules keyed by module name" />
          <scope name="ongoing_visibility=" ilk="function" signature="ongoing_visibility=(visibility)" doc="Changes the visibility for new methods to +visibility+" />
          <scope name="record_location" ilk="function" signature="record_location(top_level)" doc="Record which file +top_level+ is in" />
          <scope name="remove_classes_and_modules" ilk="function" signature="remove_classes_and_modules()" doc="Removes classes and modules when we see a :nodoc: all" />
          <scope name="remove_methods_etc" ilk="function" signature="remove_methods_etc()" doc="If a class&apos;s documentation is turned off after we&apos;ve started collecting methods etc., we need to remove the ones we have" />
          <scope name="set_current_section" ilk="function" signature="set_current_section(title, comment)" doc="Creates a new section with +title+ and +comment+" />
          <scope name="set_visibility_for" ilk="function" signature="set_visibility_for(methods, visibility, singleton = false)" doc="Given an array +methods+ of method names, set the visibility of each to +visibility+" />
          <scope name="top_level" ilk="function" signature="top_level()" doc="Return the TopLevel that owns us" />
          <scope ilk="function" name="aliases" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="constants" />
          <scope ilk="function" name="current_section" />
          <scope ilk="function" name="in_files" />
          <scope ilk="function" name="includes" />
          <scope ilk="function" name="method_list" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="requires" />
          <scope ilk="function" name="sections" />
          <scope ilk="function" name="unmatched_alias_lists" />
          <scope ilk="function" name="unmatched_alias_lists=" />
          <scope ilk="function" name="visibility" />
          <variable name="TYPES" attributes="__const__" citdl="Object" />
          <variable name="VISIBILITIES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Parser" ilk="namespace">
          <scope name="C" ilk="class" classrefs="RDoc::Parser">
            <import symbol="RDoc::Text" />
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Prepare to parse a C file" />
            <scope name="reset" ilk="function" signature="reset()" attributes="__classmethod__" doc="Resets cross-file state.  Call when parsing different projects that need separate documentation." />
            <scope name="do_aliases" ilk="function" signature="do_aliases()" />
            <scope name="do_classes" ilk="function" signature="do_classes()" />
            <scope name="do_constants" ilk="function" signature="do_constants()" />
            <scope name="do_includes" ilk="function" signature="do_includes()" doc="Look for includes of the form: &#xA;   rb_include_module(rb_cArray, rb_mEnumerable);" />
            <scope name="do_methods" ilk="function" signature="do_methods()" />
            <scope name="find_attr_comment" ilk="function" signature="find_attr_comment(attr_name)" />
            <scope name="find_body" ilk="function" signature="find_body(class_name, meth_name, meth_obj, body, quiet = false)" doc="Find the C code corresponding to a Ruby method" />
            <scope name="find_class" ilk="function" signature="find_class(raw_name, name)" />
            <scope name="find_class_comment" ilk="function" signature="find_class_comment(class_name, class_mod)" doc="Look for class or module documentation above Init_+class_name+(void), in a Document-class +class_name+ (or module) comment or above an rb_define_class (or module).  If a comment is supplied above a matching Init_ and a rb_define_class the Init_ comment is used. &#xA;   /*&#xA;   * This is a comment for Foo&#xA;   */&#xA;  Init_Foo(void) {&#xA;      VALUE cFoo = rb_define_class(&quot;Foo&quot;, rb_cObject);&#xA;  }&#xA;  /*&#xA;   * Document-class: Foo&#xA;   * This is a comment for Foo&#xA;   */&#xA;  Init_foo(void) {&#xA;      VALUE cFoo = rb_define_class(&quot;Foo&quot;, rb_cObject);" />
            <scope name="find_const_comment" ilk="function" signature="find_const_comment(type, const_name)" doc="Finds a comment matching +type+ and +const_name+ either above the comment or in the matching Document- section." />
            <scope name="find_modifiers" ilk="function" signature="find_modifiers(comment, meth_obj)" doc="If the comment block contains a section that looks like: &#xA;    &#xA; use it for the parameters." />
            <scope name="find_override_comment" ilk="function" signature="find_override_comment(class_name, meth_name)" />
            <scope name="handle_attr" ilk="function" signature="handle_attr(var_name, attr_name, reader, writer)" />
            <scope name="handle_class_module" ilk="function" signature="handle_class_module(var_name, type, class_name, parent, in_module)" />
            <scope name="handle_constants" ilk="function" signature="handle_constants(type, var_name, const_name, definition)" doc="Adds constant comments.  By providing some_value: at the start ofthe comment you can override the C value of the comment to give a friendly definition. &#xA;   /* 300: The perfect score in bowling */&#xA;  rb_define_const(cFoo, &quot;PERFECT&quot;, INT2FIX(300);&#xA; Will override +INT2FIX(300)+ with the value +300+ in the output RDoc. Values may include quotes and escaped colons (\:)." />
            <scope name="handle_ifdefs_in" ilk="function" signature="handle_ifdefs_in(body)" doc="Removes #ifdefs that would otherwise confuse us" />
            <scope name="handle_method" ilk="function" signature="handle_method(type, var_name, meth_name, meth_body, param_count, source_file = nil)" />
            <scope name="handle_tab_width" ilk="function" signature="handle_tab_width(body)" />
            <scope name="look_for_directives_in" ilk="function" signature="look_for_directives_in(context, comment)" doc="Look for directives in a normal comment block: &#xA;   /*&#xA;   * :title: My Awesome Project&#xA;   */&#xA; This routine modifies it&apos;s parameter" />
            <scope name="remove_commented_out_lines" ilk="function" signature="remove_commented_out_lines()" doc="Removes lines that are commented out that might otherwise get picked up when scanning for classes and methods" />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(comment)" />
            <scope name="scan" ilk="function" signature="scan()" doc="Extract the classes/modules and methods from a C file and return the corresponding top-level object" />
            <scope ilk="function" name="content" />
            <scope ilk="function" name="content=" />
          </scope>
        </scope>
        <scope name="RDoc" ilk="class" classrefs="Object">
          <scope name="add_generator" ilk="function" signature="add_generator(klass)" attributes="__classmethod__" doc="Add +klass+ that can generate output after parsing" />
          <scope name="current" ilk="function" signature="current()" attributes="__classmethod__" doc="Active RDoc::RDoc instance" />
          <scope name="current=" ilk="function" signature="current=(rdoc)" attributes="__classmethod__" doc="Sets the active RDoc::RDoc instance" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="document" ilk="function" signature="document(argv)" doc="Format up one or more files according to the given arguments. &#xA; For simplicity, +argv+ is an array of strings, equivalent to the strings that would be passed on the command line. (This isn&apos;t a coincidence, as we _do_ pass in ARGV when running interactively). For a list of options, see rdoc/rdoc.rb. By default, output will be stored in a directory called +doc+ below the current directory, so make sure you&apos;re somewhere writable before invoking. &#xA; Throws: RDoc::Error on error" />
          <scope name="error" ilk="function" signature="error(msg)" doc="Report an error message and exit" />
          <scope name="gather_files" ilk="function" signature="gather_files(files)" doc="Gathers a set of parseable files from the files and directories listed in +files+." />
          <scope name="handle_pipe" ilk="function" signature="handle_pipe()" doc="Turns RDoc from stdin into HTML" />
          <scope name="install_siginfo_handler" ilk="function" signature="install_siginfo_handler()" doc="Installs a siginfo handler that prints the current filename." />
          <scope name="list_files_in_directory" ilk="function" signature="list_files_in_directory(dir)" doc="Return a list of the files to be processed in a directory. We know that this directory doesn&apos;t have a .document file, so we&apos;re looking for real files. However we may well contain subdirectories which must be tested for .document files." />
          <scope name="normalized_file_list" ilk="function" signature="normalized_file_list(relative_files, force_doc = false, exclude_pattern = nil)" doc="Given a list of files and directories, create a list of all the Ruby files they contain. &#xA; If +force_doc+ is true we always add the given files, if false, only add files that we guarantee we can parse.  It is true when looking at files given on the command line, false when recursing through subdirectories. &#xA; The effect of this is that if you want a file with a non-standard extension parsed, you must name it explicitly." />
          <scope name="output_flag_file" ilk="function" signature="output_flag_file(op_dir)" doc="Return the path name of the flag file in an output directory." />
          <scope name="parse_dot_doc_file" ilk="function" signature="parse_dot_doc_file(in_dir, filename)" doc="The .document file contains a list of file and directory name patterns, representing candidates for documentation. It may also contain comments (starting with &apos;#&apos;)" />
          <scope name="parse_file" ilk="function" signature="parse_file(filename)" doc="Parses +filename+ and returns an RDoc::TopLevel" />
          <scope name="parse_files" ilk="function" signature="parse_files(files)" doc="Parse each file on the command line, recursively entering directories." />
          <scope name="read_file_contents" ilk="function" signature="read_file_contents(filename)" />
          <scope name="remove_siginfo_handler" ilk="function" signature="remove_siginfo_handler()" doc="Removes a siginfo handler and replaces the previous" />
          <scope name="remove_unparseable" ilk="function" signature="remove_unparseable(files)" doc="Removes file extensions known to be unparseable from +files+" />
          <scope name="setup_output_dir" ilk="function" signature="setup_output_dir(dir, force)" doc="Create an output dir if it doesn&apos;t exist. If it does exist, but doesn&apos;t contain the flag file created.rid then we refuse to use it, as we may clobber some manually generated documentation" />
          <scope name="update_output_dir" ilk="function" signature="update_output_dir(op_dir, time, last = {})" doc="Update the flag file in an output directory." />
          <scope ilk="function" name="exclude" />
          <scope ilk="function" name="exclude=" />
          <scope ilk="function" name="generator" />
          <scope ilk="function" name="generator=" />
          <scope ilk="function" name="last_modified" />
          <scope ilk="function" name="options" />
          <scope ilk="function" name="options=" />
          <scope ilk="function" name="stats" />
          <variable name="GENERATORS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="TopLevel" ilk="class" classrefs="RDoc::Context">
          <scope name="all_classes_and_modules" ilk="function" signature="all_classes_and_modules()" attributes="__classmethod__" doc="Returns all classes and modules discovered by RDoc" />
          <scope name="classes" ilk="function" signature="classes()" attributes="__classmethod__" doc="Returns all classes discovered by RDoc" />
          <scope name="classes_hash" ilk="function" signature="classes_hash()" attributes="__classmethod__" doc="Hash of all classes known to RDoc" />
          <scope name="files" ilk="function" signature="files()" attributes="__classmethod__" doc="All TopLevels known to RDoc" />
          <scope name="files_hash" ilk="function" signature="files_hash()" attributes="__classmethod__" doc="Hash of all files known to RDoc" />
          <scope name="find_class_named" ilk="function" signature="find_class_named(name)" attributes="__classmethod__" doc="Finds the class with +name+ in all discovered classes" />
          <scope name="find_class_named_from" ilk="function" signature="find_class_named_from(name, from)" attributes="__classmethod__" doc="Finds the class with +name+ starting in namespace +from+" />
          <scope name="find_class_or_module" ilk="function" signature="find_class_or_module(name)" attributes="__classmethod__" doc="Finds the class or module with +name+" />
          <scope name="find_file_named" ilk="function" signature="find_file_named(name)" attributes="__classmethod__" doc="Finds the file with +name+ in all discovered files" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" attributes="__classmethod__" doc="Finds the module with +name+ in all discovered modules" />
          <scope name="modules" ilk="function" signature="modules()" attributes="__classmethod__" doc="Returns all modules discovered by RDoc" />
          <scope name="modules_hash" ilk="function" signature="modules_hash()" attributes="__classmethod__" doc="Hash of all modules known to RDoc" />
          <scope name="new" ilk="function" signature="new(file_name)" attributes="__classmethod__ __ctor__" doc="Creates a new TopLevel for +file_name+" />
          <scope name="reset" ilk="function" signature="reset()" attributes="__classmethod__" doc="Empties RDoc of stored class, module and file information" />
          <scope name="add_method" ilk="function" signature="add_method(method)" doc="Adds +method+ to Object instead of RDoc::TopLevel" />
          <scope name="base_name" ilk="function" signature="base_name()" doc="Base name of this file" />
          <scope name="cvs_url" ilk="function" signature="cvs_url()" doc="Returns a URL for this source file on some web repository.  Use the -W command line option to set." />
          <scope name="find_class_or_module" ilk="function" signature="find_class_or_module(name)" doc="See RDoc::TopLevel.find_class_or_module" />
          <scope name="find_local_symbol" ilk="function" signature="find_local_symbol(symbol)" doc="Finds a class or module named +symbol+" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" doc="Finds a module or class with +name+" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="The name of this file" />
          <scope name="http_url" ilk="function" signature="http_url(prefix)" doc="URL for this with a +prefix+" />
          <scope name="last_modified" ilk="function" signature="last_modified()" doc="Date this file was last modified, if known" />
          <scope name="name" ilk="function" signature="name()" doc="Base name of this file" />
          <scope name="path" ilk="function" signature="path()" doc="Path to this file" />
          <scope ilk="function" name="absolute_name" />
          <scope ilk="function" name="absolute_name=" />
          <scope ilk="function" name="diagram" />
          <scope ilk="function" name="diagram=" />
          <scope ilk="function" name="file_stat" />
          <scope ilk="function" name="file_stat=" />
          <scope ilk="function" name="parser" />
          <scope ilk="function" name="parser=" />
          <scope ilk="function" name="relative_name" />
          <scope ilk="function" name="relative_name=" />
        </scope>
      </scope>
    </scope>
    <scope name="readline" ilk="blob" lang="Ruby">
      <scope name="Readline" ilk="namespace">
        <scope name="basic_quote_characters" ilk="function" signature="basic_quote_characters()" attributes="__classmethod__" doc="Gets a list of quote characters which can cause a word break. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_quote_characters=" ilk="function" signature="basic_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of quote characters which can cause a word break. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_word_break_characters" ilk="function" signature="basic_word_break_characters()" attributes="__classmethod__" doc="Gets the basic list of characters that signal a break between words for the completer routine. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_word_break_characters=" ilk="function" signature="basic_word_break_characters=(p1)" attributes="__classmethod__" doc="Sets the basic list of characters that signal a break between words for the completer routine. The default is the characters which break words for completion in Bash: &quot;\t\n\&quot;\\&apos;`@$&gt;&lt;=;|&amp;{(&quot;. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_quote_characters" ilk="function" signature="completer_quote_characters()" attributes="__classmethod__" doc="Gets a list of characters which can be used to quote a substring of the line. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_quote_characters=" ilk="function" signature="completer_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of characters which can be used to quote a substring of the line. Completion occurs on the entire substring, and within the substring Readline.completer_word_break_characters are treated as any other character, unless they also appear within this list. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_word_break_characters" ilk="function" signature="completer_word_break_characters()" attributes="__classmethod__" doc="Gets the basic list of characters that signal a break between words for rl_complete_internal(). &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_word_break_characters=" ilk="function" signature="completer_word_break_characters=(p1)" attributes="__classmethod__" doc="Sets the basic list of characters that signal a break between words for rl_complete_internal(). The default is the value of Readline.basic_word_break_characters. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_append_character" ilk="function" signature="completion_append_character()" attributes="__classmethod__" doc="Returns a string containing a character to be appended on completion. The default is a space (&quot; &quot;). &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_append_character=" ilk="function" signature="completion_append_character=(p1)" attributes="__classmethod__" doc="Specifies a character to be appended on completion. Nothing will be appended if an empty string (&quot;&quot;) or nil is specified. &#xA; For example:   require &quot;readline&quot;&#xA;  Readline.readline(&quot;&gt; &quot;, true)&#xA;  Readline.completion_append_character = &quot; &quot;&#xA; Result:   &gt;&#xA;  Input &quot;/var/li&quot;.&#xA;  &gt; /var/li&#xA;  Press TAB key.&#xA;  &gt; /var/lib&#xA;  Completes &quot;b&quot; and appends &quot; &quot;. So, you can continuously input &quot;/usr&quot;.&#xA;  &gt; /var/lib /usr&#xA; NOTE: Only one character can be specified. When &quot;string&quot; is specified, sets only &quot;s&quot; that is the first. &#xA;   require &quot;readline&quot;" />
        <scope name="completion_case_fold" ilk="function" signature="completion_case_fold()" attributes="__classmethod__" doc="Returns true if completion ignores case. If no, returns false. &#xA; NOTE: Returns the same object that is specified by Readline.completion_case_fold= method. &#xA;   require &quot;readline&quot;&#xA;&#xA;  Readline.completion_case_fold = &quot;This is a String.&quot;&#xA;  p Readline.completion_case_fold # =&gt; &quot;This is a String.&quot;&#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_case_fold=" ilk="function" signature="completion_case_fold=(p1)" attributes="__classmethod__" doc="Sets whether or not to ignore case on completion. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_proc" ilk="function" signature="completion_proc()" attributes="__classmethod__" doc="Returns the completion Proc object. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_proc=" ilk="function" signature="completion_proc=(p1)" attributes="__classmethod__" doc="Specifies a Proc object +proc+ to determine completion behavior. It should take input-string, and return an array of completion candidates. &#xA; Set default if +proc+ is nil. &#xA; Raises ArgumentError exception if +proc+ does not respond to call method. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="emacs_editing_mode" ilk="function" signature="emacs_editing_mode()" attributes="__classmethod__" doc="Specifies Emacs editing mode. The default is this mode. See the manual of GNU Readline for details of Emacs editing mode. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="emacs_editing_mode?" ilk="function" signature="emacs_editing_mode?()" attributes="__classmethod__" doc="Returns true if emacs mode is active. Returns false if not. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="filename_quote_characters" ilk="function" signature="filename_quote_characters()" attributes="__classmethod__" doc="Gets a list of characters that cause a filename to be quoted by the completer when they appear in a completed filename. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="filename_quote_characters=" ilk="function" signature="filename_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of characters that cause a filename to be quoted by the completer when they appear in a completed filename. The default is nil. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="get_screen_size" ilk="function" signature="get_screen_size()" attributes="__classmethod__" doc="Returns the terminal&apos;s rows and columns. &#xA; See GNU Readline&apos;s rl_get_screen_size function. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="input=" ilk="function" signature="input=(p1)" attributes="__classmethod__" doc="Specifies a File object +input+ that is input stream for Readline.readline method. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="line_buffer" ilk="function" signature="line_buffer()" attributes="__classmethod__" doc="Returns the full line that is being edited. This is useful from within the complete_proc for determining the context of the completion request. &#xA; The length of +Readline.line_buffer+ and GNU Readline&apos;s rl_end are same." />
        <scope name="output=" ilk="function" signature="output=(p1)" attributes="__classmethod__" doc="Specifies a File object +output+ that is output stream for Readline.readline method. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="point" ilk="function" signature="point()" attributes="__classmethod__" doc="Returns the index of the current cursor position in +Readline.line_buffer+. &#xA; The index in +Readline.line_buffer+ which matches the start of input-string passed to completion_proc is computed by subtracting the length of input-string from +Readline.point+. &#xA;   start = (the length of input-string) - Readline.point" />
        <scope name="readline" ilk="function" signature="readline(...)" attributes="__classmethod__" doc="Shows the +prompt+ and reads the inputted line with line editing. The inputted line is added to the history if +add_hist+ is true. &#xA; Returns nil when the inputted line is empty and user inputs EOF (Presses ^D on UNIX). &#xA; Raises IOError exception if below conditions are satisfied. stdin is not tty.&#xA;stdin was closed. (errno is EBADF after called isatty(2).) &#xA; This method supports thread. Switchs the thread context when waits inputting line. &#xA; Supports line edit when inputs line. Provides VI and Emacs editing mode. Default is Emacs editing mode. &#xA; NOTE: Terminates ruby interpreter and does not return the terminal status after user pressed &apos;^C&apos; when wait inputting line. Give 3 examples that avoid it. &#xA; Catches the Interrupt exception by pressed ^C after returns terminal status: &#xA;   require &quot;readline&quot;&#xA;  stty_save = `stty -g`.chomp&#xA;  begin&#xA;    while buf = Readline.readline&#xA;        p buf" />
        <scope name="refresh_line" ilk="function" signature="refresh_line()" attributes="__classmethod__" doc="Clear the current input line. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="set_screen_size" ilk="function" signature="set_screen_size(p1, p2)" attributes="__classmethod__" doc="Set terminal size to +rows+ and +columns+. &#xA; See GNU Readline&apos;s rl_set_screen_size function. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="vi_editing_mode" ilk="function" signature="vi_editing_mode()" attributes="__classmethod__" doc="Specifies VI editing mode. See the manual of GNU Readline for details of VI editing mode. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="vi_editing_mode?" ilk="function" signature="vi_editing_mode?()" attributes="__classmethod__" doc="Returns true if vi mode is active. Returns false if not. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <variable name="HISTORY" attributes="__const__" citdl="Object" />
        <variable name="FILENAME_COMPLETION_PROC" attributes="__const__" citdl="Object" />
        <variable name="USERNAME_COMPLETION_PROC" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="resolv" ilk="blob" lang="Ruby">
      <scope name="Resolv" ilk="class" classrefs="Object">
        <scope name="each_address" ilk="function" signature="each_address(name, &amp;block)" attributes="__classmethod__" doc="Iterates over all IP addresses for +name+." />
        <scope name="each_name" ilk="function" signature="each_name(address, &amp;proc)" attributes="__classmethod__" doc="Iterates over all hostnames for +address+." />
        <scope name="getaddress" ilk="function" signature="getaddress(name)" attributes="__classmethod__" doc="Looks up the first IP address for +name+." />
        <scope name="getaddresses" ilk="function" signature="getaddresses(name)" attributes="__classmethod__" doc="Looks up all IP address for +name+." />
        <scope name="getname" ilk="function" signature="getname(address)" attributes="__classmethod__" doc="Looks up the hostname of +address+." />
        <scope name="getnames" ilk="function" signature="getnames(address)" attributes="__classmethod__" doc="Looks up all hostnames for +address+." />
        <scope name="new" ilk="function" signature="new(resolvers=[Hosts.new, DNS.new])" attributes="__classmethod__ __ctor__" doc="Creates a new Resolv using +resolvers+." />
        <scope name="each_address" ilk="function" signature="each_address(name)" doc="Iterates over all IP addresses for +name+." />
        <scope name="each_name" ilk="function" signature="each_name(address)" doc="Iterates over all hostnames for +address+." />
        <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Looks up the first IP address for +name+." />
        <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Looks up all IP address for +name+." />
        <scope name="getname" ilk="function" signature="getname(address)" doc="Looks up the hostname of +address+." />
        <scope name="getnames" ilk="function" signature="getnames(address)" doc="Looks up all hostnames for +address+." />
        <scope name="DNS" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config_info=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new DNS resolver. &#xA; +config_info+ can be: &#xA; Uses /etc/resolv.conf.&#xA;Path to a file using /etc/resolv.conf&apos;s format.&#xA;Must contain :nameserver, :search and :ndots keys. :nameserver_port can be used to specify port number of nameserver address. &#xA; The value of :nameserver should be an address string or an array of address strings. :nameserver =&gt; &apos;8.8.8.8&apos;&#xA;:nameserver =&gt; [&apos;8.8.8.8&apos;, &apos;8.8.4.4&apos;] &#xA; The value of :nameserver_port should be an array of pair of nameserver address and port number. :nameserver_port =&gt; [[&apos;8.8.8.8&apos;, 53], [&apos;8.8.4.4&apos;, 53]] &#xA; Example: &#xA;   Resolv::DNS.new(:nameserver =&gt; [&apos;210.251.121.21&apos;],&#xA;                  :search =&gt; [&apos;ruby-lang.org&apos;],&#xA;                  :ndots =&gt; 1)" />
          <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Creates a new DNS resolver.  See Resolv::DNS.new for argument details. &#xA; Yields the created DNS resolver to the block, if given, otherwise returns it." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the DNS resolver." />
          <scope name="each_address" ilk="function" signature="each_address(name)" doc="Iterates over all IP addresses for +name+ retrieved from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="each_name" ilk="function" signature="each_name(address)" doc="Iterates over all hostnames for +address+ retrieved from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names will be Resolv::DNS::Name instances." />
          <scope name="each_resource" ilk="function" signature="each_resource(name, typeclass, &amp;proc)" doc="Iterates over all +typeclass+ DNS resources for +name+.  See #getresource for argument details." />
          <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Gets the IP address of +name+ from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved address will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Gets all IP addresses for +name+ from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="getname" ilk="function" signature="getname(address)" doc="Gets the hostname for +address+ from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved name will be a Resolv::DNS::Name." />
          <scope name="getnames" ilk="function" signature="getnames(address)" doc="Gets all hostnames for +address+ from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names will be Resolv::DNS::Name instances." />
          <scope name="getresource" ilk="function" signature="getresource(name, typeclass)" doc="Look up the +typeclass+ DNS resource of +name+. &#xA; +name+ must be a Resolv::DNS::Name or a String. &#xA; +typeclass+ should be one of the following: &#xA; Resolv::DNS::Resource::IN::A&#xA;Resolv::DNS::Resource::IN::AAAA&#xA;Resolv::DNS::Resource::IN::ANY&#xA;Resolv::DNS::Resource::IN::CNAME&#xA;Resolv::DNS::Resource::IN::HINFO&#xA;Resolv::DNS::Resource::IN::MINFO&#xA;Resolv::DNS::Resource::IN::MX&#xA;Resolv::DNS::Resource::IN::NS&#xA;Resolv::DNS::Resource::IN::PTR&#xA;Resolv::DNS::Resource::IN::SOA" />
          <scope name="getresources" ilk="function" signature="getresources(name, typeclass)" doc="Looks up all +typeclass+ DNS resources for +name+.  See #getresource for argument details." />
          <scope name="Config" ilk="class" classrefs="Object">
            <scope name="NXDomain" ilk="class" classrefs="ResolvError">
            </scope>
            <scope name="OtherResolvError" ilk="class" classrefs="ResolvError">
            </scope>
          </scope>
          <scope name="DecodeError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="EncodeError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="Label" ilk="namespace">
            <scope name="Str" ilk="class" classrefs="Object">
            </scope>
          </scope>
          <scope name="Message" ilk="class" classrefs="Object">
            <scope name="MessageDecoder" ilk="class" classrefs="Object">
            </scope>
            <scope name="MessageEncoder" ilk="class" classrefs="Object">
            </scope>
          </scope>
          <scope name="Name" ilk="class" classrefs="Object">
            <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" doc="Creates a new DNS name from +arg+.  +arg+ can be: &#xA; returns +arg+.&#xA;Creates a new Name." />
            <scope name="absolute?" ilk="function" signature="absolute?()" doc="True if this name is absolute." />
            <scope name="subdomain_of?" ilk="function" signature="subdomain_of?(other)" doc="Returns true if +other+ is a subdomain. &#xA; Example: &#xA;   domain = Resolv::DNS::Name.create(&quot;y.z&quot;)&#xA;  p Resolv::DNS::Name.create(&quot;w.x.y.z&quot;).subdomain_of?(domain) =&gt; true&#xA;  p Resolv::DNS::Name.create(&quot;x.y.z&quot;).subdomain_of?(domain) =&gt; true&#xA;  p Resolv::DNS::Name.create(&quot;y.z&quot;).subdomain_of?(domain) =&gt; false&#xA;  p Resolv::DNS::Name.create(&quot;z&quot;).subdomain_of?(domain) =&gt; false&#xA;  p Resolv::DNS::Name.create(&quot;x.y.z.&quot;).subdomain_of?(domain) =&gt; false&#xA;  p Resolv::DNS::Name.create(&quot;w.z&quot;).subdomain_of?(domain) =&gt; false" />
            <scope name="to_s" ilk="function" signature="to_s()" doc="returns the domain name as a string. &#xA; The domain name doesn&apos;t have a trailing dot even if the name object is absolute. &#xA; Example: &#xA;   p Resolv::DNS::Name.create(&quot;x.y.z.&quot;).to_s =&gt; &quot;x.y.z&quot;&#xA;  p Resolv::DNS::Name.create(&quot;x.y.z&quot;).to_s =&gt; &quot;x.y.z&quot;" />
          </scope>
          <scope name="OpCode" ilk="namespace">
          </scope>
          <scope name="Query" ilk="class" classrefs="Object">
          </scope>
          <scope name="RCode" ilk="namespace">
          </scope>
          <scope name="Requester" ilk="class" classrefs="Object">
            <scope name="ConnectedUDP" ilk="class" classrefs="Requester">
              <scope name="Sender" ilk="class" classrefs="Requester::Sender">
              </scope>
            </scope>
            <scope name="RequestError" ilk="class" classrefs="StandardError">
            </scope>
            <scope name="Sender" ilk="class" classrefs="Object">
            </scope>
            <scope name="TCP" ilk="class" classrefs="Requester">
              <scope name="Sender" ilk="class" classrefs="Requester::Sender">
              </scope>
            </scope>
            <scope name="UnconnectedUDP" ilk="class" classrefs="Requester">
              <scope name="Sender" ilk="class" classrefs="Requester::Sender">
              </scope>
            </scope>
          </scope>
          <scope name="Resource" ilk="class" classrefs="Query">
            <scope ilk="function" name="ttl" />
            <scope name="ANY" ilk="class" classrefs="Query">
            </scope>
            <scope name="CNAME" ilk="class" classrefs="DomainName">
            </scope>
            <scope name="DomainName" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(name)" attributes="__classmethod__ __ctor__" doc="Creates a new DomainName from +name+." />
              <scope ilk="function" name="name" />
            </scope>
            <scope name="Generic" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(data)" attributes="__classmethod__ __ctor__" doc="Creates a new generic resource." />
              <scope ilk="function" name="data" />
            </scope>
            <scope name="HINFO" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(cpu, os)" attributes="__classmethod__ __ctor__" doc="Creates a new HINFO running +os+ on +cpu+." />
              <scope ilk="function" name="cpu" />
              <scope ilk="function" name="os" />
            </scope>
            <scope name="IN" ilk="namespace">
              <scope name="A" ilk="class" classrefs="Resource">
                <scope name="new" ilk="function" signature="new(address)" attributes="__classmethod__ __ctor__" doc="Creates a new A for +address+." />
                <scope ilk="function" name="address" />
              </scope>
              <scope name="AAAA" ilk="class" classrefs="Resource">
                <scope name="new" ilk="function" signature="new(address)" attributes="__classmethod__ __ctor__" doc="Creates a new AAAA for +address+." />
                <scope ilk="function" name="address" />
              </scope>
              <scope name="SRV" ilk="class" classrefs="Resource">
                <scope name="new" ilk="function" signature="new(priority, weight, port, target)" attributes="__classmethod__ __ctor__" doc="Create a SRV resource record. &#xA; See the documentation for #priority, #weight, #port and #target for +priority+, +weight+, +port and +target+ respectively." />
                <scope ilk="function" name="port" />
                <scope ilk="function" name="priority" />
                <scope ilk="function" name="target" />
                <scope ilk="function" name="weight" />
              </scope>
              <scope name="WKS" ilk="class" classrefs="Resource">
                <scope name="new" ilk="function" signature="new(address, protocol, bitmap)" attributes="__classmethod__ __ctor__" />
                <scope ilk="function" name="address" />
                <scope ilk="function" name="bitmap" />
                <scope ilk="function" name="protocol" />
              </scope>
            </scope>
            <scope name="MINFO" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(rmailbx, emailbx)" attributes="__classmethod__ __ctor__" />
              <scope ilk="function" name="emailbx" />
              <scope ilk="function" name="rmailbx" />
            </scope>
            <scope name="MX" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(preference, exchange)" attributes="__classmethod__ __ctor__" doc="Creates a new MX record with +preference+, accepting mail at +exchange+." />
              <scope ilk="function" name="exchange" />
              <scope ilk="function" name="preference" />
            </scope>
            <scope name="NS" ilk="class" classrefs="DomainName">
            </scope>
            <scope name="PTR" ilk="class" classrefs="DomainName">
            </scope>
            <scope name="SOA" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(mname, rname, serial, refresh, retry_, expire, minimum)" attributes="__classmethod__ __ctor__" doc="Creates a new SOA record.  See the attr documentation for the details of each argument." />
              <scope ilk="function" name="expire" />
              <scope ilk="function" name="minimum" />
              <scope ilk="function" name="mname" />
              <scope ilk="function" name="refresh" />
              <scope ilk="function" name="retry" />
              <scope ilk="function" name="rname" />
              <scope ilk="function" name="serial" />
            </scope>
            <scope name="TXT" ilk="class" classrefs="Resource">
              <scope name="new" ilk="function" signature="new(first_string, *rest_strings)" attributes="__classmethod__ __ctor__" />
              <scope name="data" ilk="function" signature="data()" doc="Returns the first string from +strings+." />
              <scope ilk="function" name="strings" />
            </scope>
          </scope>
        </scope>
        <scope name="Hosts" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(filename = DefaultFileName)" attributes="__classmethod__ __ctor__" doc="Creates a new Resolv::Hosts, using +filename+ for its data source." />
          <scope name="each_address" ilk="function" signature="each_address(name, &amp;proc)" doc="Iterates over all IP addresses for +name+ retrieved from the hosts file." />
          <scope name="each_name" ilk="function" signature="each_name(address, &amp;proc)" doc="Iterates over all hostnames for +address+ retrieved from the hosts file." />
          <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Gets the IP address of +name+ from the hosts file." />
          <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Gets all IP addresses for +name+ from the hosts file." />
          <scope name="getname" ilk="function" signature="getname(address)" doc="Gets the hostname of +address+ from the hosts file." />
          <scope name="getnames" ilk="function" signature="getnames(address)" doc="Gets all hostnames for +address+ from the hosts file." />
        </scope>
        <scope name="IPv4" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" />
          <scope name="to_name" ilk="function" signature="to_name()" doc="Turns this IPv4 address into a Resolv::DNS::Name." />
          <scope ilk="function" name="address" />
        </scope>
        <scope name="IPv6" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" doc="Creates a new IPv6 address from +arg+ which may be: &#xA; returns +arg+.&#xA;+arg+ must match one of the IPv6::Regex* constants" />
          <scope name="to_name" ilk="function" signature="to_name()" doc="Turns this IPv6 address into a Resolv::DNS::Name." />
          <scope ilk="function" name="address" />
        </scope>
        <scope name="ResolvError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="ResolvTimeout" ilk="class" classrefs="TimeoutError">
        </scope>
      </scope>
    </scope>
    <scope name="rexml/attlistdecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="AttlistDecl" ilk="class" classrefs="Child">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" doc="Create an AttlistDecl, pulling the information from a Source.  Notice that this isn&apos;t very convenient; to create an AttlistDecl, you basically have to format it yourself, and then have the initializer parse it. Sorry, but for the forseeable future, DTD support in REXML is pretty weak on convenience.  Have I mentioned how much I hate DTDs?" />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Iterate over the key/value pairs:  attlist_decl.each { |attribute_name, attribute_value| ... }" />
          <scope name="include?" ilk="function" signature="include?(key)" doc="Whether an attlist declaration includes the given attribute definition  if attlist_decl.include? &quot;xmlns:foobar&quot;" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write(out, indent=-1)" doc="Write out exactly what we got in." />
          <scope ilk="function" name="element_name" />
        </scope>
        <scope name="DTD" ilk="namespace">
          <scope name="AttlistDecl" ilk="class" classrefs="Child">
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PATTERN_RE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/cdata" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="CData" ilk="class" classrefs="Text">
          <scope name="new" ilk="function" signature="new( first, whitespace=true, parent=nil )" attributes="__classmethod__ __ctor__" doc="  Constructor.  CData is data between &lt;![CDATA[ ... ]]&gt;&#xA; _Examples_  CData.new( source )&#xA; CData.new( &quot;Here is some CDATA&quot; )&#xA; CData.new( &quot;Some unprocessed data&quot;, respect_whitespace_TF, parent_element )" />
          <scope name="clone" ilk="function" signature="clone()" doc="Make a copy of this object &#xA; _Examples_  c = CData.new( &quot;Some text&quot; )&#xA; d = c.clone&#xA; d.to_s        # -&gt; &quot;Some text&quot;" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the content of this CData object &#xA; _Examples_  c = CData.new( &quot;Some text&quot; )&#xA; c.to_s        # -&gt; &quot;Some text&quot;" />
          <scope name="value" ilk="function" signature="value()" />
          <scope name="write" ilk="function" signature="write( output=$stdout, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See the rexml/formatters package &#xA; Generates XML output of this object &#xA; Where to write the string.  Defaults to $stdout&#xA;The amount to indent this node by&#xA;Ignored&#xA;Ignored &#xA; _Examples_  c = CData.new( &quot; Some text &quot; )&#xA; c.write( $stdout )     #-&gt;  &lt;![CDATA[ Some text ]]&gt;" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
          <variable name="ILLEGAL" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/child" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Child" ilk="class" classrefs="Object">
          <import symbol="Node" />
          <scope name="new" ilk="function" signature="new( parent = nil )" attributes="__classmethod__ __ctor__" doc="Constructor.  Any inheritors of this class should call super to make sure this method is called. if supplied, the parent of this child will be set to the supplied value, and self will be added to the parent" />
          <scope name="bytes" ilk="function" signature="bytes()" doc="This doesn&apos;t yet handle encodings" />
          <scope name="document" ilk="function" signature="document()" doc="the document this child belongs to, or nil if this child belongs to no document" />
          <scope name="next_sibling=" ilk="function" signature="next_sibling=( other )" doc="Sets the next sibling of this child.  This can be used to insert a child after some other child.  a = Element.new(&quot;a&quot;)&#xA; b = a.add_element(&quot;b&quot;)&#xA; c = Element.new(&quot;c&quot;)&#xA; b.next_sibling = c&#xA; # =&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="parent=" ilk="function" signature="parent=( other )" doc="Sets the parent of this child to the supplied argument. &#xA; Must be a Parent object.  If this object is the same object as the existing parent of this child, no action is taken. Otherwise, this child is removed from the current parent (if one exists), and is added to the new parent.&#xA;The parent added" />
          <scope name="previous_sibling=" ilk="function" signature="previous_sibling=(other)" doc="Sets the previous sibling of this child.  This can be used to insert a child before some other child.  a = Element.new(&quot;a&quot;)&#xA; b = a.add_element(&quot;b&quot;)&#xA; c = Element.new(&quot;c&quot;)&#xA; b.previous_sibling = c&#xA; # =&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="remove" ilk="function" signature="remove()" doc="Removes this child from the parent. &#xA; self" />
          <scope name="replace_with" ilk="function" signature="replace_with( child )" doc="Replaces this object with another object.  Basically, calls Parent.replace_child &#xA; self" />
          <scope ilk="function" name="parent" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/comment" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Comment" ilk="class" classrefs="Child">
          <import symbol="Comparable" />
          <scope name="new" ilk="function" signature="new( first, second = nil )" attributes="__classmethod__ __ctor__" doc="Constructor.  The first argument can be one of three types: @param first If String, the contents of this comment are set to the argument.  If Comment, the argument is duplicated.  If Source, the argument is scanned for a comment. @param second If the first argument is a Source, this argument should be nil, not supplied, or a Parent to be set as the parent of this object" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write( output, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See REXML::Formatters &#xA; Where to write the string&#xA;An integer.      If -1, no indenting will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.&#xA;Ignored by this class.   The contents of comments are never modified.&#xA;Needed for conformity to the child API, but not used by this class." />
          <scope ilk="function" name="string" />
          <scope ilk="function" name="string=" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/doctype" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="ElementDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(match)" attributes="__classmethod__ __ctor__" doc="\s*(((([&quot;&apos;]).*?\5)|[^\/&apos;&quot;&gt;]*)*?)(\/)?&gt;/um, true)" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PATTERN_RE" attributes="__const__" citdl="Object" />
            <variable name="PATTERN_RE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="DTD" ilk="namespace">
          <scope name="NotationDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" />
            <scope name="parse_source" ilk="function" signature="parse_source(source, listener)" attributes="__classmethod__" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="write" ilk="function" signature="write( output, indent )" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Declaration" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent )" doc="DEPRECATED See REXML::Formatters" />
        </scope>
        <scope name="DocType" ilk="class" classrefs="Parent">
          <import symbol="XMLTokens" />
          <scope name="new" ilk="function" signature="new( first, parent=nil )" attributes="__classmethod__ __ctor__" doc="Constructor &#xA;   dt = DocType.new( &apos;foo&apos;, &apos;-//I/Hate/External/IDs&apos; )&#xA;  # &lt;!DOCTYPE foo &apos;-//I/Hate/External/IDs&apos;&gt;&#xA;  dt = DocType.new( doctype_to_clone )&#xA;  # Incomplete.  Shallow clone of doctype&#xA; +Note+ that the constructor: &#xA;  Doctype.new( Source.new( &quot;&lt;!DOCTYPE foo &apos;bar&apos;&gt;&quot; ) )&#xA; is _deprecated_.  Do not use it.  It will probably disappear." />
          <scope name="add" ilk="function" signature="add(child)" />
          <scope name="attribute_of" ilk="function" signature="attribute_of(element, attribute)" />
          <scope name="attributes_of" ilk="function" signature="attributes_of(element)" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="context" ilk="function" signature="context()" />
          <scope name="entity" ilk="function" signature="entity( name )" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="notation" ilk="function" signature="notation(name)" doc="Retrieves a named notation. Only notations declared in the internal DTD subset can be retrieved. &#xA; Method contributed by Henrik Martensson" />
          <scope name="notations" ilk="function" signature="notations()" doc="This method returns a list of notations that have been declared in the _internal_ DTD subset. Notations in the external DTD subset are not listed. &#xA; Method contributed by Henrik Martensson" />
          <scope name="public" ilk="function" signature="public()" doc="This method retrieves the public identifier identifying the document&apos;s DTD. &#xA; Method contributed by Henrik Martensson" />
          <scope name="system" ilk="function" signature="system()" doc="This method retrieves the system identifier identifying the document&apos;s DTD &#xA; Method contributed by Henrik Martensson" />
          <scope name="write" ilk="function" signature="write( output, indent=0, transitive=false, ie_hack=false )" doc="Where to write the string&#xA;An integer.  If -1, no indentation will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.&#xA;Ignored&#xA;Ignored" />
          <scope ilk="function" name="entities" />
          <scope ilk="function" name="external_id" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="namespaces" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
          <variable name="SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="PUBLIC" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_ENTITIES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ElementDecl" ilk="class" classrefs="Declaration">
          <scope name="new" ilk="function" signature="new( src )" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="ExternalEntity" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new( src )" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent )" />
        </scope>
        <scope name="NotationDecl" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(name, middle, pub, sys)" attributes="__classmethod__ __ctor__" />
          <scope name="name" ilk="function" signature="name()" doc="This method retrieves the name of the notation. &#xA; Method contributed by Henrik Martensson" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent=-1 )" />
          <scope ilk="function" name="public" />
          <scope ilk="function" name="public=" />
          <scope ilk="function" name="system" />
          <scope ilk="function" name="system=" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/document" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Document" ilk="class" classrefs="Element">
          <scope name="entity_expansion_limit" ilk="function" signature="entity_expansion_limit()" attributes="__classmethod__" doc="Get the entity expansion limit. By default the limit is set to 10000." />
          <scope name="entity_expansion_limit=" ilk="function" signature="entity_expansion_limit=( val )" attributes="__classmethod__" doc="Set the entity expansion limit. By default the limit is set to 10000." />
          <scope name="new" ilk="function" signature="new( source = nil, context = {} )" attributes="__classmethod__ __ctor__" doc="Constructor @param source if supplied, must be a Document, String, or IO. Documents have their context and Element attributes cloned. Strings are expected to be valid XML documents.  IOs are expected to be sources of valid XML documents. @param context if supplied, contains the context of the document; this should be a Hash." />
          <scope name="parse_stream" ilk="function" signature="parse_stream( source, listener )" attributes="__classmethod__" />
          <scope name="add" ilk="function" signature="add( child )" doc="We override this, because XMLDecls and DocTypes must go at the start of the document" />
          <scope name="add_element" ilk="function" signature="add_element(arg=nil, arg2=nil)" />
          <scope name="clone" ilk="function" signature="clone()" doc="Should be obvious" />
          <scope name="doctype" ilk="function" signature="doctype()" doc="@return the DocType child of the document, if one exists, and nil otherwise." />
          <scope name="encoding" ilk="function" signature="encoding()" doc="@return the XMLDecl encoding of this document as a String. If no XMLDecl has been set, returns the default encoding." />
          <scope name="expanded_name" ilk="function" signature="expanded_name()" doc="According to the XML spec, a root node has no expanded name" />
          <scope name="name" ilk="function" signature="name()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="record_entity_expansion" ilk="function" signature="record_entity_expansion()" />
          <scope name="root" ilk="function" signature="root()" doc="@return the root Element of the document, or nil if this document has no children." />
          <scope name="stand_alone?" ilk="function" signature="stand_alone?()" doc="@return the XMLDecl standalone value of this document as a String. If no XMLDecl has been set, returns the default setting." />
          <scope name="version" ilk="function" signature="version()" doc="@return the XMLDecl version of this document as a String. If no XMLDecl has been set, returns the default version." />
          <scope name="write" ilk="function" signature="write( output=$stdout, indent=-1, transitive=false, ie_hack=false )" doc="Write the XML tree out, optionally with indent.  This writes out the entire XML document, including XML declarations, doctype declarations, and processing instructions (if any are given). &#xA; A controversial point is whether Document should always write the XML declaration (&lt;?xml version=&apos;1.0&apos;?&gt;) whether or not one is given by the user (or source document).  REXML does not write one if one was not specified, because it adds unnecessary bandwidth to applications such as XML-RPC. &#xA; See also the classes in the rexml/formatters package for the proper way to change the default formatting of XML output &#xA; _Examples_   Document.new(&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;).serialize&#xA;&#xA;  output_string = &quot;&quot;&#xA;  tr = Transitive.new( output_string )&#xA;  Document.new(&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;).serialize( tr )&#xA; output an object which supports &apos;&lt;&lt; string&apos;; this is where the   document will be written.&#xA; An integer.  If -1, no indenting will be used; otherwise, the indentation will be twice this number of spaces, and children will be indented an additional amount.  For a value of 3, every item will be indented 3 more levels, or 6 more spaces (2 * 3). Defaults to -1&#xA;If transitive is true and indent is &gt;= 0, then the output will be pretty-printed in such a way that the added whitespace does not affect the absolute *value* of the document -- that is, it leaves the value and number of Text nodes in the document unchanged.&#xA;Internet Explorer is the worst piece of crap to have ever been written, with the possible exception of Windows itself.  Since IE is unable to parse proper XML, we have to provide a hack to generate XML that IE&apos;s limited abilities can handle.  This hack inserts a space before the /&gt; on empty tags.  Defaults to false" />
          <scope name="xml_decl" ilk="function" signature="xml_decl()" doc="@return the XMLDecl of this document; if no XMLDecl has been set, the default declaration is returned." />
          <scope ilk="function" name="entity_expansion_count" />
          <variable name="DECLARATION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/dtd" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="Parser" ilk="class" classrefs="Object">
            <scope name="parse" ilk="function" signature="parse( input )" attributes="__classmethod__" />
            <scope name="parse_helper" ilk="function" signature="parse_helper( input )" attributes="__classmethod__" doc="Takes a String and parses it out" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/entitydecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="EntityDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" doc="&lt;!ENTITY name SYSTEM &quot;...&quot;&gt; &lt;!ENTITY name &quot;...&quot;&gt;" />
            <scope name="parse_source" ilk="function" signature="parse_source(source, listener)" attributes="__classmethod__" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="write" ilk="function" signature="write( output, indent )" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
            <variable name="PLAIN" attributes="__const__" citdl="Object" />
            <variable name="PERCENT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/notationdecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rexml/element" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Attribute" ilk="class" classrefs="Object">
          <import symbol="Namespace" />
          <import symbol="Node" />
          <scope name="new" ilk="function" signature="new( first, second=nil, parent=nil )" attributes="__classmethod__ __ctor__" doc="Constructor. FIXME: The parser doesn&apos;t catch illegal characters in attributes &#xA; Either: an Attribute, which this new attribute will become a clone of; or a String, which is the name of this attribute&#xA;If +first+ is an Attribute, then this may be an Element, or nil. If nil, then the Element parent of this attribute is the parent of the +first+ Attribute.  If the first argument is a String, then this must also be a String, and is the content of the attribute. If this is the content, it must be fully normalized (contain no illegal characters).&#xA;Ignored unless +first+ is a String; otherwise, may be the Element parent of this attribute, or nil. &#xA; &#xA;  Attribute.new( attribute_to_clone )&#xA; Attribute.new( attribute_to_clone, parent_element )&#xA; Attribute.new( &quot;attr&quot;, &quot;attr_value&quot; )&#xA; Attribute.new( &quot;attr&quot;, &quot;attr_value&quot;, parent_element )" />
          <scope name="clone" ilk="function" signature="clone()" doc="Returns a copy of this attribute" />
          <scope name="doctype" ilk="function" signature="doctype()" />
          <scope name="element=" ilk="function" signature="element=( element )" doc="Sets the element of which this object is an attribute.  Normally, this is not directly called. &#xA; Returns this attribute" />
          <scope name="hash" ilk="function" signature="hash()" doc="Creates (and returns) a hash from both the name and value" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="namespace" ilk="function" signature="namespace(arg=nil)" doc="Returns the namespace URL, if defined, or nil otherwise &#xA;  e = Element.new(&quot;el&quot;)&#xA; e.add_attributes({&quot;xmlns:ns&quot;, &quot;http://url&quot;})&#xA; e.namespace( &quot;ns&quot; )              # -&gt; &quot;http://url&quot;" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="prefix" ilk="function" signature="prefix()" doc="Returns the namespace of the attribute. &#xA;  e = Element.new( &quot;elns:myelement&quot; )&#xA; e.add_attribute( &quot;nsa:a&quot;, &quot;aval&quot; )&#xA; e.add_attribute( &quot;b&quot;, &quot;bval&quot; )&#xA; e.attributes.get_attribute( &quot;a&quot; ).prefix   # -&gt; &quot;nsa&quot;&#xA; e.attributes.get_attribute( &quot;b&quot; ).prefix   # -&gt; &quot;elns&quot;&#xA; a = Attribute.new( &quot;x&quot;, &quot;y&quot; )&#xA; a.prefix                                   # -&gt; &quot;&quot;" />
          <scope name="remove" ilk="function" signature="remove()" doc="Removes this Attribute from the tree, and returns true if successfull &#xA; This method is usually not called directly." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the attribute value, with entities replaced" />
          <scope name="to_string" ilk="function" signature="to_string()" doc="Returns this attribute out as XML source, expanding the name &#xA;  a = Attribute.new( &quot;x&quot;, &quot;y&quot; )&#xA; a.to_string     # -&gt; &quot;x=&apos;y&apos;&quot;&#xA; b = Attribute.new( &quot;ns:x&quot;, &quot;y&quot; )&#xA; b.to_string     # -&gt; &quot;ns:x=&apos;y&apos;&quot;" />
          <scope name="value" ilk="function" signature="value()" doc="Returns the UNNORMALIZED value of this attribute.  That is, entities have been expanded to their values" />
          <scope name="write" ilk="function" signature="write( output, indent=-1 )" doc="Writes this attribute (EG, puts &apos;key=&quot;value&quot;&apos; to the output)" />
          <scope name="xpath" ilk="function" signature="xpath()" />
          <scope ilk="function" name="element" />
          <scope ilk="function" name="normalized=" />
          <variable name="PATTERN" attributes="__const__" citdl="Object" />
          <variable name="NEEDS_A_SECOND_CHECK" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Attributes" ilk="class" classrefs="Hash">
          <scope name="new" ilk="function" signature="new(element)" attributes="__classmethod__ __ctor__" doc="Constructor the Element of which this is an Attribute" />
          <scope name="add" ilk="function" signature="add( attribute )" doc="Adds an attribute, overriding any existing attribute by the same name.  Namespaces are significant. An Attribute" />
          <scope name="delete" ilk="function" signature="delete( attribute )" doc="Removes an attribute either a String, which is the name of the attribute to remove -- namespaces are significant here -- or the attribute to remove.&#xA;the owning element  doc = Document.new &quot;&lt;a y:foo=&apos;0&apos; x:foo=&apos;1&apos; foo=&apos;3&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA; doc.root.attributes.delete &apos;foo&apos;   #-&gt; &lt;a y:foo=&apos;0&apos; x:foo=&apos;1&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA; doc.root.attributes.delete &apos;x:foo&apos; #-&gt; &lt;a y:foo=&apos;0&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA; attr = doc.root.attributes.get_attribute(&apos;y:foo&apos;)&#xA; doc.root.attributes.delete attr    #-&gt; &lt;a z:foo=&apos;4&apos;/&gt;&quot;" />
          <scope name="delete_all" ilk="function" signature="delete_all( name )" doc="Deletes all attributes matching a name.  Namespaces are significant. A String; all attributes that match this path will be removed&#xA;an Array of the Attributes that were removed" />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over each attribute of an Element, yielding the expanded name and value as a pair of Strings. &#xA;  doc = Document.new &apos;&lt;a x=&quot;1&quot; y=&quot;2&quot;/&gt;&apos;&#xA; doc.root.attributes.each {|name, value| p name+&quot; =&gt; &quot;+value }" />
          <scope name="each_attribute" ilk="function" signature="each_attribute()" doc="Iterates over the attributes of an Element.  Yields actual Attribute nodes, not String values. &#xA;  doc = Document.new &apos;&lt;a x=&quot;1&quot; y=&quot;2&quot;/&gt;&apos;&#xA; doc.root.attributes.each_attribute {|attr|&#xA;   p attr.expanded_name+&quot; =&gt; &quot;+attr.value&#xA; }" />
          <scope name="get_attribute" ilk="function" signature="get_attribute( name )" doc="Fetches an attribute the name by which to search for the attribute.  Can be a prefix:name namespace name.&#xA;The first matching attribute, or nil if there was none.  This value is an Attribute node, not the String value of the attribute.  doc = Document.new &apos;&lt;a x:foo=&quot;1&quot; foo=&quot;2&quot; bar=&quot;3&quot;/&gt;&apos;&#xA; doc.root.attributes.get_attribute(&quot;foo&quot;).value    #-&gt; &quot;2&quot;&#xA; doc.root.attributes.get_attribute(&quot;x:foo&quot;).value  #-&gt; &quot;1&quot;" />
          <scope name="get_attribute_ns" ilk="function" signature="get_attribute_ns(namespace, name)" doc="The +get_attribute_ns+ method retrieves a method by its namespace and name. Thus it is possible to reliably identify an attribute even if an XML processor has changed the prefix. &#xA; Method contributed by Henrik Martensson" />
          <scope name="length" ilk="function" signature="length()" doc="Returns the number of attributes the owning Element contains.  doc = Document &quot;&lt;a x=&apos;1&apos; y=&apos;2&apos; foo:x=&apos;3&apos;/&gt;&quot;&#xA; doc.root.attributes.length        #-&gt; 3" />
          <scope name="namespaces" ilk="function" signature="namespaces()" />
          <scope name="prefixes" ilk="function" signature="prefixes()" doc="Returns an array of Strings containing all of the prefixes declared by this set of # attributes.  The array does not include the default namespace declaration, if one exists.  doc = Document.new(&quot;&lt;a xmlns=&apos;foo&apos; xmlns:x=&apos;bar&apos; xmlns:y=&apos;twee&apos; &quot;+&#xA;       &quot;z=&apos;glorp&apos; p:k=&apos;gru&apos;/&gt;&quot;)&#xA; prefixes = doc.root.attributes.prefixes    #-&gt; [&apos;x&apos;, &apos;y&apos;]" />
          <scope name="size" ilk="function" signature="size()" />
          <scope name="to_a" ilk="function" signature="to_a()" />
        </scope>
        <scope name="Element" ilk="class" classrefs="Parent">
          <import symbol="Namespace" />
          <scope name="new" ilk="function" signature="new( arg = UNDEFINED, parent=nil, context=nil )" attributes="__classmethod__ __ctor__" doc="Constructor if not supplied, will be set to the default value. If a String, the name of this object will be set to the argument. If an Element, the object will be shallowly cloned; name, attributes, and namespaces will be copied.  Children will +not+ be copied.&#xA;if supplied, must be a Parent, and will be used as the parent of this object.&#xA;If supplied, must be a hash containing context items.  Context items include: :respect_whitespace the value of this is :+all+ or an array of strings being the names of the elements to respect whitespace for.  Defaults to :+all+.&#xA;:compress_whitespace the value can be :+all+ or an array of strings being the names of the elements to ignore whitespace on. Overrides :+respect_whitespace+.&#xA;:ignore_whitespace_nodes the value can be :+all+ or an array of strings being the names of the elements in which to ignore whitespace-only nodes.  If this is set, Text nodes which contain only whitespace will not be added to the document tree.&#xA;:raw can be :+all+, or an array of strings being the names of the elements to process in raw mode.  In raw mode, special characters in text is not converted to or from entities." />
          <scope name="add_attribute" ilk="function" signature="add_attribute( key, value=nil )" doc="Adds an attribute to this element, overwriting any existing attribute by the same name. can be either an Attribute or a String.  If an Attribute, the attribute is added to the list of Element attributes.  If String, the argument is used as the name of the new attribute, and the value parameter must be supplied.&#xA;Required if +key+ is a String, and ignored if the first argument is an Attribute.  This is a String, and is used as the value of the new Attribute.  This should be the unnormalized value of the attribute (without entities).&#xA;the Attribute added  e = Element.new &apos;e&apos;&#xA; e.add_attribute( &apos;a&apos;, &apos;b&apos; )               #-&gt; &lt;e a=&apos;b&apos;/&gt;&#xA; e.add_attribute( &apos;x:a&apos;, &apos;c&apos; )             #-&gt; &lt;e a=&apos;b&apos; x:a=&apos;c&apos;/&gt;&#xA; e.add_attribute Attribute.new(&apos;b&apos;, &apos;d&apos;)   #-&gt; &lt;e a=&apos;b&apos; x:a=&apos;c&apos; b=&apos;d&apos;/&gt;" />
          <scope name="add_attributes" ilk="function" signature="add_attributes(hash)" doc="Add multiple attributes to this element. is either a hash, or array of arrays  el.add_attributes( {&quot;name1&quot;=&gt;&quot;value1&quot;, &quot;name2&quot;=&gt;&quot;value2&quot;} )&#xA; el.add_attributes( [ [&quot;name1&quot;,&quot;value1&quot;], [&quot;name2&quot;=&gt;&quot;value2&quot;] ] )" />
          <scope name="add_element" ilk="function" signature="add_element(element, attrs=nil)" doc="Adds a child to this element, optionally setting attributes in the element. optional.  If Element, the element is added. Otherwise, a new Element is constructed with the argument (see Element.initialize).&#xA;If supplied, must be a Hash containing String name,value pairs, which will be used to set the attributes of the new Element.&#xA;the Element that was added  el = doc.add_element &apos;my-tag&apos;&#xA; el = doc.add_element &apos;my-tag&apos;, {&apos;attr1&apos;=&gt;&apos;val1&apos;, &apos;attr2&apos;=&gt;&apos;val2&apos;}&#xA; el = Element.new &apos;my-tag&apos;&#xA; doc.add_element el" />
          <scope name="add_namespace" ilk="function" signature="add_namespace( prefix, uri=nil )" doc="Adds a namespace to this element. the prefix string, or the namespace URI if +uri+ is not supplied&#xA;the namespace URI.  May be nil, in which +prefix+ is used as the URI Evaluates to: this Element  a = Element.new(&quot;a&quot;)&#xA; a.add_namespace(&quot;xmlns:foo&quot;, &quot;bar&quot; )&#xA; a.add_namespace(&quot;foo&quot;, &quot;bar&quot;)  # shorthand for previous line&#xA; a.add_namespace(&quot;twiddle&quot;)&#xA; puts a   #-&gt; &lt;a xmlns:foo=&apos;bar&apos; xmlns=&apos;twiddle&apos;/&gt;" />
          <scope name="add_text" ilk="function" signature="add_text( text )" doc="A helper method to add a Text child.  Actual Text instances can be added with regular Parent methods, such as add() and &lt;&lt;() if a String, a new Text instance is created and added to the parent.  If Text, the object is added directly.&#xA;this Element  e = Element.new(&apos;a&apos;)          #-&gt; &lt;e/&gt;&#xA; e.add_text &apos;foo&apos;              #-&gt; &lt;e&gt;foo&lt;/e&gt;&#xA; e.add_text Text.new(&apos; bar&apos;)    #-&gt; &lt;e&gt;foo bar&lt;/e&gt;&#xA; Note that at the end of this example, the branch has &lt;b&gt;3&lt;/b&gt; nodes; the &apos;e&apos; element and &lt;b&gt;2&lt;/b&gt; Text node children." />
          <scope name="attribute" ilk="function" signature="attribute( name, namespace=nil )" doc="                                               &#xA; Attributes                                    #                                                " />
          <scope name="cdatas" ilk="function" signature="cdatas()" doc="Get an array of all CData children. IMMUTABLE" />
          <scope name="clone" ilk="function" signature="clone()" doc="Creates a shallow copy of self.   d = Document.new &quot;&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;c&gt;&lt;d/&gt;&lt;/c&gt;&lt;/a&gt;&quot;&#xA;  new_a = d.root.clone&#xA;  puts new_a  # =&gt; &quot;&lt;a/&gt;&quot;" />
          <scope name="comments" ilk="function" signature="comments()" doc="Get an array of all Comment children. IMMUTABLE" />
          <scope name="delete_attribute" ilk="function" signature="delete_attribute(key)" doc="Removes an attribute either an Attribute or a String.  In either case, the attribute is found by matching the attribute name to the argument, and then removed.  If no attribute is found, no action is taken.&#xA;the attribute removed, or nil if this Element did not contain a matching attribute  e = Element.new(&apos;E&apos;)&#xA; e.add_attribute( &apos;name&apos;, &apos;Sean&apos; )             #-&gt; &lt;E name=&apos;Sean&apos;/&gt;&#xA; r = e.add_attribute( &apos;sur:name&apos;, &apos;Russell&apos; )  #-&gt; &lt;E name=&apos;Sean&apos; sur:name=&apos;Russell&apos;/&gt;&#xA; e.delete_attribute( &apos;name&apos; )                  #-&gt; &lt;E sur:name=&apos;Russell&apos;/&gt;&#xA; e.delete_attribute( r )                       #-&gt; &lt;E/&gt;" />
          <scope name="delete_element" ilk="function" signature="delete_element(element)" doc="Deletes a child element. Must be an +Element+, +String+, or +Integer+.  If Element, the element is removed.  If String, the element is found (via XPath) and removed.  This means that any parent can remove any descendant.  If Integer, the Element indexed by that number will be removed.&#xA;the element that was removed.  doc.delete_element &quot;/a/b/c[@id=&apos;4&apos;]&quot;&#xA; doc.delete_element doc.elements[&quot;//k&quot;]&#xA; doc.delete_element 1" />
          <scope name="delete_namespace" ilk="function" signature="delete_namespace(namespace=&quot;xmlns&quot;)" doc="Removes a namespace from this node.  This only works if the namespace is actually declared in this node.  If no argument is passed, deletes the default namespace. &#xA; Evaluates to: this element  doc = Document.new &quot;&lt;a xmlns:foo=&apos;bar&apos; xmlns=&apos;twiddle&apos;/&gt;&quot;&#xA; doc.root.delete_namespace&#xA; puts doc     # -&gt; &lt;a xmlns:foo=&apos;bar&apos;/&gt;&#xA; doc.root.delete_namespace &apos;foo&apos;&#xA; puts doc     # -&gt; &lt;a/&gt;" />
          <scope name="document" ilk="function" signature="document()" doc="Evaluates to the document to which this element belongs, or nil if this element doesn&apos;t belong to a document." />
          <scope name="each_element" ilk="function" signature="each_element( xpath=nil )" doc="Synonym for Element.elements.each" />
          <scope name="each_element_with_attribute" ilk="function" signature="each_element_with_attribute( key, value=nil, max=0, name=nil )" doc="Iterates through the child elements, yielding for each Element that has a particular attribute set. the name of the attribute to search for&#xA;the value of the attribute&#xA;(optional) causes this method to return after yielding for this number of matching children&#xA;(optional) if supplied, this is an XPath that filters the children to check. &#xA;  doc = Document.new &quot;&lt;a&gt;&lt;b @id=&apos;1&apos;/&gt;&lt;c @id=&apos;2&apos;/&gt;&lt;d @id=&apos;1&apos;/&gt;&lt;e/&gt;&lt;/a&gt;&quot;&#xA; # Yields b, c, d&#xA; doc.root.each_element_with_attribute( &apos;id&apos; ) {|e| p e}&#xA; # Yields b, d&#xA; doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos; ) {|e| p e}&#xA; # Yields b&#xA; doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos;, 1 ) {|e| p e}&#xA; # Yields d&#xA; doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos;, 0, &apos;d&apos; ) {|e| p e}" />
          <scope name="each_element_with_text" ilk="function" signature="each_element_with_text( text=nil, max=0, name=nil )" doc="Iterates through the children, yielding for each Element that has a particular text set. the text to search for.  If nil, or not supplied, will iterate over all +Element+ children that contain at least one +Text+ node.&#xA;(optional) causes this method to return after yielding for this number of matching children&#xA;(optional) if supplied, this is an XPath that filters the children to check. &#xA;  doc = Document.new &apos;&lt;a&gt;&lt;b&gt;b&lt;/b&gt;&lt;c&gt;b&lt;/c&gt;&lt;d&gt;d&lt;/d&gt;&lt;e/&gt;&lt;/a&gt;&apos;&#xA; # Yields b, c, d&#xA; doc.each_element_with_text {|e|p e}&#xA; # Yields b, c&#xA; doc.each_element_with_text(&apos;b&apos;){|e|p e}&#xA; # Yields b&#xA; doc.each_element_with_text(&apos;b&apos;, 1){|e|p e}&#xA; # Yields d&#xA; doc.each_element_with_text(nil, 0, &apos;d&apos;){|e|p e}" />
          <scope name="get_elements" ilk="function" signature="get_elements( xpath )" doc="Synonym for Element.to_a This is a little slower than calling elements.each directly. any XPath by which to search for elements in the tree&#xA;an array of Elements that match the supplied path" />
          <scope name="get_text" ilk="function" signature="get_text(path = nil)" doc="Returns the first child Text node, if any, or +nil+ otherwise. This method returns the actual +Text+ node, rather than the String content.  doc = Document.new &quot;&lt;p&gt;some text &lt;b&gt;this is bold!&lt;/b&gt; more text&lt;/p&gt;&quot;&#xA; # The element &apos;p&apos; has two text elements, &quot;some text &quot; and &quot; more text&quot;.&#xA; doc.root.get_text.value            #-&gt; &quot;some text &quot;" />
          <scope name="has_attributes?" ilk="function" signature="has_attributes?()" doc="Evaluates to +true+ if this element has any attributes set, false otherwise." />
          <scope name="has_elements?" ilk="function" signature="has_elements?()" doc="Evaluates to +true+ if this element has at least one child Element  doc = Document.new &quot;&lt;a&gt;&lt;b/&gt;&lt;c&gt;Text&lt;/c&gt;&lt;/a&gt;&quot;&#xA; doc.root.has_elements               # -&gt; true&#xA; doc.elements[&quot;/a/b&quot;].has_elements   # -&gt; false&#xA; doc.elements[&quot;/a/c&quot;].has_elements   # -&gt; false" />
          <scope name="has_text?" ilk="function" signature="has_text?()" doc="Evaluates to +true+ if this element has at least one Text child" />
          <scope name="ignore_whitespace_nodes" ilk="function" signature="ignore_whitespace_nodes()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="instructions" ilk="function" signature="instructions()" doc="Get an array of all Instruction children. IMMUTABLE" />
          <scope name="namespace" ilk="function" signature="namespace(prefix=nil)" doc="Evalutas to the URI for a prefix, or the empty string if no such namespace is declared for this element. Evaluates recursively for ancestors.  Returns the default namespace, if there is one. the prefix to search for.  If not supplied, returns the default namespace if one exists&#xA;the namespace URI as a String, or nil if no such namespace exists.  If the namespace is undefined, returns an empty string  doc = Document.new(&quot;&lt;a xmlns=&apos;1&apos; xmlns:y=&apos;2&apos;&gt;&lt;b/&gt;&lt;c xmlns:z=&apos;3&apos;/&gt;&lt;/a&gt;&quot;)&#xA; b = doc.elements[&apos;//b&apos;]&#xA; b.namespace           # -&gt; &apos;1&apos;&#xA; b.namespace(&quot;y&quot;)      # -&gt; &apos;2&apos;" />
          <scope name="namespaces" ilk="function" signature="namespaces()" />
          <scope name="next_element" ilk="function" signature="next_element()" doc="Returns the next sibling that is an element, or nil if there is no Element sibling after this one  doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&apos;&#xA; doc.root.elements[&apos;b&apos;].next_element          #-&gt; &lt;c/&gt;&#xA; doc.root.elements[&apos;c&apos;].next_element          #-&gt; nil" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="prefixes" ilk="function" signature="prefixes()" doc="Evaluates to an +Array+ containing the prefixes (names) of all defined namespaces at this context node.  doc = Document.new(&quot;&lt;a xmlns:x=&apos;1&apos; xmlns:y=&apos;2&apos;&gt;&lt;b/&gt;&lt;c xmlns:z=&apos;3&apos;/&gt;&lt;/a&gt;&quot;)&#xA; doc.elements[&apos;//b&apos;].prefixes # -&gt; [&apos;x&apos;, &apos;y&apos;]" />
          <scope name="previous_element" ilk="function" signature="previous_element()" doc="Returns the previous sibling that is an element, or nil if there is no Element sibling prior to this one  doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&apos;&#xA; doc.root.elements[&apos;c&apos;].previous_element          #-&gt; &lt;b/&gt;&#xA; doc.root.elements[&apos;b&apos;].previous_element          #-&gt; nil" />
          <scope name="raw" ilk="function" signature="raw()" doc="Evaluates to +true+ if raw mode is set for this element.  This is the case if the context has :+raw+ set to :+all+ or an array containing the name of this element. &#xA; The evaluation is tested against +expanded_name+, and so is namespace sensitive." />
          <scope name="root" ilk="function" signature="root()" />
          <scope name="root_node" ilk="function" signature="root_node()" doc="Evaluates to the root node of the document that this element belongs to. If this element doesn&apos;t belong to a document, but does belong to another Element, the parent&apos;s root will be returned, until the earliest ancestor is found. &#xA; Note that this is not the same as the document element. In the following example, &lt;a&gt; is the document element, and the root node is the parent node of the document element.  You may ask yourself why the root node is useful: consider the doctype and XML declaration, and any processing instructions before the document element... they are children of the root node, or siblings of the document element. The only time this isn&apos;t true is when an Element is created that is not part of any Document.  In this case, the ancestor that has no parent acts as the root node.  d = Document.new &apos;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&apos;&#xA; a = d[1] ; c = a[1][1]&#xA; d.root_node == d   # TRUE&#xA; a.root_node        # namely, d&#xA; c.root_node        # again, d" />
          <scope name="text" ilk="function" signature="text( path = nil )" doc="A convenience method which returns the String value of the _first_ child text element, if one exists, and +nil+ otherwise. &#xA; Note that an element may have multiple Text elements, perhaps separated by other children.  Be aware that this method only returns the first Text node. &#xA; This method returns the +value+ of the first text child node, which ignores the +raw+ setting, so always returns normalized text. See the Text::value documentation. &#xA;  doc = Document.new &quot;&lt;p&gt;some text &lt;b&gt;this is bold!&lt;/b&gt; more text&lt;/p&gt;&quot;&#xA; # The element &apos;p&apos; has two text elements, &quot;some text &quot; and &quot; more text&quot;.&#xA; doc.root.text              #-&gt; &quot;some text &quot;" />
          <scope name="text=" ilk="function" signature="text=( text )" doc="Sets the first Text child of this object.  See text() for a discussion about Text children. &#xA; If a Text child already exists, the child is replaced by this content.  This means that Text content can be deleted by calling this method with a nil argument.  In this case, the next Text child becomes the first Text child.  In no case is the order of any siblings disturbed. If a String, a new Text child is created and added to this Element as the first Text child.  If Text, the text is set as the first Child element.  If nil, then any existing first Text child is removed.&#xA;this Element.  doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&apos;&#xA; doc.root.text = &apos;Sean&apos;      #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Sean&lt;/a&gt;&apos;&#xA; doc.root.text = &apos;Elliott&apos;   #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Elliott&lt;/a&gt;&apos;&#xA; doc.root.add_element &apos;c&apos;    #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Elliott&lt;c/&gt;&lt;/a&gt;&apos;&#xA; doc.root.text = &apos;Russell&apos;   #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Russell&lt;c/&gt;&lt;/a&gt;&apos;&#xA; doc.root.text = nil         #-&gt; &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;&apos;" />
          <scope name="texts" ilk="function" signature="texts()" doc="Get an array of all Text children. IMMUTABLE" />
          <scope name="whitespace" ilk="function" signature="whitespace()" doc="Evaluates to +true+ if whitespace is respected for this element.  This is the case if: Neither :+respect_whitespace+ nor :+compress_whitespace+ has any value&#xA;The context has :+respect_whitespace+ set to :+all+ or an array containing the name of this element, and :+compress_whitespace+ isn&apos;t set to :+all+ or an array containing the name of this element. The evaluation is tested against +expanded_name+, and so is namespace sensitive." />
          <scope name="write" ilk="function" signature="write(output=$stdout, indent=-1, transitive=false, ie_hack=false)" doc="DEPRECATED See REXML::Formatters &#xA; Writes out this element, and recursively, all children. output an object which supports &apos;&lt;&lt; string&apos;; this is where the   document will be written.&#xA; An integer.  If -1, no indenting will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.  Defaults to -1&#xA;If transitive is true and indent is &gt;= 0, then the output will be pretty-printed in such a way that the added whitespace does not affect the parse tree of the document&#xA;Internet Explorer is the worst piece of crap to have ever been written, with the possible exception of Windows itself.  Since IE is unable to parse proper XML, we have to provide a hack to generate XML that IE&apos;s limited abilities can handle.  This hack inserts a space before the /&gt; on empty tags.  Defaults to false &#xA;  out = &apos;&apos;&#xA; doc.write( out )     #-&gt; doc is written to the string &apos;out&apos;&#xA; doc.write( $stdout ) #-&gt; doc written to the console" />
          <scope name="xpath" ilk="function" signature="xpath()" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="context" />
          <scope ilk="function" name="context=" />
          <scope ilk="function" name="elements" />
          <variable name="UNDEFINED" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Elements" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(parent)" attributes="__classmethod__ __ctor__" doc="Constructor the parent Element" />
          <scope name="add" ilk="function" signature="add(element=nil)" doc="Adds an element if supplied, is either an Element, String, or Source (see Element.initialize).  If not supplied or nil, a new, default Element will be constructed&#xA;the added Element  a = Element.new(&apos;a&apos;)&#xA; a.elements.add(Element.new(&apos;b&apos;))  #-&gt; &lt;a&gt;&lt;b/&gt;&lt;/a&gt;&#xA; a.elements.add(&apos;c&apos;)               #-&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="collect" ilk="function" signature="collect( xpath=nil, &amp;block )" />
          <scope name="delete" ilk="function" signature="delete(element)" doc="Deletes a child Element Either an Element, which is removed directly; an xpath, where the first matching child is removed; or an Integer, where the n&apos;th Element is removed.&#xA;the removed child  doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;c id=&quot;1&quot;/&gt;&lt;/a&gt;&apos;&#xA; b = doc.root.elements[1]&#xA; doc.root.elements.delete b           #-&gt; &lt;a&gt;&lt;c/&gt;&lt;c id=&quot;1&quot;/&gt;&lt;/a&gt;&#xA; doc.elements.delete(&quot;a/c[@id=&apos;1&apos;]&quot;)  #-&gt; &lt;a&gt;&lt;c/&gt;&lt;/a&gt;&#xA; doc.root.elements.delete 1           #-&gt; &lt;a/&gt;" />
          <scope name="delete_all" ilk="function" signature="delete_all( xpath )" doc="Removes multiple elements.  Filters for Element children, regardless of XPath matching. all elements matching this String path are removed.&#xA;an Array of Elements that have been removed  doc = Document.new &apos;&lt;a&gt;&lt;c/&gt;&lt;c/&gt;&lt;c/&gt;&lt;c/&gt;&lt;/a&gt;&apos;&#xA; deleted = doc.elements.delete_all &apos;a/c&apos; #-&gt; [&lt;c/&gt;, &lt;c/&gt;, &lt;c/&gt;, &lt;c/&gt;]" />
          <scope name="each" ilk="function" signature="each( xpath=nil, &amp;block)" doc="Iterates through all of the child Elements, optionally filtering them by a given XPath optional.  If supplied, this is a String XPath, and is used to filter the children, so that only matching children are yielded.  Note that XPaths are automatically filtered for Elements, so that non-Element children will not be yielded  doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;d/&gt;sean&lt;b/&gt;&lt;c/&gt;&lt;d/&gt;&lt;/a&gt;&apos;&#xA; doc.root.each {|e|p e}       #-&gt; Yields b, c, d, b, c, d elements&#xA; doc.root.each(&apos;b&apos;) {|e|p e}  #-&gt; Yields b, b elements&#xA; doc.root.each(&apos;child::node()&apos;)  {|e|p e}&#xA; #-&gt; Yields &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;, &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;&#xA; XPath.each(doc.root, &apos;child::node()&apos;, &amp;block)&#xA; #-&gt; Yields &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;, sean, &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;" />
          <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if there are no +Element+ children, +false+ otherwise" />
          <scope name="index" ilk="function" signature="index(element)" doc="Returns the index of the supplied child (starting at 1), or -1 if the element is not a child an +Element+ child" />
          <scope name="inject" ilk="function" signature="inject( xpath=nil, initial=nil, &amp;block )" />
          <scope name="size" ilk="function" signature="size()" doc="Returns the number of +Element+ children of the parent object.  doc = Document.new &apos;&lt;a&gt;sean&lt;b/&gt;elliott&lt;b/&gt;russell&lt;b/&gt;&lt;/a&gt;&apos;&#xA; doc.root.size            #-&gt; 6, 3 element and 3 text nodes&#xA; doc.root.elements.size   #-&gt; 3" />
          <scope name="to_a" ilk="function" signature="to_a( xpath=nil )" doc="Returns an Array of Element children.  An XPath may be supplied to filter the children.  Only Element children are returned, even if the supplied XPath matches non-Element children.  doc = Document.new &apos;&lt;a&gt;sean&lt;b/&gt;elliott&lt;c/&gt;&lt;/a&gt;&apos;&#xA; doc.root.elements.to_a                  #-&gt; [ &lt;b/&gt;, &lt;c/&gt; ]&#xA; doc.root.elements.to_a(&quot;child::node()&quot;) #-&gt; [ &lt;b/&gt;, &lt;c/&gt; ]&#xA; XPath.match(doc.root, &quot;child::node()&quot;)  #-&gt; [ sean, &lt;b/&gt;, elliott, &lt;c/&gt; ]" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/encoding" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Encoding" ilk="namespace">
          <scope name="apply" ilk="function" signature="apply(obj, enc)" attributes="__classmethod__" />
          <scope name="encoding_method" ilk="function" signature="encoding_method(enc)" attributes="__classmethod__" />
          <scope name="register" ilk="function" signature="register(enc, &amp;block)" attributes="__classmethod__" />
          <scope name="check_encoding" ilk="function" signature="check_encoding(str)" />
          <scope name="decode" ilk="function" signature="decode(str)" />
          <scope name="decode_ascii" ilk="function" signature="decode_ascii(str)" doc="Convert to UTF-8" />
          <scope name="decode_eucjp" ilk="function" signature="decode_eucjp(str)" />
          <scope name="decode_iconv" ilk="function" signature="decode_iconv(str)" />
          <scope name="decode_sjis" ilk="function" signature="decode_sjis(str)" />
          <scope name="decode_unile" ilk="function" signature="decode_unile(str)" />
          <scope name="decode_utf16" ilk="function" signature="decode_utf16(str)" />
          <scope name="decode_utf8" ilk="function" signature="decode_utf8(str)" />
          <scope name="encode" ilk="function" signature="encode(content)" />
          <scope name="encode_ascii" ilk="function" signature="encode_ascii(content)" doc="Convert from UTF-8" />
          <scope name="encode_eucjp" ilk="function" signature="encode_eucjp(content)" />
          <scope name="encode_iconv" ilk="function" signature="encode_iconv(content)" />
          <scope name="encode_sjis" ilk="function" signature="encode_sjis(content)" />
          <scope name="encode_unile" ilk="function" signature="encode_unile(content)" />
          <scope name="encode_utf16" ilk="function" signature="encode_utf16(content)" />
          <scope name="encode_utf8" ilk="function" signature="encode_utf8(content)" />
          <scope name="encoding=" ilk="function" signature="encoding=( enc )" />
          <scope name="from_iso_8859_15" ilk="function" signature="from_iso_8859_15(str)" doc="Convert to UTF-8" />
          <scope name="to_iso_8859_15" ilk="function" signature="to_iso_8859_15(content)" doc="Convert from UTF-8" />
          <scope ilk="function" name="encoding" />
          <variable name="UNILE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/entity" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Entity" ilk="class" classrefs="Child">
          <import symbol="XMLTokens" />
          <scope name="matches?" ilk="function" signature="matches?(string)" attributes="__classmethod__" doc="Evaluates whether the given string matchs an entity definition, returning true if so, and false otherwise." />
          <scope name="new" ilk="function" signature="new(stream, value=nil, parent=nil, reference=false)" attributes="__classmethod__ __ctor__" doc="Create a new entity.  Simple entities can be constructed by passing a name, value to the constructor; this creates a generic, plain entity reference. For anything more complicated, you have to pass a Source to the constructor with the entity definition, or use the accessor methods. +WARNING+: There is no validation of entity state except when the entity is read from a stream.  If you start poking around with the accessors, you can easily create a non-conformant Entity.  The best thing to do is dump the stupid DTDs and use XMLSchema instead. &#xA;  e = Entity.new( &apos;amp&apos;, &apos;&amp;&apos; )" />
          <scope name="normalized" ilk="function" signature="normalized()" doc="Returns the value of this entity unprocessed -- raw.  This is the normalized value; that is, with all %ent; and &amp;ent; entities intact" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns this entity as a string.  See write()." />
          <scope name="unnormalized" ilk="function" signature="unnormalized()" doc="Evaluates to the unnormalized value of this entity; that is, replacing all entities -- both %ent; and &amp;ent; entities.  This differs from +value()+ in that +value+ only replaces %ent; entities." />
          <scope name="value" ilk="function" signature="value()" doc="Returns the value of this entity.  At the moment, only internal entities are processed.  If the value contains internal references (IE, %blah;), those are replaced with their values.  IE, if the doctype contains:  &lt;!ENTITY % foo &quot;bar&quot;&gt;&#xA; &lt;!ENTITY yada &quot;nanoo %foo; nanoo&gt;&#xA; then:  doctype.entity(&apos;yada&apos;).value   #-&gt; &quot;nanoo bar nanoo&quot;" />
          <scope name="write" ilk="function" signature="write(out, indent=-1)" doc="Write out a fully formed, correct entity definition (assuming the Entity object itself is valid.) &#xA; An object implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;TT&gt; to which the entity will be output&#xA;*DEPRECATED* and ignored" />
          <scope ilk="function" name="external" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="ndata" />
          <scope ilk="function" name="pubid" />
          <scope ilk="function" name="ref" />
          <variable name="PUBIDCHAR" attributes="__const__" citdl="Object" />
          <variable name="SYSTEMLITERAL" attributes="__const__" citdl="Object" />
          <variable name="PUBIDLITERAL" attributes="__const__" citdl="Object" />
          <variable name="EXTERNALID" attributes="__const__" citdl="Object" />
          <variable name="NDATADECL" attributes="__const__" citdl="Object" />
          <variable name="PEREFERENCE" attributes="__const__" citdl="Object" />
          <variable name="ENTITYVALUE" attributes="__const__" citdl="Object" />
          <variable name="PEDEF" attributes="__const__" citdl="Object" />
          <variable name="ENTITYDEF" attributes="__const__" citdl="Object" />
          <variable name="PEDECL" attributes="__const__" citdl="Object" />
          <variable name="GEDECL" attributes="__const__" citdl="Object" />
          <variable name="ENTITYDECL" attributes="__const__" citdl="Object" />
          <variable name="PEREFERENCE_RE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="EntityConst" ilk="namespace">
          <variable name="GT" attributes="__const__" citdl="Object" />
          <variable name="LT" attributes="__const__" citdl="Object" />
          <variable name="AMP" attributes="__const__" citdl="Object" />
          <variable name="QUOT" attributes="__const__" citdl="Object" />
          <variable name="APOS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/default" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Default" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( ie_hack=false )" attributes="__classmethod__ __ctor__" doc="Prints out the XML document with no formatting -- except if id_hack is set. &#xA; If set to true, then inserts whitespace before the close of an empty tag, so that IE&apos;s bad XML parser doesn&apos;t choke." />
            <scope name="write" ilk="function" signature="write( node, output )" doc="Writes the node to some output. &#xA; The node to write&#xA;A class implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;/TT&gt;.  Pass in an Output object to change the output encoding." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/pretty" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Pretty" ilk="class" classrefs="Default">
            <scope name="new" ilk="function" signature="new( indentation=2, ie_hack=false )" attributes="__classmethod__ __ctor__" doc="Create a new pretty printer. &#xA; An object implementing &apos;&lt;&lt;(String)&apos;, to which the output will be written.&#xA;An integer greater than 0.  The indentation of each level will be this number of spaces.  If this is &lt; 1, the behavior of this object is undefined.  Defaults to 2.&#xA;If true, the printer will insert whitespace before closing empty tags, thereby allowing Internet Explorer&apos;s feeble XML parser to function. Defaults to false." />
            <scope ilk="function" name="compact" />
            <scope ilk="function" name="compact=" />
            <scope ilk="function" name="width" />
            <scope ilk="function" name="width=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/transitive" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Transitive" ilk="class" classrefs="Default">
            <scope name="new" ilk="function" signature="new( indentation=2, ie_hack=false )" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/functions" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Functions" ilk="namespace">
          <scope name="boolean" ilk="function" signature="boolean( object=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="ceiling" ilk="function" signature="ceiling( number )" attributes="__classmethod__" />
          <scope name="compare_language" ilk="function" signature="compare_language(lang1, lang2)" attributes="__classmethod__" />
          <scope name="concat" ilk="function" signature="concat( *objects )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="contains" ilk="function" signature="contains( string, test )" attributes="__classmethod__" doc="Fixed by Mike Stok" />
          <scope name="context=" ilk="function" signature="context=(value)" attributes="__classmethod__" />
          <scope name="count" ilk="function" signature="count( node_set )" attributes="__classmethod__" />
          <scope name="false" ilk="function" signature="false( )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="floor" ilk="function" signature="floor( number )" attributes="__classmethod__" />
          <scope name="get_namespace" ilk="function" signature="get_namespace( node_set = nil )" attributes="__classmethod__" doc="Helper method." />
          <scope name="id" ilk="function" signature="id( object )" attributes="__classmethod__" doc="Since REXML is non-validating, this method is not implemented as it requires a DTD" />
          <scope name="lang" ilk="function" signature="lang( language )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="last" ilk="function" signature="last( )" attributes="__classmethod__" />
          <scope name="local_name" ilk="function" signature="local_name( node_set=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="method_missing" ilk="function" signature="method_missing( id )" attributes="__classmethod__" />
          <scope name="name" ilk="function" signature="name( node_set=nil )" attributes="__classmethod__" />
          <scope name="namespace_context" ilk="function" signature="namespace_context()" attributes="__classmethod__" />
          <scope name="namespace_context=" ilk="function" signature="namespace_context=(x)" attributes="__classmethod__" />
          <scope name="namespace_uri" ilk="function" signature="namespace_uri( node_set=nil )" attributes="__classmethod__" />
          <scope name="normalize_space" ilk="function" signature="normalize_space( string=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="not" ilk="function" signature="not( object )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="number" ilk="function" signature="number( object=nil )" attributes="__classmethod__" doc="a string that consists of optional whitespace followed by an optional minus sign followed by a Number followed by whitespace is converted to the IEEE 754 number that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical value represented by the string; any other string is converted to NaN &#xA; boolean true is converted to 1; boolean false is converted to 0 &#xA; a node-set is first converted to a string as if by a call to the string function and then converted in the same way as a string argument &#xA; an object of a type other than the four basic types is converted to a number in a way that is dependent on that type" />
          <scope name="position" ilk="function" signature="position( )" attributes="__classmethod__" />
          <scope name="processing_instruction" ilk="function" signature="processing_instruction( node )" attributes="__classmethod__" />
          <scope name="round" ilk="function" signature="round( number )" attributes="__classmethod__" />
          <scope name="starts_with" ilk="function" signature="starts_with( string, test )" attributes="__classmethod__" doc="Fixed by Mike Stok" />
          <scope name="string" ilk="function" signature="string( object=nil )" attributes="__classmethod__" doc="A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned. &#xA; A number is converted to a string as follows &#xA; NaN is converted to the string NaN &#xA; positive zero is converted to the string 0 &#xA; negative zero is converted to the string 0 &#xA; positive infinity is converted to the string Infinity &#xA; negative infinity is converted to the string -Infinity &#xA; if the number is an integer, the number is represented in decimal form as a Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is negative &#xA; otherwise, the number is represented in decimal form as a Number including a decimal point with at least one digit before the decimal point and at least one digit after the decimal point, preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the decimal point apart possibly from the one required digit immediately before the decimal point; beyond the one required digit after the decimal point there must be as many, but only as many, more digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. &#xA; The boolean false value is converted to the string false. The boolean true value is converted to the string true. &#xA; An object of a type other than the four basic types is converted to a string in a way that is dependent on that type." />
          <scope name="string_length" ilk="function" signature="string_length( string )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="string_value" ilk="function" signature="string_value( o )" attributes="__classmethod__" />
          <scope name="substring" ilk="function" signature="substring( string, start, length=nil )" attributes="__classmethod__" doc="Take equal portions of Mike Stok and Sean Russell; mix vigorously, and pour into a tall, chilled glass.  Serves 10,000." />
          <scope name="substring_after" ilk="function" signature="substring_after( string, test )" attributes="__classmethod__" doc="Kouhei fixed this too" />
          <scope name="substring_before" ilk="function" signature="substring_before( string, test )" attributes="__classmethod__" doc="Kouhei fixed this" />
          <scope name="sum" ilk="function" signature="sum( nodes )" attributes="__classmethod__" />
          <scope name="text" ilk="function" signature="text( )" attributes="__classmethod__" />
          <scope name="translate" ilk="function" signature="translate( string, tr1, tr2 )" attributes="__classmethod__" doc="This is entirely Mike Stok&apos;s beast" />
          <scope name="true" ilk="function" signature="true( )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="variables" ilk="function" signature="variables()" attributes="__classmethod__" />
          <scope name="variables=" ilk="function" signature="variables=(x)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/instruction" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Instruction" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(target, content=nil)" attributes="__classmethod__ __ctor__" doc="Constructs a new Instruction @param target can be one of a number of things.  If String, then the target of this instruction is set to this.  If an Instruction, then the Instruction is shallowly cloned (target and content are copied).  If a Source, then the source is scanned and parsed for an Instruction declaration. @param content Must be either a String, or a Parent.  Can only be a Parent if the target argument is a Source.  Otherwise, this String is set as the content of this instruction." />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write(writer, indent=-1, transitive=false, ie_hack=false)" doc="DEPRECATED See the rexml/formatters package" />
          <scope ilk="function" name="content" />
          <scope ilk="function" name="content=" />
          <scope ilk="function" name="target" />
          <scope ilk="function" name="target=" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/light/node" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Light" ilk="namespace">
          <scope name="Node" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(node=nil)" attributes="__classmethod__ __ctor__" doc="Create a new element." />
            <scope name="children" ilk="function" signature="children()" />
            <scope name="each" ilk="function" signature="each( &amp;block )" />
            <scope name="has_name?" ilk="function" signature="has_name?( name, namespace = &apos;&apos; )" />
            <scope name="local_name" ilk="function" signature="local_name()" />
            <scope name="local_name=" ilk="function" signature="local_name=( name_str )" />
            <scope name="name" ilk="function" signature="name()" />
            <scope name="name=" ilk="function" signature="name=( name_str, ns=nil )" />
            <scope name="namespace" ilk="function" signature="namespace( prefix=prefix() )" />
            <scope name="namespace=" ilk="function" signature="namespace=( namespace )" />
            <scope name="node_type" ilk="function" signature="node_type()" />
            <scope name="parent" ilk="function" signature="parent()" />
            <scope name="parent=" ilk="function" signature="parent=( node )" />
            <scope name="prefix" ilk="function" signature="prefix( namespace=nil )" />
            <scope name="root" ilk="function" signature="root()" />
            <scope name="size" ilk="function" signature="size()" />
            <scope name="text=" ilk="function" signature="text=( foo )" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
            <variable name="PARENTS" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/namespace" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Namespace" ilk="namespace">
          <import symbol="XMLTokens" />
          <scope name="fully_expanded_name" ilk="function" signature="fully_expanded_name()" doc="Fully expand the name, even if the prefix wasn&apos;t specified in the source file." />
          <scope name="has_name?" ilk="function" signature="has_name?( other, ns=nil )" doc="Compares names optionally WITH namespaces" />
          <scope name="name=" ilk="function" signature="name=( name )" doc="Sets the name and the expanded name" />
          <scope ilk="function" name="expanded_name" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="prefix" />
          <scope ilk="function" name="prefix=" />
          <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/node" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Node" ilk="namespace">
          <scope name="each_recursive" ilk="function" signature="each_recursive()" doc="Visit all subnodes of +self+ recursively" />
          <scope name="find_first_recursive" ilk="function" signature="find_first_recursive()" doc="Find (and return) first subnode (recursively) for which the block evaluates to true. Returns +nil+ if none was found." />
          <scope name="indent" ilk="function" signature="indent(to, ind)" />
          <scope name="index_in_parent" ilk="function" signature="index_in_parent()" doc="Returns the position that +self+ holds in its parent&apos;s array, indexed from 1." />
          <scope name="next_sibling_node" ilk="function" signature="next_sibling_node()" doc="@return the next sibling (nil if unset)" />
          <scope name="parent?" ilk="function" signature="parent?()" />
          <scope name="previous_sibling_node" ilk="function" signature="previous_sibling_node()" doc="@return the previous sibling (nil if unset)" />
          <scope name="to_s" ilk="function" signature="to_s(indent=nil)" doc="*DEPRECATED* This parameter is now ignored.  See the formatters in the REXML::Formatters package for changing the output style." />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/output" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Output" ilk="class" classrefs="Object">
          <import symbol="Encoding" />
          <scope name="new" ilk="function" signature="new(real_IO, encd=&quot;iso-8859-1&quot;)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="encoding" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parent" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parent" ilk="class" classrefs="Child">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(parent=nil)" attributes="__classmethod__ __ctor__" doc="Constructor @param parent if supplied, will be set as the parent of this object" />
          <scope name="add" ilk="function" signature="add( object )" />
          <scope name="children" ilk="function" signature="children()" />
          <scope name="deep_clone" ilk="function" signature="deep_clone()" doc="Deeply clones this object.  This creates a complete duplicate of this Parent, including all descendants." />
          <scope name="delete" ilk="function" signature="delete( object )" />
          <scope name="delete_at" ilk="function" signature="delete_at( index )" />
          <scope name="delete_if" ilk="function" signature="delete_if( &amp;block )" />
          <scope name="each" ilk="function" signature="each(&amp;block)" />
          <scope name="each_child" ilk="function" signature="each_child(&amp;block)" />
          <scope name="each_index" ilk="function" signature="each_index( &amp;block )" />
          <scope name="index" ilk="function" signature="index( child )" doc="Fetches the index of a given child @param child the child to get the index of @return the index of the child, or nil if the object is not a child of this parent." />
          <scope name="insert_after" ilk="function" signature="insert_after( child1, child2 )" doc="Inserts an child after another child @param child1 this is either an xpath or an Element.  If an Element, child2 will be inserted after child1 in the child list of the parent. If an xpath, child2 will be inserted after the first child to match the xpath. @param child2 the child to insert @return the parent (self)" />
          <scope name="insert_before" ilk="function" signature="insert_before( child1, child2 )" doc="Inserts an child before another child @param child1 this is either an xpath or an Element.  If an Element, child2 will be inserted before child1 in the child list of the parent. If an xpath, child2 will be inserted before the first child to match the xpath. @param child2 the child to insert @return the parent (self)" />
          <scope name="length" ilk="function" signature="length()" />
          <scope name="parent?" ilk="function" signature="parent?()" />
          <scope name="push" ilk="function" signature="push( object )" />
          <scope name="replace_child" ilk="function" signature="replace_child( to_replace, replacement )" doc="Replaces one child with another, making sure the nodelist is correct @param to_replace the child to replace (must be a Child) @param replacement the child to insert into the nodelist (must be a Child)" />
          <scope name="size" ilk="function" signature="size()" doc="@return the number of children of this parent" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="unshift" ilk="function" signature="unshift( object )" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parseexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="ParseException" ilk="class" classrefs="RuntimeError">
          <scope name="new" ilk="function" signature="new( message, source=nil, parser=nil, exception=nil )" attributes="__classmethod__ __ctor__" />
          <scope name="context" ilk="function" signature="context()" />
          <scope name="line" ilk="function" signature="line()" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="continued_exception" />
          <scope ilk="function" name="continued_exception=" />
          <scope ilk="function" name="parser" />
          <scope ilk="function" name="parser=" />
          <scope ilk="function" name="source" />
          <scope ilk="function" name="source=" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/baseparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="BaseParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( source )" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if there are no more events" />
            <scope name="entity" ilk="function" signature="entity( reference, entities )" />
            <scope name="has_next?" ilk="function" signature="has_next?()" doc="Returns true if there are more events.  Synonymous with !empty?" />
            <scope name="normalize" ilk="function" signature="normalize( input, entities=nil, entity_filter=nil )" doc="Escapes all possible entities" />
            <scope name="peek" ilk="function" signature="peek(depth=0)" doc="Peek at the +depth+ event in the stack.  The first element on the stack is at depth 0.  If +depth+ is -1, will parse to the end of the input stream and return the last event, which is always :end_document. Be aware that this causes the stream to be parsed up to the +depth+ event, so you can effectively pre-parse the entire document (pull the entire thing into memory) using this method." />
            <scope name="position" ilk="function" signature="position()" />
            <scope name="pull" ilk="function" signature="pull()" doc="Returns the next event.  This is a +PullEvent+ object." />
            <scope name="stream=" ilk="function" signature="stream=( source )" />
            <scope name="unnormalize" ilk="function" signature="unnormalize( string, entities=nil, filter=nil )" doc="Unescapes all possible entities" />
            <scope name="unshift" ilk="function" signature="unshift(token)" doc="Push an event back on the head of the stream.  This method has (theoretically) infinite depth." />
            <scope ilk="function" name="source" />
            <variable name="LETTER" attributes="__const__" citdl="Object" />
            <variable name="DIGIT" attributes="__const__" citdl="Object" />
            <variable name="COMBININGCHAR" attributes="__const__" citdl="Object" />
            <variable name="EXTENDER" attributes="__const__" citdl="Object" />
            <variable name="NCNAME_STR" attributes="__const__" citdl="Object" />
            <variable name="NAME_STR" attributes="__const__" citdl="Object" />
            <variable name="UNAME_STR" attributes="__const__" citdl="Object" />
            <variable name="NAMECHAR" attributes="__const__" citdl="Object" />
            <variable name="NAME" attributes="__const__" citdl="Object" />
            <variable name="NMTOKEN" attributes="__const__" citdl="Object" />
            <variable name="NMTOKENS" attributes="__const__" citdl="Object" />
            <variable name="REFERENCE" attributes="__const__" citdl="Object" />
            <variable name="REFERENCE_RE" attributes="__const__" citdl="Object" />
            <variable name="DOCTYPE_START" attributes="__const__" citdl="Object" />
            <variable name="DOCTYPE_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="ATTRIBUTE_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="COMMENT_START" attributes="__const__" citdl="Object" />
            <variable name="COMMENT_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="CDATA_START" attributes="__const__" citdl="Object" />
            <variable name="CDATA_END" attributes="__const__" citdl="Object" />
            <variable name="CDATA_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="XMLDECL_START" attributes="__const__" citdl="Object" />
            <variable name="XMLDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="INSTRUCTION_START" attributes="__const__" citdl="Object" />
            <variable name="INSTRUCTION_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="TAG_MATCH" attributes="__const__" citdl="Object" />
            <variable name="CLOSE_MATCH" attributes="__const__" citdl="Object" />
            <variable name="VERSION" attributes="__const__" citdl="Object" />
            <variable name="ENCODING" attributes="__const__" citdl="Object" />
            <variable name="STANDALONE" attributes="__const__" citdl="Object" />
            <variable name="ENTITY_START" attributes="__const__" citdl="Object" />
            <variable name="IDENTITY" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTDECL_START" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="SYSTEMENTITY" attributes="__const__" citdl="Object" />
            <variable name="ENUMERATION" attributes="__const__" citdl="Object" />
            <variable name="NOTATIONTYPE" attributes="__const__" citdl="Object" />
            <variable name="ENUMERATEDTYPE" attributes="__const__" citdl="Object" />
            <variable name="ATTTYPE" attributes="__const__" citdl="Object" />
            <variable name="ATTVALUE" attributes="__const__" citdl="Object" />
            <variable name="DEFAULTDECL" attributes="__const__" citdl="Object" />
            <variable name="ATTDEF" attributes="__const__" citdl="Object" />
            <variable name="ATTDEF_RE" attributes="__const__" citdl="Object" />
            <variable name="ATTLISTDECL_START" attributes="__const__" citdl="Object" />
            <variable name="ATTLISTDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="NOTATIONDECL_START" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
            <variable name="TEXT_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="PUBIDCHAR" attributes="__const__" citdl="Object" />
            <variable name="SYSTEMLITERAL" attributes="__const__" citdl="Object" />
            <variable name="PUBIDLITERAL" attributes="__const__" citdl="Object" />
            <variable name="EXTERNALID" attributes="__const__" citdl="Object" />
            <variable name="NDATADECL" attributes="__const__" citdl="Object" />
            <variable name="PEREFERENCE" attributes="__const__" citdl="Object" />
            <variable name="ENTITYVALUE" attributes="__const__" citdl="Object" />
            <variable name="PEDEF" attributes="__const__" citdl="Object" />
            <variable name="ENTITYDEF" attributes="__const__" citdl="Object" />
            <variable name="PEDECL" attributes="__const__" citdl="Object" />
            <variable name="GEDECL" attributes="__const__" citdl="Object" />
            <variable name="ENTITYDECL" attributes="__const__" citdl="Object" />
            <variable name="EREFERENCE" attributes="__const__" citdl="Object" />
            <variable name="DEFAULT_ENTITIES" attributes="__const__" citdl="Object" />
            <variable name="MISSING_ATTRIBUTE_QUOTES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/lightparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="LightParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="rewind" ilk="function" signature="rewind()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/pullparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="PullEvent" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(arg)" attributes="__classmethod__ __ctor__" doc="The type of this event.  Will be one of :tag_start, :tag_end, :text, :processing_instruction, :comment, :doctype, :attlistdecl, :entitydecl, :notationdecl, :entity, :cdata, :xmldecl, or :error." />
            <scope name="attlistdecl?" ilk="function" signature="attlistdecl?()" doc="Content: [ String text ]" />
            <scope name="cdata?" ilk="function" signature="cdata?()" doc="Content: [ String text ]" />
            <scope name="comment?" ilk="function" signature="comment?()" doc="Content: [ String text ]" />
            <scope name="doctype?" ilk="function" signature="doctype?()" doc="Content: [ String name, String pub_sys, String long_name, String uri ]" />
            <scope name="elementdecl?" ilk="function" signature="elementdecl?()" doc="Content: [ String text ]" />
            <scope name="end_element?" ilk="function" signature="end_element?()" doc="Content: [ String tag_name ]" />
            <scope name="entity?" ilk="function" signature="entity?()" doc="Content: [ String text ]" />
            <scope name="entitydecl?" ilk="function" signature="entitydecl?()" doc="Due to the wonders of DTDs, an entity declaration can be just about anything.  There&apos;s no way to normalize it; you&apos;ll have to interpret the content yourself.  However, the following is true: &#xA; If the entity declaration is an internal entity: &#xA; Content: [ String text ]" />
            <scope name="error?" ilk="function" signature="error?()" />
            <scope name="event_type" ilk="function" signature="event_type()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="instruction?" ilk="function" signature="instruction?()" doc="Content: [ String text ]" />
            <scope name="notationdecl?" ilk="function" signature="notationdecl?()" doc="Content: [ String text ]" />
            <scope name="start_element?" ilk="function" signature="start_element?()" doc="Content: [ String tag_name, Hash attributes ]" />
            <scope name="text?" ilk="function" signature="text?()" doc="Content: [ String raw_text, String unnormalized_text ]" />
            <scope name="xmldecl?" ilk="function" signature="xmldecl?()" doc="Content: [ String version, String encoding, String standalone ]" />
          </scope>
        </scope>
        <scope name="Parsers" ilk="namespace">
          <scope name="PullParser" ilk="class" classrefs="Object">
            <import symbol="XMLTokens" />
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="peek" ilk="function" signature="peek(depth=0)" />
            <scope name="pull" ilk="function" signature="pull()" />
            <scope name="unshift" ilk="function" signature="unshift(token)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/sax2parser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="SAX2Parser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="deafen" ilk="function" signature="deafen( listener=nil, &amp;blok )" />
            <scope name="listen" ilk="function" signature="listen( *args, &amp;blok )" doc="Listen arguments: &#xA; Symbol, Array, Block         Listen to Symbol events on Array elements&#xA; Symbol, Block   Listen to Symbol events&#xA; Array, Listener         Listen to all events on Array elements&#xA; Array, Block         Listen to :start_element events on Array elements&#xA; Listener         Listen to All events&#xA; Symbol can be one of: :start_element, :end_element, :start_prefix_mapping, :end_prefix_mapping, :characters, :processing_instruction, :doctype, :attlistdecl, :elementdecl, :entitydecl, :notationdecl, :cdata, :xmldecl, :comment &#xA; There is an additional symbol that can be listened for: :progress. This will be called for every event generated, passing in the current stream position. &#xA; Array contains regular expressions or strings which will be matched against fully qualified element names. &#xA; Listener must implement the methods in SAX2Listener &#xA; Block will be passed the same arguments as a SAX2Listener method would be, where the method name is the same as the matched Symbol. See the SAX2Listener for more information." />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="source" ilk="function" signature="source()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/streamparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="StreamParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(source, listener)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/treeparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="TreeParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( source, build_context = Document.new )" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/ultralightparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="UltraLightParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="rewind" ilk="function" signature="rewind()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/xpathparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rexml/quickpath" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="QuickPath" ilk="class" classrefs="Object">
          <import symbol="Functions" />
          <import symbol="XMLTokens" />
          <scope name="attribute" ilk="function" signature="attribute( name )" attributes="__classmethod__" />
          <scope name="axe" ilk="function" signature="axe( elements, axe_name, rest )" attributes="__classmethod__" />
          <scope name="each" ilk="function" signature="each(element, path, namespaces=EMPTY_HASH, &amp;block)" attributes="__classmethod__" />
          <scope name="filter" ilk="function" signature="filter(elements, path)" attributes="__classmethod__" doc="Given an array of nodes it filters the array based on the path. The result is that when this method returns, the array will contain elements which match the path" />
          <scope name="first" ilk="function" signature="first(element, path, namespaces=EMPTY_HASH)" attributes="__classmethod__" />
          <scope name="function" ilk="function" signature="function( elements, fname, rest )" attributes="__classmethod__" />
          <scope name="match" ilk="function" signature="match(element, path, namespaces=EMPTY_HASH)" attributes="__classmethod__" />
          <scope name="method_missing" ilk="function" signature="method_missing( id, *args )" attributes="__classmethod__" />
          <scope name="name" ilk="function" signature="name()" attributes="__classmethod__" />
          <scope name="parse_args" ilk="function" signature="parse_args( element, string )" attributes="__classmethod__" />
          <scope name="predicate" ilk="function" signature="predicate( elements, path )" attributes="__classmethod__" doc="A predicate filters a node-set with respect to an axis to produce a new node-set. For each node in the node-set to be filtered, the PredicateExpr is evaluated with that node as the context node, with the number of nodes in the node-set as the context size, and with the proximity position of the node in the node-set with respect to the axis as the context position; if PredicateExpr evaluates to true for that node, the node is included in the new node-set; otherwise, it is not included. &#xA; A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the context position and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function. Thus a location path para[3] is equivalent to para[position()=3]." />
          <variable name="EMPTY_HASH" attributes="__const__" citdl="Object" />
          <variable name="OPERAND_" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/sax2listener" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="SAX2Listener" ilk="namespace">
          <scope name="attlistdecl" ilk="function" signature="attlistdecl(element, pairs, contents)" doc="If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;.  This is the same for all of the .*decl methods." />
          <scope name="cdata" ilk="function" signature="cdata(content)" doc="Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;" />
          <scope name="characters" ilk="function" signature="characters(text)" />
          <scope name="comment" ilk="function" signature="comment(comment)" doc="Called when a comment is encountered. @p comment The content of the comment" />
          <scope name="doctype" ilk="function" signature="doctype(name, pub_sys, long_name, uri)" doc="Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil.  EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil.  EG, &quot;foo&quot; @p uri the uri of the doctype, or nil.  EG, &quot;bar&quot;" />
          <scope name="elementdecl" ilk="function" signature="elementdecl(content)" doc="&lt;!ELEMENT ...&gt;" />
          <scope name="end_document" ilk="function" signature="end_document()" />
          <scope name="end_element" ilk="function" signature="end_element(uri, localname, qname)" />
          <scope name="end_prefix_mapping" ilk="function" signature="end_prefix_mapping(prefix)" />
          <scope name="entitydecl" ilk="function" signature="entitydecl(name, decl)" doc="&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration.  It can be in a number of formats, but in general it returns (example, result):  &lt;!ENTITY % YN &apos;&quot;Yes&quot;&apos;&gt;&#xA; [&quot;%&quot;, &quot;YN&quot;, &quot;&apos;\&quot;Yes\&quot;&apos;&quot;, &quot;\&quot;&quot;]&#xA; &lt;!ENTITY % YN &apos;Yes&apos;&gt;&#xA; [&quot;%&quot;, &quot;YN&quot;, &quot;&apos;Yes&apos;&quot;, &quot;s&quot;]&#xA; &lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot;&gt;&#xA; [&quot;WhatHeSaid&quot;, &quot;\&quot;He said %YN;\&quot;&quot;, &quot;YN&quot;]&#xA; &lt;!ENTITY open-hatch SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA; [&quot;open-hatch&quot;, &quot;SYSTEM&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA; &lt;!ENTITY open-hatch PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot; &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA; [&quot;open-hatch&quot;, &quot;PUBLIC&quot;, &quot;\&quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN\&quot;&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA; &lt;!ENTITY hatch-pic SYSTEM &quot;../grafix/OpenHatch.gif&quot; NDATA gif&gt;&#xA; [&quot;hatch-pic&quot;, &quot;SYSTEM&quot;, &quot;\&quot;../grafix/OpenHatch.gif\&quot;&quot;, &quot;\n\t\t\t\t\t\t\tNDATA gif&quot;, &quot;gif&quot;]" />
          <scope name="notationdecl" ilk="function" signature="notationdecl(content)" doc="&lt;!NOTATION ...&gt;" />
          <scope name="processing_instruction" ilk="function" signature="processing_instruction(target, data)" />
          <scope name="progress" ilk="function" signature="progress(position)" />
          <scope name="start_document" ilk="function" signature="start_document()" />
          <scope name="start_element" ilk="function" signature="start_element(uri, localname, qname, attributes)" />
          <scope name="start_prefix_mapping" ilk="function" signature="start_prefix_mapping(prefix, uri)" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value.  EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil.  EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil.  EG, nil @p spaced the declaration is followed by a line break" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/source" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="IOSource" ilk="class" classrefs="Source">
          <scope name="new" ilk="function" signature="new(arg, block_size=500, encoding=nil)" attributes="__classmethod__ __ctor__" doc="block_size has been deprecated" />
          <scope name="consume" ilk="function" signature="consume( pattern )" />
          <scope name="current_line" ilk="function" signature="current_line()" doc="@return the current line in the source" />
          <scope name="empty?" ilk="function" signature="empty?()" />
          <scope name="match" ilk="function" signature="match( pattern, cons=false )" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="read" ilk="function" signature="read()" />
          <scope name="scan" ilk="function" signature="scan(pattern, cons=false)" />
        </scope>
        <scope name="Source" ilk="class" classrefs="Object">
          <import symbol="Encoding" />
          <scope name="new" ilk="function" signature="new(arg, encoding=nil)" attributes="__classmethod__ __ctor__" doc="Constructor @param arg must be a String, and should be a valid XML document @param encoding if non-null, sets the encoding of the source to this value, overriding all encoding detection" />
          <scope name="consume" ilk="function" signature="consume( pattern )" />
          <scope name="current_line" ilk="function" signature="current_line()" doc="@return the current line in the source" />
          <scope name="empty?" ilk="function" signature="empty?()" doc="@return true if the Source is exhausted" />
          <scope name="encoding=" ilk="function" signature="encoding=(enc)" doc="Inherited from Encoding Overridden to support optimized en/decoding" />
          <scope name="match" ilk="function" signature="match(pattern, cons=false)" />
          <scope name="match_to" ilk="function" signature="match_to( char, pattern )" />
          <scope name="match_to_consume" ilk="function" signature="match_to_consume( char, pattern )" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="read" ilk="function" signature="read()" />
          <scope name="scan" ilk="function" signature="scan(pattern, cons=false)" doc="Scans the source for a given pattern.  Note, that this is not your usual scan() method.  For one thing, the pattern argument has some requirements; for another, the source can be consumed.  You can easily confuse this method.  Originally, the patterns were easier to construct and this method more robust, because this method generated search regexes on the fly; however, this was computationally expensive and slowed down the entire REXML package considerably, since this is by far the most commonly called method. @param pattern must be a Regexp, and must be in the form of /^\s*(#{your pattern, with no groups})(.*)/.  The first group will be returned; the second group is used if the consume flag is set. @param consume if true, the pattern returned will be consumed, leaving everything after it in the Source. @return the pattern, if found, or nil if the Source is empty or the pattern is not found." />
          <scope ilk="function" name="buffer" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="line" />
        </scope>
        <scope name="SourceFactory" ilk="class" classrefs="Object">
          <scope name="create_from" ilk="function" signature="create_from(arg)" attributes="__classmethod__" doc="Generates a Source object @param arg Either a String, or an IO @return a Source, or nil if a bad argument was given" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/streamlistener" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="StreamListener" ilk="namespace">
          <scope name="attlistdecl" ilk="function" signature="attlistdecl(element_name, attributes, raw_content)" doc="If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;.  This is the same for all of the .*decl methods." />
          <scope name="cdata" ilk="function" signature="cdata(content)" doc="Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;" />
          <scope name="comment" ilk="function" signature="comment(comment)" doc="Called when a comment is encountered. @p comment The content of the comment" />
          <scope name="doctype" ilk="function" signature="doctype(name, pub_sys, long_name, uri)" doc="Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil.  EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil.  EG, &quot;foo&quot; @p uri the uri of the doctype, or nil.  EG, &quot;bar&quot;" />
          <scope name="doctype_end" ilk="function" signature="doctype_end()" doc="Called when the doctype is done" />
          <scope name="elementdecl" ilk="function" signature="elementdecl(content)" doc="&lt;!ELEMENT ...&gt;" />
          <scope name="entity" ilk="function" signature="entity(content)" doc="Called when %foo; is encountered in a doctype declaration. @p content &quot;foo&quot;" />
          <scope name="entitydecl" ilk="function" signature="entitydecl(content)" doc="&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration.  It can be in a number of formats, but in general it returns (example, result):  &lt;!ENTITY % YN &apos;&quot;Yes&quot;&apos;&gt;&#xA; [&quot;%&quot;, &quot;YN&quot;, &quot;&apos;\&quot;Yes\&quot;&apos;&quot;, &quot;\&quot;&quot;]&#xA; &lt;!ENTITY % YN &apos;Yes&apos;&gt;&#xA; [&quot;%&quot;, &quot;YN&quot;, &quot;&apos;Yes&apos;&quot;, &quot;s&quot;]&#xA; &lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot;&gt;&#xA; [&quot;WhatHeSaid&quot;, &quot;\&quot;He said %YN;\&quot;&quot;, &quot;YN&quot;]&#xA; &lt;!ENTITY open-hatch SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA; [&quot;open-hatch&quot;, &quot;SYSTEM&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA; &lt;!ENTITY open-hatch PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot; &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA; [&quot;open-hatch&quot;, &quot;PUBLIC&quot;, &quot;\&quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN\&quot;&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA; &lt;!ENTITY hatch-pic SYSTEM &quot;../grafix/OpenHatch.gif&quot; NDATA gif&gt;&#xA; [&quot;hatch-pic&quot;, &quot;SYSTEM&quot;, &quot;\&quot;../grafix/OpenHatch.gif\&quot;&quot;, &quot;\n\t\t\t\t\t\t\tNDATA gif&quot;, &quot;gif&quot;]" />
          <scope name="instruction" ilk="function" signature="instruction(name, instruction)" doc="Called when an instruction is encountered.  EG: &lt;?xsl sheet=&apos;foo&apos;?&gt; @p name the instruction name; in the example, &quot;xsl&quot; @p instruction the rest of the instruction.  In the example, &quot;sheet=&apos;foo&apos;&quot;" />
          <scope name="notationdecl" ilk="function" signature="notationdecl(content)" doc="&lt;!NOTATION ...&gt;" />
          <scope name="tag_end" ilk="function" signature="tag_end(name)" doc="Called when the end tag is reached.  In the case of &lt;tag/&gt;, tag_end will be called immidiately after tag_start @p the name of the tag" />
          <scope name="tag_start" ilk="function" signature="tag_start(name, attrs)" doc="Called when a tag is encountered. @p name the tag name @p attrs an array of arrays of attribute/value pairs, suitable for use with assoc or rassoc.  IE, &lt;tag attr1=&quot;value1&quot; attr2=&quot;value2&quot;&gt; will result in tag_start( &quot;tag&quot;, # [[&quot;attr1&quot;,&quot;value1&quot;],[&quot;attr2&quot;,&quot;value2&quot;]])" />
          <scope name="text" ilk="function" signature="text(text)" doc="Called when text is encountered in the document @p text the text content." />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value.  EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil.  EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil.  EG, nil" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/syncenumerator" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="SyncEnumerator" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(*enums)" attributes="__classmethod__ __ctor__" doc="Creates a new SyncEnumerator which enumerates rows of given Enumerable objects." />
          <scope name="each" ilk="function" signature="each()" doc="Enumerates rows of the Enumerable objects." />
          <scope name="length" ilk="function" signature="length()" doc="Returns the number of enumerated Enumerable objects, i.e. the size of each row." />
          <scope name="size" ilk="function" signature="size()" doc="Returns the number of enumerated Enumerable objects, i.e. the size of each row." />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/text" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Text" ilk="class" classrefs="Child">
          <import symbol="Comparable" />
          <scope name="check" ilk="function" signature="check(string, pattern, doctype)" attributes="__classmethod__" doc="check for illegal characters" />
          <scope name="new" ilk="function" signature="new(arg, respect_whitespace=false, parent=nil, raw=nil, entity_filter=nil, illegal=NEEDS_A_SECOND_CHECK )" attributes="__classmethod__ __ctor__" doc="Constructor +arg+ if a String, the content is set to the String.  If a Text, the object is shallowly cloned. &#xA; +respect_whitespace+ (boolean, false) if true, whitespace is respected &#xA; +parent+ (nil) if this is a Parent object, the parent will be set to this. &#xA; +raw+ (nil) This argument can be given three values. If true, then the value of used to construct this object is expected to contain no unescaped XML markup, and REXML will not change the text. If this value is false, the string may contain any characters, and REXML will escape any and all defined entities whose values are contained in the text.  If this value is nil (the default), then the raw value of the parent will be used as the raw value for this node.  If there is no raw value for the parent, and no value is supplied, the default is false. Use this field if you have entities defined for some text, and you don&apos;t want REXML to escape that text in output.   Text.new( &quot;&lt;&amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;lt;&amp;amp;&quot;&#xA;  Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;amp;lt;&amp;amp;amp;&quot;&#xA;  Text.new( &quot;&lt;&amp;&quot;, false, nil, true )  #-&gt; Parse exception&#xA;  Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, true )  #-&gt; &quot;&amp;lt;&amp;amp;&quot;&#xA;  # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;&#xA;  # and that the entity    &quot;r&quot; is defined to be &quot;russell&quot;&#xA;  Text.new( &quot;sean russell&quot; )          #-&gt; &quot;&amp;s; &amp;r;&quot;&#xA;  Text.new( &quot;sean russell&quot;, false, nil, true ) #-&gt; &quot;sean russell&quot;&#xA; +entity_filter+ (nil) This can be an array of entities to match in the supplied text.  This argument is only useful if +raw+ is set to false.   Text.new( &quot;sean russell&quot;, false, nil, false, [&quot;s&quot;] ) #-&gt; &quot;&amp;s; russell&quot;&#xA;  Text.new( &quot;sean russell&quot;, false, nil, true, [&quot;s&quot;] ) #-&gt; &quot;sean russell&quot;" />
          <scope name="normalize" ilk="function" signature="normalize( input, doctype=nil, entity_filter=nil )" attributes="__classmethod__" doc="Escapes all possible entities" />
          <scope name="read_with_substitution" ilk="function" signature="read_with_substitution( input, illegal=nil )" attributes="__classmethod__" doc="Reads text, substituting entities" />
          <scope name="unnormalize" ilk="function" signature="unnormalize( string, doctype=nil, filter=nil, illegal=nil )" attributes="__classmethod__" doc="Unescapes all possible entities" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="doctype" ilk="function" signature="doctype()" />
          <scope name="empty?" ilk="function" signature="empty?()" />
          <scope name="indent_text" ilk="function" signature="indent_text(string, level=1, style=&quot;\t&quot;, indentfirstline=true)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="parent=" ilk="function" signature="parent=(parent)" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the string value of this text node.  This string is always escaped, meaning that it is a valid XML text node string, and all entities that can be escaped, have been inserted.  This method respects the entity filter set in the constructor. &#xA;   # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the&#xA;  # entity &quot;r&quot; is defined to be &quot;russell&quot;&#xA;  t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, [&apos;s&apos;] )&#xA;  t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;&#xA;  t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false )&#xA;  t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;&#xA;  u = Text.new( &quot;sean russell&quot;, false, nil, true )&#xA;  u.to_s   #-&gt; &quot;sean russell&quot;" />
          <scope name="value" ilk="function" signature="value()" doc="Returns the string value of this text.  This is the text without entities, as it might be used programmatically, or printed to the console.  This ignores the &apos;raw&apos; attribute setting, and any entity_filter. &#xA;   # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the&#xA;  # entity &quot;r&quot; is defined to be &quot;russell&quot;&#xA;  t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, [&apos;s&apos;] )&#xA;  t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;&#xA;  t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false )&#xA;  t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;&#xA;  u = Text.new( &quot;sean russell&quot;, false, nil, true )&#xA;  u.value   #-&gt; &quot;sean russell&quot;" />
          <scope name="value=" ilk="function" signature="value=( val )" doc="Sets the contents of this text node.  This expects the text to be unnormalized.  It returns self. &#xA;   e = Element.new( &quot;a&quot; )&#xA;  e.add_text( &quot;foo&quot; )   # &lt;a&gt;foo&lt;/a&gt;&#xA;  e[0].value = &quot;bar&quot;    # &lt;a&gt;bar&lt;/a&gt;&#xA;  e[0].value = &quot;&lt;a&gt;&quot;    # &lt;a&gt;&amp;lt;a&amp;gt;&lt;/a&gt;" />
          <scope name="wrap" ilk="function" signature="wrap(string, width, addnewline=false)" />
          <scope name="write" ilk="function" signature="write( writer, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See REXML::Formatters" />
          <scope name="write_with_substitution" ilk="function" signature="write_with_substitution(out, input)" doc="Writes out text, substituting special characters beforehand. +out+ A String, IO, or any other object supporting &lt;&lt;( String ) +input+ the text to substitute and the write out &#xA;   z=utf8.unpack(&quot;U*&quot;)&#xA;  ascOut=&quot;&quot;&#xA;  z.each{|r|&#xA;    if r &lt;  0x100&#xA;      ascOut.concat(r.chr)&#xA;    else&#xA;      ascOut.concat(sprintf(&quot;&amp;#x%x;&quot;, r))&#xA;    end&#xA;  }&#xA;  puts ascOut" />
          <scope name="xpath" ilk="function" signature="xpath()" doc="FIXME This probably won&apos;t work properly" />
          <scope ilk="function" name="raw" />
          <scope ilk="function" name="raw=" />
          <variable name="SPECIALS" attributes="__const__" citdl="Object" />
          <variable name="SUBSTITUTES" attributes="__const__" citdl="Object" />
          <variable name="SLAICEPS" attributes="__const__" citdl="Object" />
          <variable name="SETUTITSBUS" attributes="__const__" citdl="Object" />
          <variable name="NEEDS_A_SECOND_CHECK" attributes="__const__" citdl="Object" />
          <variable name="NUMERICENTITY" attributes="__const__" citdl="Object" />
          <variable name="VALID_CHAR" attributes="__const__" citdl="Object" />
          <variable name="VALID_XML_CHARS" attributes="__const__" citdl="Object" />
          <variable name="VALID_XML_CHARS" attributes="__const__" citdl="Object" />
          <variable name="REFERENCE" attributes="__const__" citdl="Object" />
          <variable name="EREFERENCE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/undefinednamespaceexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="UndefinedNamespaceException" ilk="class" classrefs="ParseException">
          <scope name="new" ilk="function" signature="new( prefix, source, parser )" attributes="__classmethod__ __ctor__" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/relaxng" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="Choice" ilk="class" classrefs="State">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Interleave" ilk="class" classrefs="Choice">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="next_current" ilk="function" signature="next_current( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="OneOrMore" ilk="class" classrefs="State">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Optional" ilk="class" classrefs="State">
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="matches?" ilk="function" signature="matches?(event)" />
            <scope name="next" ilk="function" signature="next( event )" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Ref" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(value)" attributes="__classmethod__ __ctor__" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="RelaxNG" ilk="class" classrefs="Object">
            <import symbol="Validator" />
            <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" doc="FIXME: Namespaces" />
            <scope name="receive" ilk="function" signature="receive(event)" />
            <scope ilk="function" name="count" />
            <scope ilk="function" name="count=" />
            <scope ilk="function" name="current" />
            <scope ilk="function" name="current=" />
            <scope ilk="function" name="references" />
            <variable name="INFINITY" attributes="__const__" citdl="Object" />
            <variable name="EMPTY" attributes="__const__" citdl="Object" />
            <variable name="TEXT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Sequence" ilk="class" classrefs="State">
            <scope name="matches?" ilk="function" signature="matches?(event)" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="State" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( context )" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="previous=" ilk="function" signature="previous=( previous )" />
            <scope name="reset" ilk="function" signature="reset()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="ZeroOrMore" ilk="class" classrefs="Optional">
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="next" ilk="function" signature="next( event )" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/validation" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="Event" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(event_type, event_arg=nil )" attributes="__classmethod__ __ctor__" />
            <scope name="done?" ilk="function" signature="done?()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="single?" ilk="function" signature="single?()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="event_arg" />
            <scope ilk="function" name="event_arg=" />
            <scope ilk="function" name="event_type" />
          </scope>
          <scope name="Validator" ilk="namespace">
            <scope name="dump" ilk="function" signature="dump()" />
            <scope name="reset" ilk="function" signature="reset()" />
            <scope name="validate" ilk="function" signature="validate( event )" />
            <variable name="NILEVENT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/validationexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="ValidationException" ilk="class" classrefs="RuntimeError">
            <scope name="new" ilk="function" signature="new(msg)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xmldecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XMLDecl" ilk="class" classrefs="Child">
          <import symbol="Encoding" />
          <scope name="default" ilk="function" signature="default()" attributes="__classmethod__" doc="Only use this if you do not want the XML declaration to be written; this object is ignored by the XML writer.  Otherwise, instantiate your own XMLDecl and add it to the document. &#xA; Note that XML 1.1 documents *must* include an XML declaration" />
          <scope name="new" ilk="function" signature="new(version=DEFAULT_VERSION, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="dowrite" ilk="function" signature="dowrite()" />
          <scope name="encoding=" ilk="function" signature="encoding=( enc )" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="nowrite" ilk="function" signature="nowrite()" />
          <scope name="old_enc=" ilk="function" signature="old_enc=( enc )" />
          <scope name="write" ilk="function" signature="write(writer, indent=-1, transitive=false, ie_hack=false)" doc="Ignored.  There must be no whitespace before an XML declaration&#xA;Ignored&#xA;Ignored" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
          <scope ilk="function" name="standalone" />
          <scope ilk="function" name="standalone=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
          <scope ilk="function" name="writeencoding" />
          <scope ilk="function" name="writethis" />
          <variable name="DEFAULT_VERSION" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_ENCODING" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_STANDALONE" attributes="__const__" citdl="Object" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xmltokens" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XMLTokens" ilk="namespace">
          <variable name="NCNAME_STR" attributes="__const__" citdl="Object" />
          <variable name="NAME_STR" attributes="__const__" citdl="Object" />
          <variable name="NAMECHAR" attributes="__const__" citdl="Object" />
          <variable name="NAME" attributes="__const__" citdl="Object" />
          <variable name="NMTOKEN" attributes="__const__" citdl="Object" />
          <variable name="NMTOKENS" attributes="__const__" citdl="Object" />
          <variable name="REFERENCE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xpath" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="decode_cp1252" ilk="function" signature="decode_cp1252(str)" doc="Convert to UTF-8" />
        <scope name="encode_cp1252" ilk="function" signature="encode_cp1252(content)" doc="Convert from UTF-8" />
        <variable name="COPYRIGHT" attributes="__const__" citdl="Object" />
        <variable name="DATE" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="REVISION" attributes="__const__" citdl="Object" />
        <scope name="XPath" ilk="class" classrefs="Object">
          <import symbol="Functions" />
          <scope name="each" ilk="function" signature="each(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Iterates over nodes that match the given path, calling the supplied block with the match. The context element&#xA;The xpath to search for.  If not supplied or nil, defaults to &apos;*&apos;&#xA;If supplied, a Hash which defines a namespace mapping&#xA;If supplied, a Hash which maps $variables in the query to values. This can be used to avoid XPath injection attacks or to automatically handle escaping string values. &#xA;  XPath.each( node ) { |el| ... }&#xA; XPath.each( node, &apos;/*[@attr=&apos;v&apos;]&apos; ) { |el| ... }&#xA; XPath.each( node, &apos;ancestor::x&apos; ) { |el| ... }&#xA; XPath.each( node, &apos;/book/publisher/text()=$publisher&apos;, {}, {&quot;publisher&quot;=&gt;&quot;O&apos;Reilly&quot;}) \&#xA;   {|el| ... }" />
          <scope name="first" ilk="function" signature="first(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Finds and returns the first node that matches the supplied xpath. The context element&#xA;The xpath to search for.  If not supplied or nil, returns the first node matching &apos;*&apos;.&#xA;If supplied, a Hash which defines a namespace mapping.&#xA;If supplied, a Hash which maps $variables in the query to values. This can be used to avoid XPath injection attacks or to automatically handle escaping string values. &#xA;  XPath.first( node )&#xA; XPath.first( doc, &quot;//b&quot;} )&#xA; XPath.first( node, &quot;a/x:b&quot;, { &quot;x&quot;=&gt;&quot;http://doofus&quot; } )&#xA; XPath.first( node, &apos;/book/publisher/text()=$publisher&apos;, {}, {&quot;publisher&quot;=&gt;&quot;O&apos;Reilly&quot;})" />
          <scope name="match" ilk="function" signature="match(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Returns an array of nodes matching a given XPath." />
          <variable name="EMPTY_HASH" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xpath_parser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="XPathParser" ilk="class" classrefs="Object">
            <import symbol="XMLTokens" />
            <scope name="abbreviate" ilk="function" signature="abbreviate( path )" />
            <scope name="expand" ilk="function" signature="expand( path )" />
            <scope name="namespaces=" ilk="function" signature="namespaces=( namespaces )" />
            <scope name="parse" ilk="function" signature="parse(path)" />
            <scope name="predicate" ilk="function" signature="predicate(path)" />
            <scope name="predicate_to_string" ilk="function" signature="predicate_to_string( path, &amp;block )" />
            <variable name="LITERAL" attributes="__const__" citdl="Object" />
            <variable name="AXIS" attributes="__const__" citdl="Object" />
            <variable name="NCNAMETEST" attributes="__const__" citdl="Object" />
            <variable name="QNAME" attributes="__const__" citdl="Object" />
            <variable name="NODE_TYPE" attributes="__const__" citdl="Object" />
            <variable name="PI" attributes="__const__" citdl="Object" />
            <variable name="VARIABLE_REFERENCE" attributes="__const__" citdl="Object" />
            <variable name="NUMBER" attributes="__const__" citdl="Object" />
            <variable name="NT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="XPathParser" ilk="class" classrefs="Object">
          <import symbol="XMLTokens" />
          <scope name="new" ilk="function" signature="new( )" attributes="__classmethod__ __ctor__" />
          <scope name="first" ilk="function" signature="first( path_stack, node )" doc="Performs a depth-first (document order) XPath search, and returns the first match.  This is the fastest, lightest way to return a single result. &#xA; FIXME: This method is incomplete!" />
          <scope name="get_first" ilk="function" signature="get_first(path, nodeset)" />
          <scope name="match" ilk="function" signature="match( path_stack, nodeset )" />
          <scope name="namespaces=" ilk="function" signature="namespaces=( namespaces={} )" />
          <scope name="parse" ilk="function" signature="parse(path, nodeset)" />
          <scope name="predicate" ilk="function" signature="predicate(path, nodeset)" />
          <scope name="variables=" ilk="function" signature="variables=( vars={} )" />
          <variable name="LITERAL" attributes="__const__" citdl="Object" />
          <variable name="ALL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/rinda" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="DRbObjectTemplate" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(uri=nil, ref=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new DRbObjectTemplate that will match against +uri+ and +ref+." />
        </scope>
        <scope name="InvalidHashTupleKey" ilk="class" classrefs="RindaError">
        </scope>
        <scope name="RequestCanceledError" ilk="class" classrefs="ThreadError">
        </scope>
        <scope name="RequestExpiredError" ilk="class" classrefs="ThreadError">
        </scope>
        <scope name="RindaError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="SimpleRenewer" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(sec=180)" attributes="__classmethod__ __ctor__" doc="Creates a new SimpleRenewer that keeps an object alive for another +sec+ seconds." />
          <scope name="renew" ilk="function" signature="renew()" doc="Called by the TupleSpace to check if the object is still alive." />
        </scope>
        <scope name="TupleSpaceProxy" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(ts)" attributes="__classmethod__ __ctor__" doc="Creates a new TupleSpaceProxy to wrap +ts+." />
          <scope name="notify" ilk="function" signature="notify(ev, tuple, sec=nil)" doc="Registers for notifications of event +ev+ on the proxied TupleSpace. See TupleSpace#notify" />
          <scope name="read" ilk="function" signature="read(tuple, sec=nil, &amp;block)" doc="Reads +tuple+ from the proxied TupleSpace.  See TupleSpace#read." />
          <scope name="read_all" ilk="function" signature="read_all(tuple)" doc="Reads all tuples matching +tuple+ from the proxied TupleSpace.  See TupleSpace#read_all." />
          <scope name="take" ilk="function" signature="take(tuple, sec=nil, &amp;block)" doc="Takes +tuple+ from the proxied TupleSpace.  See TupleSpace#take." />
          <scope name="write" ilk="function" signature="write(tuple, sec=nil)" doc="Adds +tuple+ to the proxied TupleSpace.  See TupleSpace#write." />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/ring" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="RingFinger" ilk="class" classrefs="Object">
          <scope name="finger" ilk="function" signature="finger()" attributes="__classmethod__" doc="Creates a singleton RingFinger and looks for a RingServer.  Returns the created RingFinger." />
          <scope name="new" ilk="function" signature="new(broadcast_list=@@broadcast_list, port=Ring_PORT)" attributes="__classmethod__ __ctor__" doc="Creates a new RingFinger that will look for RingServers at +port+ on the addresses in +broadcast_list+." />
          <scope name="primary" ilk="function" signature="primary()" attributes="__classmethod__" doc="Returns the first advertised TupleSpace." />
          <scope name="to_a" ilk="function" signature="to_a()" attributes="__classmethod__" doc="Contains all discovered TupleSpaces except for the primary." />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over all discovered TupleSpaces starting with the primary." />
          <scope name="lookup_ring" ilk="function" signature="lookup_ring(timeout=5, &amp;block)" doc="Looks up RingServers waiting +timeout+ seconds.  RingServers will be given +block+ as a callback, which will be called with the remote TupleSpace." />
          <scope name="lookup_ring_any" ilk="function" signature="lookup_ring_any(timeout=5)" doc="Returns the first found remote TupleSpace.  Any further recovered TupleSpaces can be found by calling +to_a+." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Contains all discovered TupleSpaces except for the primary." />
          <scope ilk="function" name="broadcast_list" />
          <scope ilk="function" name="broadcast_list=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="port=" />
          <scope ilk="function" name="primary" />
          <scope ilk="function" name="primary=" />
        </scope>
        <scope name="RingProvider" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(klass, front, desc, renewer = nil)" attributes="__classmethod__ __ctor__" doc="Creates a RingProvider that will provide a +klass+ service running on +front+, with a +description+.  +renewer+ is optional." />
          <scope name="provide" ilk="function" signature="provide()" doc="Advertises this service on the primary remote TupleSpace." />
        </scope>
        <scope name="RingServer" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(ts, port=Ring_PORT)" attributes="__classmethod__ __ctor__" doc="Advertises +ts+ on the UDP broadcast address at +port+." />
          <scope name="do_reply" ilk="function" signature="do_reply()" doc="Pulls lookup tuples out of the TupleSpace and sends their DRb object the address of the local TupleSpace." />
          <scope name="do_write" ilk="function" signature="do_write(msg)" doc="Extracts the response URI from +msg+ and adds it to TupleSpace where it will be picked up by +reply_service+ for notification." />
          <scope name="reply_service" ilk="function" signature="reply_service()" doc="Creates a thread that notifies waiting clients from the TupleSpace." />
          <scope name="write_service" ilk="function" signature="write_service()" doc="Creates a thread that picks up UDP packets and passes them to do_write for decoding." />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/tuplespace" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="NotifyTemplateEntry" ilk="class" classrefs="TemplateEntry">
          <scope name="new" ilk="function" signature="new(place, event, tuple, expires=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new NotifyTemplateEntry that watches +place+ for +event+s that match +tuple+." />
          <scope name="each" ilk="function" signature="each()" doc="Yields event/tuple pairs until this NotifyTemplateEntry expires." />
          <scope name="notify" ilk="function" signature="notify(ev)" doc="Called by TupleSpace to notify this NotifyTemplateEntry of a new event." />
          <scope name="pop" ilk="function" signature="pop()" doc="Retrieves a notification.  Raises RequestExpiredError when this NotifyTemplateEntry expires." />
        </scope>
        <scope name="Template" ilk="class" classrefs="Tuple">
          <scope name="match" ilk="function" signature="match(tuple)" doc="Matches this template against +tuple+.  The +tuple+ must be the same size as the template.  An element with a +nil+ value in a template acts as a wildcard, matching any value in the corresponding position in the tuple.  Elements of the template match the +tuple+ if the are == or ===. &#xA;   Template.new([:foo, 5]).match   Tuple.new([:foo, 5]) # =&gt; true&#xA;  Template.new([:foo, nil]).match Tuple.new([:foo, 5]) # =&gt; true&#xA;  Template.new([String]).match    Tuple.new([&apos;hello&apos;]) # =&gt; true&#xA;&#xA;  Template.new([:foo]).match      Tuple.new([:foo, 5]) # =&gt; false&#xA;  Template.new([:foo, 6]).match   Tuple.new([:foo, 5]) # =&gt; false&#xA;  Template.new([:foo, nil]).match Tuple.new([:foo])    # =&gt; false&#xA;  Template.new([:foo, 6]).match   Tuple.new([:foo])    # =&gt; false" />
        </scope>
        <scope name="TemplateEntry" ilk="class" classrefs="TupleEntry">
          <scope name="match" ilk="function" signature="match(tuple)" doc="Matches this TemplateEntry against +tuple+.  See Template#match for details on how a Template matches a Tuple." />
        </scope>
        <scope name="Tuple" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(ary_or_hash)" attributes="__classmethod__ __ctor__" doc="Creates a new Tuple from +ary_or_hash+ which must be an Array or Hash." />
          <scope name="each" ilk="function" signature="each()" doc="Iterate through the tuple, yielding the index or key, and the value, thus ensuring arrays are iterated similarly to hashes." />
          <scope name="fetch" ilk="function" signature="fetch(k)" doc="Fetches item +k+ from the tuple." />
          <scope name="size" ilk="function" signature="size()" doc="The number of elements in the tuple." />
          <scope name="value" ilk="function" signature="value()" doc="Return the tuple itself" />
        </scope>
        <scope name="TupleBag" ilk="class" classrefs="Object">
          <scope name="delete" ilk="function" signature="delete(tuple)" doc="Removes +tuple+ from the TupleBag." />
          <scope name="delete_unless_alive" ilk="function" signature="delete_unless_alive()" doc="Delete tuples which dead tuples from the TupleBag, returning the deleted tuples." />
          <scope name="find" ilk="function" signature="find(template)" doc="Finds a live tuple that matches +template+." />
          <scope name="find_all" ilk="function" signature="find_all(template)" doc="Finds all live tuples that match +template+." />
          <scope name="find_all_template" ilk="function" signature="find_all_template(tuple)" doc="Finds all tuples in the TupleBag which when treated as templates, match +tuple+ and are alive." />
          <scope name="has_expires?" ilk="function" signature="has_expires?()" doc="+true+ if the TupleBag to see if it has any expired entries." />
          <scope name="push" ilk="function" signature="push(tuple)" doc="Add +tuple+ to the TupleBag." />
          <scope name="TupleBin" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="add" ilk="function" signature="add(tuple)" />
            <scope name="delete" ilk="function" signature="delete(tuple)" />
            <scope name="find" ilk="function" signature="find(&amp;blk)" />
          </scope>
        </scope>
        <scope name="TupleEntry" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(ary, sec=nil)" attributes="__classmethod__ __ctor__" doc="Creates a TupleEntry based on +ary+ with an optional renewer or expiry time +sec+. &#xA; A renewer must implement the +renew+ method which returns a Numeric, nil, or true to indicate when the tuple has expired." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="A TupleEntry is dead when it is canceled or expired." />
          <scope name="cancel" ilk="function" signature="cancel()" doc="Marks this TupleEntry as canceled." />
          <scope name="canceled?" ilk="function" signature="canceled?()" doc="Returns the canceled status." />
          <scope name="expired?" ilk="function" signature="expired?()" doc="Has this tuple expired? (true/false). &#xA; A tuple has expired when its expiry timer based on the +sec+ argument to #initialize runs out." />
          <scope name="fetch" ilk="function" signature="fetch(key)" doc="Fetches +key+ from the tuple." />
          <scope name="make_expires" ilk="function" signature="make_expires(sec=nil)" doc="Returns an expiry Time based on +sec+ which can be one of: +sec+ seconds into the future&#xA;the expiry time is the start of 1970 (i.e. expired)&#xA;it is  Tue Jan 19 03:14:07 GMT Standard Time 2038 (i.e. when UNIX clocks will die)" />
          <scope name="make_tuple" ilk="function" signature="make_tuple(ary)" doc="Creates a Rinda::Tuple for +ary+." />
          <scope name="renew" ilk="function" signature="renew(sec_or_renewer)" doc="Reset the expiry time according to +sec_or_renewer+. &#xA; it is set to expire in the far future.&#xA;it has expired.&#xA;it will expire in that many seconds. &#xA; Otherwise the argument refers to some kind of renewer object which will reset its expiry time." />
          <scope name="size" ilk="function" signature="size()" doc="The size of the tuple." />
          <scope name="value" ilk="function" signature="value()" doc="Return the object which makes up the tuple itself: the Array or Hash." />
          <scope ilk="function" name="expires" />
          <scope ilk="function" name="expires=" />
        </scope>
        <scope name="TupleSpace" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(period=60)" attributes="__classmethod__ __ctor__" doc="Creates a new TupleSpace.  +period+ is used to control how often to look for dead tuples after modifications to the TupleSpace. &#xA; If no dead tuples are found +period+ seconds after the last modification, the TupleSpace will stop looking for dead tuples." />
          <scope name="move" ilk="function" signature="move(port, tuple, sec=nil)" doc="Moves +tuple+ to +port+." />
          <scope name="notify" ilk="function" signature="notify(event, tuple, sec=nil)" doc="Registers for notifications of +event+.  Returns a NotifyTemplateEntry. See NotifyTemplateEntry for examples of how to listen for notifications. &#xA; +event+ can be: A tuple was added&#xA;A tuple was taken or moved&#xA;A tuple was lost after being overwritten or expiring &#xA; The TupleSpace will also notify you of the &apos;close&apos; event when the NotifyTemplateEntry has expired." />
          <scope name="read" ilk="function" signature="read(tuple, sec=nil)" doc="Reads +tuple+, but does not remove it." />
          <scope name="read_all" ilk="function" signature="read_all(tuple)" doc="Returns all tuples matching +tuple+.  Does not remove the found tuples." />
          <scope name="take" ilk="function" signature="take(tuple, sec=nil, &amp;block)" doc="Removes +tuple+" />
          <scope name="write" ilk="function" signature="write(tuple, sec=nil)" doc="Adds +tuple+" />
        </scope>
        <scope name="WaitTemplateEntry" ilk="class" classrefs="TemplateEntry">
          <scope name="new" ilk="function" signature="new(place, ary, expires=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="cancel" ilk="function" signature="cancel()" />
          <scope name="read" ilk="function" signature="read(tuple)" />
          <scope name="signal" ilk="function" signature="signal()" />
          <scope name="wait" ilk="function" signature="wait()" />
          <scope ilk="function" name="found" />
        </scope>
      </scope>
    </scope>
    <scope name="ripper" ilk="blob" lang="Ruby">
      <scope name="Ripper" ilk="class" classrefs="Object">
        <scope name="lex" ilk="function" signature="lex(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Tokenizes Ruby program and returns an Array of Array, which is formatted like [[lineno, column], type, token]. &#xA;   require &apos;ripper&apos;&#xA;  require &apos;pp&apos;&#xA;  p Ripper.lex(&quot;def m(a) nil end&quot;)&#xA;    =&gt; [[[1,  0], :on_kw,     &quot;def&quot;],&#xA;         [[1,  3], :on_sp,     &quot; &quot;  ],&#xA;         [[1,  4], :on_ident,  &quot;m&quot;  ],&#xA;         [[1,  5], :on_lparen, &quot;(&quot;  ],&#xA;         [[1,  6], :on_ident,  &quot;a&quot;  ],&#xA;         [[1,  7], :on_rparen, &quot;)&quot;  ],&#xA;         [[1,  8], :on_sp,     &quot; &quot;  ],&#xA;         [[1,  9], :on_kw,     &quot;nil&quot;],&#xA;         [[1, 12], :on_sp,     &quot; &quot;  ]," />
        <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Create a new Ripper object. _src_ must be a String, an IO, or an Object which has #gets method. &#xA; This method does not starts parsing. See also Ripper#parse and Ripper.parse." />
        <scope name="parse" ilk="function" signature="parse(src, filename = &apos;(ripper)&apos;, lineno = 1)" attributes="__classmethod__" doc="Parses Ruby program read from _src_. _src_ must be a String or a IO or a object which has #gets method." />
        <scope name="sexp" ilk="function" signature="sexp(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc=" Parses +src+ and create S-exp tree. This method is for mainly developper use. &#xA;   require &apos;ripper&apos;&#xA;  require &apos;pp&#xA;  pp Ripper.sexp(&quot;def m(a) nil end&quot;)&#xA;    =&gt; [:program,&#xA;         [:stmts_add,&#xA;          [:stmts_new],&#xA;          [:def,&#xA;           [:@ident, &quot;m&quot;, [1, 4]],&#xA;           [:paren, [:params, [[:@ident, &quot;a&quot;, [1, 6]]], nil, nil, nil]],&#xA;           [:bodystmt,&#xA;            [:stmts_add, [:stmts_new], [:var_ref, [:@kw, &quot;nil&quot;, [1, 9]]]],&#xA;            nil," />
        <scope name="sexp_raw" ilk="function" signature="sexp_raw(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" />
        <scope name="slice" ilk="function" signature="slice(src, pattern, n = 0)" attributes="__classmethod__" doc="&#xA; Parses +src+ and return a string which was matched to +pattern+. +pattern+ should be described as Regexp. &#xA;   require &apos;ripper&apos;&#xA;&#xA;  p Ripper.slice(&apos;def m(a) nil end&apos;, &apos;ident&apos;)                   =&gt; &quot;m&quot;&#xA;  p Ripper.slice(&apos;def m(a) nil end&apos;, &apos;[ident lparen rparen]+&apos;)  =&gt; &quot;m(a)&quot;&#xA;  p Ripper.slice(&quot;&lt;&lt;EOS\nstring\nEOS&quot;,&#xA;                 &apos;heredoc_beg nl $(tstring_content*) heredoc_end&apos;, 1)&#xA;      =&gt; &quot;string\n&quot;" />
        <scope name="tokenize" ilk="function" signature="tokenize(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Tokenizes Ruby program and returns an Array of String." />
        <scope name="column" ilk="function" signature="column()" doc="Return column number of current parsing line. This number starts from 0." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Return encoding of the source." />
        <scope name="end_seen?" ilk="function" signature="end_seen?()" doc="Return if parsed source ended by +\_\_END\_\_+. This number starts from 1." />
        <scope name="filename" ilk="function" signature="filename()" doc="Return current parsing filename." />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Return line number of current parsing line. This number starts from 1." />
        <scope name="parse" ilk="function" signature="parse()" doc="Start parsing and returns the value of the root action." />
        <scope name="yydebug" ilk="function" signature="yydebug()" doc="Get yydebug." />
        <scope name="yydebug=" ilk="function" signature="yydebug=(p1)" doc="Set yydebug." />
        <variable name="PARSER_EVENTS" attributes="__const__" citdl="Object" />
        <variable name="SCANNER_EVENTS" attributes="__const__" citdl="Object" />
        <variable name="EVENTS" attributes="__const__" citdl="Object" />
        <scope name="Filter" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__ __ctor__" />
          <scope name="column" ilk="function" signature="column()" doc="The column number of the current token. This value starts from 0. This method is valid only in event handlers." />
          <scope name="filename" ilk="function" signature="filename()" doc="The file name of the input." />
          <scope name="lineno" ilk="function" signature="lineno()" doc="The line number of the current token. This value starts from 1. This method is valid only in event handlers." />
          <scope name="parse" ilk="function" signature="parse(init = nil)" doc="Starts parsing.  _init_ is a data accumulator. It is passed to the next event handler (as of Enumerable#inject)." />
        </scope>
        <scope name="Lexer" ilk="class" classrefs="::Ripper">
        </scope>
        <scope name="SexpBuilder" ilk="class" classrefs="::Ripper">
        </scope>
        <scope name="SexpBuilderPP" ilk="class" classrefs="::Ripper">
        </scope>
        <scope name="TokenPattern" ilk="class" classrefs="Object">
          <scope name="CompileError" ilk="class" classrefs="Error">
          </scope>
          <scope name="Error" ilk="class" classrefs="::StandardError">
          </scope>
          <scope name="MatchData" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(tokens, match)" attributes="__classmethod__ __ctor__" />
            <scope name="string" ilk="function" signature="string(n = 0)" />
          </scope>
          <scope name="MatchError" ilk="class" classrefs="Error">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <variable name="ITUNES_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="ITUNES_URI" attributes="__const__" citdl="Object" />
        <variable name="SY_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="SY_URI" attributes="__const__" citdl="Object" />
        <variable name="AVAILABLE_PARSER_LIBRARIES" attributes="__const__" citdl="Object" />
        <variable name="AVAILABLE_PARSERS" attributes="__const__" citdl="Object" />
        <variable name="TRACKBACK_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="TRACKBACK_URI" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="URI" attributes="__const__" citdl="Object" />
        <variable name="DEBUG" attributes="__const__" citdl="Object" />
        <variable name="DC_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="DC_URI" attributes="__const__" citdl="Object" />
        <variable name="CONTENT_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="CONTENT_URI" attributes="__const__" citdl="Object" />
        <variable name="SLASH_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="SLASH_URI" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_URI" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_ELEMENTS" attributes="__const__" citdl="Object" />
        <variable name="TAXO_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="TAXO_URI" attributes="__const__" citdl="Object" />
        <variable name="TAXO_ELEMENTS" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="rss/0.9" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="namespace">
              <scope name="Enclosure" ilk="class" classrefs="EnclosureBase">
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="CloudBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="SkipDaysBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                <scope name="Day" ilk="class" classrefs="DayBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, days)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="SkipHoursBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                <scope name="Hour" ilk="class" classrefs="HourBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, hours)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="EnclosureBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="CloudBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="SkipDaysBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                <scope name="Day" ilk="class" classrefs="DayBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="SkipHoursBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                <scope name="Hour" ilk="class" classrefs="HourBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="EnclosureBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="RSS09::Channel::Cloud">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="RSS09::Channel::SkipDays">
                <scope name="Day" ilk="class" classrefs="RSS09::Channel::SkipDays::Day">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="RSS09::Channel::SkipHours">
                <scope name="Hour" ilk="class" classrefs="RSS09::Channel::SkipHours::Hour">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="RSS09::Items::Item::Enclosure">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="RSS09" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="NSPOOL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/1.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="class" classrefs="ItemsBase">
            <scope name="to_feed" ilk="function" signature="to_feed(feed)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="ItemsBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="TextinputBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="ItemsBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="TextinputBase">
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Bag" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" />
            <scope name="setup_maker" ilk="function" />
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Seq" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" />
            <scope name="setup_maker" ilk="function" />
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Textinput" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="RSS10" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="NSPOOL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/2.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="namespace">
              <scope name="Guid" ilk="class" classrefs="GuidBase">
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="GuidBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="GuidBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="RSS09::Items::Item::Guid">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/atom" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Atom" ilk="namespace">
          <variable name="URI" attributes="__const__" citdl="Object" />
          <variable name="XHTML_URI" attributes="__const__" citdl="Object" />
          <scope name="CommonModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="need_parent?" ilk="function" signature="need_parent?()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <variable name="NSPOOL" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="DateConstruct" ilk="namespace">
            <import symbol="ContentModel" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
          </scope>
          <scope name="DuplicateLinkChecker" ilk="namespace">
            <scope name="validate_duplicate_links" ilk="function" signature="validate_duplicate_links(links)" />
          </scope>
          <scope name="Entry" ilk="class" classrefs="RSS::Element">
            <import symbol="CommonModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="DuplicateLinkChecker" />
            <import symbol="RootElementMixin" />
            <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
            <scope name="have_author?" ilk="function" signature="have_author?()" />
            <scope name="items" ilk="function" signature="items()" />
            <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          </scope>
          <scope name="Feed" ilk="class" classrefs="RSS::Element">
            <import symbol="CommonModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="DuplicateLinkChecker" />
            <import symbol="RootElementMixin" />
            <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
            <scope name="have_author?" ilk="function" signature="have_author?()" />
            <scope name="Author" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="PersonConstruct" />
            </scope>
            <scope name="Category" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
            </scope>
            <scope name="Contributor" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="PersonConstruct" />
            </scope>
            <scope name="Entry" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="DuplicateLinkChecker" />
              <scope name="have_author?" ilk="function" signature="have_author?(check_parent=true)" />
              <scope name="Content" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <scope name="xml_getter" ilk="function" signature="xml_getter()" attributes="__classmethod__" />
                <scope name="xml_setter" ilk="function" signature="xml_setter()" attributes="__classmethod__" />
                <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
                <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
                <scope name="inline_html?" ilk="function" signature="inline_html?()" />
                <scope name="inline_other?" ilk="function" signature="inline_other?()" />
                <scope name="inline_other_base64?" ilk="function" signature="inline_other_base64?()" />
                <scope name="inline_other_text?" ilk="function" signature="inline_other_text?()" />
                <scope name="inline_other_xml?" ilk="function" signature="inline_other_xml?()" />
                <scope name="inline_text?" ilk="function" signature="inline_text?()" />
                <scope name="inline_xhtml?" ilk="function" signature="inline_xhtml?()" />
                <scope name="mime_split" ilk="function" signature="mime_split()" />
                <scope name="need_base64_encode?" ilk="function" signature="need_base64_encode?()" />
                <scope name="out_of_line?" ilk="function" signature="out_of_line?()" />
                <scope name="xhtml" ilk="function" signature="xhtml()" />
                <scope name="xml" ilk="function" />
                <scope ilk="function" name="xml=" />
              </scope>
              <scope name="Published" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <import symbol="DateConstruct" />
              </scope>
              <scope name="Source" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <scope name="have_author?" ilk="function" signature="have_author?()" />
              </scope>
              <scope name="Summary" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <import symbol="TextConstruct" />
              </scope>
            </scope>
            <scope name="Generator" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Icon" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
            <scope name="Id" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
            <scope name="Link" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
            </scope>
            <scope name="Logo" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
              <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            </scope>
            <scope name="Rights" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Subtitle" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Title" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Updated" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="DateConstruct" />
            </scope>
          </scope>
          <scope name="PersonConstruct" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            <scope name="Email" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Name" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Uri" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
          </scope>
          <scope name="TextConstruct" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="xml_getter" ilk="function" signature="xml_getter()" attributes="__classmethod__" />
            <scope name="xml_setter" ilk="function" signature="xml_setter()" attributes="__classmethod__" />
            <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
            <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
            <scope name="xhtml" ilk="function" />
            <scope ilk="function" name="xhtml=" />
          </scope>
          <scope name="URIContentModel" ilk="namespace">
            <import symbol="ContentModel" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Atom" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="ClassMethods" ilk="namespace">
              <scope name="content_type" ilk="function" signature="content_type()" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Atom" ilk="namespace">
            <scope name="Entry" ilk="class" classrefs="RSSBase">
              <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
            </scope>
            <scope name="Feed" ilk="class" classrefs="RSSBase">
              <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Categories" ilk="namespace">
            <scope name="Category" ilk="class" classrefs="CategoryBase">
              <import symbol="AtomCategory" />
              <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Content" ilk="class" classrefs="ContentBase">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="namespace">
              <scope name="Source" ilk="class" classrefs="SourceBase">
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                  <import symbol="AtomGenerator" />
                  <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
                </scope>
                <scope name="Icon" ilk="class" classrefs="IconBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="namespace">
              <scope name="Source" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="CategoryBase">
                    <import symbol="AtomCategory" />
                    <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Links" ilk="namespace">
              <scope name="Link" ilk="class" classrefs="LinkBase">
                <import symbol="AtomLink" />
                <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Logo" ilk="class" classrefs="LogoBase">
              <import symbol="AtomLogo" />
              <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Links" ilk="namespace">
            <scope name="Link" ilk="class" classrefs="LinkBase">
              <import symbol="AtomLink" />
              <scope name="not_set_name" ilk="function" signature="not_set_name()" attributes="__classmethod__" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="namespace">
                <scope name="Author" ilk="class" classrefs="AuthorBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="CategoryBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="namespace">
                <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="namespace">
                <scope name="Link" ilk="class" classrefs="LinkBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Title" ilk="class" classrefs="TitleBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="AuthorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="CategoryBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Content" ilk="class" classrefs="ContentBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="namespace">
                  <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="namespace">
                  <scope name="Link" ilk="class" classrefs="LinkBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Rights" ilk="class" classrefs="RightsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="SourceBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Icon" ilk="class" classrefs="IconBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Logo" ilk="class" classrefs="LogoBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Rights" ilk="class" classrefs="RightsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Subtitle" ilk="class" classrefs="SubtitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Title" ilk="class" classrefs="TitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="namespace">
                    <scope name="Author" ilk="class" classrefs="AuthorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="namespace">
                    <scope name="Category" ilk="class" classrefs="CategoryBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="namespace">
                    <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="LinkBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Title" ilk="class" classrefs="TitleBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="namespace">
                <scope name="Author" ilk="class" classrefs="AuthorBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="CategoryBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="namespace">
                <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="namespace">
                <scope name="Link" ilk="class" classrefs="LinkBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Title" ilk="class" classrefs="TitleBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="AuthorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="CategoryBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Content" ilk="class" classrefs="ContentBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="namespace">
                  <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="namespace">
                  <scope name="Link" ilk="class" classrefs="LinkBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Rights" ilk="class" classrefs="RightsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="SourceBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Icon" ilk="class" classrefs="IconBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Logo" ilk="class" classrefs="LogoBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Rights" ilk="class" classrefs="RightsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Subtitle" ilk="class" classrefs="SubtitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Title" ilk="class" classrefs="TitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="namespace">
                    <scope name="Author" ilk="class" classrefs="AuthorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="namespace">
                    <scope name="Category" ilk="class" classrefs="CategoryBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="namespace">
                    <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="LinkBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Title" ilk="class" classrefs="TitleBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="RSS09::Channel::Categories::Category">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="RSS09::Items::Item::Authors::Author">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="RSS09::Items::Item::Categories::Category">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="RSS09::Items::Item::Source">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="RSS09::Items::Item::Source::Links::Link">
                      <scope name="to_feed" ilk="function" signature="to_feed(rss, source)" />
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Li" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <import symbol="RSS10" />
            <import symbol="RSS10" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/content" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Atom" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
          </scope>
        </scope>
        <scope name="ContentModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/converter" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Converter" ilk="class" classrefs="Object">
          <import symbol="Utils" />
          <scope name="new" ilk="function" signature="new(to_enc, from_enc=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="convert" ilk="function" signature="convert(value)" />
          <scope name="def_convert" ilk="function" signature="def_convert(depth=0)" />
          <scope name="def_else_enc" ilk="function" signature="def_else_enc(to_enc, from_enc)" />
          <scope name="def_iconv_convert" ilk="function" signature="def_iconv_convert(to_enc, from_enc, depth=0)" />
          <scope name="def_same_enc" ilk="function" signature="def_same_enc()" />
          <scope name="def_to_euc_jp_from_iso_2022_jp" ilk="function" signature="def_to_euc_jp_from_iso_2022_jp()" />
          <scope name="def_to_euc_jp_from_shift_jis" ilk="function" signature="def_to_euc_jp_from_shift_jis()" />
          <scope name="def_to_euc_jp_from_utf_8" ilk="function" signature="def_to_euc_jp_from_utf_8()" />
          <scope name="def_to_iso_2022_jp_from_euc_jp" ilk="function" signature="def_to_iso_2022_jp_from_euc_jp()" />
          <scope name="def_to_iso_8859_1_from_utf_8" ilk="function" signature="def_to_iso_8859_1_from_utf_8()" />
          <scope name="def_to_shift_jis_from_euc_jp" ilk="function" signature="def_to_shift_jis_from_euc_jp()" />
          <scope name="def_to_shift_jis_from_utf_8" ilk="function" signature="def_to_shift_jis_from_utf_8()" />
          <scope name="def_to_utf_8_from_euc_jp" ilk="function" signature="def_to_utf_8_from_euc_jp()" />
          <scope name="def_to_utf_8_from_iso_8859_1" ilk="function" signature="def_to_utf_8_from_iso_8859_1()" />
          <scope name="def_to_utf_8_from_shift_jis" ilk="function" signature="def_to_utf_8_from_shift_jis()" />
          <scope name="def_uconv_convert_if_can" ilk="function" signature="def_uconv_convert_if_can(meth, to_enc, from_enc, nkf_arg)" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/dublincore" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseDublinCoreModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" />
        </scope>
        <scope name="DublinCoreModel" ilk="namespace">
          <variable name="TEXT_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="DATE_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_NAME_INFOS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="TEXT_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="DATE_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_NAME_INFOS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="DublinCoreModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_dublin_core" ilk="function" signature="install_dublin_core(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/image" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="ImageFaviconModel" ilk="namespace">
          <import symbol="ImageModelUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="ImageFavicon" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="image_size=" ilk="function" signature="image_size=(new_value)" />
            <scope name="set_size" ilk="function" signature="set_size(new_value)" />
            <scope name="size=" ilk="function" signature="size=(new_value)" />
            <variable name="AVAILABLE_SIZES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="ImageItemModel" ilk="namespace">
          <import symbol="ImageModelUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="ImageItem" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="ImageModelUtils" ilk="namespace">
          <scope name="validate_one_tag_name" ilk="function" signature="validate_one_tag_name(ignore_unknown_element, name, tags)" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageFaviconModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_image_favicon" ilk="function" signature="install_image_favicon(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageItemModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_image_item" ilk="function" signature="install_image_item(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="ImageBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="ImageBase">
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Image" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/itunes" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="ITunesBaseModel" ilk="namespace">
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ITunesChannelModel" ilk="namespace">
          <import symbol="ITunesBaseModel" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
          <scope name="ITunesCategory" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="ITunesImage" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="ITunesOwner" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="ITunesItemModel" ilk="namespace">
          <import symbol="ITunesBaseModel" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
          <scope name="ITunesDuration" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="construct" ilk="function" signature="construct(hour, minute, second)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="parse" ilk="function" signature="parse(duration, do_validate=true)" attributes="__classmethod__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="content=" ilk="function" signature="content=(value)" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="hour=" ilk="function" signature="hour=(hour)" />
            <scope name="minute=" ilk="function" signature="minute=(minute)" />
            <scope name="second=" ilk="function" signature="second=(second)" />
            <scope name="value=" ilk="function" signature="value=(value)" />
            <scope ilk="function" name="hour" />
            <scope ilk="function" name="minute" />
            <scope ilk="function" name="second" />
          </scope>
        </scope>
        <scope name="ITunesModelUtils" ilk="namespace">
          <import symbol="Utils" />
          <scope name="def_class_accessor" ilk="function" signature="def_class_accessor(klass, name, type, *args)" />
          <scope name="def_element_class_accessor" ilk="function" signature="def_element_class_accessor(klass, name, full_name, klass_name, recommended_attribute_name=nil)" />
          <scope name="def_elements_class_accessor" ilk="function" signature="def_elements_class_accessor(klass, name, full_name, klass_name, plural_name, recommended_attribute_name=nil)" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesCategories" ilk="namespace">
              <scope name="ITunesCategory" ilk="class" classrefs="ITunesCategoryBase">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesImage" ilk="class" classrefs="ITunesImageBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesOwner" ilk="class" classrefs="ITunesOwnerBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesBaseModel" ilk="namespace">
            <scope name="def_class_accessor" ilk="function" signature="def_class_accessor(klass, name, type, *args)" />
            <scope name="def_csv_accessor" ilk="function" signature="def_csv_accessor(klass, full_name)" />
            <scope name="def_elements_class_accessor" ilk="function" signature="def_elements_class_accessor(klass, name, full_name, full_plural_name, klass_name, plural_klass_name, recommended_attribute_name=nil)" />
            <scope name="def_yes_clean_other_accessor" ilk="function" signature="def_yes_clean_other_accessor(klass, full_name)" />
            <scope name="def_yes_other_accessor" ilk="function" signature="def_yes_other_accessor(klass, full_name)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesItemModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="add_maker" ilk="function" signature="add_maker(version, normalized_version, maker)" attributes="__classmethod__" />
          <scope name="make" ilk="function" signature="make(version, &amp;block)" attributes="__classmethod__" />
          <scope name="makers" ilk="function" signature="makers()" attributes="__classmethod__" />
          <scope name="supported?" ilk="function" signature="supported?(version)" attributes="__classmethod__" />
          <scope name="versions" ilk="function" signature="versions()" attributes="__classmethod__" />
          <variable name="MAKERS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/0.9" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="class" classrefs="RSSBase">
            <scope name="new" ilk="function" signature="new(feed_version)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="class" classrefs="RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;0.91&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="class" classrefs="RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;0.92&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/1.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="class" classrefs="RSSBase">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/2.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="class" classrefs="RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;2.0&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/atom" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="AtomCategory" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomGenerator" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomLink" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomLogo" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomPersons" ilk="namespace">
            <scope name="def_atom_persons" ilk="function" signature="def_atom_persons(klass, name, maker_name, plural=nil)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/base" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="AtomPersonConstructBase" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomTextConstruct" ilk="namespace">
            <scope name="def_atom_text_construct" ilk="function" signature="def_atom_text_construct(klass, name, maker_name, klass_name=nil, atom_klass_name=nil)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomTextConstructBase" ilk="namespace">
            <import symbol="EnsureXMLContent" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="EnsureXMLContent" ilk="namespace">
              <scope name="included" ilk="function" signature="included(base)" attributes="__classmethod__" />
              <scope name="ensure_xml_content" ilk="function" signature="ensure_xml_content(content)" />
              <scope name="xhtml=" ilk="function" signature="xhtml=(content)" />
              <scope name="xml_content=" ilk="function" signature="xml_content=(content)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="AuthorsBase" ilk="class" classrefs="Base">
              <scope name="AuthorBase" ilk="class" classrefs="Base">
                <import symbol="AtomPersonConstructBase" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CategoriesBase" ilk="class" classrefs="Base">
              <scope name="CategoryBase" ilk="class" classrefs="Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CloudBase" ilk="class" classrefs="Base">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ContributorsBase" ilk="class" classrefs="Base">
              <scope name="ContributorBase" ilk="class" classrefs="Base">
                <import symbol="AtomPersonConstructBase" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CopyrightBase" ilk="class" classrefs="Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="DescriptionBase" ilk="class" classrefs="Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="GeneratorBase" ilk="class" classrefs="Base">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="LinksBase" ilk="class" classrefs="Base">
              <scope name="LinkBase" ilk="class" classrefs="Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="SkipDaysBase" ilk="class" classrefs="Base">
              <scope name="DayBase" ilk="class" classrefs="Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="SkipHoursBase" ilk="class" classrefs="Base">
              <scope name="HourBase" ilk="class" classrefs="Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="TitleBase" ilk="class" classrefs="Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Copyright" ilk="class" classrefs="CopyrightBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Copyright" ilk="class" classrefs="CopyrightBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="RSS09::Items::Item::Authors">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="SetupDefaultDate" ilk="namespace">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="SetupDefaultLanguage" ilk="namespace">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="XMLStyleSheets" ilk="class" classrefs="Base">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/dublincore" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ImageBase" ilk="class" classrefs="Base">
            <import symbol="DublinCoreModel" />
            <scope name="link" ilk="function" signature="link()" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TextinputBase" ilk="class" classrefs="Base">
            <import symbol="DublinCoreModel" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/entry" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Description" ilk="class" classrefs="DescriptionBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Description" ilk="class" classrefs="DescriptionBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Description" ilk="class" classrefs="DescriptionBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Description" ilk="class" classrefs="DescriptionBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/feed" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="Categories" ilk="class" classrefs="CategoriesBase">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="namespace">
              <scope name="Source" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Links" ilk="class" classrefs="LinksBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Links" ilk="class" classrefs="LinksBase">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="class" classrefs="LinksBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="class" classrefs="LinksBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="LinksBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="class" classrefs="LinksBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="class" classrefs="LinksBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="LinksBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="RSS09::Channel::Categories">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="RSS09::Items::Item::Categories">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="RSS09::Items::Item::Source::Links">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, source)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/image" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ImageFaviconModel" ilk="namespace">
            <scope name="ImageFaviconBase" ilk="class" classrefs="Base">
              <import symbol="Maker::DublinCoreModel" />
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="about" />
              <scope ilk="function" name="about=" />
              <scope ilk="function" name="image_size" />
              <scope ilk="function" name="image_size=" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageItemModel" ilk="namespace">
            <scope name="ImageItemBase" ilk="class" classrefs="Base">
              <import symbol="Maker::DublinCoreModel" />
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="about" />
              <scope ilk="function" name="about=" />
              <scope ilk="function" name="image_height" />
              <scope ilk="function" name="image_height=" />
              <scope ilk="function" name="image_width" />
              <scope ilk="function" name="image_width=" />
              <scope ilk="function" name="resource" />
              <scope ilk="function" name="resource=" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/itunes" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesCategories" ilk="class" classrefs="ITunesCategoriesBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesCategoriesBase" ilk="class" classrefs="Base">
              <scope name="ITunesCategoryBase" ilk="class" classrefs="Base">
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                <scope name="to_feed_for_categories" ilk="function" signature="to_feed_for_categories(feed, current)" />
                <scope ilk="function" name="text" />
                <scope ilk="function" name="text=" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesImageBase" ilk="class" classrefs="Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="href" />
              <scope ilk="function" name="href=" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesOwnerBase" ilk="class" classrefs="Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesItemModel" ilk="namespace">
            <scope name="ITunesDurationBase" ilk="class" classrefs="Base">
              <scope name="content=" ilk="function" signature="content=(content)" />
              <scope name="hour=" ilk="function" signature="hour=(hour)" />
              <scope name="minute=" ilk="function" signature="minute=(minute)" />
              <scope name="second=" ilk="function" signature="second=(second)" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="content" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/taxonomy" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="class" classrefs="Base">
            <import symbol="DublinCoreModel" />
            <import symbol="Maker::ITunesChannelModel" />
            <import symbol="Maker::ImageFaviconModel" />
            <import symbol="SetupDefaultDate" />
            <import symbol="SyndicationModel" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="date=" ilk="function" signature="date=(_date)" />
            <scope name="icon" ilk="function" signature="icon()" />
            <scope name="icon=" ilk="function" signature="icon=(url)" />
            <scope name="lastBuildDate=" ilk="function" signature="lastBuildDate=(_date)" />
            <scope name="logo" ilk="function" signature="logo()" />
            <scope name="logo=" ilk="function" signature="logo=(url)" />
            <scope name="pubDate" ilk="function" signature="pubDate()" />
            <scope name="pubDate=" ilk="function" signature="pubDate=(date)" />
            <scope name="updated" ilk="function" signature="updated()" />
            <scope name="updated=" ilk="function" signature="updated=(date)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSSBase" ilk="class" classrefs="Base">
            <import symbol="TaxonomyTopicModel" />
            <scope name="make" ilk="function" signature="make(*args, &amp;block)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(feed_version)" attributes="__classmethod__ __ctor__" />
            <scope name="make" ilk="function" signature="make()" />
            <scope name="to_feed" ilk="function" signature="to_feed()" />
            <scope ilk="function" name="encoding" />
            <scope ilk="function" name="encoding=" />
            <scope ilk="function" name="feed_version" />
            <scope ilk="function" name="standalone" />
            <scope ilk="function" name="standalone=" />
            <scope ilk="function" name="version" />
            <scope ilk="function" name="version=" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicModel" ilk="namespace">
            <scope name="TaxonomyTopicsBase" ilk="class" classrefs="Base">
              <scope name="TaxonomyTopicBase" ilk="class" classrefs="Base">
                <import symbol="DublinCoreModel" />
                <import symbol="TaxonomyTopicsModel" />
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope ilk="function" name="value" />
                <scope ilk="function" name="value=" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicsModel" ilk="namespace">
            <scope name="TaxonomyTopicsBase" ilk="class" classrefs="Base">
              <scope ilk="function" name="resources" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/trackback" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ItemsBase" ilk="class" classrefs="Base">
            <scope name="new" ilk="function" signature="new(maker)" attributes="__classmethod__ __ctor__" />
            <scope name="normalize" ilk="function" signature="normalize()" />
            <scope ilk="function" name="do_sort" />
            <scope ilk="function" name="do_sort=" />
            <scope ilk="function" name="max_size" />
            <scope ilk="function" name="max_size=" />
            <scope name="ItemBase" ilk="class" classrefs="Base">
              <import symbol="ContentModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="Maker::ITunesItemModel" />
              <import symbol="Maker::ImageItemModel" />
              <import symbol="SetupDefaultDate" />
              <import symbol="SlashModel" />
              <import symbol="TaxonomyTopicsModel" />
              <import symbol="TrackBackModel" />
              <scope name="date=" ilk="function" signature="date=(_date)" />
              <scope name="pubDate" ilk="function" signature="pubDate()" />
              <scope name="pubDate=" ilk="function" signature="pubDate=(date)" />
              <scope name="updated" ilk="function" signature="updated()" />
              <scope name="updated=" ilk="function" signature="updated=(date)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TrackBackModel" ilk="namespace">
            <scope name="TrackBackAboutsBase" ilk="class" classrefs="Base">
              <scope name="TrackBackAboutBase" ilk="class" classrefs="Base">
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                <scope ilk="function" name="value" />
                <scope ilk="function" name="value=" />
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/parser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseListener" ilk="class" classrefs="Object">
          <scope name="available_tags" ilk="function" signature="available_tags(uri)" attributes="__classmethod__" doc="return the tag_names for setters associated with uri" />
          <scope name="class_name" ilk="function" signature="class_name(uri, tag_name)" attributes="__classmethod__" doc="retrieve class_name for the supplied uri and tag_name If it doesn&apos;t exist, capitalize the tag_name" />
          <scope name="getter" ilk="function" signature="getter(uri, tag_name)" attributes="__classmethod__" />
          <scope name="install_class_name" ilk="function" signature="install_class_name(uri, tag_name, class_name)" attributes="__classmethod__" doc="record class_name for the supplied uri and tag_name" />
          <scope name="install_get_text_element" ilk="function" signature="install_get_text_element(uri, name, accessor_base)" attributes="__classmethod__" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="register_uri" ilk="function" signature="register_uri(uri, name)" attributes="__classmethod__" doc="register uri against this name." />
          <scope name="setter" ilk="function" signature="setter(uri, tag_name)" attributes="__classmethod__" doc="return the setter for the uri, tag_name pair, or nil." />
          <scope name="uri_registered?" ilk="function" signature="uri_registered?(uri, name)" attributes="__classmethod__" doc="test if this uri is registered against this name" />
        </scope>
        <scope name="BaseParser" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(rss)" attributes="__classmethod__ __ctor__" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="do_validate" ilk="function" signature="do_validate()" />
          <scope name="do_validate=" ilk="function" signature="do_validate=(new_value)" />
          <scope name="ignore_unknown_element" ilk="function" signature="ignore_unknown_element()" />
          <scope name="ignore_unknown_element=" ilk="function" signature="ignore_unknown_element=(new_value)" />
          <scope name="parse" ilk="function" signature="parse()" />
          <scope name="rss" ilk="function" signature="rss()" />
        </scope>
        <scope name="ListenerMixin" ilk="namespace">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="instruction" ilk="function" signature="instruction(name, content)" />
          <scope name="tag_end" ilk="function" signature="tag_end(name)" />
          <scope name="tag_start" ilk="function" signature="tag_start(name, attributes)" />
          <scope name="text" ilk="function" signature="text(data)" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="set instance vars for version, encoding, standalone" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <scope ilk="function" name="ignore_unknown_element" />
          <scope ilk="function" name="ignore_unknown_element=" />
          <scope ilk="function" name="rss" />
          <variable name="CONTENT_PATTERN" attributes="__const__" citdl="Object" />
          <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Base" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="add_need_initialize_variable" ilk="function" signature="add_need_initialize_variable(variable_name, init_value=nil, &amp;init_block)" attributes="__classmethod__" />
            <scope name="add_other_element" ilk="function" signature="add_other_element(variable_name)" attributes="__classmethod__" />
            <scope name="def_array_element" ilk="function" signature="def_array_element(name, plural=nil, klass_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_element" ilk="function" signature="def_classed_element(name, class_name=nil, attribute_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_element_without_accessor" ilk="function" signature="def_classed_element_without_accessor(name, class_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_elements" ilk="function" signature="def_classed_elements(name, attribute, plural_class_name=nil, plural_name=nil, new_name=nil)" attributes="__classmethod__" />
            <scope name="def_csv_element" ilk="function" signature="def_csv_element(name, type=nil)" attributes="__classmethod__" />
            <scope name="def_other_element" ilk="function" signature="def_other_element(name)" attributes="__classmethod__" />
            <scope name="def_other_element_without_accessor" ilk="function" signature="def_other_element_without_accessor(name)" attributes="__classmethod__" />
            <scope name="inherited" ilk="function" signature="inherited(subclass)" attributes="__classmethod__" />
            <scope name="inherited_base" ilk="function" signature="inherited_base()" attributes="__classmethod__" />
            <scope name="need_initialize_variables" ilk="function" signature="need_initialize_variables()" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(maker)" attributes="__classmethod__ __ctor__" />
            <scope name="other_elements" ilk="function" signature="other_elements()" attributes="__classmethod__" />
            <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
            <scope name="variable_is_set?" ilk="function" signature="variable_is_set?()" />
            <scope ilk="function" name="maker" />
            <variable name="OTHER_ELEMENTS" attributes="__const__" citdl="Object" />
            <variable name="NEED_INITIALIZE_VARIABLES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="NSError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, prefix, require_uri)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="prefix" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="NotValidXMLParser" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(parser)" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="NotWellFormedError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(line=nil, element=nil)" attributes="__classmethod__ __ctor__" doc="Create a new NotWellFormedError for an error at +line+ in +element+.  If a block is given the return value of the block ends up in the error message." />
          <scope ilk="function" name="element" />
          <scope ilk="function" name="line" />
        </scope>
        <scope name="XMLParserNotFound" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/rexmlparser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="REXMLListener" ilk="class" classrefs="BaseListener">
          <import symbol="ListenerMixin" />
          <import symbol="REXML::StreamListener" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
        </scope>
        <scope name="REXMLParser" ilk="class" classrefs="BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/rss" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseModel" ilk="namespace">
          <import symbol="Utils" />
          <scope name="install_date_element" ilk="function" signature="install_date_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)" />
          <scope name="install_have_attribute_element" ilk="function" signature="install_have_attribute_element(tag_name, uri, occurs, name=nil, type=nil)" />
          <scope name="install_have_child_element" ilk="function" signature="install_have_child_element(tag_name, uri, occurs, name=nil, type=nil)" />
          <scope name="install_have_children_element" ilk="function" signature="install_have_children_element(tag_name, uri, occurs, name=nil, plural_name=nil)" />
          <scope name="install_text_element" ilk="function" signature="install_text_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)" />
        </scope>
        <scope name="ConversionError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(string, to, from)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="from" />
          <scope ilk="function" name="string" />
          <scope ilk="function" name="to" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="InvalidRSSError" ilk="class" classrefs="Error">
        </scope>
        <scope name="MissingAttributeError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, attribute)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="attribute" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="MissingTagError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="NotAvailableValueError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, value, attribute=nil)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="attribute" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="value" />
        </scope>
        <scope name="NotExpectedTagError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="NotSetError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(name, variables)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="variables" />
        </scope>
        <scope name="OverlappedPrefixError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(prefix)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="prefix" />
        </scope>
        <scope name="RootElementMixin" ilk="namespace">
          <import symbol="XMLStyleSheetMixin" />
          <scope name="new" ilk="function" signature="new(feed_version, version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="feed_info" ilk="function" signature="feed_info()" />
          <scope name="output_encoding=" ilk="function" signature="output_encoding=(enc)" />
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          <scope name="to_atom" ilk="function" signature="to_atom(type, &amp;block)" />
          <scope name="to_feed" ilk="function" signature="to_feed(type, &amp;block)" />
          <scope name="to_rss" ilk="function" signature="to_rss(type, &amp;block)" />
          <scope name="to_xml" ilk="function" signature="to_xml(type=nil, &amp;block)" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="encoding=" />
          <scope ilk="function" name="feed_subtype" />
          <scope ilk="function" name="feed_type" />
          <scope ilk="function" name="feed_version" />
          <scope ilk="function" name="output_encoding" />
          <scope ilk="function" name="standalone" />
          <scope ilk="function" name="standalone=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
        </scope>
        <scope name="SetupMaker" ilk="namespace">
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
        </scope>
        <scope name="TooMuchTagError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="UnknownConversionMethodError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="from" />
          <scope ilk="function" name="to" />
        </scope>
        <scope name="UnknownTagError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, uri)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="UnsupportedMakerVersionError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(version)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="version" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/slash" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="SlashModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="SlashModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/syndication" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="SyndicationModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="SyndicationModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="SY_UPDATEPERIOD_AVAILABLE_VALUES" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/taxonomy" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_taxo_topic" ilk="function" signature="install_taxo_topic(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicsModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_taxo_topics" ilk="function" signature="install_taxo_topics(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="TaxonomyTopicModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="TaxonomyTopic" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
          </scope>
        </scope>
        <scope name="TaxonomyTopicsModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="TaxonomyTopics" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            <scope name="resources" ilk="function" signature="resources()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/trackback" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseTrackBackModel" ilk="namespace">
          <import symbol="TrackBackUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Items" ilk="namespace">
            <scope name="Item" ilk="class" classrefs="ItemBase">
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="ChannelBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="ItemBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="ChannelBase">
              <import symbol="SetupDefaultLanguage" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="ItemBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TrackBackModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="RDF" ilk="class" classrefs="Element">
          <import symbol="RSS10" />
          <import symbol="RootElementMixin" />
          <import symbol="TaxonomyTopicModel" />
          <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          <scope name="full_name" ilk="function" signature="full_name()" />
          <variable name="PREFIX" attributes="__const__" citdl="Object" />
          <variable name="URI" attributes="__const__" citdl="Object" />
          <scope name="Channel" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="ImageFaviconModel" />
            <import symbol="RSS10" />
            <import symbol="SyndicationModel" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
          <scope name="Item" ilk="class" classrefs="Element">
            <import symbol="ContentModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="ImageItemModel" />
            <import symbol="RSS10" />
            <import symbol="SlashModel" />
            <import symbol="TaxonomyTopicsModel" />
            <import symbol="TrackBackModel10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Rss" ilk="class" classrefs="Element">
          <import symbol="RSS09" />
          <import symbol="RootElementMixin" />
          <scope name="new" ilk="function" signature="new(feed_version, version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="image" ilk="function" signature="image()" />
          <scope name="items" ilk="function" signature="items()" />
          <scope name="setup_maker_elements" ilk="function" signature="setup_maker_elements(maker)" />
          <scope name="textinput" ilk="function" signature="textinput()" />
          <scope ilk="function" name="feed_version=" />
          <scope name="Channel" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="ITunesChannelModel" />
            <import symbol="RSS09" />
            <scope name="Item" ilk="class" classrefs="Element">
              <import symbol="ContentModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="ITunesItemModel" />
              <import symbol="RSS09" />
              <import symbol="TrackBackModel20" />
            </scope>
          </scope>
        </scope>
        <scope name="TrackBackModel10" ilk="namespace">
          <scope name="TrackBackAbout" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="TrackBackPing" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="TrackBackModel20" ilk="namespace">
          <scope name="TrackBackAbout" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="TrackBackPing" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="TrackBackUtils" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rss/utils" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Utils" ilk="namespace">
          <scope name="element_initialize_arguments?" ilk="function" signature="element_initialize_arguments?(args)" />
          <scope name="get_file_and_line_from_caller" ilk="function" signature="get_file_and_line_from_caller(i=0)" />
          <scope name="h" ilk="function" signature="h(s)" />
          <scope name="html_escape" ilk="function" signature="html_escape(s)" doc="escape &apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos; and &apos;&gt;&apos; for use in HTML." />
          <scope name="new_with_value_if_need" ilk="function" signature="new_with_value_if_need(klass, value)" doc="If +value+ is an instance of class +klass+, return it, else create a new instance of +klass+ with value +value+." />
          <scope name="to_class_name" ilk="function" signature="to_class_name(name)" doc="Convert a name_with_underscores to CamelCase." />
          <scope name="CSV" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value, &amp;block)" />
          </scope>
          <scope name="InheritedReader" ilk="namespace">
            <scope name="inherited_array_reader" ilk="function" signature="inherited_array_reader(constant_name)" />
            <scope name="inherited_hash_reader" ilk="function" signature="inherited_hash_reader(constant_name)" />
            <scope name="inherited_reader" ilk="function" signature="inherited_reader(constant_name)" />
          </scope>
          <scope name="YesCleanOther" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value)" />
          </scope>
          <scope name="YesOther" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/xml" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Element" ilk="class" classrefs="Object">
          <import symbol="SetupMaker" />
          <import symbol="Utils" />
          <scope name="add_have_children_element" ilk="function" signature="add_have_children_element(variable_name, plural_name)" attributes="__classmethod__" />
          <scope name="add_need_initialize_variable" ilk="function" signature="add_need_initialize_variable(variable_name)" attributes="__classmethod__" />
          <scope name="add_plural_form" ilk="function" signature="add_plural_form(singular, plural)" attributes="__classmethod__" />
          <scope name="add_to_element_method" ilk="function" signature="add_to_element_method(method_name)" attributes="__classmethod__" />
          <scope name="content_setup" ilk="function" signature="content_setup(type=nil, disp_name=nil)" attributes="__classmethod__" />
          <scope name="def_corresponded_attr_reader" ilk="function" signature="def_corresponded_attr_reader(name, type=nil)" attributes="__classmethod__" />
          <scope name="def_corresponded_attr_writer" ilk="function" signature="def_corresponded_attr_writer(name, type=nil, disp_name=nil)" attributes="__classmethod__" />
          <scope name="get_attributes" ilk="function" signature="get_attributes()" attributes="__classmethod__" />
          <scope name="have_children_elements" ilk="function" signature="have_children_elements()" attributes="__classmethod__" />
          <scope name="have_content?" ilk="function" signature="have_content?()" attributes="__classmethod__" />
          <scope name="inherited" ilk="function" signature="inherited(klass)" attributes="__classmethod__" />
          <scope name="inherited_base" ilk="function" signature="inherited_base()" attributes="__classmethod__" />
          <scope name="install_get_attribute" ilk="function" signature="install_get_attribute(name, uri, required=true, type=nil, disp_name=nil, element_name=nil)" attributes="__classmethod__" />
          <scope name="install_model" ilk="function" signature="install_model(tag, uri, occurs=nil, getter=nil, plural=false)" attributes="__classmethod__" />
          <scope name="install_must_call_validator" ilk="function" signature="install_must_call_validator(prefix, uri)" attributes="__classmethod__" />
          <scope name="install_ns" ilk="function" signature="install_ns(prefix, uri)" attributes="__classmethod__" />
          <scope name="models" ilk="function" signature="models()" attributes="__classmethod__" />
          <scope name="must_call_validators" ilk="function" signature="must_call_validators()" attributes="__classmethod__" />
          <scope name="need_initialize_variables" ilk="function" signature="need_initialize_variables()" attributes="__classmethod__" />
          <scope name="need_parent?" ilk="function" signature="need_parent?()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(do_validate=true, attrs=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="plural_forms" ilk="function" signature="plural_forms()" attributes="__classmethod__" />
          <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
          <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          <scope name="tag_name" ilk="function" signature="tag_name()" attributes="__classmethod__" />
          <scope name="to_element_methods" ilk="function" signature="to_element_methods()" attributes="__classmethod__" />
          <scope name="convert" ilk="function" signature="convert(value)" />
          <scope name="converter=" ilk="function" signature="converter=(converter)" />
          <scope name="full_name" ilk="function" signature="full_name()" />
          <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
          <scope name="need_base64_encode?" ilk="function" signature="need_base64_encode?()" />
          <scope name="set_next_element" ilk="function" signature="set_next_element(tag_name, next_element)" />
          <scope name="tag_name" ilk="function" signature="tag_name()" />
          <scope name="to_s" ilk="function" signature="to_s(need_convert=true, indent=&apos;&apos;)" />
          <scope name="valid?" ilk="function" signature="valid?(ignore_unknown_element=true)" />
          <scope name="validate" ilk="function" signature="validate(ignore_unknown_element=true)" />
          <scope name="validate_for_stream" ilk="function" signature="validate_for_stream(tags, ignore_unknown_element=true)" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="parent=" />
          <variable name="INDENT" attributes="__const__" citdl="Object" />
          <variable name="MUST_CALL_VALIDATORS" attributes="__const__" citdl="Object" />
          <variable name="MODELS" attributes="__const__" citdl="Object" />
          <variable name="GET_ATTRIBUTES" attributes="__const__" citdl="Object" />
          <variable name="HAVE_CHILDREN_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="TO_ELEMENT_METHODS" attributes="__const__" citdl="Object" />
          <variable name="NEED_INITIALIZE_VARIABLES" attributes="__const__" citdl="Object" />
          <variable name="PLURAL_FORMS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XML" ilk="namespace">
          <scope name="Element" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="new" ilk="function" signature="new(name, prefix=nil, uri=nil, attributes={}, children=[])" attributes="__classmethod__ __ctor__" />
            <scope name="each" ilk="function" signature="each(&amp;block)" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="attributes" />
            <scope ilk="function" name="children" />
            <scope ilk="function" name="name" />
            <scope ilk="function" name="prefix" />
            <scope ilk="function" name="uri" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/xml-stylesheet" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="XMLStyleSheets" ilk="namespace">
            <scope name="XMLStyleSheet" ilk="class" classrefs="Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed)" />
            </scope>
          </scope>
        </scope>
        <scope name="XML" ilk="namespace">
        </scope>
        <scope name="XMLStyleSheet" ilk="class" classrefs="Object">
          <import symbol="Utils" />
          <scope name="new" ilk="function" signature="new(*attrs)" attributes="__classmethod__ __ctor__" />
          <scope name="alternate=" ilk="function" signature="alternate=(value)" />
          <scope name="href=" ilk="function" signature="href=(value)" />
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <variable name="ATTRIBUTES" attributes="__const__" citdl="Object" />
          <variable name="GUESS_TABLE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XMLStyleSheetMixin" ilk="namespace">
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="xml_stylesheets" />
          <scope ilk="function" name="xml_stylesheets=" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/xmlparser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="default_parser" ilk="function" signature="default_parser()" attributes="__classmethod__" />
          <scope name="default_parser=" ilk="function" signature="default_parser=(new_value)" attributes="__classmethod__" doc="Set @@default_parser to new_value if it is one of the available parsers. Else raise NotValidXMLParser error." />
          <scope name="new" ilk="function" signature="new(rss, parser_class=self.class.default_parser)" attributes="__classmethod__ __ctor__" />
          <scope name="parse" ilk="function" signature="parse(rss, do_validate=true, ignore_unknown_element=true, parser_class=default_parser)" attributes="__classmethod__" />
        </scope>
        <scope name="REXMLLikeXMLParser" ilk="class" classrefs="::XML::Parser">
          <import symbol="::XML::Encoding_ja" />
          <scope name="character" ilk="function" signature="character(data)" />
          <scope name="endElement" ilk="function" signature="endElement(name)" />
          <scope name="listener=" ilk="function" signature="listener=(listener)" />
          <scope name="processingInstruction" ilk="function" signature="processingInstruction(target, content)" />
          <scope name="startElement" ilk="function" signature="startElement(name, attrs)" />
          <scope name="xmlDecl" ilk="function" signature="xmlDecl(version, encoding, standalone)" />
        </scope>
        <scope name="XMLParserListener" ilk="class" classrefs="BaseListener">
          <import symbol="ListenerMixin" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
        </scope>
        <scope name="XMLParserParser" ilk="class" classrefs="BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/xmlscanner" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="XMLScanListener" ilk="class" classrefs="BaseListener">
          <import symbol="ListenerMixin" />
          <import symbol="XMLScan::Visitor" />
          <scope name="on_attr_charref" ilk="function" signature="on_attr_charref(code)" />
          <scope name="on_attr_charref_hex" ilk="function" signature="on_attr_charref_hex(code)" />
          <scope name="on_attr_entityref" ilk="function" signature="on_attr_entityref(ref)" />
          <scope name="on_attr_value" ilk="function" signature="on_attr_value(str)" />
          <scope name="on_attribute" ilk="function" signature="on_attribute(name)" />
          <scope name="on_charref" ilk="function" signature="on_charref(code)" />
          <scope name="on_charref_hex" ilk="function" signature="on_charref_hex(code)" />
          <scope name="on_entityref" ilk="function" signature="on_entityref(ref)" />
          <scope name="on_etag" ilk="function" signature="on_etag(name)" />
          <scope name="on_stag" ilk="function" signature="on_stag(name)" />
          <scope name="on_stag_end" ilk="function" signature="on_stag_end(name)" />
          <scope name="on_stag_end_empty" ilk="function" signature="on_stag_end_empty(name)" />
          <scope name="on_xmldecl_encoding" ilk="function" signature="on_xmldecl_encoding(str)" />
          <scope name="on_xmldecl_end" ilk="function" signature="on_xmldecl_end()" />
          <scope name="on_xmldecl_standalone" ilk="function" signature="on_xmldecl_standalone(str)" />
          <scope name="on_xmldecl_version" ilk="function" signature="on_xmldecl_version(str)" />
          <variable name="ENTITIES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XMLScanParser" ilk="class" classrefs="BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="scanf" ilk="blob" lang="Ruby">
      <scope name="Scanf" ilk="namespace">
        <scope name="FormatSpecifier" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(str)" attributes="__classmethod__ __ctor__" />
          <scope name="count_space?" ilk="function" signature="count_space?()" />
          <scope name="letter" ilk="function" signature="letter()" />
          <scope name="match" ilk="function" signature="match(str)" />
          <scope name="mid_match?" ilk="function" signature="mid_match?()" />
          <scope name="to_re" ilk="function" signature="to_re()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="width" ilk="function" signature="width()" />
          <scope ilk="function" name="conversion" />
          <scope ilk="function" name="matched" />
          <scope ilk="function" name="matched_string" />
          <scope ilk="function" name="re_string" />
        </scope>
        <scope name="FormatString" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(str)" attributes="__classmethod__ __ctor__" />
          <scope name="last_spec" ilk="function" signature="last_spec()" />
          <scope name="match" ilk="function" signature="match(str)" />
          <scope name="prune" ilk="function" signature="prune(n=matched_count)" />
          <scope name="spec_count" ilk="function" signature="spec_count()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="last_match_tried" />
          <scope ilk="function" name="last_spec_tried" />
          <scope ilk="function" name="matched_count" />
          <scope ilk="function" name="space" />
          <scope ilk="function" name="string_left" />
          <variable name="SPECIFIERS" attributes="__const__" citdl="Object" />
          <variable name="REGEX" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="set" ilk="blob" lang="Ruby">
      <scope name="Set" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <import symbol="TSort" />
        <scope name="new" ilk="function" signature="new(enum = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        <scope name="add" ilk="function" signature="add(o)" doc="Adds the given object to the set and returns self.  Use +merge+ to add many elements at once." />
        <scope name="add?" ilk="function" signature="add?(o)" doc="Adds the given object to the set and returns self.  If the object is already in the set, returns nil." />
        <scope name="classify" ilk="function" signature="classify()" doc="Classifies the set by the return value of the given block and returns a hash of {value =&gt; set of elements} pairs.  The block is called once for each element of the set, passing the element as parameter. &#xA; e.g.: &#xA;   require &apos;set&apos;&#xA;  files = Set.new(Dir.glob(&quot;*.rb&quot;))&#xA;  hash = files.classify { |f| File.mtime(f).year }&#xA;  p hash    # =&gt; {2000=&gt;#&lt;Set: {&quot;a.rb&quot;, &quot;b.rb&quot;}&gt;,&#xA;            #     2001=&gt;#&lt;Set: {&quot;c.rb&quot;, &quot;d.rb&quot;, &quot;e.rb&quot;}&gt;,&#xA;            #     2002=&gt;#&lt;Set: {&quot;f.rb&quot;}&gt;}" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all elements and returns self." />
        <scope name="collect!" ilk="function" signature="collect!()" doc="Replaces the elements with ones returned by collect()." />
        <scope name="delete" ilk="function" signature="delete(o)" doc="Deletes the given object from the set and returns self.  Use +subtract+ to delete many items at once." />
        <scope name="delete?" ilk="function" signature="delete?(o)" doc="Deletes the given object from the set and returns self.  If the object is not in the set, returns nil." />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every element of the set for which block evaluates to true, and returns self." />
        <scope name="difference" ilk="function" signature="difference(enum)" />
        <scope name="divide" ilk="function" signature="divide(&amp;func)" doc="Divides the set into a set of subsets according to the commonality defined by the given block. &#xA; If the arity of the block is 2, elements o1 and o2 are in common if block.call(o1, o2) is true.  Otherwise, elements o1 and o2 are in common if block.call(o1) == block.call(o2). &#xA; e.g.: &#xA;   require &apos;set&apos;&#xA;  numbers = Set[1, 3, 4, 6, 9, 10, 11]&#xA;  set = numbers.divide { |i,j| (i - j).abs == 1 }&#xA;  p set     # =&gt; #&lt;Set: {#&lt;Set: {1}&gt;,&#xA;            #            #&lt;Set: {11, 9, 10}&gt;,&#xA;            #            #&lt;Set: {3, 4}&gt;,&#xA;            #            #&lt;Set: {6}&gt;}&gt;" />
        <scope name="each" ilk="function" signature="each()" doc="Calls the given block once for each element in the set, passing the element as parameter.  Returns an enumerator if no block is given." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if the set contains no elements." />
        <scope name="flatten" ilk="function" signature="flatten()" doc="Returns a new set that is a copy of the set, flattening each containing set recursively." />
        <scope name="flatten!" ilk="function" signature="flatten!()" doc="Equivalent to Set#flatten, but replaces the receiver with the result in place.  Returns nil if no modifications were made." />
        <scope name="include?" ilk="function" signature="include?(o)" doc="Returns true if the set contains the given object." />
        <scope name="initialize_copy" ilk="function" signature="initialize_copy(orig)" doc="Copy internal hash." />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every element of the set for which block evaluates to false, and returns self." />
        <scope name="length" ilk="function" signature="length()" />
        <scope name="map!" ilk="function" signature="map!()" />
        <scope name="member?" ilk="function" signature="member?(o)" />
        <scope name="merge" ilk="function" signature="merge(enum)" doc="Merges the elements of the given enumerable object to the set and returns self." />
        <scope name="proper_subset?" ilk="function" signature="proper_subset?(set)" doc="Returns true if the set is a proper subset of the given set." />
        <scope name="proper_superset?" ilk="function" signature="proper_superset?(set)" doc="Returns true if the set is a proper superset of the given set." />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Set#delete_if, but returns nil if no changes were made." />
        <scope name="replace" ilk="function" signature="replace(enum)" doc="Replaces the contents of the set with the contents of the given enumerable object and returns self." />
        <scope name="select!" ilk="function" signature="select!()" doc="Equivalent to Set#keep_if, but returns nil if no changes were made." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of elements." />
        <scope name="subset?" ilk="function" signature="subset?(set)" doc="Returns true if the set is a subset of the given set." />
        <scope name="subtract" ilk="function" signature="subtract(enum)" doc="Deletes every element that appears in the given enumerable object and returns self." />
        <scope name="superset?" ilk="function" signature="superset?(set)" doc="Returns true if the set is a superset of the given set." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Converts the set to an array.  The order of elements is uncertain." />
        <scope name="tsort_each_child" ilk="function" signature="tsort_each_child(node, &amp;block)" />
        <scope name="union" ilk="function" signature="union(enum)" />
      </scope>
    </scope>
    <scope name="shell" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="class" classrefs="Object">
        <import symbol="Error" />
        <scope name="alias_command" ilk="function" signature="alias_command(ali, command, *opts, &amp;block)" attributes="__classmethod__" />
        <scope name="cd" ilk="function" signature="cd(path)" attributes="__classmethod__" />
        <scope name="debug=" ilk="function" signature="debug=(val)" attributes="__classmethod__" />
        <scope name="def_system_command" ilk="function" signature="def_system_command(command, path = command)" attributes="__classmethod__" doc="command definitions" />
        <scope name="default_record_separator" ilk="function" signature="default_record_separator()" attributes="__classmethod__" />
        <scope name="default_record_separator=" ilk="function" signature="default_record_separator=(rs)" attributes="__classmethod__" />
        <scope name="default_system_path" ilk="function" signature="default_system_path()" attributes="__classmethod__" />
        <scope name="default_system_path=" ilk="function" signature="default_system_path=(path)" attributes="__classmethod__" />
        <scope name="install_system_commands" ilk="function" signature="install_system_commands(pre = &quot;sys_&quot;)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(pwd = Dir.pwd, umask = nil)" attributes="__classmethod__ __ctor__" />
        <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" attributes="__classmethod__" />
        <scope name="unalias_command" ilk="function" signature="unalias_command(ali)" attributes="__classmethod__" />
        <scope name="undef_system_command" ilk="function" signature="undef_system_command(command)" attributes="__classmethod__" />
        <scope name="cd" ilk="function" signature="cd(path = nil, verbose = @verbose)" />
        <scope name="chdir" ilk="function" signature="chdir(path = nil, verbose = @verbose)" doc="If called as iterator, it restores the current directory when the block ends." />
        <scope name="debug=" ilk="function" signature="debug=(val)" />
        <scope name="expand_path" ilk="function" signature="expand_path(path)" />
        <scope name="inspect" ilk="function" signature="inspect()" />
        <scope name="jobs" ilk="function" signature="jobs()" doc="process management" />
        <scope name="kill" ilk="function" signature="kill(sig, command)" />
        <scope name="popd" ilk="function" signature="popd()" />
        <scope name="popdir" ilk="function" signature="popdir()" />
        <scope name="pushd" ilk="function" signature="pushd(path = nil, verbose = @verbose)" />
        <scope name="pushdir" ilk="function" signature="pushdir(path = nil, verbose = @verbose)" />
        <scope name="system_path=" ilk="function" signature="system_path=(path)" />
        <scope ilk="function" name="cascade" />
        <scope ilk="function" name="cascade=" />
        <scope ilk="function" name="command_processor" />
        <scope ilk="function" name="cwd" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="dir_stack" />
        <scope ilk="function" name="process_controller" />
        <scope ilk="function" name="record_separator" />
        <scope ilk="function" name="record_separator=" />
        <scope ilk="function" name="system_path" />
        <scope ilk="function" name="umask" />
        <scope ilk="function" name="umask=" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
      </scope>
    </scope>
    <scope name="shell/builtin-command" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="AppendFile" ilk="class" classrefs="AppendIO">
          <scope name="new" ilk="function" signature="new(sh, to_filename, filter)" attributes="__classmethod__ __ctor__" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
        </scope>
        <scope name="AppendIO" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, io, filter)" attributes="__classmethod__ __ctor__" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
        </scope>
        <scope name="BuiltInCommand" ilk="class" classrefs="Filter">
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="wait?" ilk="function" signature="wait?()" />
        </scope>
        <scope name="Cat" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *filenames)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Concat" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *jobs)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Echo" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *strings)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Glob" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, pattern)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Tee" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, filename)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Void" ilk="class" classrefs="BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *opts)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/command-processor" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="CommandProcessor" ilk="class" classrefs="Object">
          <scope name="add_delegate_command_to_shell" ilk="function" signature="add_delegate_command_to_shell(id)" attributes="__classmethod__" doc="&#xA;   class initializing methods  -&#xA;" />
          <scope name="alias_command" ilk="function" signature="alias_command(ali, command, *opts, &amp;block)" attributes="__classmethod__" />
          <scope name="alias_map" ilk="function" signature="alias_map()" attributes="__classmethod__" />
          <scope name="def_builtin_commands" ilk="function" signature="def_builtin_commands(delegation_class, command_specs)" attributes="__classmethod__" doc="CommandProcessor.def_builtin_commands(delegation_class, command_specs)     delegation_class: Class or Module&#xA;    command_specs: [[command_name, [argument,...]],...]&#xA;       command_name: String&#xA;       arguments:      String&#xA;          FILENAME?? -&gt; expand_path(filename??)&#xA;          *FILENAME?? -&gt; filename??.collect{|f|expand_path(f)}.join(&quot;, &quot;)&#xA;  define command_name(argument,...) as&#xA;      delegation_class.command_name(argument,...)" />
          <scope name="def_system_command" ilk="function" signature="def_system_command(command, path = command)" attributes="__classmethod__" doc="CommandProcessor.def_system_command(command, path)     command:  String&#xA;    path:       String&#xA;  define &apos;command()&apos; method as method." />
          <scope name="initialize" ilk="function" signature="initialize()" attributes="__classmethod__" />
          <scope name="install_builtin_commands" ilk="function" signature="install_builtin_commands()" attributes="__classmethod__" doc="define default builtin commands" />
          <scope name="install_system_commands" ilk="function" signature="install_system_commands(pre = &quot;sys_&quot;)" attributes="__classmethod__" doc="CommandProcessor.install_system_commands(pre)       pre: String - command name prefix&#xA; defines every command which belongs in default_system_path via CommandProcessor.command().  It doesn&apos;t define already defined methods twice.  By default, &quot;pre_&quot; is prefixes to each method name.  Characters that may not be used in a method name are all converted to &apos;_&apos;.  Definition errors are just ignored." />
          <scope name="method_added" ilk="function" signature="method_added(id)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(shell)" attributes="__classmethod__ __ctor__" />
          <scope name="run_config" ilk="function" signature="run_config()" attributes="__classmethod__" doc="include run file." />
          <scope name="unalias_command" ilk="function" signature="unalias_command(ali)" attributes="__classmethod__" />
          <scope name="undef_system_command" ilk="function" signature="undef_system_command(command)" attributes="__classmethod__" />
          <scope name="append" ilk="function" signature="append(to, filter)" />
          <scope name="cat" ilk="function" signature="cat(*filenames)" />
          <scope name="check_point" ilk="function" signature="check_point()" doc="ProcessCommand#transact" />
          <scope name="concat" ilk="function" signature="concat(*jobs)" />
          <scope name="echo" ilk="function" signature="echo(*strings)" />
          <scope name="expand_path" ilk="function" signature="expand_path(path)" doc="CommandProcessor#expand_path(path)     path:     String&#xA;    return: String&#xA;  returns the absolute path for &lt;path&gt;" />
          <scope name="find_system_command" ilk="function" signature="find_system_command(command)" doc="private functions" />
          <scope name="finish_all_jobs" ilk="function" signature="finish_all_jobs()" />
          <scope name="foreach" ilk="function" signature="foreach(path = nil, *rs)" doc="File related commands Shell#foreach Shell#open Shell#unlink Shell#test &#xA; CommandProcessor#foreach(path, rs)  path: String&#xA; rs:     String - record separator&#xA; iterator&#xA;   Same as:&#xA;    File#foreach (when path is file)&#xA;    Dir#foreach (when path is directory)&#xA;  path is relative to pwd" />
          <scope name="glob" ilk="function" signature="glob(pattern)" doc="def sort(*filenames)   Sort.new(self, *filenames)&#xA; end" />
          <scope name="mkdir" ilk="function" signature="mkdir(*path)" doc="Dir related methods &#xA; Shell#mkdir Shell#rmdir" />
          <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" doc="%pwd, %cwd -&gt; @pwd" />
          <scope name="open" ilk="function" signature="open(path, mode = nil, perm = 0666, &amp;b)" doc="CommandProcessor#open(path, mode)     path:     String&#xA;    mode:     String&#xA;    return: File or Dir&#xA;  Same as:&#xA;    File#open (when path is file)&#xA;    Dir#open  (when path is directory)&#xA;  mode has an effect only when path is a file" />
          <scope name="out" ilk="function" signature="out(dev = STDOUT, &amp;block)" doc="internal commands" />
          <scope name="rehash" ilk="function" signature="rehash()" doc="ProcessCommand#rehash   clear command hash table." />
          <scope name="rmdir" ilk="function" signature="rmdir(*path)" doc="CommandProcessor#rmdir(*path)     path: String&#xA;  same as Dir.rmdir()" />
          <scope name="system" ilk="function" signature="system(command, *opts)" doc="CommandProcessor#system(command, *opts)     command: String&#xA;    opts:      String&#xA;    return:  SystemCommand&#xA;  Same as system() function&#xA;  example:&#xA;    print sh.system(&quot;ls&quot;, &quot;-l&quot;)&#xA;    sh.system(&quot;ls&quot;, &quot;-l&quot;) | sh.head &gt; STDOUT" />
          <scope name="tee" ilk="function" signature="tee(file)" />
          <scope name="test" ilk="function" signature="test(command, file1, file2=nil)" />
          <scope name="top_level_test" ilk="function" signature="top_level_test(command, file1, file2=nil)" doc="CommandProcessor#test(command, file1, file2) CommandProcessor#[command, file1, file2]     command: char or String or Symbol&#xA;    file1:   String&#xA;    file2:   String(optional)&#xA;    return: Boolean&#xA;  same as:&#xA;    test()     (when command is char or length 1 string or symbol)&#xA;    FileTest.command (others)&#xA;  example:&#xA;    sh[?e, &quot;foo&quot;]&#xA;    sh[:e, &quot;foo&quot;]&#xA;    sh[&quot;e&quot;, &quot;foo&quot;]&#xA;    sh[:exists?, &quot;foo&quot;]&#xA;    sh[&quot;exists?&quot;, &quot;foo&quot;]" />
          <scope name="transact" ilk="function" signature="transact(&amp;block)" />
          <scope name="unlink" ilk="function" signature="unlink(path)" doc="CommandProcessor#unlink(path)   same as:&#xA;    Dir#unlink  (when path is directory)&#xA;    File#unlink (when path is file)" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/error" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="Error" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="shell/filter" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="Filter" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(sh)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="input" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/process-controller" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="ProcessController" ilk="class" classrefs="Object">
          <scope name="activate" ilk="function" signature="activate(pc)" attributes="__classmethod__" />
          <scope name="active_process_controllers" ilk="function" signature="active_process_controllers()" attributes="__classmethod__" />
          <scope name="block_output_synchronize" ilk="function" signature="block_output_synchronize(&amp;b)" attributes="__classmethod__" />
          <scope name="each_active_object" ilk="function" signature="each_active_object()" attributes="__classmethod__" />
          <scope name="inactivate" ilk="function" signature="inactivate(pc)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(shell)" attributes="__classmethod__ __ctor__" />
          <scope name="wait_to_finish_all_process_controllers" ilk="function" signature="wait_to_finish_all_process_controllers()" attributes="__classmethod__" />
          <scope name="active_job?" ilk="function" signature="active_job?(job)" />
          <scope name="active_jobs" ilk="function" signature="active_jobs()" />
          <scope name="active_jobs_exist?" ilk="function" signature="active_jobs_exist?()" />
          <scope name="add_schedule" ilk="function" signature="add_schedule(command)" doc="schedule a command" />
          <scope name="jobs" ilk="function" signature="jobs()" />
          <scope name="jobs_exist?" ilk="function" signature="jobs_exist?()" />
          <scope name="kill_job" ilk="function" signature="kill_job(sig, command)" doc="kill a job" />
          <scope name="sfork" ilk="function" signature="sfork(command, &amp;block)" doc="simple fork" />
          <scope name="start_job" ilk="function" signature="start_job(command = nil)" doc="start a job" />
          <scope name="terminate_job" ilk="function" signature="terminate_job(command)" doc="terminate a job" />
          <scope name="wait_all_jobs_execution" ilk="function" signature="wait_all_jobs_execution()" doc="wait for all jobs to terminate" />
          <scope name="waiting_job?" ilk="function" signature="waiting_job?(job)" />
          <scope name="waiting_jobs" ilk="function" signature="waiting_jobs()" />
          <scope name="waiting_jobs_exist?" ilk="function" signature="waiting_jobs_exist?()" />
          <scope ilk="function" name="shell" />
          <variable name="USING_AT_EXIT_WHEN_PROCESS_EXIT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/system-command" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="SystemCommand" ilk="class" classrefs="Filter">
          <scope name="new" ilk="function" signature="new(sh, command, *opts)" attributes="__classmethod__ __ctor__" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
          <scope name="flush" ilk="function" signature="flush()" />
          <scope name="input=" ilk="function" signature="input=(inp)" />
          <scope name="kill" ilk="function" signature="kill(sig)" />
          <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" doc="ex)    if you wish to output:&#xA;      &quot;shell: job(#{@command}:#{@pid}) close pipe-out.&quot;&#xA;   then&#xA;      mes: &quot;job(%id) close pipe-out.&quot;&#xA;   yorn: Boolean(@shell.debug? or @shell.verbose?)" />
          <scope name="start" ilk="function" signature="start()" />
          <scope name="start_export" ilk="function" signature="start_export()" />
          <scope name="start_import" ilk="function" signature="start_import()" />
          <scope name="super_each" ilk="function" signature="super_each(rs = nil)" />
          <scope name="terminate" ilk="function" signature="terminate()" />
          <scope name="wait?" ilk="function" signature="wait?()" />
          <scope ilk="function" name="command" />
        </scope>
      </scope>
    </scope>
    <scope name="shellwords" ilk="blob" lang="Ruby">
      <scope name="Shellwords" ilk="namespace">
        <scope name="shellescape" ilk="function" signature="shellescape(str)" attributes="__classmethod__" doc="Escapes a string so that it can be safely used in a Bourne shell command line. &#xA; Note that a resulted string should be used unquoted and is not intended for use in double quotes nor in single quotes. &#xA;   open(&quot;| grep #{Shellwords.escape(pattern)} file&quot;) { |pipe|&#xA;    # ...&#xA;  }&#xA; +String#shellescape+ is a shorthand for this function. &#xA;   open(&quot;| grep #{pattern.shellescape} file&quot;) { |pipe|&#xA;    # ...&#xA;  }" />
        <scope name="shelljoin" ilk="function" signature="shelljoin(array)" attributes="__classmethod__" doc="Builds a command line string from an argument list +array+ joining all elements escaped for Bourne shell and separated by a space. &#xA;   open(&apos;|&apos; + Shellwords.join([&apos;grep&apos;, pattern, *files])) { |pipe|&#xA;    # ...&#xA;  }&#xA; +Array#shelljoin+ is a shorthand for this function. &#xA;   open(&apos;|&apos; + [&apos;grep&apos;, pattern, *files].shelljoin) { |pipe|&#xA;    # ...&#xA;  }" />
        <scope name="shellsplit" ilk="function" signature="shellsplit(line)" attributes="__classmethod__" doc="Splits a string into an array of tokens in the same way the UNIX Bourne shell does. &#xA;   argv = Shellwords.split(&apos;here are &quot;two words&quot;&apos;)&#xA;  argv =&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]&#xA; +String#shellsplit+ is a shorthand for this function. &#xA;   argv = &apos;here are &quot;two words&quot;&apos;.shellsplit&#xA;  argv =&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]" />
        <scope name="shellwords" ilk="function" signature="shellwords(line)" attributes="__classmethod__" />
      </scope>
    </scope>
    <scope name="socket" ilk="blob" lang="Ruby">
      <scope name="Socket" ilk="class" classrefs="BasicSocket">
        <scope name="accept_loop" ilk="function" signature="accept_loop(*sockets)" attributes="__classmethod__" doc="yield socket and client address for each a connection accepted via given sockets. &#xA; The arguments are a list of sockets. The individual argument should be a socket or an array of sockets. &#xA; This method yields the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time." />
        <scope name="getaddrinfo" ilk="function" signature="getaddrinfo(...)" attributes="__classmethod__" doc="Obtains address information for _nodename_:_servname_. &#xA; _family_ should be an address family such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the family. 0 is default protocol for the family. &#xA; _flags_ should be bitwise OR of Socket::AI_* constants. &#xA;   Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)&#xA;  =&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP&#xA;  Socket.getaddrinfo(&quot;localhost&quot;, nil)&#xA;  =&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP&#xA;  #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP&#xA;  #    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP&#xA; _reverse_lookup_ directs the form of the third element, and has to be one of below. If it is ommitted, the default value is +nil+. &#xA;   +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time." />
        <scope name="gethostbyaddr" ilk="function" signature="gethostbyaddr(...)" attributes="__classmethod__" doc="Obtains the host information for _address_. &#xA;   p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))&#xA;  =&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]" />
        <scope name="gethostbyname" ilk="function" signature="gethostbyname(p1)" attributes="__classmethod__" doc="Obtains the host information for _hostname_. &#xA;   p Socket.gethostbyname(&quot;hal&quot;) =&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]" />
        <scope name="gethostname" ilk="function" signature="gethostname()" attributes="__classmethod__" doc="Returns the hostname. &#xA;   p Socket.gethostname =&gt; &quot;hal&quot;&#xA; Note that it is not guaranteed to be able to convert to IP address using gethostbyname, getaddrinfo, etc. If you need local IP address, use Socket.ip_address_list." />
        <scope name="getnameinfo" ilk="function" signature="getnameinfo(...)" attributes="__classmethod__" doc="Obtains name information for _sockaddr_. &#xA; _sockaddr_ should be one of follows. packed sockaddr string such as Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;3-elements array such as [&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;]&#xA;4-elements array such as [&quot;AF_INET&quot;, 80, ignored, &quot;127.0.0.1&quot;] &#xA; _flags_ should be bitwise OR of Socket::NI_* constants. &#xA; Note that the last form is compatible with IPSocket#{addr,peeraddr}. &#xA;   Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA;  Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA;  Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA; If Addrinfo object is preferred, use Addrinfo#getnameinfo." />
        <scope name="getservbyname" ilk="function" signature="getservbyname(...)" attributes="__classmethod__" doc="Obtains the port number for _service_name_. &#xA; If _protocol_name_ is not given, &quot;tcp&quot; is assumed. &#xA;   Socket.getservbyname(&quot;smtp&quot;)          =&gt; 25&#xA;  Socket.getservbyname(&quot;shell&quot;)         =&gt; 514&#xA;  Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) =&gt; 514" />
        <scope name="getservbyport" ilk="function" signature="getservbyport(...)" attributes="__classmethod__" doc="Obtains the port number for _port_. &#xA; If _protocol_name_ is not given, &quot;tcp&quot; is assumed. &#xA;   Socket.getservbyport(80)         =&gt; &quot;www&quot;&#xA;  Socket.getservbyport(514, &quot;tcp&quot;) =&gt; &quot;shell&quot;&#xA;  Socket.getservbyport(514, &quot;udp&quot;) =&gt; &quot;syslog&quot;" />
        <scope name="ip_address_list" ilk="function" signature="ip_address_list()" attributes="__classmethod__" doc="Returns local IP addresses as an array. &#xA; The array contains Addrinfo objects. &#xA;  pp Socket.ip_address_list&#xA; =&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,&#xA;      #&lt;Addrinfo: 192.168.0.128&gt;,&#xA;      #&lt;Addrinfo: ::1&gt;,&#xA;      ...]" />
        <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a new socket object. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. This is optional. If it is not given, 0 is used internally. &#xA;   Socket.new(:INET, :STREAM) # TCP socket&#xA;  Socket.new(:INET, :DGRAM)  # UDP socket&#xA;  Socket.new(:UNIX, :STREAM) # UNIX stream socket&#xA;  Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket" />
        <scope name="pack_sockaddr_in" ilk="function" signature="pack_sockaddr_in(p1, p2)" attributes="__classmethod__" doc="Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string. &#xA;   Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;  =&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;&#xA;  Socket.sockaddr_in(80, &quot;::1&quot;)&#xA;  =&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;" />
        <scope name="pack_sockaddr_un" ilk="function" signature="pack_sockaddr_un(p1)" attributes="__classmethod__" doc="Packs _path_ as an AF_UNIX sockaddr string. &#xA;   Socket.sockaddr_un(&quot;/tmp/sock&quot;) =&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;" />
        <scope name="pair" ilk="function" signature="pair(...)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA;   s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)&#xA;  s1.send &quot;a&quot;, 0&#xA;  s1.send &quot;b&quot;, 0&#xA;  p s2.recv(10) =&gt; &quot;a&quot;&#xA;  p s2.recv(10) =&gt; &quot;b&quot;" />
        <scope name="sockaddr_in" ilk="function" signature="sockaddr_in(p1, p2)" attributes="__classmethod__" doc="Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string. &#xA;   Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;  =&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;&#xA;  Socket.sockaddr_in(80, &quot;::1&quot;)&#xA;  =&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;" />
        <scope name="sockaddr_un" ilk="function" signature="sockaddr_un(p1)" attributes="__classmethod__" doc="Packs _path_ as an AF_UNIX sockaddr string. &#xA;   Socket.sockaddr_un(&quot;/tmp/sock&quot;) =&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;" />
        <scope name="socketpair" ilk="function" signature="socketpair(...)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA;   s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)&#xA;  s1.send &quot;a&quot;, 0&#xA;  s1.send &quot;b&quot;, 0&#xA;  p s2.recv(10) =&gt; &quot;a&quot;&#xA;  p s2.recv(10) =&gt; &quot;b&quot;" />
        <scope name="tcp" ilk="function" signature="tcp(host, port, local_host=nil, local_port=nil)" attributes="__classmethod__" doc="creates a new socket object connected to host:port using TCP/IP. &#xA; If local_host:local_port is given, the socket is bound to it. &#xA; If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns. &#xA; If no block is given, the socket is returned. &#xA;   Socket.tcp(&quot;www.ruby-lang.org&quot;, 80) {|sock|&#xA;    sock.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;    sock.close_write&#xA;    puts sock.read&#xA;  }" />
        <scope name="tcp_server_loop" ilk="function" signature="tcp_server_loop(host=nil, port)" attributes="__classmethod__" doc="creates a TCP/IP server on _port_ and calls the block for each connection accepted. The block is called with a socket and a client_address as an Addrinfo object. &#xA; If _host_ is specified, it is used with _port_ to determine the server addresses. &#xA; The socket is *not* closed when the block returns. So application should close it explicitly. &#xA; This method calls the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time. &#xA; Note that Addrinfo.getaddrinfo is used to determine the server socket addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and IPv6 address for example, all of them are used. Socket.tcp_server_loop succeeds if one socket can be used at least. &#xA;   # Sequential echo server.&#xA;  # It services only one client at a time.&#xA;  Socket.tcp_server_loop(16807) {|sock, client_addrinfo|&#xA;    begin&#xA;      IO.copy_stream(sock, sock)&#xA;    ensure&#xA;      sock.close&#xA;    end" />
        <scope name="tcp_server_sockets" ilk="function" signature="tcp_server_sockets(host=nil, port)" attributes="__classmethod__" doc="creates TCP/IP server sockets for _host_ and _port_. _host_ is optional. &#xA; If no block given, it returns an array of listening sockets. &#xA; If a block is given, the block is called with the sockets. The value of the block is returned. The socket is closed when this method returns. &#xA; If _port_ is 0, actual port number is choosen dynamically. However all sockets in the result has same port number. &#xA;   # tcp_server_sockets returns two sockets.&#xA;  sockets = Socket.tcp_server_sockets(1296)&#xA;  p sockets =&gt; [#&lt;Socket:fd 3&gt;, #&lt;Socket:fd 4&gt;]&#xA;  # The sockets contains IPv6 and IPv4 sockets.&#xA;  sockets.each {|s| p s.local_address }&#xA;  =&gt; #&lt;Addrinfo: [::]:1296 TCP&gt;&#xA;  #   #&lt;Addrinfo: 0.0.0.0:1296 TCP&gt;&#xA;  # IPv6 and IPv4 socket has same port number, 53114, even if it is choosen dynamically.&#xA;  sockets = Socket.tcp_server_sockets(0)" />
        <scope name="udp_server_loop" ilk="function" signature="udp_server_loop(host=nil, port)" attributes="__classmethod__" doc="creates a UDP/IP server on _port_ and calls the block for each message arrived. The block is called with the message and its source information. &#xA; This method allocates sockets internally using _port_. If _host_ is specified, it is used conjunction with _port_ to determine the server addresses. &#xA; The _msg_ is a string. &#xA; The _msg_src_ is a Socket::UDPSource object. It is used for reply. &#xA;   # UDP/IP echo server.&#xA;  Socket.udp_server_loop(9261) {|msg, msg_src|&#xA;    msg_src.reply msg&#xA;  }" />
        <scope name="udp_server_loop_on" ilk="function" signature="udp_server_loop_on(sockets)" attributes="__classmethod__" doc="Run UDP/IP server loop on the given sockets. &#xA; The return value of Socket.udp_server_sockets is appropriate for the argument. &#xA; It calls the block for each message received." />
        <scope name="udp_server_recv" ilk="function" signature="udp_server_recv(sockets)" attributes="__classmethod__" doc="Receive UDP/IP packets from the given _sockets_. For each packet received, the block is called. &#xA; The block receives _msg_ and _msg_src_. _msg_ is a string which is the payload of the received packet. _msg_src_ is a Socket::UDPSource object which is used for reply. &#xA; Socket.udp_server_loop can be implemented using this method as follows. &#xA;   udp_server_sockets(host, port) {|sockets|&#xA;    loop {&#xA;      readable, _, _ = IO.select(sockets)&#xA;      udp_server_recv(readable) {|msg, msg_src| ... }&#xA;    }&#xA;  }" />
        <scope name="udp_server_sockets" ilk="function" signature="udp_server_sockets(host=nil, port)" attributes="__classmethod__" doc="Creates UDP/IP sockets for a UDP server. &#xA; If no block given, it returns an array of sockets. &#xA; If a block is given, the block is called with the sockets. The value of the block is returned. The sockets are closed when this method returns. &#xA; If _port_ is zero, some port is choosen. But the choosen port is used for the all sockets. &#xA;   # UDP/IP echo server&#xA;  Socket.udp_server_sockets(0) {|sockets|&#xA;    p sockets.first.local_address.ip_port     =&gt; 32963&#xA;    Socket.udp_server_loop_on(sockets) {|msg, msg_src|&#xA;      msg_src.reply msg&#xA;    }&#xA;  }" />
        <scope name="unix" ilk="function" signature="unix(path)" attributes="__classmethod__" doc="creates a new socket connected to path using UNIX socket socket. &#xA; If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns. &#xA; If no block is given, the socket is returned. &#xA;   # talk to /tmp/sock socket.&#xA;  Socket.unix(&quot;/tmp/sock&quot;) {|sock|&#xA;    t = Thread.new { IO.copy_stream(sock, STDOUT) }&#xA;    IO.copy_stream(STDIN, sock)&#xA;    t.join&#xA;  }" />
        <scope name="unix_server_loop" ilk="function" signature="unix_server_loop(path)" attributes="__classmethod__" doc="creates a UNIX socket server on _path_. It calls the block for each socket accepted. &#xA; If _host_ is specified, it is used with _port_ to determine the server ports. &#xA; The socket is *not* closed when the block returns. So application should close it. &#xA; This method deletes the socket file pointed by _path_ at first if the file is a socket file and it is owned by the user of the application. This is safe only if the directory of _path_ is not changed by a malicious user. So don&apos;t use /tmp/malicious-users-directory/socket. Note that /tmp/socket and /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit. &#xA;   # Sequential echo server.&#xA;  # It services only one client at a time.&#xA;  Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|sock, client_addrinfo|&#xA;    begin&#xA;      IO.copy_stream(sock, sock)&#xA;    ensure&#xA;      sock.close&#xA;    end&#xA;  }" />
        <scope name="unix_server_socket" ilk="function" signature="unix_server_socket(path)" attributes="__classmethod__" doc="creates a UNIX server socket on _path_ &#xA; If no block given, it returns a listening socket. &#xA; If a block is given, it is called with the socket and the block value is returned. When the block exits, the socket is closed and the socket file is removed. &#xA;   socket = Socket.unix_server_socket(&quot;/tmp/s&quot;)&#xA;  p socket                  =&gt; #&lt;Socket:fd 3&gt;&#xA;  p socket.local_address    =&gt; #&lt;Addrinfo: /tmp/s SOCK_STREAM&gt;&#xA;&#xA;  Socket.unix_server_socket(&quot;/tmp/sock&quot;) {|s|&#xA;    p s                     =&gt; #&lt;Socket:fd 3&gt;&#xA;    p s.local_address       =&gt; # #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&#xA;  }" />
        <scope name="unpack_sockaddr_in" ilk="function" signature="unpack_sockaddr_in(p1)" attributes="__classmethod__" doc="Unpacks _sockaddr_ into port and ip_address. &#xA; _sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6. &#xA;   sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;  p sockaddr =&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;  p Socket.unpack_sockaddr_in(sockaddr) =&gt; [80, &quot;127.0.0.1&quot;]" />
        <scope name="unpack_sockaddr_un" ilk="function" signature="unpack_sockaddr_un(p1)" attributes="__classmethod__" doc="Unpacks _sockaddr_ into path. &#xA; _sockaddr_ should be a string or an addrinfo for AF_UNIX. &#xA;   sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)&#xA;  p Socket.unpack_sockaddr_un(sockaddr) =&gt; &quot;/tmp/sock&quot;" />
        <scope name="accept" ilk="function" signature="accept()" doc="Accepts a next connection. Returns a new Socket object and Addrinfo object. &#xA;   serv = Socket.new(:INET, :STREAM, 0)&#xA;  serv.listen(5)&#xA;  c = Socket.new(:INET, :STREAM, 0)&#xA;  c.connect(serv.connect_address)&#xA;  p serv.accept =&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]" />
        <scope name="accept_nonblock" ilk="function" signature="accept_nonblock()" doc="Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an array containing the accepted socket for the incoming connection, _client_socket_, and an Addrinfo, _client_addrinfo_. &#xA; Example      # In one script, start this first&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)&#xA;     socket.bind(sockaddr)&#xA;     socket.listen(5)&#xA;     begin # emulate blocking accept&#xA;       client_socket, client_addrinfo = socket.accept_nonblock&#xA;     rescue IO::WaitReadable, Errno::EINTR&#xA;       IO.select([socket])&#xA;       retry" />
        <scope name="bind" ilk="function" signature="bind(p1)" doc="Binds to the given local address. &#xA; Parameter +local_sockaddr+ - the +struct+ sockaddr contained in a string or an Addrinfo object &#xA; Example      require &apos;socket&apos;&#xA;     # use Addrinfo&#xA;     socket = Socket.new(:INET, :STREAM, 0)&#xA;     socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))&#xA;     p socket.local_address =&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;&#xA;     # use struct sockaddr&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;     socket.bind( sockaddr )&#xA; Unix-based Exceptions On unix-based based systems the following system exceptions may be raised if the call to _bind_ fails: Errno::EACCES - the specified _sockaddr_ is protected and the current user does not have permission to bind to it" />
        <scope name="connect" ilk="function" signature="connect(p1)" doc="Requests a connection to be made on the given +remote_sockaddr+. Returns 0 if successful, otherwise an exception is raised. &#xA; Parameter +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object &#xA; Example:      # Pull down Google&apos;s web page&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     sockaddr = Socket.pack_sockaddr_in( 80, &apos;www.google.com&apos; )&#xA;     socket.connect( sockaddr )&#xA;     socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )&#xA;     results = socket.read&#xA; Unix-based Exceptions On unix-based systems the following system exceptions may be raised if the call to _connect_ fails: Errno::EACCES - search permission is denied for a component of the prefix path or write access to the +socket+ is denied&#xA;Errno::EADDRINUSE - the _sockaddr_ is already in use&#xA;Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the local machine" />
        <scope name="connect_nonblock" ilk="function" signature="connect_nonblock(p1)" doc="Requests a connection to be made on the given +remote_sockaddr+ after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful, otherwise an exception is raised. &#xA; Parameter +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object &#xA; Example:      # Pull down Google&apos;s web page&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;     sockaddr = Socket.sockaddr_in(80, &apos;www.google.com&apos;)&#xA;     begin # emulate blocking connect&#xA;       socket.connect_nonblock(sockaddr)&#xA;     rescue IO::WaitWritable&#xA;       IO.select(nil, [socket]) # wait 3-way handshake completion&#xA;       begin&#xA;         socket.connect_nonblock(sockaddr) # check connection failure" />
        <scope name="ipv6only!" ilk="function" signature="ipv6only!()" doc="enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available." />
        <scope name="listen" ilk="function" signature="listen(p1)" doc="Listens for connections, using the specified +int+ as the backlog. A call to _listen_ only applies if the +socket+ is of type SOCK_STREAM or SOCK_SEQPACKET. &#xA; Parameter +backlog+ - the maximum length of the queue for pending connections. &#xA; Example 1      require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;     socket.bind( sockaddr )&#xA;     socket.listen( 5 )&#xA; Example 2 (listening on an arbitrary port, unix-based systems only):      require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     socket.listen( 1 )&#xA; Unix-based Exceptions On unix based systems the above will work because a new +sockaddr+ struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the +socket+ is bound by calling _bind_ before it can _listen_. " />
        <scope name="recvfrom" ilk="function" signature="recvfrom(...)" doc="Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more of the +MSG_+ options. The first element of the results, _mesg_, is the data received. The second element, _sender_addrinfo_, contains protocol-specific address information of the sender. &#xA; Parameters +maxlen+ - the maximum number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example      # In one file, start this first&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;     socket.bind( sockaddr )&#xA;     socket.listen( 5 )&#xA;     client, client_addrinfo = socket.accept&#xA;     data = client.recvfrom( 20 )[0].chomp&#xA;     puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;" />
        <scope name="recvfrom_nonblock" ilk="function" signature="recvfrom_nonblock(...)" doc="Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. _flags_ is zero or more of the +MSG_+ options. The first element of the results, _mesg_, is the data received. The second element, _sender_addrinfo_, contains protocol-specific address information of the sender. &#xA; When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc. &#xA; Parameters +maxlen+ - the maximum number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example      # In one file, start this first&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;     sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)&#xA;     socket.bind(sockaddr)&#xA;     socket.listen(5)&#xA;     client, client_addrinfo = socket.accept&#xA;     begin # emulate blocking recvfrom" />
        <scope name="sysaccept" ilk="function" signature="sysaccept()" doc="Accepts an incoming connection returning an array containing the (integer) file descriptor for the incoming connection, _client_socket_fd_, and an Addrinfo, _client_addrinfo_. &#xA; Example      # In one script, start this first&#xA;     require &apos;socket&apos;&#xA;     include Socket::Constants&#xA;     socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;     sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;     socket.bind( sockaddr )&#xA;     socket.listen( 5 )&#xA;     client_fd, client_addrinfo = socket.sysaccept&#xA;     client_socket = Socket.for_fd( client_fd )&#xA;     puts &quot;The client said, &apos;#{client_socket.readline.chomp}&apos;&quot;&#xA;     client_socket.puts &quot;Hello from script one!&quot;&#xA;     socket.close" />
        <scope name="AncillaryData" ilk="class" classrefs="Object">
          <scope name="int" ilk="function" signature="int(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::AncillaryData object which contains a int as data. &#xA; The size and endian is dependent on the host. &#xA;   p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)&#xA;  =&gt; #&lt;Socket::AncillaryData: UNIX SOCKET RIGHTS 2&gt;" />
          <scope name="ip_pktinfo" ilk="function" signature="ip_pktinfo(...)" attributes="__classmethod__" doc="Returns new ancillary data for IP_PKTINFO. &#xA; If spec_dst is not given, addr is used. &#xA; IP_PKTINFO is not standard. &#xA; Supported platform: GNU/Linux &#xA;   addr = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;  ifindex = 0&#xA;  spec_dst = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;  p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)&#xA;  =&gt; #&lt;Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1&gt;" />
          <scope name="ipv6_pktinfo" ilk="function" signature="ipv6_pktinfo(p1, p2)" attributes="__classmethod__" doc="Returns new ancillary data for IPV6_PKTINFO. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA;   addr = Addrinfo.ip(&quot;::1&quot;)&#xA;  ifindex = 0&#xA;  p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;  =&gt; #&lt;Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0&gt;" />
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4)" attributes="__classmethod__ __ctor__" doc="_family_ should be an integer, a string or a symbol. Socket::AF_INET, &quot;AF_INET&quot;, &quot;INET&quot;, :AF_INET, :INET&#xA;Socket::AF_UNIX, &quot;AF_UNIX&quot;, &quot;UNIX&quot;, :AF_UNIX, :UNIX&#xA;etc. &#xA; _cmsg_level_ should be an integer, a string or a symbol. Socket::SOL_SOCKET, &quot;SOL_SOCKET&quot;, &quot;SOCKET&quot;, :SOL_SOCKET and :SOCKET&#xA;Socket::IPPROTO_IP, &quot;IP&quot; and :IP&#xA;Socket::IPPROTO_IPV6, &quot;IPV6&quot; and :IPV6&#xA;Socket::IPPROTO_TCP, &quot;TCP&quot; and :TCP&#xA;etc. &#xA; _cmsg_type_ should be an integer, a string or a symbol. If a string/symbol is specified, it is interpreted depend on _cmsg_level_. Socket::SCM_RIGHTS, &quot;SCM_RIGHTS&quot;, &quot;RIGHTS&quot;, :SCM_RIGHTS, :RIGHTS for SOL_SOCKET&#xA;Socket::IP_RECVTTL, &quot;RECVTTL&quot; and :RECVTTL for IPPROTO_IP&#xA;Socket::IPV6_PKTINFO, &quot;PKTINFO&quot; and :PKTINFO for IPPROTO_IPV6&#xA;etc. &#xA; _cmsg_data_ should be a string. " />
          <scope name="unix_rights" ilk="function" signature="unix_rights(...)" attributes="__classmethod__" doc="Creates a new Socket::AncillaryData object which contains file descriptors as data. &#xA;   p Socket::AncillaryData.unix_rights(STDERR)&#xA;  =&gt; #&lt;Socket::AncillaryData: UNIX SOCKET RIGHTS 2&gt;" />
          <scope name="cmsg_is?" ilk="function" signature="cmsg_is?(p1, p2)" doc="tests the level and type of _ancillarydata_. &#xA;   ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;)&#xA;  ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) =&gt; true&#xA;  ancdata.cmsg_is?(:IPV6, :PKTINFO)       =&gt; true&#xA;  ancdata.cmsg_is?(:IP, :PKTINFO)         =&gt; false&#xA;  ancdata.cmsg_is?(:SOCKET, :RIGHTS)      =&gt; false" />
          <scope name="data" ilk="function" signature="data()" doc="returns the cmsg data as a string. &#xA;   p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).data&#xA;  =&gt; &quot;&quot;" />
          <scope name="family" ilk="function" signature="family()" doc="returns the socket family as an integer. &#xA;   p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).family&#xA;  =&gt; 10" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="returns a string which shows ancillarydata in human-readable form. &#xA;   p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).inspect&#xA;  =&gt; &quot;#&lt;Socket::AncillaryData: INET6 IPV6 PKTINFO \&quot;\&quot;&gt;&quot;" />
          <scope name="int" ilk="function" signature="int()" doc="Returns the data in _ancillarydata_ as an int. &#xA; The size and endian is dependent on the host. &#xA;   ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)&#xA;  p ancdata.int =&gt; 2" />
          <scope name="ip_pktinfo" ilk="function" signature="ip_pktinfo()" doc="Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data. &#xA; IP_PKTINFO is not standard. &#xA; Supported platform: GNU/Linux &#xA;   addr = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;  ifindex = 0&#xA;  spec_dest = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;  ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)&#xA;  p ancdata.ip_pktinfo&#xA;  =&gt; [#&lt;Addrinfo: 127.0.0.1&gt;, 0, #&lt;Addrinfo: 127.0.0.1&gt;]" />
          <scope name="ipv6_pktinfo" ilk="function" signature="ipv6_pktinfo()" doc="Extracts addr and ifindex from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA;   addr = Addrinfo.ip(&quot;::1&quot;)&#xA;  ifindex = 0&#xA;  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;  p ancdata.ipv6_pktinfo =&gt; [#&lt;Addrinfo: ::1&gt;, 0]" />
          <scope name="ipv6_pktinfo_addr" ilk="function" signature="ipv6_pktinfo_addr()" doc="Extracts addr from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA;   addr = Addrinfo.ip(&quot;::1&quot;)&#xA;  ifindex = 0&#xA;  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;  p ancdata.ipv6_pktinfo_addr =&gt; #&lt;Addrinfo: ::1&gt;" />
          <scope name="ipv6_pktinfo_ifindex" ilk="function" signature="ipv6_pktinfo_ifindex()" doc="Extracts ifindex from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA;   addr = Addrinfo.ip(&quot;::1&quot;)&#xA;  ifindex = 0&#xA;  ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;  p ancdata.ipv6_pktinfo_ifindex =&gt; 0" />
          <scope name="level" ilk="function" signature="level()" doc="returns the cmsg level as an integer. &#xA;   p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).level&#xA;  =&gt; 41" />
          <scope name="timestamp" ilk="function" signature="timestamp()" doc="returns the timestamp as a time object. &#xA; _ancillarydata_ should be one of following type: SOL_SOCKET/SCM_TIMESTAMP (micro second) GNU/Linux, FreeBSD, NetBSD, OpenBSD, Solaris, MacOS X&#xA;SOL_SOCKET/SCM_TIMESTAMPNS (nano second) GNU/Linux&#xA;SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD &#xA; Addrinfo.udp(&quot;127.0.0.1&quot;, 0).bind {|s1|   Addrinfo.udp(&quot;127.0.0.1&quot;, 0).bind {|s2|&#xA;    s1.setsockopt(:SOCKET, :TIMESTAMP, true)&#xA;    s2.send &quot;a&quot;, 0, s1.local_address&#xA;    ctl = s1.recvmsg.last&#xA;    p ctl    =&gt; #&lt;Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581&gt;&#xA;    t = ctl.timestamp&#xA;    p t      =&gt; 2009-02-24 17:35:46 +0900&#xA;    p t.usec =&gt; 775581&#xA;    p t.nsec =&gt; 775581000" />
          <scope name="type" ilk="function" signature="type()" doc="returns the cmsg type as an integer. &#xA;   p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).type&#xA;  =&gt; 2" />
          <scope name="unix_rights" ilk="function" signature="unix_rights()" doc="returns the array of IO objects for SCM_RIGHTS control message in UNIX domain socket. &#xA; The class of the IO objects in the array is IO or Socket. &#xA; The array is attached to _ancillarydata_ when it is instantiated. For example, BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control message and :scm_rights=&gt;true option is given. &#xA;   # recvmsg needs :scm_rights=&gt;true for unix_rights&#xA;  s1, s2 = UNIXSocket.pair&#xA;  p s1                                         =&gt; #&lt;UNIXSocket:fd 3&gt;&#xA;  s1.sendmsg &quot;stdin and a socket&quot;, 0, nil, [:SOCKET, :RIGHTS, [0,s1.fileno].pack(&quot;ii&quot;)]&#xA;  _, _, _, ctl = s2.recvmsg(:scm_rights=&gt;true)&#xA;  p ctl.unix_rights                            =&gt; [#&lt;IO:fd 6&gt;, #&lt;Socket:fd 7&gt;]&#xA;  p File.identical?(STDIN, ctl.unix_rights[0]) =&gt; true&#xA;  p File.identical?(s1, ctl.unix_rights[1])    =&gt; true&#xA;  # If :scm_rights=&gt;true is not given, unix_rights returns nil&#xA;  s1, s2 = UNIXSocket.pair" />
        </scope>
        <scope name="Constants" ilk="namespace">
          <variable name="SOCK_STREAM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_DGRAM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_RAW" attributes="__const__" citdl="Object" />
          <variable name="SOCK_RDM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_SEQPACKET" attributes="__const__" citdl="Object" />
          <variable name="SOCK_PACKET" attributes="__const__" citdl="Object" />
          <variable name="AF_UNSPEC" attributes="__const__" citdl="Object" />
          <variable name="PF_UNSPEC" attributes="__const__" citdl="Object" />
          <variable name="AF_INET" attributes="__const__" citdl="Object" />
          <variable name="PF_INET" attributes="__const__" citdl="Object" />
          <variable name="AF_UNIX" attributes="__const__" citdl="Object" />
          <variable name="PF_UNIX" attributes="__const__" citdl="Object" />
          <variable name="AF_IPX" attributes="__const__" citdl="Object" />
          <variable name="PF_IPX" attributes="__const__" citdl="Object" />
          <variable name="AF_APPLETALK" attributes="__const__" citdl="Object" />
          <variable name="PF_APPLETALK" attributes="__const__" citdl="Object" />
          <variable name="AF_LOCAL" attributes="__const__" citdl="Object" />
          <variable name="PF_LOCAL" attributes="__const__" citdl="Object" />
          <variable name="AF_IMPLINK" attributes="__const__" citdl="Object" />
          <variable name="PF_IMPLINK" attributes="__const__" citdl="Object" />
          <variable name="AF_PUP" attributes="__const__" citdl="Object" />
          <variable name="PF_PUP" attributes="__const__" citdl="Object" />
          <variable name="AF_CHAOS" attributes="__const__" citdl="Object" />
          <variable name="PF_CHAOS" attributes="__const__" citdl="Object" />
          <variable name="AF_NS" attributes="__const__" citdl="Object" />
          <variable name="PF_NS" attributes="__const__" citdl="Object" />
          <variable name="AF_ISO" attributes="__const__" citdl="Object" />
          <variable name="PF_ISO" attributes="__const__" citdl="Object" />
          <variable name="AF_OSI" attributes="__const__" citdl="Object" />
          <variable name="PF_OSI" attributes="__const__" citdl="Object" />
          <variable name="AF_ECMA" attributes="__const__" citdl="Object" />
          <variable name="PF_ECMA" attributes="__const__" citdl="Object" />
          <variable name="AF_DATAKIT" attributes="__const__" citdl="Object" />
          <variable name="PF_DATAKIT" attributes="__const__" citdl="Object" />
          <variable name="AF_CCITT" attributes="__const__" citdl="Object" />
          <variable name="PF_CCITT" attributes="__const__" citdl="Object" />
          <variable name="AF_SNA" attributes="__const__" citdl="Object" />
          <variable name="PF_SNA" attributes="__const__" citdl="Object" />
          <variable name="AF_DEC" attributes="__const__" citdl="Object" />
          <variable name="PF_DEC" attributes="__const__" citdl="Object" />
          <variable name="AF_DLI" attributes="__const__" citdl="Object" />
          <variable name="PF_DLI" attributes="__const__" citdl="Object" />
          <variable name="AF_LAT" attributes="__const__" citdl="Object" />
          <variable name="PF_LAT" attributes="__const__" citdl="Object" />
          <variable name="AF_HYLINK" attributes="__const__" citdl="Object" />
          <variable name="PF_HYLINK" attributes="__const__" citdl="Object" />
          <variable name="AF_ROUTE" attributes="__const__" citdl="Object" />
          <variable name="PF_ROUTE" attributes="__const__" citdl="Object" />
          <variable name="AF_LINK" attributes="__const__" citdl="Object" />
          <variable name="PF_LINK" attributes="__const__" citdl="Object" />
          <variable name="AF_COIP" attributes="__const__" citdl="Object" />
          <variable name="PF_COIP" attributes="__const__" citdl="Object" />
          <variable name="AF_CNT" attributes="__const__" citdl="Object" />
          <variable name="PF_CNT" attributes="__const__" citdl="Object" />
          <variable name="AF_SIP" attributes="__const__" citdl="Object" />
          <variable name="PF_SIP" attributes="__const__" citdl="Object" />
          <variable name="AF_NDRV" attributes="__const__" citdl="Object" />
          <variable name="PF_NDRV" attributes="__const__" citdl="Object" />
          <variable name="AF_ISDN" attributes="__const__" citdl="Object" />
          <variable name="PF_ISDN" attributes="__const__" citdl="Object" />
          <variable name="AF_NATM" attributes="__const__" citdl="Object" />
          <variable name="PF_NATM" attributes="__const__" citdl="Object" />
          <variable name="AF_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="PF_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="AF_NETBIOS" attributes="__const__" citdl="Object" />
          <variable name="PF_NETBIOS" attributes="__const__" citdl="Object" />
          <variable name="AF_PPP" attributes="__const__" citdl="Object" />
          <variable name="PF_PPP" attributes="__const__" citdl="Object" />
          <variable name="AF_ATM" attributes="__const__" citdl="Object" />
          <variable name="PF_ATM" attributes="__const__" citdl="Object" />
          <variable name="AF_NETGRAPH" attributes="__const__" citdl="Object" />
          <variable name="PF_NETGRAPH" attributes="__const__" citdl="Object" />
          <variable name="AF_MAX" attributes="__const__" citdl="Object" />
          <variable name="PF_MAX" attributes="__const__" citdl="Object" />
          <variable name="AF_PACKET" attributes="__const__" citdl="Object" />
          <variable name="PF_PACKET" attributes="__const__" citdl="Object" />
          <variable name="PF_XTP" attributes="__const__" citdl="Object" />
          <variable name="PF_RTIP" attributes="__const__" citdl="Object" />
          <variable name="PF_PIP" attributes="__const__" citdl="Object" />
          <variable name="PF_KEY" attributes="__const__" citdl="Object" />
          <variable name="MSG_OOB" attributes="__const__" citdl="Object" />
          <variable name="MSG_PEEK" attributes="__const__" citdl="Object" />
          <variable name="MSG_DONTROUTE" attributes="__const__" citdl="Object" />
          <variable name="MSG_EOR" attributes="__const__" citdl="Object" />
          <variable name="MSG_TRUNC" attributes="__const__" citdl="Object" />
          <variable name="MSG_CTRUNC" attributes="__const__" citdl="Object" />
          <variable name="MSG_WAITALL" attributes="__const__" citdl="Object" />
          <variable name="MSG_DONTWAIT" attributes="__const__" citdl="Object" />
          <variable name="MSG_EOF" attributes="__const__" citdl="Object" />
          <variable name="MSG_FLUSH" attributes="__const__" citdl="Object" />
          <variable name="MSG_HOLD" attributes="__const__" citdl="Object" />
          <variable name="MSG_SEND" attributes="__const__" citdl="Object" />
          <variable name="MSG_HAVEMORE" attributes="__const__" citdl="Object" />
          <variable name="MSG_RCVMORE" attributes="__const__" citdl="Object" />
          <variable name="MSG_COMPAT" attributes="__const__" citdl="Object" />
          <variable name="MSG_PROXY" attributes="__const__" citdl="Object" />
          <variable name="MSG_FIN" attributes="__const__" citdl="Object" />
          <variable name="MSG_SYN" attributes="__const__" citdl="Object" />
          <variable name="MSG_CONFIRM" attributes="__const__" citdl="Object" />
          <variable name="MSG_RST" attributes="__const__" citdl="Object" />
          <variable name="MSG_ERRQUEUE" attributes="__const__" citdl="Object" />
          <variable name="MSG_NOSIGNAL" attributes="__const__" citdl="Object" />
          <variable name="MSG_MORE" attributes="__const__" citdl="Object" />
          <variable name="SOL_SOCKET" attributes="__const__" citdl="Object" />
          <variable name="SOL_IP" attributes="__const__" citdl="Object" />
          <variable name="SOL_IPX" attributes="__const__" citdl="Object" />
          <variable name="SOL_ATALK" attributes="__const__" citdl="Object" />
          <variable name="SOL_TCP" attributes="__const__" citdl="Object" />
          <variable name="SOL_UDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ICMP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IGMP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_GGP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_TCP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_EGP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_PUP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_UDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_HELLO" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ND" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_TP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_XTP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_EON" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_BIP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_AH" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_DSTOPTS" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ESP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_FRAGMENT" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_HOPOPTS" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_NONE" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ROUTING" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_RAW" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_MAX" attributes="__const__" citdl="Object" />
          <variable name="IPPORT_RESERVED" attributes="__const__" citdl="Object" />
          <variable name="IPPORT_USERRESERVED" attributes="__const__" citdl="Object" />
          <variable name="INADDR_ANY" attributes="__const__" citdl="Object" />
          <variable name="INADDR_BROADCAST" attributes="__const__" citdl="Object" />
          <variable name="INADDR_LOOPBACK" attributes="__const__" citdl="Object" />
          <variable name="INADDR_UNSPEC_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_ALLHOSTS_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_MAX_LOCAL_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_NONE" attributes="__const__" citdl="Object" />
          <variable name="IP_OPTIONS" attributes="__const__" citdl="Object" />
          <variable name="IP_HDRINCL" attributes="__const__" citdl="Object" />
          <variable name="IP_TOS" attributes="__const__" citdl="Object" />
          <variable name="IP_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVRETOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVDSTADDR" attributes="__const__" citdl="Object" />
          <variable name="IP_RETOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_MINTTL" attributes="__const__" citdl="Object" />
          <variable name="IP_DONTFRAG" attributes="__const__" citdl="Object" />
          <variable name="IP_SENDSRCADDR" attributes="__const__" citdl="Object" />
          <variable name="IP_ONESBCAST" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVTTL" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVIF" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVSLLA" attributes="__const__" citdl="Object" />
          <variable name="IP_PORTRANGE" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_IF" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
          <variable name="IP_ADD_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DROP_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DEFAULT_MULTICAST_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_DEFAULT_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
          <variable name="IP_MAX_MEMBERSHIPS" attributes="__const__" citdl="Object" />
          <variable name="IP_ROUTER_ALERT" attributes="__const__" citdl="Object" />
          <variable name="IP_PKTINFO" attributes="__const__" citdl="Object" />
          <variable name="IP_PKTOPTIONS" attributes="__const__" citdl="Object" />
          <variable name="IP_MTU_DISCOVER" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVERR" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVTOS" attributes="__const__" citdl="Object" />
          <variable name="IP_MTU" attributes="__const__" citdl="Object" />
          <variable name="IP_FREEBIND" attributes="__const__" citdl="Object" />
          <variable name="IP_IPSEC_POLICY" attributes="__const__" citdl="Object" />
          <variable name="IP_XFRM_POLICY" attributes="__const__" citdl="Object" />
          <variable name="IP_PASSSEC" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_DONT" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_WANT" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_DO" attributes="__const__" citdl="Object" />
          <variable name="IP_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="IP_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="IP_ADD_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DROP_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_MSFILTER" attributes="__const__" citdl="Object" />
          <variable name="MCAST_JOIN_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_LEAVE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_JOIN_SOURCE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_LEAVE_SOURCE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_MSFILTER" attributes="__const__" citdl="Object" />
          <variable name="MCAST_EXCLUDE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_INCLUDE" attributes="__const__" citdl="Object" />
          <variable name="SO_DEBUG" attributes="__const__" citdl="Object" />
          <variable name="SO_REUSEADDR" attributes="__const__" citdl="Object" />
          <variable name="SO_REUSEPORT" attributes="__const__" citdl="Object" />
          <variable name="SO_TYPE" attributes="__const__" citdl="Object" />
          <variable name="SO_ERROR" attributes="__const__" citdl="Object" />
          <variable name="SO_DONTROUTE" attributes="__const__" citdl="Object" />
          <variable name="SO_BROADCAST" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDBUF" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVBUF" attributes="__const__" citdl="Object" />
          <variable name="SO_KEEPALIVE" attributes="__const__" citdl="Object" />
          <variable name="SO_OOBINLINE" attributes="__const__" citdl="Object" />
          <variable name="SO_NO_CHECK" attributes="__const__" citdl="Object" />
          <variable name="SO_PRIORITY" attributes="__const__" citdl="Object" />
          <variable name="SO_LINGER" attributes="__const__" citdl="Object" />
          <variable name="SO_PASSCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_PEERCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVLOWAT" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDLOWAT" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVTIMEO" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDTIMEO" attributes="__const__" citdl="Object" />
          <variable name="SO_ACCEPTCONN" attributes="__const__" citdl="Object" />
          <variable name="SO_USELOOPBACK" attributes="__const__" citdl="Object" />
          <variable name="SO_ACCEPTFILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_DONTTRUNC" attributes="__const__" citdl="Object" />
          <variable name="SO_WANTMORE" attributes="__const__" citdl="Object" />
          <variable name="SO_WANTOOBFLAG" attributes="__const__" citdl="Object" />
          <variable name="SO_NREAD" attributes="__const__" citdl="Object" />
          <variable name="SO_NKE" attributes="__const__" citdl="Object" />
          <variable name="SO_NOSIGPIPE" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_AUTHENTICATION" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_ENCRYPTION_TRANSPORT" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_ENCRYPTION_NETWORK" attributes="__const__" citdl="Object" />
          <variable name="SO_BINDTODEVICE" attributes="__const__" citdl="Object" />
          <variable name="SO_ATTACH_FILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_DETACH_FILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_PEERNAME" attributes="__const__" citdl="Object" />
          <variable name="SO_TIMESTAMP" attributes="__const__" citdl="Object" />
          <variable name="SO_TIMESTAMPNS" attributes="__const__" citdl="Object" />
          <variable name="SO_BINTIME" attributes="__const__" citdl="Object" />
          <variable name="SO_RECVUCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_MAC_EXEMPT" attributes="__const__" citdl="Object" />
          <variable name="SO_ALLZONES" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_INTERACTIVE" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_NORMAL" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_BACKGROUND" attributes="__const__" citdl="Object" />
          <variable name="IPX_TYPE" attributes="__const__" citdl="Object" />
          <variable name="TCP_NODELAY" attributes="__const__" citdl="Object" />
          <variable name="TCP_MAXSEG" attributes="__const__" citdl="Object" />
          <variable name="TCP_CORK" attributes="__const__" citdl="Object" />
          <variable name="TCP_DEFER_ACCEPT" attributes="__const__" citdl="Object" />
          <variable name="TCP_INFO" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPCNT" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPIDLE" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPINTVL" attributes="__const__" citdl="Object" />
          <variable name="TCP_NOOPT" attributes="__const__" citdl="Object" />
          <variable name="TCP_NOPUSH" attributes="__const__" citdl="Object" />
          <variable name="TCP_QUICKACK" attributes="__const__" citdl="Object" />
          <variable name="TCP_SYNCNT" attributes="__const__" citdl="Object" />
          <variable name="TCP_WINDOW_CLAMP" attributes="__const__" citdl="Object" />
          <variable name="UDP_CORK" attributes="__const__" citdl="Object" />
          <variable name="EAI_ADDRFAMILY" attributes="__const__" citdl="Object" />
          <variable name="EAI_AGAIN" attributes="__const__" citdl="Object" />
          <variable name="EAI_BADFLAGS" attributes="__const__" citdl="Object" />
          <variable name="EAI_FAIL" attributes="__const__" citdl="Object" />
          <variable name="EAI_FAMILY" attributes="__const__" citdl="Object" />
          <variable name="EAI_MEMORY" attributes="__const__" citdl="Object" />
          <variable name="EAI_NODATA" attributes="__const__" citdl="Object" />
          <variable name="EAI_NONAME" attributes="__const__" citdl="Object" />
          <variable name="EAI_OVERFLOW" attributes="__const__" citdl="Object" />
          <variable name="EAI_SERVICE" attributes="__const__" citdl="Object" />
          <variable name="EAI_SOCKTYPE" attributes="__const__" citdl="Object" />
          <variable name="EAI_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="EAI_BADHINTS" attributes="__const__" citdl="Object" />
          <variable name="EAI_PROTOCOL" attributes="__const__" citdl="Object" />
          <variable name="EAI_MAX" attributes="__const__" citdl="Object" />
          <variable name="AI_PASSIVE" attributes="__const__" citdl="Object" />
          <variable name="AI_CANONNAME" attributes="__const__" citdl="Object" />
          <variable name="AI_NUMERICHOST" attributes="__const__" citdl="Object" />
          <variable name="AI_NUMERICSERV" attributes="__const__" citdl="Object" />
          <variable name="AI_MASK" attributes="__const__" citdl="Object" />
          <variable name="AI_ALL" attributes="__const__" citdl="Object" />
          <variable name="AI_ADDRCONFIG" attributes="__const__" citdl="Object" />
          <variable name="AI_DEFAULT" attributes="__const__" citdl="Object" />
          <variable name="NI_MAXHOST" attributes="__const__" citdl="Object" />
          <variable name="NI_MAXSERV" attributes="__const__" citdl="Object" />
          <variable name="NI_NOFQDN" attributes="__const__" citdl="Object" />
          <variable name="NI_NUMERICHOST" attributes="__const__" citdl="Object" />
          <variable name="NI_NAMEREQD" attributes="__const__" citdl="Object" />
          <variable name="NI_NUMERICSERV" attributes="__const__" citdl="Object" />
          <variable name="NI_DGRAM" attributes="__const__" citdl="Object" />
          <variable name="SHUT_RD" attributes="__const__" citdl="Object" />
          <variable name="SHUT_WR" attributes="__const__" citdl="Object" />
          <variable name="SHUT_RDWR" attributes="__const__" citdl="Object" />
          <variable name="INET_ADDRSTRLEN" attributes="__const__" citdl="Object" />
          <variable name="IFNAMSIZ" attributes="__const__" citdl="Object" />
          <variable name="SOMAXCONN" attributes="__const__" citdl="Object" />
          <variable name="SCM_RIGHTS" attributes="__const__" citdl="Object" />
          <variable name="SCM_TIMESTAMP" attributes="__const__" citdl="Object" />
          <variable name="SCM_TIMESTAMPNS" attributes="__const__" citdl="Object" />
          <variable name="SCM_BINTIME" attributes="__const__" citdl="Object" />
          <variable name="SCM_CREDENTIALS" attributes="__const__" citdl="Object" />
          <variable name="SCM_CREDS" attributes="__const__" citdl="Object" />
          <variable name="SCM_UCRED" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_PEERCRED" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_CREDS" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_CONNWAIT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Option" ilk="class" classrefs="Object">
          <scope name="bool" ilk="function" signature="bool(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::Option object which contains boolean as data. Actually 0 or 1 as int is used. &#xA;   p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, true)&#xA;  =&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;&#xA;&#xA;  p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, false)&#xA;  =&gt; #&lt;Socket::Option: AF_INET SOCKET KEEPALIVE 0&gt;" />
          <scope name="int" ilk="function" signature="int(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::Option object which contains an int as data. &#xA; The size and endian is dependent on the platform. &#xA;   p Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;  =&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;" />
          <scope name="linger" ilk="function" signature="linger(p1, p2)" attributes="__classmethod__" doc="Creates a new Socket::Option object for SOL_SOCKET/SO_LINGER. &#xA; _onoff_ should be an integer or a boolean. &#xA; _secs_ should be the number of seconds. &#xA;   p Socket::Option.linger(true, 10)&#xA;  =&gt; #&lt;Socket::Option: UNSPEC SOCKET LINGER on 10sec&gt;" />
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4)" attributes="__classmethod__ __ctor__" doc="Returns a new Socket::Option object. &#xA;   sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;))&#xA;  p sockopt =&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;" />
          <scope name="bool" ilk="function" signature="bool()" doc="Returns the data in _sockopt_ as an boolean value. &#xA;   sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;  p sockopt.bool =&gt; true" />
          <scope name="data" ilk="function" signature="data()" doc="returns the socket option data as a string. &#xA;   p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).data&#xA;  =&gt; &quot;\x01\x00\x00\x00&quot;" />
          <scope name="family" ilk="function" signature="family()" doc="returns the socket family as an integer. &#xA;   p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).family&#xA;  =&gt; 10" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string which shows sockopt in human-readable form. &#xA;   p Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;)).inspect&#xA;  =&gt; &quot;#&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;&quot;" />
          <scope name="int" ilk="function" signature="int()" doc="Returns the data in _sockopt_ as an int. &#xA; The size and endian is dependent on the platform. &#xA;   sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;  p sockopt.int =&gt; 1" />
          <scope name="level" ilk="function" signature="level()" doc="returns the socket level as an integer. &#xA;   p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).level&#xA;  =&gt; 41" />
          <scope name="linger" ilk="function" signature="linger()" doc="Returns the linger data in _sockopt_ as a pair of boolean and integer. &#xA;   sockopt = Socket::Option.linger(true, 10)&#xA;  p sockopt.linger =&gt; [true, 10]" />
          <scope name="optname" ilk="function" signature="optname()" doc="returns the socket option name as an integer. &#xA;   p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).optname&#xA;  =&gt; 2" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="returns the socket option data as a string. &#xA;   p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).data&#xA;  =&gt; &quot;\x01\x00\x00\x00&quot;" />
          <scope name="unpack" ilk="function" signature="unpack(p1)" doc="Calls String#unpack on sockopt.data. &#xA;   sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;))&#xA;  p sockopt.unpack(&quot;i&quot;)      =&gt; [1]&#xA;  p sockopt.data.unpack(&quot;i&quot;) =&gt; [1]" />
        </scope>
        <scope name="UDPSource" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(remote_address, local_address, &amp;reply_proc)" attributes="__classmethod__ __ctor__" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="reply" ilk="function" signature="reply(msg)" />
          <scope ilk="function" name="local_address" />
          <scope ilk="function" name="remote_address" />
        </scope>
      </scope>
    </scope>
    <scope name="sync" ilk="blob" lang="Ruby">
      <scope name="Sync" ilk="class" classrefs="Object">
        <import symbol="Sync_m" />
        <import symbol="Sync_m" />
      </scope>
    </scope>
    <scope name="tempfile" ilk="blob" lang="Ruby">
      <scope name="Tempfile" ilk="class" classrefs="DelegateClass(File)">
        <import symbol="Dir::Tmpname" />
        <scope name="mkdir" ilk="function" signature="mkdir(*args)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(basename, *rest)" attributes="__classmethod__ __ctor__" doc="Creates a temporary file with permissions 0600 (= only readable and writable by the owner) and opens it with mode &quot;w+&quot;. &#xA; The +basename+ parameter is used to determine the name of the temporary file. You can either pass a String or an Array with 2 String elements. In the former form, the temporary file&apos;s base name will begin with the given string. In the latter form, the temporary file&apos;s base name will begin with the array&apos;s first element, and end with the second element. For example: &#xA;   file = Tempfile.new(&apos;hello&apos;)&#xA;  file.path  # =&gt; something like: &quot;/tmp/foo2843-8392-92849382--0&quot;&#xA;  # Use the Array form to enforce an extension in the filename:&#xA;  file = Tempfile.new([&apos;hello&apos;, &apos;.jpg&apos;])&#xA;  file.path  # =&gt; something like: &quot;/tmp/foo2843-8392-92849382--0.jpg&quot;&#xA; The temporary file will be placed in the directory as specified by the +tmpdir+ parameter. By default, this is +Dir.tmpdir+. When $SAFE &gt; 0 and the given +tmpdir+ is tainted, it uses &apos;/tmp&apos; as the temporary directory. Please note that ENV values are tainted by default, and +Dir.tmpdir+&apos;s return value might come from environment variables (e.g. $TMPDIR). &#xA;   file = Tempfile.new(&apos;hello&apos;, &apos;/home/aisaka&apos;)&#xA;  file.path  # =&gt; something like: &quot;/home/aisaka/foo2843-8392-92849382--0&quot;&#xA; You can also pass an options hash. Under the hood, Tempfile creates the temporary file using +File.open+. These options will be passed to +File.open+. This is mostly useful for specifying encoding options, e.g.: &#xA;   Tempfile.new(&apos;hello&apos;, &apos;/home/aisaka&apos;, :encoding =&gt; &apos;ascii-8bit&apos;)&#xA;  # You can also omit the &apos;tmpdir&apos; parameter:" />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Creates a new Tempfile. &#xA; If no block is given, this is a synonym for Tempfile.new. &#xA; If a block is given, then a Tempfile object will be constructed, and the block is run with said object as argument. The Tempfile oject will be automatically closed after the block terminates. The call returns the value of the block. &#xA; In any case, all arguments (+*args+) will be passed to Tempfile.new. &#xA;   Tempfile.open(&apos;foo&apos;, &apos;/home/temp&apos;) do |f|&#xA;     ... do something with f ...&#xA;  end&#xA;  # Equivalent:&#xA;  f = Tempfile.open(&apos;foo&apos;, &apos;/home/temp&apos;)&#xA;  begin&#xA;     ... do something with f ...&#xA;  ensure&#xA;     f.close" />
        <scope name="rmdir" ilk="function" signature="rmdir(*args)" attributes="__classmethod__" />
        <scope name="close" ilk="function" signature="close(unlink_now=false)" doc="Closes the file. If +unlink_now+ is true, then the file will be unlinked (deleted) after closing. Of course, you can choose to later call #unlink if you do not unlink it now. &#xA; If you don&apos;t explicitly unlink the temporary file, the removal will be delayed until the object is finalized." />
        <scope name="close!" ilk="function" signature="close!()" doc="Closes and unlinks (deletes) the file. Has the same effect as called close(true)." />
        <scope name="delete" ilk="function" signature="delete()" />
        <scope name="length" ilk="function" signature="length()" />
        <scope name="open" ilk="function" signature="open()" doc="Opens or reopens the file with mode &quot;r+&quot;." />
        <scope name="path" ilk="function" signature="path()" doc="Returns the full path name of the temporary file. This will be nil if #unlink has been called." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of the temporary file.  As a side effect, the IO buffer is flushed before determining the size." />
        <scope name="unlink" ilk="function" signature="unlink()" doc="Unlinks (deletes) the file from the filesystem. One should always unlink the file after using it, as is explained in the &quot;Explicit close&quot; good practice section in the Tempfile overview: &#xA;   file = Tempfile.new(&apos;foo&apos;)&#xA;  begin&#xA;     ...do something with file...&#xA;  ensure&#xA;     file.close&#xA;     file.unlink   # deletes the temp file&#xA;  end&#xA; Unlink-before-close &#xA; On POSIX systems it&apos;s possible to unlink a file before closing it. This practice is explained in detail in the Tempfile overview (section &quot;Unlink after creation&quot;); please refer there for more information. &#xA; However, unlink-before-close may not be supported on non-POSIX operating systems. Microsoft Windows is the most notable case: unlinking a non-closed file will result in an error, which this method will silently ignore. If you want to practice unlink-before-close whenever possible, then you should write code like this: &#xA;   file = Tempfile.new(&apos;foo&apos;)&#xA;  file.unlink   # On Windows this silently fails." />
      </scope>
    </scope>
    <scope name="test/unit" ilk="blob" lang="Ruby">
      <scope name="Test" ilk="namespace">
        <scope name="Unit" ilk="namespace">
          <scope name="setup_argv" ilk="function" signature="setup_argv(original_argv=ARGV)" attributes="__classmethod__" />
          <variable name="TEST_UNIT_IMPLEMENTATION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="timeout" ilk="blob" lang="Ruby">
      <scope name="Timeout" ilk="namespace">
        <scope name="timeout" ilk="function" signature="timeout(sec, klass = nil)" attributes="__classmethod__" doc="Executes the method&apos;s block.  If the block execution terminates before +sec+ seconds has passed, it returns the result value of the block. If not, it terminates the execution and raises +exception+ (which defaults to Timeout::Error). &#xA; Note that this is both a method of module Timeout, so you can &apos;include Timeout&apos; into your classes so they have a #timeout method, as well as a module method, so you can call it directly as Timeout.timeout()." />
        <variable name="THIS_FILE" attributes="__const__" citdl="Object" />
        <variable name="CALLER_OFFSET" attributes="__const__" citdl="Object" />
        <scope name="Error" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="ExitException" ilk="class" classrefs="::Exception">
        </scope>
      </scope>
    </scope>
    <scope name="tracer" ilk="blob" lang="Ruby">
      <scope name="Tracer" ilk="class" classrefs="Object">
        <scope name="add_filter" ilk="function" signature="add_filter(p = proc)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        <scope name="off" ilk="function" signature="off()" attributes="__classmethod__" />
        <scope name="on" ilk="function" signature="on()" attributes="__classmethod__" />
        <scope name="set_get_line_procs" ilk="function" signature="set_get_line_procs(file_name, p = proc)" attributes="__classmethod__" />
        <scope name="trace_func" ilk="function" signature="trace_func(*vars)" attributes="__classmethod__" />
        <scope name="add_filter" ilk="function" signature="add_filter(p = proc)" />
        <scope name="get_line" ilk="function" signature="get_line(file, line)" />
        <scope name="get_thread_no" ilk="function" signature="get_thread_no()" />
        <scope name="off" ilk="function" signature="off()" />
        <scope name="on" ilk="function" signature="on()" />
        <scope name="set_get_line_procs" ilk="function" signature="set_get_line_procs(file, p = proc)" />
        <scope name="stdout" ilk="function" />
        <scope name="trace_func" ilk="function" signature="trace_func(event, file, line, id, binding, klass, *)" />
        <scope ilk="function" name="display_c_call" />
        <scope ilk="function" name="display_c_call=" />
        <scope ilk="function" name="display_process_id" />
        <scope ilk="function" name="display_process_id=" />
        <scope ilk="function" name="display_thread_id" />
        <scope ilk="function" name="display_thread_id=" />
        <scope ilk="function" name="stdout" />
        <scope ilk="function" name="stdout=" />
        <scope ilk="function" name="stdout_mutex" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
        <variable name="EVENT_SYMBOL" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="tsort" ilk="blob" lang="Ruby">
      <scope name="TSort" ilk="namespace">
        <scope name="each_strongly_connected_component" ilk="function" signature="each_strongly_connected_component()" doc="The iterator version of the #strongly_connected_components method. obj.each_strongly_connected_component is similar to obj.strongly_connected_components.each, but modification of _obj_ during the iteration may lead to unexpected results. &#xA; #each_strongly_connected_component returns +nil+." />
        <scope name="each_strongly_connected_component_from" ilk="function" signature="each_strongly_connected_component_from(node, id_map={}, stack=[])" doc="Iterates over strongly connected component in the subgraph reachable from _node_. &#xA; Return value is unspecified. &#xA; #each_strongly_connected_component_from doesn&apos;t call #tsort_each_node." />
        <scope name="strongly_connected_components" ilk="function" signature="strongly_connected_components()" doc="Returns strongly connected components as an array of arrays of nodes. The array is sorted from children to parents. Each elements of the array represents a strongly connected component." />
        <scope name="tsort" ilk="function" signature="tsort()" doc="Returns a topologically sorted array of nodes. The array is sorted from children to parents, i.e. the first element has no child and the last node has no parent. &#xA; If there is a cycle, TSort::Cyclic is raised." />
        <scope name="tsort_each" ilk="function" signature="tsort_each()" doc="The iterator version of the #tsort method. obj.tsort_each is similar to obj.tsort.each, but modification of _obj_ during the iteration may lead to unexpected results. &#xA; #tsort_each returns +nil+. If there is a cycle, TSort::Cyclic is raised." />
        <scope name="tsort_each_child" ilk="function" signature="tsort_each_child(node)" doc="Should be implemented by a extended class. &#xA; #tsort_each_child is used to iterate for child nodes of _node_." />
        <scope name="tsort_each_node" ilk="function" signature="tsort_each_node()" doc="Should be implemented by a extended class. &#xA; #tsort_each_node is used to iterate for all nodes over a graph." />
        <scope name="Cyclic" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="uri" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <import symbol="REGEXP" />
        <scope name="decode_www_form" ilk="function" signature="decode_www_form(str, enc=Encoding::UTF_8)" attributes="__classmethod__" doc="Decode URL-encoded form data from given +str+. &#xA; This decodes application/x-www-form-urlencoded data and returns array of key-value array. This internally uses URI.decode_www_form_component. &#xA; _charset_ hack is not supported now because the mapping from given charset to Ruby&apos;s encoding is not clear yet. see also http://www.w3.org/TR/html5/syntax.html#character-encodings-0 &#xA; This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; ary = URI.decode_www_form(&quot;a=1&amp;a=2&amp;b=3&quot;) p ary                  =&gt; [[&apos;a&apos;, &apos;1&apos;], [&apos;a&apos;, &apos;2&apos;], [&apos;b&apos;, &apos;3&apos;]] p ary.assoc(&apos;a&apos;).last  =&gt; &apos;1&apos; p ary.assoc(&apos;b&apos;).last  =&gt; &apos;3&apos; p ary.rassoc(&apos;a&apos;).last =&gt; &apos;2&apos; p Hash[ary]            # =&gt; {&quot;a&quot;=&gt;&quot;2&quot;, &quot;b&quot;=&gt;&quot;3&quot;} &#xA; See URI.decode_www_form_component, URI.encode_www_form" />
        <scope name="decode_www_form_component" ilk="function" signature="decode_www_form_component(str, enc=Encoding::UTF_8)" attributes="__classmethod__" doc="Decode given +str+ of URL-encoded form data. &#xA; This decods + to SP. &#xA; See URI.encode_www_form_component, URI.decode_www_form" />
        <scope name="encode_www_form" ilk="function" signature="encode_www_form(enum)" attributes="__classmethod__" doc="Generate URL-encoded form data from given +enum+. &#xA; This generates application/x-www-form-urlencoded data defined in HTML5 from given an Enumerable object. &#xA; This internally uses URI.encode_www_form_component(str). &#xA; This doesn&apos;t convert encodings of give items, so convert them before call this method if you want to send data as other than original encoding or mixed encoding data. (strings which is encoded in HTML5 ASCII incompatible encoding is converted to UTF-8) &#xA; This doesn&apos;t treat files. When you send a file, use multipart/form-data. &#xA; This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; See URI.encode_www_form_component, URI.decode_www_form" />
        <scope name="encode_www_form_component" ilk="function" signature="encode_www_form_component(str)" attributes="__classmethod__" doc="Encode given +str+ to URL-encoded form data. &#xA; This doesn&apos;t convert *, -, ., 0-9, A-Z, _, a-z, does convert SP to +, and convert others to %XX. &#xA; This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; See URI.decode_www_form_component, URI.encode_www_form" />
        <scope name="extract" ilk="function" signature="extract(str, schemes = nil, &amp;block)" attributes="__classmethod__" doc="Synopsis &#xA;   URI::extract(str[, schemes][,&amp;blk])&#xA; Args &#xA; String to extract URIs from.&#xA;Limit URI matching to a specific schemes. &#xA; Description &#xA; Extracts URIs from a string. If block given, iterates through all matched URIs. Returns nil if block given or array with matches. &#xA; Usage &#xA;   require &quot;uri&quot;&#xA;&#xA;  URI.extract(&quot;text here http://foo.example.org/bla and here mailto:test@example.com and here also.&quot;)&#xA;  # =&gt; [&quot;http://foo.example.com/bla&quot;, &quot;mailto:test@example.com&quot;]" />
        <scope name="join" ilk="function" signature="join(*str)" attributes="__classmethod__" doc="Synopsis &#xA;   URI::join(str[, str, ...])&#xA; Args &#xA; String(s) to work with &#xA; Description &#xA; Joins URIs. &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  p URI.join(&quot;http://localhost/&quot;,&quot;main.rbx&quot;)&#xA;  # =&gt; #&lt;URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx&gt;" />
        <scope name="parse" ilk="function" signature="parse(uri)" attributes="__classmethod__" doc="Synopsis &#xA;   URI::parse(uri_str)&#xA; Args &#xA; String with URI. &#xA; Description &#xA; Creates one of the URI&apos;s subclasses instance from the string. &#xA; Raises &#xA; URI::InvalidURIError   Raised if URI given is not a correct one.&#xA; Usage &#xA;   require &apos;uri&apos;&#xA;  uri = URI.parse(&quot;http://www.ruby-lang.org/&quot;)&#xA;  p uri&#xA;  # =&gt; #&lt;URI::HTTP:0x202281be URL:http://www.ruby-lang.org/&gt;" />
        <scope name="regexp" ilk="function" signature="regexp(schemes = nil)" attributes="__classmethod__" doc="Synopsis &#xA;   URI::regexp([match_schemes])&#xA; Args &#xA; Array of schemes. If given, resulting regexp matches to URIs whose scheme is one of the match_schemes. &#xA; Description Returns a Regexp object which matches to URI-like strings. The Regexp object returned by this method includes arbitrary number of capture group (parentheses).  Never rely on it&apos;s number. &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;  # extract first URI from html_string&#xA;  html_string.slice(URI.regexp)&#xA;  # remove ftp URIs&#xA;  html_string.sub(URI.regexp([&apos;ftp&apos;])&#xA;  # You should not rely on the number of parentheses&#xA;  html_string.scan(URI.regexp) do |*matches|" />
        <scope name="scheme_list" ilk="function" signature="scheme_list()" attributes="__classmethod__" />
        <scope name="split" ilk="function" signature="split(uri)" attributes="__classmethod__" doc="Synopsis &#xA;   URI::split(uri)&#xA; Args &#xA; String with URI. &#xA; Description &#xA; Splits the string on following parts and returns array with result: &#xA;   * Scheme&#xA;  * Userinfo&#xA;  * Host&#xA;  * Port&#xA;  * Registry&#xA;  * Path&#xA;  * Opaque" />
        <variable name="DEFAULT_PARSER" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="uri/common" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="BadURIError" ilk="class" classrefs="Error">
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="Escape" ilk="namespace">
          <scope name="decode" ilk="function" signature="decode(*arg)" />
          <scope name="encode" ilk="function" signature="encode(*arg)" />
          <scope name="escape" ilk="function" signature="escape(*arg)" doc="Synopsis &#xA;   URI.escape(str [, unsafe])&#xA; Args &#xA; String to replaces in.&#xA;Regexp that matches all symbols that must be replaced with codes. By default uses REGEXP::UNSAFE. When this argument is a String, it represents a character set. &#xA; Description &#xA; Escapes the string, replacing all unsafe characters with codes. &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;  enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)&#xA;  p enc_uri&#xA;  # =&gt; &quot;http://example.com/?a=%09%0D&quot;&#xA;  p URI.unescape(enc_uri)" />
          <scope name="unescape" ilk="function" signature="unescape(*arg)" doc="Synopsis &#xA;   URI.unescape(str)&#xA; Args &#xA; Unescapes the string. &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)&#xA;  p enc_uri&#xA;  # =&gt; &quot;http://example.com/?a=%09%0D&quot;&#xA;&#xA;  p URI.unescape(enc_uri)&#xA;  # =&gt; &quot;http://example.com/?a=\t\r&quot;" />
        </scope>
        <scope name="InvalidComponentError" ilk="class" classrefs="Error">
        </scope>
        <scope name="InvalidURIError" ilk="class" classrefs="Error">
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object">
          <import symbol="REGEXP" />
          <scope name="new" ilk="function" signature="new(opts = {})" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA;   URI::Parser.new([opts])&#xA; Args &#xA; The constructor accepts a hash as options for parser. Keys of options are pattern names of URI components and values of options are pattern strings. The constructor generetes set of regexps for parsing URIs. &#xA; You can use the following keys: &#xA;   * :ESCAPED (URI::PATTERN::ESCAPED in default)&#xA;  * :UNRESERVED (URI::PATTERN::UNRESERVED in default)&#xA;  * :DOMLABEL (URI::PATTERN::DOMLABEL in default)&#xA;  * :TOPLABEL (URI::PATTERN::TOPLABEL in default)&#xA;  * :HOSTNAME (URI::PATTERN::HOSTNAME in default)&#xA; Examples &#xA;   p = URI::Parser.new(:ESCPAED =&gt; &quot;(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})&quot;&#xA;  u = p.parse(&quot;http://example.jp/%uABCD&quot;) =&gt; #&lt;URI::HTTP:0xb78cf4f8 URL:http://example.jp/%uABCD&gt;" />
          <scope name="escape" ilk="function" signature="escape(str, unsafe = @regexp[:UNSAFE])" />
          <scope name="extract" ilk="function" signature="extract(str, schemes = nil, &amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="join" ilk="function" signature="join(*str)" />
          <scope name="make_regexp" ilk="function" signature="make_regexp(schemes = nil)" />
          <scope name="parse" ilk="function" signature="parse(uri)" />
          <scope name="split" ilk="function" signature="split(uri)" />
          <scope name="unescape" ilk="function" signature="unescape(str, escaped = @regexp[:ESCAPED])" />
          <scope ilk="function" name="pattern" />
          <scope ilk="function" name="regexp" />
        </scope>
        <scope name="REGEXP" ilk="namespace">
          <scope name="PATTERN" ilk="namespace">
          </scope>
        </scope>
        <scope name="Util" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="uri/ftp" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="FTP" ilk="class" classrefs="Generic">
          <import symbol="OpenURI::OpenRead" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Creates a new URI::FTP object from components, with syntax checking. &#xA; The components accepted are +userinfo+, +host+, +port+, +path+ and +typecode+. &#xA; The components should be provided either as an Array, or as a Hash with keys formed by preceding the component names with a colon. &#xA; If an Array is used, the components must be passed in the order &#xA; If the path supplied is absolute, it will be escaped in order to make it absolute in the URI. Examples: &#xA;     require &apos;uri&apos;&#xA;    uri = URI::FTP.build([&apos;user:password&apos;, &apos;ftp.example.com&apos;, nil,&#xA;      &apos;/path/file.&gt; zip&apos;, &apos;i&apos;])&#xA;    puts uri.to_s  -&gt;  ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=a&#xA;    uri2 = URI::FTP.build({:host =&gt; &apos;ftp.example.com&apos;,&#xA;      :path =&gt; &apos;ruby/src&apos;})&#xA;    puts uri2.to_s  -&gt;  ftp://ftp.example.com/ruby/src" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Creates a new URI::FTP object from generic URL components with no syntax checking. &#xA; Unlike build(), this method does not escape the path component as required by RFC1738; instead it is treated as per RFC2396. &#xA; Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, +opaque+, +query+ and +fragment+, in that order." />
          <scope name="new2" ilk="function" signature="new2(user, password, host, port, path, typecode = nil, arg_check = true)" attributes="__classmethod__" />
          <scope name="path" ilk="function" signature="path()" doc="Returns the path from an FTP URI. &#xA; RFC 1738 specifically states that the path for an FTP URI does not include the / which separates the URI path from the URI host. Example: &#xA;     ftp://ftp.example.com/pub/ruby&#xA; The above URI indicates that the client should connect to ftp.example.com then cd pub/ruby from the initial login directory. &#xA; If you want to cd to an absolute directory, you must include an escaped / (%2F) in the path. Example: &#xA;     ftp://ftp.example.com/%2Fpub/ruby&#xA; This method will then return &quot;/pub/ruby&quot;" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="typecode=" ilk="function" signature="typecode=(typecode)" />
          <scope ilk="function" name="typecode" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="TYPECODE" attributes="__const__" citdl="Object" />
          <variable name="TYPECODE_PREFIX" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/generic" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="Generic" ilk="class" classrefs="Object">
          <import symbol="URI" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Synopsis &#xA; See #new &#xA; Description &#xA; Creates a new URI::Generic instance from components of URI::Generic with check.  Components are: scheme, userinfo, host, port, registry, path, opaque, query and fragment. You can provide arguments either by an Array or a Hash. See #new for hash keys to use or for order of array items." />
          <scope name="build2" ilk="function" signature="build2(args)" attributes="__classmethod__" doc="Synopsis &#xA; See #new &#xA; Description &#xA; At first, tries to create a new URI::Generic instance using URI::Generic::build. But, if exception URI::InvalidComponentError is raised, then it URI::Escape.escape all URI components and tries again." />
          <scope name="component" ilk="function" signature="component()" attributes="__classmethod__" doc="Components of the URI in the order." />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="Returns default port" />
          <scope name="new" ilk="function" signature="new(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = DEFAULT_PARSER, arg_check = false)" attributes="__classmethod__ __ctor__" doc="Args &#xA; Protocol scheme, i.e. &apos;http&apos;,&apos;ftp&apos;,&apos;mailto&apos; and so on.&#xA;User name and password, i.e. &apos;sdmitry:bla&apos;&#xA;Server host name&#xA;Server port&#xA;DOC: FIXME!&#xA;Path on server&#xA;DOC: FIXME!&#xA;Query data&#xA;A part of URI after &apos;#&apos; sign&#xA;Parser for internal use [URI::DEFAULT_PARSER by default]&#xA;Check arguments [false by default] &#xA; Description " />
          <scope name="use_registry" ilk="function" signature="use_registry()" attributes="__classmethod__" doc="DOC: FIXME!" />
          <scope name="absolute" ilk="function" signature="absolute()" />
          <scope name="absolute?" ilk="function" signature="absolute?()" doc="Checks if URI is an absolute one" />
          <scope name="coerce" ilk="function" signature="coerce(oth)" />
          <scope name="component" ilk="function" signature="component()" />
          <scope name="default_port" ilk="function" signature="default_port()" />
          <scope name="eql?" ilk="function" signature="eql?(oth)" />
          <scope name="find_proxy" ilk="function" signature="find_proxy()" doc="returns a proxy URI. The proxy URI is obtained from environment variables such as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is returned. &#xA; Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.) are examined too. &#xA; But http_proxy and HTTP_PROXY is treated specially under CGI environment. It&apos;s because HTTP_PROXY may be set by Proxy: header. So HTTP_PROXY is not used. http_proxy is not used too if the variable is case insensitive. CGI_HTTP_PROXY can be used instead." />
          <scope name="fragment=" ilk="function" signature="fragment=(v)" />
          <scope name="hash" ilk="function" signature="hash()" />
          <scope name="hierarchical?" ilk="function" signature="hierarchical?()" doc="Checks if URI has a path" />
          <scope name="host=" ilk="function" signature="host=(v)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="merge" ilk="function" signature="merge(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Merges two URI&apos;s. &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;  p uri.merge(&quot;/main.rbx?page=1&quot;)&#xA;  # =&gt;  #&lt;URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1&gt;" />
          <scope name="merge!" ilk="function" signature="merge!(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Destructive form of #merge &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;  uri.merge!(&quot;/main.rbx?page=1&quot;)&#xA;  p uri&#xA;  # =&gt;  #&lt;URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1&gt;" />
          <scope name="normalize" ilk="function" signature="normalize()" doc="Returns normalized URI" />
          <scope name="normalize!" ilk="function" signature="normalize!()" doc="Destructive version of #normalize" />
          <scope name="opaque=" ilk="function" signature="opaque=(v)" />
          <scope name="parser" ilk="function" signature="parser()" />
          <scope name="password" ilk="function" signature="password()" />
          <scope name="password=" ilk="function" signature="password=(password)" />
          <scope name="path=" ilk="function" signature="path=(v)" />
          <scope name="port=" ilk="function" signature="port=(v)" />
          <scope name="query=" ilk="function" signature="query=(v)" />
          <scope name="registry=" ilk="function" signature="registry=(v)" />
          <scope name="relative?" ilk="function" signature="relative?()" doc="Checks if URI is relative" />
          <scope name="route_from" ilk="function" signature="route_from(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Calculates relative path from oth to self &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&apos;http://my.example.com/main.rbx?page=1&apos;)&#xA;  p uri.route_from(&apos;http://my.example.com&apos;)&#xA;  =&gt; #&lt;URI::Generic:0x20218858 URL:/main.rbx?page=1&gt;" />
          <scope name="route_to" ilk="function" signature="route_to(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Calculates relative path to oth from self &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&apos;http://my.example.com&apos;)&#xA;  p uri.route_to(&apos;http://my.example.com/main.rbx?page=1&apos;)&#xA;  =&gt; #&lt;URI::Generic:0x2020c2f6 URL:/main.rbx?page=1&gt;" />
          <scope name="scheme=" ilk="function" signature="scheme=(v)" />
          <scope name="select" ilk="function" signature="select(*components)" doc="Args &#xA; Multiple Symbol arguments defined in URI::HTTP &#xA; Description &#xA; Selects specified components from URI &#xA; Usage &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&apos;http://myuser:mypass@my.example.com/test.rbx&apos;)&#xA;  p uri.select(:userinfo, :host, :path)&#xA;  # =&gt; [&quot;myuser:mypass&quot;, &quot;my.example.com&quot;, &quot;/test.rbx&quot;]" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Constructs String from URI" />
          <scope name="user" ilk="function" signature="user()" />
          <scope name="user=" ilk="function" signature="user=(user)" />
          <scope name="userinfo" ilk="function" signature="userinfo()" />
          <scope name="userinfo=" ilk="function" signature="userinfo=(userinfo)" doc="Sets userinfo, argument is string like &apos;name:pass&apos;" />
          <scope ilk="function" name="fragment" />
          <scope ilk="function" name="host" />
          <scope ilk="function" name="opaque" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="query" />
          <scope ilk="function" name="registry" />
          <scope ilk="function" name="scheme" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="USE_REGISTRY" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/https" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="HTTP" ilk="class" classrefs="Generic">
          <import symbol="OpenURI::OpenRead" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Create a new URI::HTTP object from components, with syntax checking. &#xA; The components accepted are userinfo, host, port, path, query and fragment. &#xA; The components should be provided either as an Array, or as a Hash with keys formed by preceding the component names with a colon. &#xA; If an Array is used, the components must be passed in the order [userinfo, host, port, path, query, fragment]. &#xA; Example: &#xA;     newuri = URI::HTTP.build({:host =&gt; &apos;www.example.com&apos;,&#xA;      :path&gt; =&gt; &apos;/foo/bar&apos;})&#xA;&#xA;    newuri = URI::HTTP.build([nil, &quot;www.example.com&quot;, nil, &quot;/path&quot;,&#xA;      &quot;query&quot;, &apos;fragment&apos;])&#xA; Currently, if passed userinfo components this method generates invalid HTTP URIs as per RFC 1738." />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Create a new URI::HTTP object from generic URI components as per RFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is performed. &#xA; Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, +opaque+, +query+ and +fragment+, in that order. &#xA; Example: &#xA;     uri = URI::HTTP.new([&apos;http&apos;, nil, &quot;www.example.com&quot;, nil, &quot;/path&quot;,&#xA;      &quot;query&quot;, &apos;fragment&apos;])" />
          <scope name="request_uri" ilk="function" signature="request_uri()" doc="Description &#xA; Returns the full path for an HTTP request, as required by Net::HTTP::Get. &#xA; If the URI contains a query, the full path is URI#path + &apos;?&apos; + URI#query. Otherwise, the path is simply URI#path." />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="HTTPS" ilk="class" classrefs="HTTP">
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/ldaps" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="LDAP" ilk="class" classrefs="Generic">
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" />
          <scope name="attributes" ilk="function" signature="attributes()" />
          <scope name="attributes=" ilk="function" signature="attributes=(val)" />
          <scope name="dn" ilk="function" signature="dn()" />
          <scope name="dn=" ilk="function" signature="dn=(val)" />
          <scope name="extensions" ilk="function" signature="extensions()" />
          <scope name="extensions=" ilk="function" signature="extensions=(val)" />
          <scope name="filter" ilk="function" signature="filter()" />
          <scope name="filter=" ilk="function" signature="filter=(val)" />
          <scope name="hierarchical?" ilk="function" signature="hierarchical?()" />
          <scope name="scope" ilk="function" signature="scope()" />
          <scope name="scope=" ilk="function" signature="scope=(val)" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="SCOPE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/mailto" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="MailTo" ilk="class" classrefs="Generic">
          <import symbol="REGEXP" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Creates a new URI::MailTo object from components, with syntax checking. &#xA; Components can be provided as an Array or Hash. If an Array is used, the components must be supplied as [to, headers]. &#xA; If a Hash is used, the keys are the component names preceded by colons. &#xA; The headers can be supplied as a pre-encoded string, such as &quot;subject=subscribe&amp;cc=address&quot;, or as an Array of Arrays like &#xA; Examples: &#xA;    require &apos;uri&apos;&#xA;   m1 = URI::MailTo.build([&apos;joe@example.com&apos;, &apos;subject=Ruby&apos;])&#xA;   puts m1.to_s  -&gt;  mailto:joe@example.com?subject=Ruby&#xA;   m2 = URI::MailTo.build([&apos;john@example.com&apos;, [[&apos;Subject&apos;, &apos;Ruby&apos;], [&apos;Cc&apos;, &apos;jack@example.com&apos;]]])&#xA;   puts m2.to_s  -&gt;  mailto:john@example.com?Subject=Ruby&amp;Cc=jack@example.com&#xA;   m3 = URI::MailTo.build({:to =&gt; &apos;listman@example.com&apos;, :headers =&gt; [[&apos;subject&apos;, &apos;subscribe&apos;]]})&#xA;   puts m3.to_s  -&gt;  mailto:listman@example.com?subject=subscribe" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Creates a new URI::MailTo object from generic URL components with no syntax checking. &#xA; This method is usually called from URI::parse, which checks the validity of each component." />
          <scope name="headers=" ilk="function" signature="headers=(v)" />
          <scope name="to=" ilk="function" signature="to=(v)" />
          <scope name="to_mailtext" ilk="function" signature="to_mailtext()" doc="Returns the RFC822 e-mail text equivalent of the URL, as a String. &#xA; Example: &#xA;   require &apos;uri&apos;&#xA;&#xA;  uri = URI.parse(&quot;mailto:ruby-list@ruby-lang.org?Subject=subscribe&amp;cc=myaddr&quot;)&#xA;  uri.to_mailtext&#xA;  # =&gt; &quot;To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n&quot;" />
          <scope name="to_rfc822text" ilk="function" signature="to_rfc822text()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="headers" />
          <scope ilk="function" name="to" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="weakref" ilk="blob" lang="Ruby">
      <scope name="WeakRef" ilk="class" classrefs="Delegator">
        <scope name="new" ilk="function" signature="new(orig)" attributes="__classmethod__ __ctor__" />
        <scope name="__getobj__" ilk="function" signature="__getobj__()" />
        <scope name="__setobj__" ilk="function" signature="__setobj__(obj)" />
        <scope name="weakref_alive?" ilk="function" signature="weakref_alive?()" />
        <scope name="RefError" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="webrick" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <variable name="CR" attributes="__const__" citdl="Object" />
        <variable name="LF" attributes="__const__" citdl="Object" />
        <variable name="CRLF" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <scope name="FakeProxyURI" ilk="namespace">
          <scope name="method_missing" ilk="function" signature="method_missing(meth, *args)" attributes="__classmethod__" />
        </scope>
        <scope name="NullReader" ilk="namespace">
          <scope name="read" ilk="function" signature="read(*args)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/accesslog" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="AccessLog" ilk="namespace">
          <scope name="escape" ilk="function" signature="escape(data)" />
          <scope name="format" ilk="function" signature="format(format_string, params)" />
          <scope name="setup_params" ilk="function" signature="setup_params(config, req, res)" doc="This format specification is a subset of mod_log_config of Apache.   http://httpd.apache.org/docs/mod/mod_log_config.html#formats" />
          <variable name="CLF_TIME_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="COMMON_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="CLF" attributes="__const__" citdl="Object" />
          <variable name="REFERER_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="AGENT_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="COMBINED_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <scope name="AccessLogError" ilk="class" classrefs="StandardError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/cgi" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="CGI" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="service" ilk="function" signature="service(req, res)" />
          <scope name="start" ilk="function" signature="start(env=ENV, stdin=$stdin, stdout=$stdout)" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="logger" />
          <scope name="Socket" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="new" ilk="function" signature="new(config, env, stdin, stdout)" attributes="__classmethod__ __ctor__" />
            <scope name="addr" ilk="function" signature="addr()" />
            <scope name="cert" ilk="function" signature="cert()" />
            <scope name="cipher" ilk="function" signature="cipher()" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="eof?" ilk="function" signature="eof?()" />
            <scope name="gets" ilk="function" signature="gets(eol=LF, size=nil)" />
            <scope name="peer_cert" ilk="function" signature="peer_cert()" />
            <scope name="peer_cert_chain" ilk="function" signature="peer_cert_chain()" />
            <scope name="peeraddr" ilk="function" signature="peeraddr()" />
            <scope name="read" ilk="function" signature="read(size=nil)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/cookie" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Cookie" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(name, value)" attributes="__classmethod__ __ctor__" doc="attr_accessor :comment_url, :discard, :port" />
          <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" doc="Cookie::parse()   It parses Cookie field sent from the user agent." />
          <scope name="parse_set_cookie" ilk="function" signature="parse_set_cookie(str)" attributes="__classmethod__" />
          <scope name="parse_set_cookies" ilk="function" signature="parse_set_cookies(str)" attributes="__classmethod__" />
          <scope name="expires" ilk="function" signature="expires()" />
          <scope name="expires=" ilk="function" signature="expires=(t)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="comment" />
          <scope ilk="function" name="comment=" />
          <scope ilk="function" name="domain" />
          <scope ilk="function" name="domain=" />
          <scope ilk="function" name="max_age" />
          <scope ilk="function" name="max_age=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="path=" />
          <scope ilk="function" name="secure" />
          <scope ilk="function" name="secure=" />
          <scope ilk="function" name="value" />
          <scope ilk="function" name="value=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/htmlutils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTMLUtils" ilk="namespace">
          <scope name="escape" ilk="function" signature="escape(string)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="_basic_auth" ilk="function" signature="_basic_auth(req, res, realm, req_field, res_field, err_type, block)" />
          <scope name="basic_auth" ilk="function" signature="basic_auth(req, res, realm, &amp;block)" />
          <scope name="proxy_basic_auth" ilk="function" signature="proxy_basic_auth(req, res, realm, &amp;block)" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/authenticator" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Authenticator" ilk="namespace">
            <scope ilk="function" name="logger" />
            <scope ilk="function" name="realm" />
            <scope ilk="function" name="userdb" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyAuthenticator" ilk="namespace">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/basicauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="BasicAuth" ilk="class" classrefs="Object">
            <import symbol="Authenticator" />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(config, default=Config::BasicAuth)" attributes="__classmethod__ __ctor__" />
            <scope name="authenticate" ilk="function" signature="authenticate(req, res)" />
            <scope name="challenge" ilk="function" signature="challenge(req, res)" />
            <scope ilk="function" name="logger" />
            <scope ilk="function" name="realm" />
            <scope ilk="function" name="userdb" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyBasicAuth" ilk="class" classrefs="BasicAuth">
            <import symbol="ProxyAuthenticator" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/digestauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="DigestAuth" ilk="class" classrefs="Object">
            <import symbol="Authenticator" />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(config, default=Config::DigestAuth)" attributes="__classmethod__ __ctor__" />
            <scope name="authenticate" ilk="function" signature="authenticate(req, res)" />
            <scope name="challenge" ilk="function" signature="challenge(req, res, stale=false)" />
            <scope ilk="function" name="algorithm" />
            <scope ilk="function" name="qop" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyDigestAuth" ilk="class" classrefs="DigestAuth">
            <import symbol="ProxyAuthenticator" />
            <scope name="check_uri" ilk="function" signature="check_uri(req, auth_req)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htdigest" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htdigest" ilk="class" classrefs="Object">
            <import symbol="UserDB" />
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" />
            <scope name="delete_passwd" ilk="function" signature="delete_passwd(realm, user)" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="flush" ilk="function" signature="flush(output=nil)" />
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db)" />
            <scope name="reload" ilk="function" signature="reload()" />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htgroup" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htgroup" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" />
            <scope name="add" ilk="function" signature="add(group, members)" />
            <scope name="flush" ilk="function" signature="flush(output=nil)" />
            <scope name="members" ilk="function" signature="members(group)" />
            <scope name="reload" ilk="function" signature="reload()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htpasswd" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htpasswd" ilk="class" classrefs="Object">
            <import symbol="UserDB" />
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" />
            <scope name="delete_passwd" ilk="function" signature="delete_passwd(realm, user)" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="flush" ilk="function" signature="flush(output=nil)" />
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db)" />
            <scope name="reload" ilk="function" signature="reload()" />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/userdb" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="UserDB" ilk="namespace">
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db=false)" />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" />
            <scope ilk="function" name="auth_type" />
            <scope ilk="function" name="auth_type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpproxy" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPProxyServer" ilk="class" classrefs="HTTPServer">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::HTTP)" attributes="__classmethod__ __ctor__" />
          <scope name="do_CONNECT" ilk="function" signature="do_CONNECT(req, res)" />
          <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
          <scope name="do_HEAD" ilk="function" signature="do_HEAD(req, res)" />
          <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
          <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
          <scope name="proxy_auth" ilk="function" signature="proxy_auth(req, res)" />
          <scope name="proxy_service" ilk="function" signature="proxy_service(req, res)" />
          <scope name="proxy_uri" ilk="function" signature="proxy_uri(req, res)" />
          <scope name="service" ilk="function" signature="service(req, res)" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpresponse" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPResponse" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" />
          <scope name="chunked=" ilk="function" signature="chunked=(val)" />
          <scope name="chunked?" ilk="function" signature="chunked?()" />
          <scope name="content_length" ilk="function" signature="content_length()" />
          <scope name="content_length=" ilk="function" signature="content_length=(len)" />
          <scope name="content_type" ilk="function" signature="content_type()" />
          <scope name="content_type=" ilk="function" signature="content_type=(type)" />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="keep_alive?" ilk="function" signature="keep_alive?()" />
          <scope name="send_body" ilk="function" signature="send_body(socket)" />
          <scope name="send_header" ilk="function" signature="send_header(socket)" />
          <scope name="send_response" ilk="function" signature="send_response(socket)" />
          <scope name="set_error" ilk="function" signature="set_error(ex, backtrace=false)" />
          <scope name="set_redirect" ilk="function" signature="set_redirect(status, url)" />
          <scope name="setup_header" ilk="function" signature="setup_header()" />
          <scope name="status=" ilk="function" signature="status=(status)" />
          <scope name="status_line" ilk="function" signature="status_line()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="body" />
          <scope ilk="function" name="body=" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="cookies" />
          <scope ilk="function" name="filename" />
          <scope ilk="function" name="filename=" />
          <scope ilk="function" name="header" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="keep_alive" />
          <scope ilk="function" name="keep_alive=" />
          <scope ilk="function" name="reason_phrase" />
          <scope ilk="function" name="reason_phrase=" />
          <scope ilk="function" name="request_http_version" />
          <scope ilk="function" name="request_http_version=" />
          <scope ilk="function" name="request_method" />
          <scope ilk="function" name="request_method=" />
          <scope ilk="function" name="request_uri" />
          <scope ilk="function" name="request_uri=" />
          <scope ilk="function" name="sent_size" />
          <scope ilk="function" name="status" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/https" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPRequest" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" />
          <scope name="body" ilk="function" signature="body(&amp;block)" />
          <scope name="content_length" ilk="function" signature="content_length()" />
          <scope name="content_type" ilk="function" signature="content_type()" />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="fixup" ilk="function" signature="fixup()" />
          <scope name="host" ilk="function" signature="host()" />
          <scope name="keep_alive?" ilk="function" signature="keep_alive?()" />
          <scope name="meta_vars" ilk="function" signature="meta_vars()" />
          <scope name="orig_meta_vars" ilk="function" signature="orig_meta_vars()" />
          <scope name="orig_parse" ilk="function" signature="orig_parse(socket=nil)" />
          <scope name="parse" ilk="function" signature="parse(socket=nil)" />
          <scope name="parse_uri" ilk="function" signature="parse_uri(str, scheme=&quot;http&quot;)" />
          <scope name="port" ilk="function" signature="port()" />
          <scope name="query" ilk="function" signature="query()" />
          <scope name="remote_ip" ilk="function" signature="remote_ip()" />
          <scope name="server_name" ilk="function" signature="server_name()" />
          <scope name="ssl?" ilk="function" signature="ssl?()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="accept" />
          <scope ilk="function" name="accept_charset" />
          <scope ilk="function" name="accept_encoding" />
          <scope ilk="function" name="accept_language" />
          <scope ilk="function" name="addr" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="cipher" />
          <scope ilk="function" name="client_cert" />
          <scope ilk="function" name="cookies" />
          <scope ilk="function" name="header" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="keep_alive" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="path_info" />
          <scope ilk="function" name="path_info=" />
          <scope ilk="function" name="peeraddr" />
          <scope ilk="function" name="query_string" />
          <scope ilk="function" name="query_string=" />
          <scope ilk="function" name="raw_header" />
          <scope ilk="function" name="request_line" />
          <scope ilk="function" name="request_method" />
          <scope ilk="function" name="request_time" />
          <scope ilk="function" name="request_uri" />
          <scope ilk="function" name="script_name" />
          <scope ilk="function" name="script_name=" />
          <scope ilk="function" name="server_cert" />
          <scope ilk="function" name="unparsed_uri" />
          <scope ilk="function" name="user" />
          <scope ilk="function" name="user=" />
          <variable name="BODY_CONTAINABLE_METHODS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpserver" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServer" ilk="class" classrefs="::WEBrick::GenericServer">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::HTTP)" attributes="__classmethod__ __ctor__" />
          <scope name="access_log" ilk="function" signature="access_log(config, req, res)" />
          <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
          <scope name="lookup_server" ilk="function" signature="lookup_server(req)" />
          <scope name="mount" ilk="function" signature="mount(dir, servlet, *options)" />
          <scope name="mount_proc" ilk="function" signature="mount_proc(dir, proc=nil, &amp;block)" />
          <scope name="run" ilk="function" signature="run(sock)" />
          <scope name="search_servlet" ilk="function" signature="search_servlet(path)" />
          <scope name="service" ilk="function" signature="service(req, res)" />
          <scope name="umount" ilk="function" signature="umount(dir)" />
          <scope name="unmount" ilk="function" signature="unmount(dir)" />
          <scope name="virtual_host" ilk="function" signature="virtual_host(server)" />
          <scope name="MountTable" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="delete" ilk="function" signature="delete(dir)" />
            <scope name="scan" ilk="function" signature="scan(path)" />
          </scope>
        </scope>
        <scope name="HTTPServerError" ilk="class" classrefs="ServerError">
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/abstract" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="AbstractServlet" ilk="class" classrefs="Object">
            <scope name="get_instance" ilk="function" signature="get_instance(config, *options)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(server, *options)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_HEAD" ilk="function" signature="do_HEAD(req, res)" />
            <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
            <scope name="service" ilk="function" signature="service(req, res)" />
          </scope>
        </scope>
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="HTTPServletError" ilk="class" classrefs="StandardError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/cgihandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="CGIHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, name)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/erbhandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="ERBHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, name)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/filehandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="DefaultFileHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, local_path)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="make_partial_content" ilk="function" signature="make_partial_content(req, res, filename, filesize)" />
            <scope name="not_modified?" ilk="function" signature="not_modified?(req, res, mtime, etag)" />
            <scope name="prepare_range" ilk="function" signature="prepare_range(range, filesize)" />
          </scope>
        </scope>
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="FileHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="add_handler" ilk="function" signature="add_handler(suffix, handler)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(server, root, options={}, default=Config::FileHandler)" attributes="__classmethod__ __ctor__" />
            <scope name="remove_handler" ilk="function" signature="remove_handler(suffix)" attributes="__classmethod__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
            <scope name="service" ilk="function" signature="service(req, res)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/prochandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="ProcHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="new" ilk="function" signature="new(proc)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(request, response)" />
            <scope name="do_POST" ilk="function" signature="do_POST(request, response)" />
            <scope name="get_instance" ilk="function" signature="get_instance(server, *options)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpstatus" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPStatus" ilk="namespace">
          <scope name="client_error?" ilk="function" signature="client_error?(code)" attributes="__classmethod__" />
          <scope name="error?" ilk="function" signature="error?(code)" attributes="__classmethod__" />
          <scope name="info?" ilk="function" signature="info?(code)" attributes="__classmethod__" />
          <scope name="reason_phrase" ilk="function" signature="reason_phrase(code)" attributes="__classmethod__" />
          <scope name="redirect?" ilk="function" signature="redirect?(code)" attributes="__classmethod__" />
          <scope name="server_error?" ilk="function" signature="server_error?(code)" attributes="__classmethod__" />
          <scope name="success?" ilk="function" signature="success?(code)" attributes="__classmethod__" />
          <scope name="ClientError" ilk="class" classrefs="Error">
          </scope>
          <scope name="EOFError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="Error" ilk="class" classrefs="Status">
          </scope>
          <scope name="Info" ilk="class" classrefs="Status">
          </scope>
          <scope name="Redirect" ilk="class" classrefs="Status">
          </scope>
          <scope name="Status" ilk="class" classrefs="StandardError">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="code" ilk="function" />
            <scope name="reason_phrase" ilk="function" />
            <scope name="to_i" ilk="function" signature="to_i()" />
            <scope ilk="function" name="code" />
            <scope ilk="function" name="reason_phrase" />
          </scope>
          <scope name="Success" ilk="class" classrefs="Status">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httputils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPUtils" ilk="namespace">
          <scope name="dequote" ilk="function" signature="dequote(str)" attributes="__classmethod__" />
          <scope name="load_mime_types" ilk="function" signature="load_mime_types(file)" attributes="__classmethod__" doc="Load Apache compatible mime.types file." />
          <scope name="mime_type" ilk="function" signature="mime_type(filename, mime_tab)" attributes="__classmethod__" />
          <scope name="normalize_path" ilk="function" signature="normalize_path(path)" attributes="__classmethod__" />
          <scope name="parse_form_data" ilk="function" signature="parse_form_data(io, boundary)" attributes="__classmethod__" />
          <scope name="parse_header" ilk="function" signature="parse_header(raw)" attributes="__classmethod__" />
          <scope name="parse_query" ilk="function" signature="parse_query(str)" attributes="__classmethod__" />
          <scope name="parse_qvalues" ilk="function" signature="parse_qvalues(value)" attributes="__classmethod__" />
          <scope name="parse_range_header" ilk="function" signature="parse_range_header(ranges_specifier)" attributes="__classmethod__" />
          <scope name="quote" ilk="function" signature="quote(str)" attributes="__classmethod__" />
          <scope name="split_header_value" ilk="function" signature="split_header_value(str)" attributes="__classmethod__" />
          <scope name="_escape" ilk="function" signature="_escape(str, regex)" />
          <scope name="_make_regex" ilk="function" signature="_make_regex(str)" />
          <scope name="_make_regex!" ilk="function" signature="_make_regex!(str)" />
          <scope name="_unescape" ilk="function" signature="_unescape(str, regex)" />
          <scope name="escape" ilk="function" signature="escape(str)" />
          <scope name="escape8bit" ilk="function" signature="escape8bit(str)" />
          <scope name="escape_form" ilk="function" signature="escape_form(str)" />
          <scope name="escape_path" ilk="function" signature="escape_path(str)" />
          <scope name="unescape" ilk="function" signature="unescape(str)" />
          <scope name="unescape_form" ilk="function" signature="unescape_form(str)" />
          <variable name="UNESCAPED" attributes="__const__" citdl="Object" />
          <variable name="UNESCAPED_FORM" attributes="__const__" citdl="Object" />
          <variable name="NONASCII" attributes="__const__" citdl="Object" />
          <variable name="ESCAPED" attributes="__const__" citdl="Object" />
          <variable name="UNESCAPED_PCHAR" attributes="__const__" citdl="Object" />
          <scope name="FormData" ilk="class" classrefs="String">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="append_data" ilk="function" signature="append_data(data)" />
            <scope name="each_data" ilk="function" signature="each_data()" />
            <scope name="list" ilk="function" signature="list()" />
            <scope name="to_ary" ilk="function" signature="to_ary()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="filename" />
            <scope ilk="function" name="filename=" />
            <scope ilk="function" name="name" />
            <scope ilk="function" name="name=" />
            <scope ilk="function" name="next_data" />
            <scope ilk="function" name="next_data=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpversion" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPVersion" ilk="class" classrefs="Object">
          <import symbol="Comparable" />
          <scope name="convert" ilk="function" signature="convert(version)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(version)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="major" />
          <scope ilk="function" name="major=" />
          <scope ilk="function" name="minor" />
          <scope ilk="function" name="minor=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/log" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="BasicLog" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(log_file=nil, level=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="debug" ilk="function" signature="debug(msg)" />
          <scope name="debug?" ilk="function" signature="debug?()" />
          <scope name="error" ilk="function" signature="error(msg)" />
          <scope name="error?" ilk="function" signature="error?()" />
          <scope name="fatal" ilk="function" signature="fatal(msg)" />
          <scope name="fatal?" ilk="function" signature="fatal?()" />
          <scope name="info" ilk="function" signature="info(msg)" />
          <scope name="info?" ilk="function" signature="info?()" />
          <scope name="log" ilk="function" signature="log(level, data)" />
          <scope name="warn" ilk="function" signature="warn(msg)" />
          <scope name="warn?" ilk="function" signature="warn?()" />
          <scope ilk="function" name="level" />
          <scope ilk="function" name="level=" />
          <variable name="DEBUG" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Log" ilk="class" classrefs="BasicLog">
          <scope name="new" ilk="function" signature="new(log_file=nil, level=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="log" ilk="function" signature="log(level, data)" />
          <scope ilk="function" name="time_format" />
          <scope ilk="function" name="time_format=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/server" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Daemon" ilk="class" classrefs="Object">
          <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" />
        </scope>
        <scope name="HTTPStatus" ilk="namespace">
          <scope name="ServerError" ilk="class" classrefs="Error">
          </scope>
        </scope>
        <scope name="ServerError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="SimpleServer" ilk="class" classrefs="Object">
          <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/ssl" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Config" ilk="namespace">
          <variable name="SSL" attributes="__const__" citdl="Object" />
          <variable name="LIBDIR" attributes="__const__" citdl="Object" />
          <variable name="HTTP" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="GenericServer" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::General)" attributes="__classmethod__ __ctor__" />
          <scope name="listen" ilk="function" signature="listen(address, port)" />
          <scope name="run" ilk="function" signature="run(sock)" />
          <scope name="setup_ssl_context" ilk="function" signature="setup_ssl_context(config)" />
          <scope name="shutdown" ilk="function" signature="shutdown()" />
          <scope name="ssl_context" ilk="function" signature="ssl_context()" />
          <scope name="start" ilk="function" signature="start(&amp;block)" />
          <scope name="stop" ilk="function" signature="stop()" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="listeners" />
          <scope ilk="function" name="logger" />
          <scope ilk="function" name="status" />
          <scope ilk="function" name="tokens" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/utils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Utils" ilk="namespace">
          <scope name="create_listeners" ilk="function" signature="create_listeners(address, port, logger=nil)" attributes="__classmethod__" />
          <scope name="create_self_signed_cert" ilk="function" signature="create_self_signed_cert(bits, cn, comment)" attributes="__classmethod__" />
          <scope name="getservername" ilk="function" signature="getservername()" attributes="__classmethod__" />
          <scope name="random_string" ilk="function" signature="random_string(len)" attributes="__classmethod__" />
          <scope name="set_close_on_exec" ilk="function" signature="set_close_on_exec(io)" attributes="__classmethod__" />
          <scope name="set_non_blocking" ilk="function" signature="set_non_blocking(io)" attributes="__classmethod__" />
          <scope name="su" ilk="function" signature="su(user)" attributes="__classmethod__" />
          <scope name="timeout" ilk="function" signature="timeout(seconds, exception=Timeout::Error)" attributes="__classmethod__" />
          <variable name="RAND_CHARS" attributes="__const__" citdl="Object" />
          <scope name="TimeoutHandler" ilk="class" classrefs="Object">
            <import symbol="Singleton" />
            <scope name="cancel" ilk="function" signature="cancel(id)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="register" ilk="function" signature="register(seconds, exception)" attributes="__classmethod__" />
            <scope name="cancel" ilk="function" signature="cancel(thread, id)" />
            <scope name="interrupt" ilk="function" signature="interrupt(thread, id, exception)" />
            <scope name="register" ilk="function" signature="register(thread, time, exception)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="zlib" ilk="blob" lang="Ruby">
      <scope name="Zlib" ilk="namespace">
        <scope name="adler32" ilk="function" signature="adler32(...)" attributes="__classmethod__" doc="Calculates Adler-32 checksum for +string+, and returns updated value of +adler+. If +string+ is omitted, it returns the Adler-32 initial value. If +adler+ is omitted, it assumes that the initial value is given to +adler+. &#xA; FIXME: expression." />
        <scope name="adler32_combine" ilk="function" signature="adler32_combine(p1, p2, p3)" attributes="__classmethod__" doc="Combine two Adler-32 check values in to one.  +alder1+ is the first Adler-32 value, +adler2+ is the second Adler-32 value.  +len2+ is the length of the string used to generate +adler2+." />
        <scope name="crc32" ilk="function" signature="crc32(...)" attributes="__classmethod__" doc="Calculates CRC checksum for +string+, and returns updated value of +crc+. If +string+ is omitted, it returns the CRC initial value. If +crc+ is omitted, it assumes that the initial value is given to +crc+. &#xA; FIXME: expression." />
        <scope name="crc32_combine" ilk="function" signature="crc32_combine(p1, p2, p3)" attributes="__classmethod__" doc="Combine two CRC-32 check values in to one.  +crc1+ is the first CRC-32 value, +crc2+ is the second CRC-32 value.  +len2+ is the length of the string used to generate +crc2+." />
        <scope name="crc_table" ilk="function" signature="crc_table()" attributes="__classmethod__" doc="Returns the table for calculating CRC checksum as an array." />
        <scope name="zlib_version" ilk="function" signature="zlib_version()" attributes="__classmethod__" doc="Returns the string which represents the version of zlib library." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="ZLIB_VERSION" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        <variable name="NO_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="BEST_SPEED" attributes="__const__" citdl="Object" />
        <variable name="BEST_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="FILTERED" attributes="__const__" citdl="Object" />
        <variable name="HUFFMAN_ONLY" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_STRATEGY" attributes="__const__" citdl="Object" />
        <variable name="MAX_WBITS" attributes="__const__" citdl="Object" />
        <variable name="DEF_MEM_LEVEL" attributes="__const__" citdl="Object" />
        <variable name="MAX_MEM_LEVEL" attributes="__const__" citdl="Object" />
        <variable name="NO_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="SYNC_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="FULL_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="FINISH" attributes="__const__" citdl="Object" />
        <variable name="OS_CODE" attributes="__const__" citdl="Object" />
        <variable name="OS_MSDOS" attributes="__const__" citdl="Object" />
        <variable name="OS_AMIGA" attributes="__const__" citdl="Object" />
        <variable name="OS_VMS" attributes="__const__" citdl="Object" />
        <variable name="OS_UNIX" attributes="__const__" citdl="Object" />
        <variable name="OS_ATARI" attributes="__const__" citdl="Object" />
        <variable name="OS_MACOS" attributes="__const__" citdl="Object" />
        <variable name="OS_VMCMS" attributes="__const__" citdl="Object" />
        <variable name="OS_ZSYSTEM" attributes="__const__" citdl="Object" />
        <variable name="OS_CPM" attributes="__const__" citdl="Object" />
        <variable name="OS_QDOS" attributes="__const__" citdl="Object" />
        <variable name="OS_RISCOS" attributes="__const__" citdl="Object" />
        <variable name="OS_UNKNOWN" attributes="__const__" citdl="Object" />
        <scope name="BufError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="DataError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="Deflate" ilk="class" classrefs="Zlib::ZStream">
          <scope name="deflate" ilk="function" signature="deflate(...)" attributes="__classmethod__" doc="Compresses the given +string+. Valid values of level are Zlib::NO_COMPRESSION, Zlib::BEST_SPEED, Zlib::BEST_COMPRESSION, Zlib::DEFAULT_COMPRESSION, and an integer from 0 to 9. &#xA; This method is almost equivalent to the following code: &#xA;   def deflate(string, level)&#xA;    z = Zlib::Deflate.new(level)&#xA;    dst = z.deflate(string, Zlib::FINISH)&#xA;    z.close&#xA;    dst&#xA;  end&#xA; TODO: what&apos;s default value of +level+?" />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a new deflate stream for compression. See zlib.h for details of each argument. If an argument is nil, the default value of that argument is used. &#xA; TODO: document better!" />
          <scope name="deflate" ilk="function" signature="deflate(...)" doc="Inputs +string+ into the deflate stream and returns the output from the stream.  On calling this method, both the input and the output buffers of the stream are flushed. If +string+ is nil, this method finishes the stream, just like Zlib::ZStream#finish. &#xA; The value of +flush+ should be either Zlib::NO_FLUSH, Zlib::SYNC_FLUSH, Zlib::FULL_FLUSH, or Zlib::FINISH. See zlib.h for details. &#xA; TODO: document better!" />
          <scope name="flush" ilk="function" signature="flush(...)" doc="This method is equivalent to deflate(&apos;&apos;, flush).  If flush is omitted, Zlib::SYNC_FLUSH is used as flush.  This method is just provided to improve the readability of your Ruby program. &#xA; TODO: document better!" />
          <scope name="initialize_copy" ilk="function" signature="initialize_copy(p1)" doc="Duplicates the deflate stream." />
          <scope name="params" ilk="function" signature="params(p1, p2)" doc="Changes the parameters of the deflate stream. See zlib.h for details. The output from the stream by changing the params is preserved in output buffer. &#xA; TODO: document better!" />
          <scope name="set_dictionary" ilk="function" signature="set_dictionary(p1)" doc="Sets the preset dictionary and returns +string+. This method is available just only after Zlib::Deflate.new or Zlib::ZStream#reset method was called. See zlib.h for details. &#xA; TODO: document better!" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="GzipFile" ilk="class" classrefs="Object">
          <scope name="wrap" ilk="function" signature="wrap(...)" attributes="__classmethod__" doc="Creates a GzipFile object associated with +io+, and executes the block with the newly created GzipFile object, just like File.open. The GzipFile object will be closed automatically after executing the block. If you want to keep the associated IO object opening, you may call +Zlib::GzipFile#finish+ method in the block." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the GzipFile object. This method calls close method of the associated IO object. Returns the associated IO object." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Same as IO." />
          <scope name="comment" ilk="function" signature="comment()" doc="Returns comments recorded in the gzip file header, or nil if the comments is not present." />
          <scope name="crc" ilk="function" signature="crc()" doc="Returns CRC value of the uncompressed data." />
          <scope name="finish" ilk="function" signature="finish()" doc="Closes the GzipFile object. Unlike Zlib::GzipFile#close, this method never calls the close method of the associated IO object. Returns the associated IO object." />
          <scope name="level" ilk="function" signature="level()" doc="Returns compression level." />
          <scope name="mtime" ilk="function" signature="mtime()" doc="Returns last modification time recorded in the gzip file header." />
          <scope name="orig_name" ilk="function" signature="orig_name()" doc="Returns original filename recorded in the gzip file header, or +nil+ if original filename is not present." />
          <scope name="os_code" ilk="function" signature="os_code()" doc="Returns OS code number recorded in the gzip file header." />
          <scope name="sync" ilk="function" signature="sync()" doc="Same as IO." />
          <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Same as IO.  If flag is +true+, the associated IO object must respond to the +flush+ method.  While +sync+ mode is +true+, the compression ratio decreases sharply." />
          <scope name="to_io" ilk="function" signature="to_io()" doc="Same as IO." />
          <scope name="CRCError" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
          <scope name="Error" ilk="class" classrefs="Zlib::Error">
          </scope>
          <scope name="LengthError" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
          <scope name="NoFooter" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
        </scope>
        <scope name="GzipReader" ilk="class" classrefs="Zlib::GzipFile">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a GzipReader object associated with +io+. The GzipReader object reads gzipped data from +io+, and parses/decompresses them.  At least, +io+ must have a +read+ method that behaves same as the +read+ method in IO class. &#xA; If the gzip file header is incorrect, raises an Zlib::GzipFile::Error exception." />
          <scope name="open" ilk="function" signature="open(...)" attributes="__classmethod__" doc="Opens a file specified by +filename+ as a gzipped file, and returns a GzipReader object associated with that file.  Further details of this method are in Zlib::GzipReader.new and ZLib::GzipFile.wrap." />
          <scope name="bytes" ilk="function" signature="bytes()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each" ilk="function" signature="each(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_byte" ilk="function" signature="each_byte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_char" ilk="function" signature="each_char()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_line" ilk="function" signature="each_line(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="eof" ilk="function" signature="eof()" doc="???" />
          <scope name="eof?" ilk="function" signature="eof?()" doc="???" />
          <scope name="getbyte" ilk="function" signature="getbyte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="getc" ilk="function" signature="getc()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="gets" ilk="function" signature="gets(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="lineno" ilk="function" signature="lineno()" doc="???" />
          <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="???" />
          <scope name="lines" ilk="function" signature="lines(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="pos" ilk="function" signature="pos()" doc="???" />
          <scope name="read" ilk="function" signature="read(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readbyte" ilk="function" signature="readbyte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readchar" ilk="function" signature="readchar()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readline" ilk="function" signature="readline(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readlines" ilk="function" signature="readlines(...)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readpartial" ilk="function" signature="readpartial(...)" doc="Reads at most maxlen bytes from the gziped stream but it blocks only if gzipreader has no data immediately available. If the optional outbuf argument is present, it must reference a String, which will receive the data. It raises EOFError on end of file." />
          <scope name="rewind" ilk="function" signature="rewind()" doc="Resets the position of the file pointer to the point created the GzipReader object.  The associated IO object needs to respond to the +seek+ method." />
          <scope name="tell" ilk="function" signature="tell()" doc="???" />
          <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="unused" ilk="function" signature="unused()" doc="Returns the rest of the data which had read for parsing gzip format, or +nil+ if the whole gzip file is not parsed yet." />
        </scope>
        <scope name="GzipWriter" ilk="class" classrefs="Zlib::GzipFile">
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a GzipWriter object associated with +io+. +level+ and +strategy+ should be the same as the arguments of Zlib::Deflate.new.  The GzipWriter object writes gzipped data to +io+.  At least, +io+ must respond to the +write+ method that behaves same as write method in IO class." />
          <scope name="open" ilk="function" signature="open(...)" attributes="__classmethod__" doc="Opens a file specified by +filename+ for writing gzip compressed data, and returns a GzipWriter object associated with that file.  Further details of this method are found in Zlib::GzipWriter.new and Zlib::GzipFile.wrap." />
          <scope name="comment=" ilk="function" signature="comment=(p1)" doc="???" />
          <scope name="flush" ilk="function" signature="flush(...)" doc="Flushes all the internal buffers of the GzipWriter object.  The meaning of +flush+ is same as in Zlib::Deflate#deflate.  Zlib::SYNC_FLUSH is used if +flush+ is omitted.  It is no use giving flush Zlib::NO_FLUSH." />
          <scope name="mtime=" ilk="function" signature="mtime=(p1)" doc="???" />
          <scope name="orig_name=" ilk="function" signature="orig_name=(p1)" doc="???" />
          <scope name="pos" ilk="function" signature="pos()" doc="???" />
          <scope name="print" ilk="function" signature="print(...)" doc="  &#xA;   &#xA;   Same as IO.&#xA;   &#xA; Same as IO." />
          <scope name="printf" ilk="function" signature="printf(...)" doc="  &#xA;   &#xA;   Same as IO.&#xA;   &#xA; Same as IO." />
          <scope name="putc" ilk="function" signature="putc(p1)" doc="Same as IO." />
          <scope name="puts" ilk="function" signature="puts(...)" doc="  &#xA;   &#xA;   Same as IO.&#xA;   &#xA; Same as IO." />
          <scope name="tell" ilk="function" signature="tell()" doc="???" />
          <scope name="write" ilk="function" signature="write(p1)" doc="Same as IO." />
        </scope>
        <scope name="Inflate" ilk="class" classrefs="Zlib::ZStream">
          <scope name="inflate" ilk="function" signature="inflate(p1)" attributes="__classmethod__" doc="Decompresses +string+. Raises a Zlib::NeedDict exception if a preset dictionary is needed for decompression. &#xA; This method is almost equivalent to the following code: &#xA;   def inflate(string)&#xA;    zstream = Zlib::Inflate.new&#xA;    buf = zstream.inflate(string)&#xA;    zstream.finish&#xA;    zstream.close&#xA;    buf&#xA;  end" />
          <scope name="new" ilk="function" signature="new(...)" attributes="__classmethod__ __ctor__" doc="Creates a new inflate stream for decompression. See zlib.h for details of the argument.  If +window_bits+ is +nil+, the default value is used. &#xA; TODO: document better!" />
          <scope name="inflate" ilk="function" signature="inflate(p1)" doc="Inputs +string+ into the inflate stream and returns the output from the stream.  Calling this method, both the input and the output buffer of the stream are flushed.  If string is +nil+, this method finishes the stream, just like Zlib::ZStream#finish. &#xA; Raises a Zlib::NeedDict exception if a preset dictionary is needed to decompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then call this method again with an empty string.  (???) &#xA; TODO: document better!" />
          <scope name="set_dictionary" ilk="function" signature="set_dictionary(p1)" doc="Sets the preset dictionary and returns +string+.  This method is available just only after a Zlib::NeedDict exception was raised.  See zlib.h for details. &#xA; TODO: document better!" />
          <scope name="sync" ilk="function" signature="sync(p1)" doc="Inputs +string+ into the end of input buffer and skips data until a full flush point can be found.  If the point is found in the buffer, this method flushes the buffer and returns false.  Otherwise it returns +true+ and the following data of full flush point is preserved in the buffer." />
          <scope name="sync_point?" ilk="function" signature="sync_point?()" doc="Quoted verbatim from original documentation: &#xA;   What is this?&#xA; :)" />
        </scope>
        <scope name="MemError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="NeedDict" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="StreamEnd" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="StreamError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="VersionError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="ZStream" ilk="class" classrefs="Object">
          <scope name="adler" ilk="function" signature="adler()" doc="Returns the adler-32 checksum." />
          <scope name="avail_in" ilk="function" signature="avail_in()" doc="Returns bytes of data in the input buffer. Normally, returns 0." />
          <scope name="avail_out" ilk="function" signature="avail_out()" doc="Returns number of bytes of free spaces in output buffer.  Because the free space is allocated automatically, this method returns 0 normally." />
          <scope name="avail_out=" ilk="function" signature="avail_out=(p1)" doc="Allocates +size+ bytes of free space in the output buffer. If there are more than +size+ bytes already in the buffer, the buffer is truncated. Because free space is allocated automatically, you usually don&apos;t need to use this method." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the stream. All operations on the closed stream will raise an exception." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if the stream is closed." />
          <scope name="data_type" ilk="function" signature="data_type()" doc="Guesses the type of the data which have been inputed into the stream. The returned value is either Zlib::BINARY, Zlib::ASCII, or Zlib::UNKNOWN." />
          <scope name="end" ilk="function" signature="end()" doc="Closes the stream. All operations on the closed stream will raise an exception." />
          <scope name="ended?" ilk="function" signature="ended?()" doc="Returns true if the stream is closed." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the stream and flushes output buffer. See Zlib::Deflate#finish and Zlib::Inflate#finish for details of this behavior." />
          <scope name="finished?" ilk="function" signature="finished?()" doc="Returns true if the stream is finished." />
          <scope name="flush_next_in" ilk="function" signature="flush_next_in()" doc="Flushes input buffer and returns all data in that buffer." />
          <scope name="flush_next_out" ilk="function" signature="flush_next_out()" doc="Flushes output buffer and returns all data in that buffer." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets and initializes the stream. All data in both input and output buffer are discarded." />
          <scope name="stream_end?" ilk="function" signature="stream_end?()" doc="Returns true if the stream is finished." />
          <scope name="total_in" ilk="function" signature="total_in()" doc="Returns the total bytes of the input data to the stream.  FIXME" />
          <scope name="total_out" ilk="function" signature="total_out()" doc="Returns the total bytes of the output data from the stream.  FIXME" />
        </scope>
      </scope>
    </scope>
  </file>
</codeintel>
