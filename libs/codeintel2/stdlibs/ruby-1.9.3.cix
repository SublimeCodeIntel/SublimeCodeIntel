<?xml version="1.0" encoding="utf-8" ?>
<codeintel version="2.0" name="Ruby 1.9.2" description="Cix data for Ruby 1.9.2">
  <file lang="Ruby" mtime="1338831415" path="ruby-1.9.2.cix">
    <scope ilk="blob" lang="Ruby" name="*">
      <scope name="Object" ilk="class" >
        <scope name="__id__" ilk="function" />
        <scope name="class" ilk="function" signature="class()" doc="Returns the class of obj. This method must always be called with an explicit receiver, as class is also a reserved word in Ruby. &#xA; 1.class      =&gt; Fixnum&#xA;self.class   =&gt; Object" />
        <scope name="clone" ilk="function" signature="clone()" doc="Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. Copies the frozen and tainted state of obj. See also the discussion under Object#dup. &#xA; class Klass&#xA;   attr_accessor :str&#xA;end&#xA;s1 = Klass.new      =&gt; #&lt;Klass:0x401b3a38&gt;&#xA;s1.str = &quot;Hello&quot;    =&gt; &quot;Hello&quot;&#xA;s2 = s1.clone       =&gt; #&lt;Klass:0x401b3998 @str=&quot;Hello&quot;&gt;&#xA;s2.str[1,4] = &quot;i&quot;   =&gt; &quot;i&quot;&#xA;s1.inspect          =&gt; &quot;#&lt;Klass:0x401b3a38 @str=\&quot;Hi\&quot;&gt;&quot;&#xA;s2.inspect          =&gt; &quot;#&lt;Klass:0x401b3998 @str=\&quot;Hi\&quot;&gt;&quot;&#xA; This method may have class-specific behavior.  If so, that behavior will be documented under the #+initialize_copy+ method of the class." />
        <scope name="define_singleton_method" ilk="function" signature="define_singleton_method(*args)" doc="Defines a singleton method in the receiver. The _method_ parameter can be a +Proc+, a +Method+ or an +UnboundMethod+ object. If a block is specified, it is used as the method body. &#xA; class A&#xA;  class &lt;&lt; self&#xA;    def class_name&#xA;      to_s&#xA;    end&#xA;  end&#xA;end&#xA;A.define_singleton_method(:who_am_i) do&#xA;  &quot;I am: #{class_name}&quot;&#xA;end&#xA;A.who_am_i   # ==&gt; &quot;I am: A&quot;&#xA;guy = &quot;Bob&quot;" />
        <scope name="display" ilk="function" signature="display(p1 = v1)" doc="Prints obj on the given port (default $&gt;). Equivalent to: &#xA; def display(port=$&gt;)&#xA;  port.write self&#xA;end&#xA; For example: &#xA; 1.display&#xA;&quot;cat&quot;.display&#xA;[ 4, 5, 6 ].display&#xA;puts&#xA; produces: &#xA; 1cat456" />
        <scope name="dup" ilk="function" signature="dup()" doc="Produces a shallow copy of obj---the instance variables of obj are copied, but not the objects they reference. dup copies the tainted state of obj. See also the discussion under Object#clone. In general, clone and dup may have different semantics in descendant classes. While clone is used to duplicate an object, including its internal state, dup typically uses the class of the descendant object to create the new instance. &#xA; This method may have class-specific behavior.  If so, that behavior will be documented under the #+initialize_copy+ method of the class." />
        <scope name="enum_for" ilk="function" signature="enum_for(*args)" doc="Creates a new Enumerator which will enumerate by on calling +method+ on +obj+. &#xA; the method to call on +obj+ to generate the enumeration&#xA;arguments that will be passed in +method+ in addition to the item itself.  Note that the number of args must not exceed the number expected by +method+ &#xA; Example &#xA; str = &quot;xyz&quot;&#xA;enum = str.enum_for(:each_byte)&#xA;enum.each { |b| puts b }&#xA;# =&gt; 120&#xA;# =&gt; 121&#xA;# =&gt; 122&#xA;# protect an array from being modified by some_method&#xA;a = [1, 2, 3]&#xA;some_method(a.to_enum)" />
        <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Equality---At the Object level, == returns true only if obj and other are the same object. Typically, this method is overridden in descendant classes to provide class-specific meaning. &#xA; Unlike ==, the equal? method should never be overridden by subclasses: it is used to determine object identity (that is, a.equal?(b) iff a is the same object as b). &#xA; The eql? method returns true if obj and anObject have the same value. Used by Hash to test members for equality.  For objects of class Object, eql? is synonymous with ==. Subclasses normally continue this tradition, but there are exceptions. Numeric types, for example, perform type conversion across ==, but not across eql?, so: &#xA; 1 == 1.0     =&gt; true&#xA;1.eql? 1.0   =&gt; false" />
        <scope name="extend" ilk="function" signature="extend(*args)" doc="Adds to _obj_ the instance methods from each module given as a parameter. &#xA; module Mod&#xA;  def hello&#xA;    &quot;Hello from Mod.\n&quot;&#xA;  end&#xA;end&#xA;class Klass&#xA;  def hello&#xA;    &quot;Hello from Klass.\n&quot;&#xA;  end&#xA;end&#xA;k = Klass.new&#xA;k.hello         =&gt; &quot;Hello from Klass.\n&quot;" />
        <scope name="freeze" ilk="function" signature="freeze()" doc="Prevents further modifications to obj. A RuntimeError will be raised if modification is attempted. There is no way to unfreeze a frozen object. See also Object#frozen?. &#xA; This method returns self. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.freeze&#xA;a &lt;&lt; &quot;z&quot;&#xA; produces: &#xA; prog.rb:3:in `&lt;&lt;&apos;: can&apos;t modify frozen array (RuntimeError)&#xA; from prog.rb:3" />
        <scope name="frozen?" ilk="function" signature="frozen?()" doc="Returns the freeze status of obj. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.freeze    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;a.frozen?   =&gt; true" />
        <scope name="hash" ilk="function" signature="hash()" doc="Generates a Fixnum hash value for this object. This function must have the property that a.eql?(b) implies a.hash == b.hash. The hash value is used by class Hash. Any hash value that exceeds the capacity of a Fixnum will be truncated before being used. &#xA; &quot;waffle&quot;.hash =&gt; -910576647" />
        <scope name="initialize_clone" ilk="function" />
        <scope name="initialize_dup" ilk="function" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a human-readable representation of obj. If not overridden and no instance variables, uses the to_s method to generate the string. obj.  If not overridden, uses the to_s method to generate the string. &#xA; [ 1, 2, 3..4, &apos;five&apos; ].inspect   =&gt; &quot;[1, 2, 3..4, \&quot;five\&quot;]&quot;&#xA;Time.new.inspect                 =&gt; &quot;2008-03-08 19:43:39 +0900&quot;" />
        <scope name="instance_of?" ilk="function" signature="instance_of?(p1)" doc="Returns true if obj is an instance of the given class. See also Object#kind_of?. &#xA; class A;     end&#xA;class B &lt; A; end&#xA;class C &lt; B; end&#xA;&#xA;b = B.new&#xA;b.instance_of? A   =&gt; false&#xA;b.instance_of? B   =&gt; true&#xA;b.instance_of? C   =&gt; false" />
        <scope name="instance_variable_defined?" ilk="function" signature="instance_variable_defined?(p1)" doc="Returns true if the given instance variable is defined in obj. &#xA; class Fred&#xA;  def initialize(p1, p2)&#xA;    @a, @b = p1, p2&#xA;  end&#xA;end&#xA;fred = Fred.new(&apos;cat&apos;, 99)&#xA;fred.instance_variable_defined?(:@a)    =&gt; true&#xA;fred.instance_variable_defined?(&quot;@b&quot;)   =&gt; true&#xA;fred.instance_variable_defined?(&quot;@c&quot;)   =&gt; false" />
        <scope name="instance_variable_get" ilk="function" signature="instance_variable_get(p1)" doc="Returns the value of the given instance variable, or nil if the instance variable is not set. The @ part of the variable name should be included for regular instance variables. Throws a NameError exception if the supplied symbol is not valid as an instance variable name. &#xA; class Fred&#xA;  def initialize(p1, p2)&#xA;    @a, @b = p1, p2&#xA;  end&#xA;end&#xA;fred = Fred.new(&apos;cat&apos;, 99)&#xA;fred.instance_variable_get(:@a)    =&gt; &quot;cat&quot;&#xA;fred.instance_variable_get(&quot;@b&quot;)   =&gt; 99" />
        <scope name="instance_variable_set" ilk="function" signature="instance_variable_set(p1, p2)" doc="Sets the instance variable names by symbol to object, thereby frustrating the efforts of the class&apos;s author to attempt to provide proper encapsulation. The variable did not have to exist prior to this call. &#xA; class Fred&#xA;  def initialize(p1, p2)&#xA;    @a, @b = p1, p2&#xA;  end&#xA;end&#xA;fred = Fred.new(&apos;cat&apos;, 99)&#xA;fred.instance_variable_set(:@a, &apos;dog&apos;)   =&gt; &quot;dog&quot;&#xA;fred.instance_variable_set(:@c, &apos;cat&apos;)   =&gt; &quot;cat&quot;&#xA;fred.inspect                             =&gt; &quot;#&lt;Fred:0x401b3da8 @a=\&quot;dog\&quot;, @b=99, @c=\&quot;cat\&quot;&gt;&quot;" />
        <scope name="instance_variables" ilk="function" signature="instance_variables()" doc="Returns an array of instance variable names for the receiver. Note that simply defining an accessor does not create the corresponding instance variable. &#xA; class Fred&#xA;  attr_accessor :a1&#xA;  def initialize&#xA;    @iv = 3&#xA;  end&#xA;end&#xA;Fred.new.instance_variables   =&gt; [:@iv]" />
        <scope name="is_a?" ilk="function" signature="is_a?(p1)" doc="Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj. &#xA; module M;    end&#xA;class A&#xA;  include M&#xA;end&#xA;class B &lt; A; end&#xA;class C &lt; B; end&#xA;b = B.new&#xA;b.is_a? A          =&gt; true&#xA;b.is_a? B          =&gt; true&#xA;b.is_a? C          =&gt; false&#xA;b.is_a? M          =&gt; true&#xA;b.kind_of? A       =&gt; true" />
        <scope name="kind_of?" ilk="function" signature="kind_of?(p1)" doc="Returns true if class is the class of obj, or if class is one of the superclasses of obj or modules included in obj. &#xA; module M;    end&#xA;class A&#xA;  include M&#xA;end&#xA;class B &lt; A; end&#xA;class C &lt; B; end&#xA;b = B.new&#xA;b.is_a? A          =&gt; true&#xA;b.is_a? B          =&gt; true&#xA;b.is_a? C          =&gt; false&#xA;b.is_a? M          =&gt; true&#xA;b.kind_of? A       =&gt; true" />
        <scope name="method" ilk="function" signature="method(p1)" doc="Looks up the named method as a receiver in obj, returning a Method object (or raising NameError). The Method object acts as a closure in obj&apos;s object instance, so instance variables and the value of self remain available. &#xA; class Demo&#xA;  def initialize(n)&#xA;    @iv = n&#xA;  end&#xA;  def hello()&#xA;    &quot;Hello, @iv = #{@iv}&quot;&#xA;  end&#xA;end&#xA;k = Demo.new(99)&#xA;m = k.method(:hello)&#xA;m.call   =&gt; &quot;Hello, @iv = 99&quot;&#xA;l = Demo.new(&apos;Fred&apos;)" />
        <scope name="methods" ilk="function" />
        <scope name="nil?" ilk="function" signature="nil?()" doc="call_seq: nil.nil?               -&gt; true&#xA;&lt;anything_else&gt;.nil?   -&gt; false&#xA; Only the object nil responds true to nil?." />
        <scope name="object_id" ilk="function" signature="object_id()" doc="Returns an integer identifier for obj. The same number will be returned on all calls to id for a given object, and no two active objects will share an id. Object#object_id is a different concept from the :name notation, which returns the symbol id of name. Replaces the deprecated Object#id." />
        <scope name="private_methods" ilk="function" />
        <scope name="protected_methods" ilk="function" />
        <scope name="public_method" ilk="function" signature="public_method(p1)" doc="Similar to _method_, searches public method only." />
        <scope name="public_methods" ilk="function" />
        <scope name="public_send" ilk="function" signature="public_send(*args)" doc="Invokes the method identified by _symbol_, passing it any arguments specified. Unlike send, public_send calls public methods only. &#xA; 1.public_send(:puts, &quot;hello&quot;)  # causes NoMethodError" />
        <scope name="respond_to?" ilk="function" signature="respond_to?(p1, p2 = v2)" doc="Returns +true+ if _obj_ responds to the given method. Private methods are included in the search only if the optional second parameter evaluates to +true+. &#xA; If the method is not implemented, as Process.fork on Windows, File.lchmod on GNU/Linux, etc., false is returned. &#xA; If the method is not defined, respond_to_missing? method is called and the result is returned." />
        <scope name="respond_to_missing?" ilk="function" signature="respond_to_missing?(p1, p2)" doc="Hook method to return whether the _obj_ can respond to _id_ method or not. &#xA; See #respond_to?." />
        <scope name="send" ilk="function" signature="send(*args)" doc="Invokes the method identified by _symbol_, passing it any arguments specified. You can use __send__ if the name +send+ clashes with an existing method in _obj_. &#xA; class Klass&#xA;  def hello(*args)&#xA;    &quot;Hello &quot; + args.join(&apos; &apos;)&#xA;  end&#xA;end&#xA;k = Klass.new&#xA;k.send :hello, &quot;gentle&quot;, &quot;readers&quot;   =&gt; &quot;Hello gentle readers&quot;" />
        <scope name="singleton_class" ilk="function" signature="singleton_class()" doc="Returns the singleton class of obj.  This method creates a new singleton class if obj does not have it. &#xA; If obj is nil, true, or false, it returns NilClass, TrueClass, or FalseClass, respectively. If obj is a Fixnum or a Symbol, it raises a TypeError. &#xA; Object.new.singleton_class  =&gt; #&lt;Class:#&lt;Object:0xb7ce1e24&gt;&gt;&#xA;String.singleton_class      =&gt; #&lt;Class:String&gt;&#xA;nil.singleton_class         =&gt; NilClass" />
        <scope name="singleton_methods" ilk="function" signature="singleton_methods(p1 = v1)" doc="Returns an array of the names of singleton methods for obj. If the optional all parameter is true, the list will include methods in modules included in obj. Only public and protected singleton methods are returned. &#xA; module Other&#xA;  def three() end&#xA;end&#xA;class Single&#xA;  def Single.four() end&#xA;end&#xA;a = Single.new&#xA;def a.one()&#xA;end&#xA;class &lt;&lt; a&#xA;  include Other&#xA;  def two()" />
        <scope name="syck_to_yaml" ilk="function" />
        <scope name="taguri" ilk="function" />
        <scope name="taguri=" ilk="function" />
        <scope name="taint" ilk="function" signature="taint()" doc="Marks obj as tainted---if the $SAFE level is set appropriately, many method calls which might alter the running programs environment will refuse to accept tainted strings." />
        <scope name="tainted?" ilk="function" signature="tainted?()" doc="Returns true if the object is tainted." />
        <scope name="tap" ilk="function" signature="tap()" doc="Yields x to the block, and then returns x. The primary purpose of this method is to &quot;tap into&quot; a method chain, in order to perform operations on intermediate results within the chain. &#xA; (1..10)                .tap {|x| puts &quot;original: #{x.inspect}&quot;}&#xA;  .to_a                .tap {|x| puts &quot;array: #{x.inspect}&quot;}&#xA;  .select {|x| x%2==0} .tap {|x| puts &quot;evens: #{x.inspect}&quot;}&#xA;  .map { |x| x*x }     .tap {|x| puts &quot;squares: #{x.inspect}&quot;}" />
        <scope name="to_enum" ilk="function" signature="to_enum(*args)" doc="Creates a new Enumerator which will enumerate by on calling +method+ on +obj+. &#xA; the method to call on +obj+ to generate the enumeration&#xA;arguments that will be passed in +method+ in addition to the item itself.  Note that the number of args must not exceed the number expected by +method+ &#xA; Example &#xA; str = &quot;xyz&quot;&#xA;enum = str.enum_for(:each_byte)&#xA;enum.each { |b| puts b }&#xA;# =&gt; 120&#xA;# =&gt; 121&#xA;# =&gt; 122&#xA;# protect an array from being modified by some_method&#xA;a = [1, 2, 3]&#xA;some_method(a.to_enum)" />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Returns a string representing obj. The default to_s prints the object&apos;s class and an encoding of the object id. As a special case, the top-level object that is the initial execution context of Ruby programs returns ``main.&apos;&apos;" />
        <scope name="to_yaml" ilk="function" signature="to_yaml(options = {})" />
        <scope name="to_yaml_properties" ilk="function" />
        <scope name="to_yaml_style" ilk="function" />
        <scope name="trust" ilk="function" signature="trust()" doc="Removes the untrusted mark from obj." />
        <scope name="untaint" ilk="function" signature="untaint()" doc="Removes the taint from obj." />
        <scope name="untrust" ilk="function" signature="untrust()" doc="Marks obj as untrusted." />
        <scope name="untrusted?" ilk="function" signature="untrusted?()" doc="Returns true if the object is untrusted." />
        <scope name="yaml_tag_subclasses?" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Module" ilk="class" classrefs="Object" >
        <scope name="ancestors" ilk="function" signature="ancestors()" doc="Returns a list of modules included in mod (including mod itself). &#xA; module Mod&#xA;  include Math&#xA;  include Comparable&#xA;end&#xA;&#xA;Mod.ancestors    =&gt; [Mod, Comparable, Math]&#xA;Math.ancestors   =&gt; [Math]" />
        <scope name="autoload" ilk="function" signature="autoload(p1, p2)" doc="Registers _filename_ to be loaded (using Kernel::require) the first time that _module_ (which may be a String or a symbol) is accessed in the namespace of _mod_. &#xA; module A&#xA;end&#xA;A.autoload(:B, &quot;b&quot;)&#xA;A::B.doit            # autoloads &quot;b&quot;" />
        <scope name="autoload?" ilk="function" signature="autoload?(p1)" doc="Returns _filename_ to be loaded if _name_ is registered as +autoload+ in the namespace of _mod_. &#xA; module A&#xA;end&#xA;A.autoload(:B, &quot;b&quot;)&#xA;A.autoload?(:B)            =&gt; &quot;b&quot;" />
        <scope name="class_eval" ilk="function" signature="class_eval(*args)" doc="Evaluates the string or block in the context of _mod_. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional _filename_ and _lineno_ parameters set the text for error messages. &#xA; class Thing&#xA;end&#xA;a = %q{def hello() &quot;Hello there!&quot; end}&#xA;Thing.module_eval(a)&#xA;puts Thing.new.hello()&#xA;Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)&#xA; produces: &#xA; Hello there!&#xA;dummy:123:in `module_eval&apos;: undefined local variable&#xA;    or method `code&apos; for Thing:Class" />
        <scope name="class_exec" ilk="function" signature="class_exec(*args)" doc="Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. &#xA; class Thing&#xA;end&#xA;Thing.class_exec{&#xA;  def hello() &quot;Hello there!&quot; end&#xA;}&#xA;puts Thing.new.hello()&#xA; produces: &#xA; Hello there!" />
        <scope name="class_variable_defined?" ilk="function" signature="class_variable_defined?(p1)" doc="Returns true if the given class variable is defined in obj. &#xA; class Fred&#xA;  @@foo = 99&#xA;end&#xA;Fred.class_variable_defined?(:@@foo)    =&gt; true&#xA;Fred.class_variable_defined?(:@@bar)    =&gt; false" />
        <scope name="class_variable_get" ilk="function" signature="class_variable_get(p1)" doc="Returns the value of the given class variable (or throws a NameError exception). The @@ part of the variable name should be included for regular class variables &#xA; class Fred&#xA;  @@foo = 99&#xA;end&#xA;Fred.class_variable_get(:@@foo)     =&gt; 99" />
        <scope name="class_variable_set" ilk="function" signature="class_variable_set(p1, p2)" doc="Sets the class variable names by symbol to object. &#xA; class Fred&#xA;  @@foo = 99&#xA;  def foo&#xA;    @@foo&#xA;  end&#xA;end&#xA;Fred.class_variable_set(:@@foo, 101)     =&gt; 101&#xA;Fred.new.foo                             =&gt; 101" />
        <scope name="class_variables" ilk="function" signature="class_variables()" doc="Returns an array of the names of class variables in mod. &#xA; class One&#xA;  @@var1 = 1&#xA;end&#xA;class Two &lt; One&#xA;  @@var2 = 2&#xA;end&#xA;One.class_variables   =&gt; [:@@var1]&#xA;Two.class_variables   =&gt; [:@@var2]" />
        <scope name="const_defined?" ilk="function" signature="const_defined?(p1, p2 = v2)" doc="Checks for a constant with the given name in mod If +inherit+ is set, the lookup will also search the ancestors (and +Object+ if mod is a +Module+.) &#xA; Returns whether or not a definition is found: &#xA; Math.const_defined? &quot;PI&quot;   =&gt; true&#xA;IO.const_defined? :SYNC   =&gt; true&#xA;IO.const_defined? :SYNC, false   =&gt; false" />
        <scope name="const_get" ilk="function" signature="const_get(p1, p2 = v2)" doc="Checks for a constant with the given name in mod If +inherit+ is set, the lookup will also search the ancestors (and +Object+ if mod is a +Module+.) &#xA; The value of the constant is returned if a definition is found, otherwise a +NameError+ is raised. &#xA; Math.const_get(:PI)   =&gt; 3.14159265358979" />
        <scope name="const_missing" ilk="function" signature="const_missing(p1)" doc="Invoked when a reference is made to an undefined constant in mod. It is passed a symbol for the undefined constant, and returns a value to be used for that constant. The following code is an example of the same: &#xA; def Foo.const_missing(name)&#xA;  name # return the constant name as Symbol&#xA;end&#xA;Foo::UNDEFINED_CONST    =&gt; :UNDEFINED_CONST: symbol returned&#xA; In the next example when a reference is made to an undefined constant, it attempts to load a file whose name is the lowercase version of the constant (thus class Fred is assumed to be in file fred.rb).  If found, it returns the loaded class. It therefore implements an autoload feature similar to Kernel#autoload and Module#autoload. &#xA; def Object.const_missing(name)&#xA;  @looked_for ||= {}&#xA;  str_name = name.to_s&#xA;  raise &quot;Class not found: #{name}&quot; if @looked_for[str_name]&#xA;  @looked_for[str_name] = 1&#xA;  file = str_name.downcase&#xA;  require file" />
        <scope name="const_set" ilk="function" signature="const_set(p1, p2)" doc="Sets the named constant to the given object, returning that object. Creates a new constant if no constant with the given name previously existed. &#xA; Math.const_set(&quot;HIGH_SCHOOL_PI&quot;, 22.0/7.0)   =&gt; 3.14285714285714&#xA;Math::HIGH_SCHOOL_PI - Math::PI              =&gt; 0.00126448926734968" />
        <scope name="constants" ilk="function" signature="constants(p1 = v1)" doc="Returns an array of the names of the constants accessible in mod. This includes the names of constants in any included modules (example at start of section), unless the all parameter is set to false. &#xA; IO.constants.include?(:SYNC)        =&gt; true&#xA;IO.constants(false).include?(:SYNC) =&gt; false&#xA; Also see Module::const_defined?." />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if module is included in mod or one of mod&apos;s ancestors. &#xA; module A&#xA;end&#xA;class B&#xA;  include A&#xA;end&#xA;class C &lt; B&#xA;end&#xA;B.include?(A)   =&gt; true&#xA;C.include?(A)   =&gt; true&#xA;A.include?(A)   =&gt; false" />
        <scope name="included_modules" ilk="function" signature="included_modules()" doc="Returns the list of modules included in mod. &#xA; module Mixin&#xA;end&#xA;&#xA;module Outer&#xA;  include Mixin&#xA;end&#xA;&#xA;Mixin.included_modules   =&gt; []&#xA;Outer.included_modules   =&gt; [Mixin]" />
        <scope name="instance_method" ilk="function" signature="instance_method(p1)" doc="Returns an +UnboundMethod+ representing the given instance method in _mod_. &#xA; class Interpreter&#xA;  def do_a() print &quot;there, &quot;; end&#xA;  def do_d() print &quot;Hello &quot;;  end&#xA;  def do_e() print &quot;!\n&quot;;     end&#xA;  def do_v() print &quot;Dave&quot;;    end&#xA;  Dispatcher = {&#xA;    &quot;a&quot; =&gt; instance_method(:do_a),&#xA;    &quot;d&quot; =&gt; instance_method(:do_d),&#xA;    &quot;e&quot; =&gt; instance_method(:do_e),&#xA;    &quot;v&quot; =&gt; instance_method(:do_v)&#xA;  }&#xA;  def interpret(string)" />
        <scope name="instance_methods" ilk="function" signature="instance_methods(*args)" doc="Returns an array containing the names of the public and protected instance methods in the receiver. For a module, these are the public and protected methods; for a class, they are the instance (not singleton) methods. With no argument, or with an argument that is false, the instance methods in mod are returned, otherwise the methods in mod and mod&apos;s superclasses are returned. &#xA; module A&#xA;  def method1()  end&#xA;end&#xA;class B&#xA;  def method2()  end&#xA;end&#xA;class C &lt; B&#xA;  def method3()  end&#xA;end&#xA;A.instance_methods                =&gt; [:method1]&#xA;B.instance_methods(false)         =&gt; [:method2]&#xA;C.instance_methods(false)         =&gt; [:method3]" />
        <scope name="method_defined?" ilk="function" signature="method_defined?(p1)" doc="Returns +true+ if the named method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). Public and protected methods are matched. &#xA; module A&#xA;  def method1()  end&#xA;end&#xA;class B&#xA;  def method2()  end&#xA;end&#xA;class C &lt; B&#xA;  include A&#xA;  def method3()  end&#xA;end&#xA;A.method_defined? :method1    =&gt; true&#xA;C.method_defined? &quot;method1&quot;   =&gt; true" />
        <scope name="module_eval" ilk="function" signature="module_eval(*args)" doc="Evaluates the string or block in the context of _mod_. This can be used to add methods to a class. module_eval returns the result of evaluating its argument. The optional _filename_ and _lineno_ parameters set the text for error messages. &#xA; class Thing&#xA;end&#xA;a = %q{def hello() &quot;Hello there!&quot; end}&#xA;Thing.module_eval(a)&#xA;puts Thing.new.hello()&#xA;Thing.module_eval(&quot;invalid code&quot;, &quot;dummy&quot;, 123)&#xA; produces: &#xA; Hello there!&#xA;dummy:123:in `module_eval&apos;: undefined local variable&#xA;    or method `code&apos; for Thing:Class" />
        <scope name="module_exec" ilk="function" signature="module_exec(*args)" doc="Evaluates the given block in the context of the class/module. The method defined in the block will belong to the receiver. &#xA; class Thing&#xA;end&#xA;Thing.class_exec{&#xA;  def hello() &quot;Hello there!&quot; end&#xA;}&#xA;puts Thing.new.hello()&#xA; produces: &#xA; Hello there!" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the module mod.  Returns nil for anonymous modules." />
        <scope name="private_class_method" ilk="function" signature="private_class_method(*args)" doc="Makes existing class methods private. Often used to hide the default constructor new. &#xA; class SimpleSingleton  # Not thread safe&#xA;  private_class_method :new&#xA;  def SimpleSingleton.create(*args, &amp;block)&#xA;    @me = new(*args, &amp;block) if ! @me&#xA;    @me&#xA;  end&#xA;end" />
        <scope name="private_instance_methods" ilk="function" signature="private_instance_methods(*args)" doc="Returns a list of the private instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included. &#xA; module Mod&#xA;  def method1()  end&#xA;  private :method1&#xA;  def method2()  end&#xA;end&#xA;Mod.instance_methods           =&gt; [:method2]&#xA;Mod.private_instance_methods   =&gt; [:method1]" />
        <scope name="private_method_defined?" ilk="function" signature="private_method_defined?(p1)" doc="Returns +true+ if the named private method is defined by _ mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA; module A&#xA;  def method1()  end&#xA;end&#xA;class B&#xA;  private&#xA;  def method2()  end&#xA;end&#xA;class C &lt; B&#xA;  include A&#xA;  def method3()  end&#xA;end&#xA;A.method_defined? :method1            =&gt; true" />
        <scope name="protected_instance_methods" ilk="function" signature="protected_instance_methods(*args)" doc="Returns a list of the protected instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included." />
        <scope name="protected_method_defined?" ilk="function" signature="protected_method_defined?(p1)" doc="Returns +true+ if the named protected method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA; module A&#xA;  def method1()  end&#xA;end&#xA;class B&#xA;  protected&#xA;  def method2()  end&#xA;end&#xA;class C &lt; B&#xA;  include A&#xA;  def method3()  end&#xA;end&#xA;A.method_defined? :method1              =&gt; true" />
        <scope name="public_class_method" ilk="function" signature="public_class_method(*args)" doc="Makes a list of existing class methods public." />
        <scope name="public_instance_method" ilk="function" signature="public_instance_method(p1)" doc="Similar to _instance_method_, searches public method only." />
        <scope name="public_instance_methods" ilk="function" signature="public_instance_methods(*args)" doc="Returns a list of the public instance methods defined in mod. If the optional parameter is not false, the methods of any ancestors are included." />
        <scope name="public_method_defined?" ilk="function" signature="public_method_defined?(p1)" doc="Returns +true+ if the named public method is defined by _mod_ (or its included modules and, if _mod_ is a class, its ancestors). &#xA; module A&#xA;  def method1()  end&#xA;end&#xA;class B&#xA;  protected&#xA;  def method2()  end&#xA;end&#xA;class C &lt; B&#xA;  include A&#xA;  def method3()  end&#xA;end&#xA;A.method_defined? :method1           =&gt; true" />
        <scope name="remove_class_variable" ilk="function" signature="remove_class_variable(p1)" doc="Removes the definition of the sym, returning that constant&apos;s value. &#xA; class Dummy&#xA;  @@var = 99&#xA;  puts @@var&#xA;  remove_class_variable(:@@var)&#xA;  p(defined? @@var)&#xA;end&#xA; produces: &#xA; 99&#xA;nil" />
        <scope name="syck_yaml_as" ilk="function" />
        <scope name="yaml_as" ilk="function" signature="yaml_as(url)" />
        <scope name="yaml_tag_class_name" ilk="function" />
        <scope name="yaml_tag_read_class" ilk="function" />
        <scope name="constants" ilk="function" attributes="__classmethod__" signature="constants(*args)" doc="In the first form, returns an array of the names of all constants accessible from the point of call. This list includes the names of all modules and classes defined in the global scope. &#xA; Module.constants.first(4)&#xA;   # =&gt; [:ARGF, :ARGV, :ArgumentError, :Array]&#xA;&#xA;Module.constants.include?(:SEEK_SET)   # =&gt; false&#xA;&#xA;class IO&#xA;  Module.constants.include?(:SEEK_SET) # =&gt; true&#xA;end&#xA; The second form calls the instance method +constants+." />
        <scope name="nesting" ilk="function" attributes="__classmethod__" signature="nesting()" doc="Returns the list of +Modules+ nested at the point of call. &#xA; module M1&#xA;  module M2&#xA;    $a = Module.nesting&#xA;  end&#xA;end&#xA;$a           =&gt; [M1::M2, M1]&#xA;$a[0].name   =&gt; &quot;M1::M2&quot;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new anonymous module. If a block is given, it is passed the module object, and the block is evaluated in the context of this module using module_eval. &#xA; fred = Module.new do&#xA;  def meth1&#xA;    &quot;hello&quot;&#xA;  end&#xA;  def meth2&#xA;    &quot;bye&quot;&#xA;  end&#xA;end&#xA;a = &quot;my string&quot;&#xA;a.extend(fred)   =&gt; &quot;my string&quot;&#xA;a.meth1          =&gt; &quot;hello&quot;&#xA;a.meth2          =&gt; &quot;bye&quot;" />
      </scope>
      <scope name="Class" ilk="class" classrefs="Module" >
        <scope name="allocate" ilk="function" signature="allocate()" doc="Allocates space for a new object of class&apos;s class and does not call initialize on the new instance. The returned object must be an instance of class. &#xA; klass = Class.new do&#xA;  def initialize(*args)&#xA;    @initialized = true&#xA;  end&#xA;&#xA;  def initialized?&#xA;    @initialized || false&#xA;  end&#xA;end&#xA;&#xA;klass.allocate.initialized? =&gt; false" />
        <scope name="new" ilk="function" signature="new(*args)" doc="Calls allocate to create a new object of class&apos;s class, then invokes that object&apos;s initialize method, passing it args. This is the method that ends up getting called whenever an object is constructed using .new." />
        <scope name="superclass" ilk="function" signature="superclass()" doc="Returns the superclass of class, or nil. &#xA; File.superclass          =&gt; IO&#xA;IO.superclass            =&gt; Object&#xA;Object.superclass        =&gt; BasicObject&#xA;class Foo; end&#xA;class Bar &lt; Foo; end&#xA;Bar.superclass           =&gt; Foo&#xA; returns nil when the given class hasn&apos;t a parent class: &#xA; BasicObject.superclass   =&gt; nil" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Creates a new anonymous (unnamed) class with the given superclass (or Object if no parameter is given). You can give a class a name by assigning the class object to a constant. &#xA; If a block is given, it is passed the class object, and the block is evaluated in the context of this class using class_eval. &#xA; fred = Class.new do&#xA;  def meth1&#xA;    &quot;hello&quot;&#xA;  end&#xA;  def meth2&#xA;    &quot;bye&quot;&#xA;  end&#xA;end&#xA;a = fred.new     =&gt; #&lt;#&lt;Class:0x100381890&gt;:0x100376b98&gt;&#xA;a.meth1          =&gt; &quot;hello&quot;&#xA;a.meth2          =&gt; &quot;bye&quot;" />
      </scope>
      <scope name="Kernel" ilk="namespace" >
        <scope name="Array" ilk="function" signature="Array(p1)" doc="Returns arg as an Array. First tries to call arg.to_ary, then arg.to_a. &#xA; Array(1..5)   =&gt; [1, 2, 3, 4, 5]" />
        <scope name="Complex" ilk="function" signature="Complex(*args)" doc="Returns x+i*y;" />
        <scope name="Float" ilk="function" signature="Float(p1)" doc="Returns arg converted to a float. Numeric types are converted directly, the rest are converted using arg.to_f. As of Ruby 1.8, converting nil generates a TypeError. &#xA; Float(1)           =&gt; 1.0&#xA;Float(&quot;123.456&quot;)   =&gt; 123.456" />
        <scope name="Integer" ilk="function" signature="Integer(p1, p2 = v2)" doc="Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating point numbers being truncated).    base (0, or between 2 and 36) is a base for integer string representation.  If arg is a String, when base is omitted or equals to zero, radix indicators (0, 0b, and 0x) are honored. In any case, strings should be strictly conformed to numeric representation. This behavior is different from that of String#to_i.  Non string values will be converted using to_int, and to_i. &#xA; Integer(123.999)    =&gt; 123&#xA;Integer(&quot;0x1a&quot;)     =&gt; 26&#xA;Integer(Time.new)   =&gt; 1204973019&#xA;Integer(&quot;0930&quot;, 10) =&gt; 930&#xA;Integer(&quot;111&quot;, 2)   =&gt; 7" />
        <scope name="Rational" ilk="function" signature="Rational(*args)" doc="Returns x/y;" />
        <scope name="String" ilk="function" signature="String(p1)" doc="Converts arg to a String by calling its to_s method. &#xA; String(self)        =&gt; &quot;main&quot;&#xA;String(self.class)  =&gt; &quot;Object&quot;&#xA;String(123456)      =&gt; &quot;123456&quot;" />
        <scope name="__callee__" ilk="function" signature="__callee__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
        <scope name="__method__" ilk="function" signature="__method__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
        <scope name="abort" ilk="function" signature="abort(p1)" doc="Terminate execution immediately, effectively by calling Kernel.exit(false). If _msg_ is given, it is written to STDERR prior to terminating." />
        <scope name="at_exit" ilk="function" signature="at_exit()" doc="Converts _block_ to a +Proc+ object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration. &#xA; def do_at_exit(str1)&#xA;  at_exit { print str1 }&#xA;end&#xA;at_exit { puts &quot;cruel world&quot; }&#xA;do_at_exit(&quot;goodbye &quot;)&#xA;exit&#xA; produces: &#xA; goodbye cruel world" />
        <scope name="binding" ilk="function" signature="binding()" doc="Returns a +Binding+ object, describing the variable and method bindings at the point of call. This object can be used when calling +eval+ to execute the evaluated command in this environment. See also the description of class +Binding+. &#xA; def get_binding(param)&#xA;  return binding&#xA;end&#xA;b = get_binding(&quot;hello&quot;)&#xA;eval(&quot;param&quot;, b)   =&gt; &quot;hello&quot;" />
        <scope name="block_given?" ilk="function" signature="block_given?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA; def try&#xA;  if block_given?&#xA;    yield&#xA;  else&#xA;    &quot;no block&quot;&#xA;  end&#xA;end&#xA;try                  =&gt; &quot;no block&quot;&#xA;try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
        <scope name="caller" ilk="function" signature="caller(p1 = v1)" doc="Returns the current execution stack---an array containing strings in the form ``file:line&apos;&apos; or ``file:line: in `method&apos;&apos;&apos;. The optional _start_ parameter determines the number of initial stack entries to omit from the result. &#xA; Returns +nil+ if _start_ is greater than the size of current execution stack. &#xA; def a(skip)&#xA;  caller(skip)&#xA;end&#xA;def b(skip)&#xA;  a(skip)&#xA;end&#xA;def c(skip)&#xA;  b(skip)&#xA;end&#xA;c(0)   =&gt; [&quot;prog:2:in `a&apos;&quot;, &quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:10:in `&lt;main&gt;&apos;&quot;]&#xA;c(1)   =&gt; [&quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:11:in `&lt;main&gt;&apos;&quot;]" />
        <scope name="catch" ilk="function" signature="catch(p1 = v1)" doc="+catch+ executes its block. If a +throw+ is executed, Ruby searches up its stack for a +catch+ block with a tag corresponding to the +throw+&apos;s _tag_. If found, that block is terminated, and +catch+ returns the value given to +throw+. If +throw+ is not called, the block terminates normally, and the value of +catch+ is the value of the last expression evaluated. +catch+ expressions may be nested, and the +throw+ call need not be in lexical scope. &#xA; def routine(n)&#xA;  puts n&#xA;  throw :done if n &lt;= 0&#xA;  routine(n-1)&#xA;end&#xA;catch(:done) { routine(3) }&#xA; produces: &#xA; 3&#xA;2&#xA;1&#xA;0&#xA; when _arg_ is given, +catch+ yields it as is, or when no _arg_ is given, +catch+ assigns a new unique object to +throw+.  this is useful for nested +catch+.  _arg_ can be an arbitrary object, not only Symbol." />
        <scope name="eval" ilk="function" signature="eval(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Evaluates the Ruby expression(s) in string. If binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA; def get_binding(str)&#xA;  return binding&#xA;end&#xA;str = &quot;hello&quot;&#xA;eval &quot;str + &apos; Fred&apos;&quot;                      =&gt; &quot;hello Fred&quot;&#xA;eval &quot;str + &apos; Fred&apos;&quot;, get_binding(&quot;bye&quot;)  =&gt; &quot;bye Fred&quot;" />
        <scope name="exec" ilk="function" signature="exec(*args)" doc="Replaces the current process by running the given external _command_. _command..._ is one of following forms. &#xA; commandline                 : command line string which is passed to the standard shell&#xA;cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; If single string is given as the command, it is taken as a command line that is subject to shell expansion before being executed. &#xA; The standard shell means always &quot;/bin/sh&quot; on Unix-like systems, ENV[&quot;RUBYSHELL&quot;] or ENV[&quot;COMSPEC&quot;] on Windows NT series, and similar. &#xA; If two or more +string+ given, the first is taken as a command name and the rest are passed as parameters to command with no shell expansion. &#xA; If a two-element array at the beginning of the command, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. &#xA; In order to execute the command, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors). This behavior is modified by env and options. See spawn for details. &#xA; Raises SystemCallError if the command couldn&apos;t execute (typically Errno::ENOENT when it was not found). &#xA; exec &quot;echo *&quot;       # echoes list of files in current directory&#xA;# never get here&#xA;exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk" />
        <scope name="exit" ilk="function" signature="exit(p1 = v1)" doc="Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment. +true+ and +FALSE+ of _status_ means success and failure respectively.  The interpretation of other integer values are system dependent. &#xA; begin&#xA;  exit&#xA;  puts &quot;never get here&quot;&#xA;rescue SystemExit&#xA;  puts &quot;rescued a SystemExit exception&quot;&#xA;end&#xA;puts &quot;after begin block&quot;&#xA; produces: &#xA; rescued a SystemExit exception&#xA;after begin block&#xA; Just prior to termination, Ruby executes any at_exit functions (see Kernel::at_exit) and runs any object finalizers (see ObjectSpace::define_finalizer). &#xA; at_exit { puts &quot;at_exit function&quot; }" />
        <scope name="exit!" ilk="function" signature="exit!(p1 = v1)" doc="Exits the process immediately. No exit handlers are run. status is returned to the underlying system as the exit status. &#xA; Process.exit!(true)" />
        <scope name="fail" ilk="function" signature="fail(*args)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA; raise &quot;Failed to create socket&quot;&#xA;raise ArgumentError, &quot;No parameters&quot;, caller" />
        <scope name="fork" ilk="function" signature="fork()" doc="Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the +fork+ call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning _nil_. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; The thread calling fork is the only thread in the created child process. fork doesn&apos;t copy other threads. &#xA; If fork is not usable, Process.respond_to?(:fork) returns false." />
        <scope name="format" ilk="function" signature="format(*args)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA; %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA; Field |  Integer Format&#xA;------+--------------------------------------------------------------&#xA;  b   | Convert argument as a binary number.&#xA;      | Negative numbers will be displayed as a two&apos;s complement&#xA;      | prefixed with `..1&apos;.&#xA;  B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;      | in the alternative format by #.&#xA;  d   | Convert argument as a decimal number." />
        <scope name="gets" ilk="function" signature="gets(*args)" doc="Returns (and assigns to $_) the next line from the list of files in +ARGV+ (or $*), or from standard input if no files are present on the command line. Returns +nil+ at end of file. The optional argument specifies the record separator. The separator is included with the contents of each record. A separator of +nil+ reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes.  If multiple filenames are present in +ARGV+, +gets(nil)+ will read the contents one file at a time. &#xA; ARGV &lt;&lt; &quot;testfile&quot;&#xA;print while gets&#xA; produces: &#xA; This is line one&#xA;This is line two&#xA;This is line three&#xA;And so on...&#xA; The style of programming using $_ as an implicit parameter is gradually losing favor in the Ruby community." />
        <scope name="global_variables" ilk="function" signature="global_variables()" doc="Returns an array of the names of global variables. &#xA; global_variables.grep /std/   =&gt; [:$stdin, :$stdout, :$stderr]" />
        <scope name="iterator?" ilk="function" signature="iterator?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA; def try&#xA;  if block_given?&#xA;    yield&#xA;  else&#xA;    &quot;no block&quot;&#xA;  end&#xA;end&#xA;try                  =&gt; &quot;no block&quot;&#xA;try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
        <scope name="lambda" ilk="function" signature="lambda()" doc="Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called." />
        <scope name="load" ilk="function" signature="load(p1, p2 = v2)" doc="Loads and executes the Ruby program in the file _filename_. If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. If the optional _wrap_ parameter is +true+, the loaded script will be executed under an anonymous module, protecting the calling program&apos;s global namespace. In no circumstance will any local variables in the loaded file be propagated to the loading environment." />
        <scope name="local_variables" ilk="function" signature="local_variables()" doc="Returns the names of the current local variables. &#xA; fred = 1&#xA;for i in 1..10&#xA;   # ...&#xA;end&#xA;local_variables   =&gt; [:fred, :i]" />
        <scope name="loop" ilk="function" signature="loop()" doc="Repeatedly executes the block. &#xA; If no block is given, an enumerator is returned instead. &#xA; loop do&#xA;  print &quot;Input: &quot;&#xA;  line = gets&#xA;  break if !line or line =~ /^qQ/&#xA;  # ...&#xA;end&#xA; StopIteration raised in the block breaks the loop." />
        <scope name="open" ilk="function" signature="open(*args)" doc="Creates an IO object connected to the given stream, file, or subprocess. &#xA; If path does not start with a pipe character (``|&apos;&apos;), treat it as the name of a file to open using the specified mode (defaulting to ``r&apos;&apos;). &#xA; The mode_enc is either a string or an integer.  If it is an integer, it must be bitwise-or of open(2) flags, such as File::RDWR or File::EXCL. If it is a string, it is either &quot;mode&quot;, &quot;mode:ext_enc&quot;, or &quot;mode:ext_enc:int_enc&quot;. The mode is one of the following: &#xA; r: read (default)&#xA;w: write&#xA;a: append&#xA; The mode can be followed by &quot;b&quot; (means binary-mode), or &quot;+&quot; (means both reading and writing allowed) or both. If ext_enc (external encoding) is specified, read string will be tagged by the encoding in reading, and output string will be converted to the specified encoding in writing. If ext_enc starts with &apos;BOM|&apos;, check whether the input has a BOM. If there is a BOM, strip it and set external encoding as what the BOM tells. If there is no BOM, use ext_enc without &apos;BOM|&apos;. If two encoding names, ext_enc and int_enc (external encoding and internal encoding), are specified, the read string is converted from ext_enc to int_enc then tagged with the int_enc in read mode, and in write mode, the output string will be converted from int_enc to ext_enc before writing. &#xA; If a file is being created, its initial permissions may be set using the integer third parameter. &#xA; If a block is specified, it will be invoked with the File object as a parameter, and the file will be automatically closed when the block terminates. The call returns the value of the block. &#xA; If path starts with a pipe character, a subprocess is created, connected to the caller by a pair of pipes. The returned IO object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the ``|&apos;&apos; is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the open call returns nil. If the command is not ``-&apos;&apos;, the subprocess runs the command. If a block is associated with an open(&quot;|-&quot;) call, that block will be run twice---once in the parent and once in the child. The block parameter will be an IO object in the parent and nil in the child. The parent&apos;s IO object will be connected to the child&apos;s $stdin and $stdout. The subprocess will be terminated at the end of the block. &#xA; open(&quot;testfile&quot;) do |f|&#xA;  print f.gets&#xA;end" />
        <scope name="p" ilk="function" signature="p(*args)" doc="For each object, directly writes _obj_.+inspect+ followed by a newline to the program&apos;s standard output. &#xA; S = Struct.new(:name, :state)&#xA;s = S[&apos;dave&apos;, &apos;TX&apos;]&#xA;p s&#xA; produces: &#xA; #&lt;S name=&quot;dave&quot;, state=&quot;TX&quot;&gt;" />
        <scope name="print" ilk="function" signature="print(*args)" doc="Prints each object in turn to $stdout. If the output field separator ($,) is not +nil+, its contents will appear between each field. If the output record separator ($\\) is not +nil+, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. &#xA; print &quot;cat&quot;, [1,2,3], 99, &quot;\n&quot;&#xA;$, = &quot;, &quot;&#xA;$\ = &quot;\n&quot;&#xA;print &quot;cat&quot;, [1,2,3], 99&#xA; produces: &#xA; cat12399&#xA;cat, 1, 2, 3, 99" />
        <scope name="printf" ilk="function" signature="printf(*args)" doc="Equivalent to: io.write(sprintf(string, obj, ...)&#xA; or $stdout.write(sprintf(string, obj, ...)" />
        <scope name="proc" ilk="function" signature="proc()" doc="Equivalent to Proc.new." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc="Equivalent to:&#xA;&#xA;  $stdout.putc(int)&#xA; Refer to the documentation for IO#putc for important information regarding multi-byte characters." />
        <scope name="puts" ilk="function" signature="puts(*args)" doc="Equivalent to &#xA; $stdout.puts(obj, ...)" />
        <scope name="raise" ilk="function" signature="raise(*args)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA; raise &quot;Failed to create socket&quot;&#xA;raise ArgumentError, &quot;No parameters&quot;, caller" />
        <scope name="rand" ilk="function" signature="rand(p1 = v1)" doc="If max is +Range+, returns a pseudorandom number where range.member(number) == true. &#xA; Or else converts _max_ to an integer using max1 = max.to_i.abs. &#xA; Then if _max_ is +nil+ the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. &#xA; Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. &#xA; Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1. &#xA; srand 1234                 =&gt; 0&#xA;[ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]&#xA;[ rand(10), rand(1000) ]   =&gt; [6, 817]&#xA;srand 1234                 =&gt; 1234&#xA;[ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]" />
        <scope name="readline" ilk="function" signature="readline(*args)" doc="Equivalent to Kernel::gets, except +readline+ raises +EOFError+ at end of file." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" doc="Returns an array containing the lines returned by calling Kernel.gets(sep) until the end of file." />
        <scope name="require" ilk="function" signature="require(p1)" doc="Loads the given +name+, returning +true+ if successful and +false+ if the feature is already loaded. &#xA; If the filename does not resolve to an absolute path, it will be searched for in the directories listed in $LOAD_PATH ($:). &#xA; If the filename has the extension &quot;.rb&quot;, it is loaded as a source file; if the extension is &quot;.so&quot;, &quot;.o&quot;, or &quot;.dll&quot;, or the default shared library extension on the current platform, Ruby loads the shared library as a Ruby extension.  Otherwise, Ruby tries adding &quot;.rb&quot;, &quot;.so&quot;, and so on to the name until found.  If the file named cannot be found, a LoadError will be raised. &#xA; For Ruby extensions the filename given may use any shared library extension.  For example, on Linux the socket extension is &quot;socket.so&quot; and require &apos;socket.dll&apos; will load the socket extension. &#xA; The absolute path of the loaded file is added to $LOADED_FEATURES ($&quot;).  A file will not be loaded again if its path already appears in $&quot;.  For example, require &apos;a&apos;; require &apos;./a&apos; will not load a.rb again. &#xA; require &quot;my-library.rb&quot;&#xA;require &quot;db-driver&quot;" />
        <scope name="require_relative" ilk="function" signature="require_relative(p1)" doc="Ruby tries to load the library named _string_ relative to the requiring file&apos;s path.  If the file&apos;s path cannot be determined a LoadError is raised. If a file is loaded +true+ is returned and false otherwise." />
        <scope name="select" ilk="function" signature="select(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Calls select(2) system call. It monitors given arrays of IO objects, waits one or more of IO objects ready for reading, are ready for writing, and have pending exceptions respectably, and returns an array that contains arrays of those IO objects.  It will return nil if optional timeout value is given and no IO object is ready in timeout seconds. &#xA; Parameters an array of IO objects that wait until ready for read&#xA;an array of IO objects that wait until ready for write&#xA;an array of IO objects that wait for exceptions&#xA;a numeric value in second &#xA; Example &#xA; rp, wp = IO.pipe&#xA;mesg = &quot;ping &quot;&#xA;100.times {&#xA;  rs, ws, = IO.select([rp], [wp])&#xA;  if r = rs[0]&#xA;    ret = r.read(5)&#xA;    print ret" />
        <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ as the handler for tracing, or disables tracing if the parameter is +nil+. _proc_ takes up to six parameters: an event name, a filename, a line number, an object id, a binding, and the name of a class. _proc_ is invoked whenever an event occurs. Events are: c-call (call a C-language routine), c-return (return from a C-language routine), call (call a Ruby method), class (start a class or module definition), end (finish a class or module definition), line (execute code on a new line), raise (raise an exception), and return (return from a Ruby method). Tracing is disabled within the context of _proc_. &#xA;   class Test&#xA;  def test&#xA;    a = 1&#xA;    b = 2&#xA;  end&#xA;  end&#xA;  set_trace_func proc { |event, file, line, id, binding, classname|&#xA;     printf &quot;%8s %s:%-2d %10s %8s\n&quot;, event, file, line, id, classname&#xA;  }&#xA;  t = Test.new&#xA;  t.test&#xA;    line prog.rb:11               false" />
        <scope name="sleep" ilk="function" signature="sleep(*args)" doc="Suspends the current thread for _duration_ seconds (which may be any number, including a +Float+ with fractional seconds). Returns the actual number of seconds slept (rounded), which may be less than that asked for if another thread calls Thread#run. Called without an argument, sleep() will sleep forever. &#xA; Time.new    =&gt; 2008-03-08 19:56:19 +0900&#xA;sleep 1.2   =&gt; 1&#xA;Time.new    =&gt; 2008-03-08 19:56:20 +0900&#xA;sleep 1.9   =&gt; 2&#xA;Time.new    =&gt; 2008-03-08 19:56:22 +0900" />
        <scope name="spawn" ilk="function" signature="spawn(*args)" doc="spawn executes specified command and return its pid. &#xA; This method doesn&apos;t wait for end of the command. The parent process should use Process.wait to collect the termination status of its child or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; spawn has bunch of options to specify process attributes: &#xA; env: hash&#xA;  name =&gt; val : set the environment variable&#xA;  name =&gt; nil : unset the environment variable&#xA;command...:&#xA;  commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA;options: hash&#xA;  clearing environment variables:&#xA;    :unsetenv_others =&gt; true   : clear environment variables except specified by env" />
        <scope name="sprintf" ilk="function" signature="sprintf(*args)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA; %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA; Field |  Integer Format&#xA;------+--------------------------------------------------------------&#xA;  b   | Convert argument as a binary number.&#xA;      | Negative numbers will be displayed as a two&apos;s complement&#xA;      | prefixed with `..1&apos;.&#xA;  B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;      | in the alternative format by #.&#xA;  d   | Convert argument as a decimal number." />
        <scope name="srand" ilk="function" signature="srand(p1 = v1)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
        <scope name="syscall" ilk="function" signature="syscall(*args)" doc="Calls the operating system function identified by _num_ and&#xA;returns the result of the function or raises SystemCallError if&#xA;it failed.&#xA;Arguments for the function can follow _num_. They must be either&#xA;+String+ objects or +Integer+ objects. A +String+ object is passed&#xA;as a pointer to the byte sequence. An +Integer+ object is passed&#xA;as an integer whose bit size is same as a pointer.&#xA;Up to nine parameters may be passed (14 on the Atari-ST).&#xA;The function identified by _num_ is system&#xA;dependent. On some Unix systems, the numbers may be obtained from a&#xA;header file called syscall.h.&#xA;   syscall 4, 1, &quot;hello\n&quot;, 6   # &apos;4&apos; is write(2) on our box&#xA;produces:" />
        <scope name="system" ilk="function" signature="system(*args)" doc="Executes _command..._ in a subshell. _command..._ is one of following forms. &#xA; commandline                 : command line string which is passed to the standard shell&#xA;cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; system returns +true+ if the command gives zero exit status, +false+ for non zero exit status. Returns +nil+ if command execution fails. An error status is available in $?. The arguments are processed in the same way as for Kernel.spawn. &#xA; The hash arguments, env and options, are same as exec and spawn. See Kernel.spawn for details. &#xA; system(&quot;echo *&quot;)&#xA;system(&quot;echo&quot;, &quot;*&quot;)&#xA; produces: &#xA; config.h main.rb&#xA;*&#xA; See Kernel.exec for the standard shell." />
        <scope name="test" ilk="function" signature="test(*args)" doc="Uses the integer aCmd to perform various tests on&#xA;file1 (first table below) or on file1 and&#xA;file2 (second table).&#xA;File tests on a single file:&#xA;  Test   Returns   Meaning&#xA;  &quot;A&quot;  | Time    | Last access time for file1&#xA;  &quot;b&quot;  | boolean | True if file1 is a block device&#xA;  &quot;c&quot;  | boolean | True if file1 is a character device&#xA;  &quot;C&quot;  | Time    | Last change time for file1&#xA;  &quot;d&quot;  | boolean | True if file1 exists and is a directory&#xA;  &quot;e&quot;  | boolean | True if file1 exists&#xA;  &quot;f&quot;  | boolean | True if file1 exists and is a regular file&#xA;  &quot;g&quot;  | boolean | True if file1 has the \CF{setgid} bit" />
        <scope name="throw" ilk="function" signature="throw(p1, p2 = v2)" doc="Transfers control to the end of the active +catch+ block waiting for _tag_. Raises +ArgumentError+ if there is no +catch+ block for the _tag_. The optional second parameter supplies a return value for the +catch+ block, which otherwise defaults to +nil+. For examples, see Kernel::catch." />
        <scope name="trace_var" ilk="function" signature="trace_var(p1, p2 = v2)" doc="Controls tracing of assignments to global variables. The parameter +symbol_ identifies the variable (as either a string name or a symbol identifier). _cmd_ (which may be a string or a +Proc+ object) or block is executed whenever the variable is assigned. The block or +Proc+ object receives the variable&apos;s new value as a parameter. Also see Kernel::untrace_var. &#xA; trace_var :$_, proc {|v| puts &quot;$_ is now &apos;#{v}&apos;&quot; }&#xA;$_ = &quot;hello&quot;&#xA;$_ = &apos; there&apos;&#xA; produces: &#xA; $_ is now &apos;hello&apos;&#xA;$_ is now &apos; there&apos;" />
        <scope name="trap" ilk="function" signature="trap(*args)" doc="Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM&apos;&apos;, ``SIGUSR1&apos;&apos;, and so on) or a signal number. The characters ``SIG&apos;&apos; may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE&apos;&apos; or ``SIG_IGN&apos;&apos;, the signal will be ignored. If the command is ``DEFAULT&apos;&apos; or ``SIG_DFL&apos;&apos;, the Ruby&apos;s default handler will be invoked. If the command is ``EXIT&apos;&apos;, the script will be terminated by the signal. If the command is ``SYSTEM_DEFAULT&apos;&apos;, the operating system&apos;s default handler will be invoked. Otherwise, the given command or block will be run. The special signal name ``EXIT&apos;&apos; or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal. &#xA; Signal.trap(0, proc { puts &quot;Terminating: #{$$}&quot; })&#xA;Signal.trap(&quot;CLD&quot;)  { puts &quot;Child died&quot; }&#xA;fork &amp;&amp; Process.wait&#xA; produces: Terminating: 27461&#xA;Child died&#xA;Terminating: 27460" />
        <scope name="untrace_var" ilk="function" signature="untrace_var(p1, p2 = v2)" doc="Removes tracing for the specified command on the given global variable and returns +nil+. If no command is specified, removes all tracing for that variable and returns an array containing the commands actually removed." />
        <scope name="warn" ilk="function" signature="warn(p1)" doc="Display the given message (followed by a newline) on STDERR unless warnings are disabled (for example with the -W0 flag)." />
      </scope>
      <scope name="NilClass" ilk="class" classrefs="Object" >
        <scope name="rationalize" ilk="function" signature="rationalize(p1 = v1)" doc="Returns zero as a rational.  An optional argument eps is always ignored." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Always returns an empty array. &#xA; nil.to_a   =&gt; []" />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns zero as a complex." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Always returns zero. &#xA; nil.to_f   =&gt; 0.0" />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Always returns zero. &#xA; nil.to_i   =&gt; 0" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns zero as a rational." />
      </scope>
      <variable name="NIL" attributes="__const__" citdl="NilClass" />
      <scope name="Data" ilk="class" classrefs="Object" >
      </scope>
      <scope name="TrueClass" ilk="class" classrefs="Object" >
      </scope>
      <variable name="TRUE" attributes="__const__" citdl="TrueClass" />
      <scope name="FalseClass" ilk="class" classrefs="Object" >
      </scope>
      <variable name="FALSE" attributes="__const__" citdl="FalseClass" />
      <scope name="Encoding" ilk="class" classrefs="Object" >
        <scope name="_dump" ilk="function" />
        <scope name="ascii_compatible?" ilk="function" signature="ascii_compatible?()" doc="Returns whether ASCII-compatible or not. &#xA; Encoding::UTF_8.ascii_compatible?     =&gt; true&#xA;Encoding::UTF_16BE.ascii_compatible?  =&gt; false" />
        <scope name="dummy?" ilk="function" signature="dummy?()" doc="Returns true for dummy encodings. A dummy encoding is an encoding for which character handling is not properly implemented. It is used for stateful encodings. &#xA; Encoding::ISO_2022_JP.dummy?       =&gt; true&#xA;Encoding::UTF_8.dummy?             =&gt; false" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the encoding. &#xA; Encoding::UTF_8.name      =&gt; &quot;UTF-8&quot;" />
        <scope name="names" ilk="function" signature="names()" doc="Returns the list of name and aliases of the encoding. &#xA; Encoding::WINDOWS_31J.names  =&gt; [&quot;Windows-31J&quot;, &quot;CP932&quot;, &quot;csWindows31J&quot;]" />
        <scope name="replicate" ilk="function" signature="replicate(p1)" doc="Returns a replicated encoding of _enc_ whose name is _name_. The new encoding should have the same byte structure of _enc_. If _name_ is used by another encoding, raise ArgumentError." />
        <scope name="_load" ilk="function" attributes="__classmethod__" />
        <scope name="aliases" ilk="function" attributes="__classmethod__" signature="aliases()" doc="Returns the hash of available encoding alias and original encoding name. &#xA; Encoding.aliases&#xA;=&gt; {&quot;BINARY&quot;=&gt;&quot;ASCII-8BIT&quot;, &quot;ASCII&quot;=&gt;&quot;US-ASCII&quot;, &quot;ANSI_X3.4-1986&quot;=&gt;&quot;US-ASCII&quot;,&#xA;      &quot;SJIS&quot;=&gt;&quot;Shift_JIS&quot;, &quot;eucJP&quot;=&gt;&quot;EUC-JP&quot;, &quot;CP932&quot;=&gt;&quot;Windows-31J&quot;}" />
        <scope name="compatible?" ilk="function" attributes="__classmethod__" signature="compatible?(p1, p2)" doc="Checks the compatibility of two objects. &#xA; If the objects are both strings they are compatible when they are concatenatable.  The encoding of the concatenated string will be returned if they are compatible, nil if they are not. &#xA; Encoding.compatible?(&quot;\xa1&quot;.force_encoding(&quot;iso-8859-1&quot;), &quot;b&quot;)&#xA;=&gt; #&lt;Encoding:ISO-8859-1&gt;&#xA;&#xA;Encoding.compatible?(&#xA;  &quot;\xa1&quot;.force_encoding(&quot;iso-8859-1&quot;),&#xA;  &quot;\xa1\xa1&quot;.force_encoding(&quot;euc-jp&quot;))&#xA;=&gt; nil&#xA; If the objects are non-strings their encodings are compatible when they have an encoding and: Either encoding is US-ASCII compatible&#xA;One of the encodings is a 7-bit encoding" />
        <scope name="default_external" ilk="function" attributes="__classmethod__" signature="default_external()" doc="Returns default external encoding. &#xA; The default external encoding is used by default for strings created from the following locations: &#xA; CSV&#xA;File data read from disk&#xA;SDBM&#xA;StringIO&#xA;Zlib::GzipReader&#xA;Zlib::GzipWriter&#xA;String#inspect&#xA;Regexp#inspect &#xA; While strings created from these locations will have this encoding, the encoding may not be valid.  Be sure to check String#valid_encoding?. &#xA; File data written to disk will be transcoded to the default external encoding when written. &#xA; The default external encoding is initialized by the locale or -E option." />
        <scope name="default_external=" ilk="function" attributes="__classmethod__" signature="default_external=(p1)" doc="Sets default external encoding.  You should not set Encoding::default_external in ruby code as strings created before changing the value may have a different encoding from strings created after thevalue was changed., instead you should use ruby -E to invoke ruby with the correct default_external. &#xA; See Encoding::default_external for information on how the default external encoding is used." />
        <scope name="default_internal" ilk="function" attributes="__classmethod__" signature="default_internal()" doc="Returns default internal encoding.  Strings will be transcoded to the default internal encoding in the following places if the default internal encoding is not nil: &#xA; CSV&#xA;Etc.sysconfdir and Etc.systmpdir&#xA;File data read from disk&#xA;File names from Dir&#xA;Integer#chr&#xA;String#inspect and Regexp#inspect&#xA;Strings returned from Curses&#xA;Strings returned from Readline&#xA;Strings returned from SDBM&#xA;Time#zone&#xA;Values from ENV&#xA;Values in ARGV including $PROGRAM_NAME" />
        <scope name="default_internal=" ilk="function" attributes="__classmethod__" signature="default_internal=(p1)" doc="Sets default internal encoding or removes default internal encoding when passed nil.  You should not set Encoding::default_internal in ruby code as strings created before changing the value may have a different encoding from strings created after the change.  Instead you should use ruby -E to invoke ruby with the correct default_internal. &#xA; See Encoding::default_internal for information on how the default internal encoding is used." />
        <scope name="find" ilk="function" attributes="__classmethod__" signature="find(p1)" doc="Search the encoding with specified name. name should be a string or symbol. &#xA; Encoding.find(&quot;US-ASCII&quot;)  =&gt; #&lt;Encoding:US-ASCII&gt;&#xA;Encoding.find(:Shift_JIS)  =&gt; #&lt;Encoding:Shift_JIS&gt;&#xA; Names which this method accept are encoding names and aliases including following special aliases &#xA; default external encoding&#xA;default internal encoding&#xA;locale encoding&#xA;filesystem encoding &#xA; An ArgumentError is raised when no encoding with name. Only Encoding.find(&quot;internal&quot;) however returns nil when no encoding named &quot;internal&quot;, in other words, when Ruby has no default internal encoding." />
        <scope name="list" ilk="function" attributes="__classmethod__" signature="list()" doc="Returns the list of loaded encodings. &#xA; Encoding.list&#xA;=&gt; [#&lt;Encoding:ASCII-8BIT&gt;, #&lt;Encoding:UTF-8&gt;,&#xA;      #&lt;Encoding:ISO-2022-JP (dummy)&gt;]&#xA;&#xA;Encoding.find(&quot;US-ASCII&quot;)&#xA;=&gt; #&lt;Encoding:US-ASCII&gt;&#xA;&#xA;Encoding.list&#xA;=&gt; [#&lt;Encoding:ASCII-8BIT&gt;, #&lt;Encoding:UTF-8&gt;,&#xA;      #&lt;Encoding:US-ASCII&gt;, #&lt;Encoding:ISO-2022-JP (dummy)&gt;]" />
        <scope name="locale_charmap" ilk="function" attributes="__classmethod__" signature="locale_charmap()" doc="Returns the locale charmap name. It returns nil if no appropriate information. &#xA; Debian GNU/Linux&#xA;  LANG=C&#xA;    Encoding.locale_charmap  =&gt; &quot;ANSI_X3.4-1968&quot;&#xA;  LANG=ja_JP.EUC-JP&#xA;    Encoding.locale_charmap  =&gt; &quot;EUC-JP&quot;&#xA;&#xA;SunOS 5&#xA;  LANG=C&#xA;    Encoding.locale_charmap  =&gt; &quot;646&quot;&#xA;  LANG=ja&#xA;    Encoding.locale_charmap  =&gt; &quot;eucJP&quot;&#xA; The result is highly platform dependent. So Encoding.find(Encoding.locale_charmap) may cause an error. If you need some encoding object even for unknown locale, Encoding.find(&quot;locale&quot;) can be used." />
        <scope name="name_list" ilk="function" attributes="__classmethod__" signature="name_list()" doc="Returns the list of available encoding names. &#xA; Encoding.name_list&#xA;=&gt; [&quot;US-ASCII&quot;, &quot;ASCII-8BIT&quot;, &quot;UTF-8&quot;,&#xA;      &quot;ISO-8859-1&quot;, &quot;Shift_JIS&quot;, &quot;EUC-JP&quot;,&#xA;      &quot;Windows-31J&quot;,&#xA;      &quot;BINARY&quot;, &quot;CP932&quot;, &quot;eucJP&quot;]" />
        <variable name="ANSI_X3_4_1968" attributes="__const__" citdl="Encoding" />
        <variable name="ASCII" attributes="__const__" citdl="Encoding" />
        <variable name="ASCII_8BIT" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5_HKSCS" attributes="__const__" citdl="Encoding" />
        <variable name="BIG5_UAO" attributes="__const__" citdl="Encoding" />
        <variable name="BINARY" attributes="__const__" citdl="Encoding" />
        <variable name="Big5" attributes="__const__" citdl="Encoding" />
        <variable name="Big5_HKSCS" attributes="__const__" citdl="Encoding" />
        <variable name="Big5_UAO" attributes="__const__" citdl="Encoding" />
        <variable name="CP1250" attributes="__const__" citdl="Encoding" />
        <variable name="CP1251" attributes="__const__" citdl="Encoding" />
        <variable name="CP1252" attributes="__const__" citdl="Encoding" />
        <variable name="CP1253" attributes="__const__" citdl="Encoding" />
        <variable name="CP1254" attributes="__const__" citdl="Encoding" />
        <variable name="CP1255" attributes="__const__" citdl="Encoding" />
        <variable name="CP1256" attributes="__const__" citdl="Encoding" />
        <variable name="CP1257" attributes="__const__" citdl="Encoding" />
        <variable name="CP1258" attributes="__const__" citdl="Encoding" />
        <variable name="CP437" attributes="__const__" citdl="Encoding" />
        <variable name="CP50220" attributes="__const__" citdl="Encoding" />
        <variable name="CP50221" attributes="__const__" citdl="Encoding" />
        <variable name="CP51932" attributes="__const__" citdl="Encoding" />
        <variable name="CP65000" attributes="__const__" citdl="Encoding" />
        <variable name="CP65001" attributes="__const__" citdl="Encoding" />
        <variable name="CP737" attributes="__const__" citdl="Encoding" />
        <variable name="CP775" attributes="__const__" citdl="Encoding" />
        <variable name="CP850" attributes="__const__" citdl="Encoding" />
        <variable name="CP852" attributes="__const__" citdl="Encoding" />
        <variable name="CP855" attributes="__const__" citdl="Encoding" />
        <variable name="CP857" attributes="__const__" citdl="Encoding" />
        <variable name="CP860" attributes="__const__" citdl="Encoding" />
        <variable name="CP861" attributes="__const__" citdl="Encoding" />
        <variable name="CP862" attributes="__const__" citdl="Encoding" />
        <variable name="CP863" attributes="__const__" citdl="Encoding" />
        <variable name="CP864" attributes="__const__" citdl="Encoding" />
        <variable name="CP865" attributes="__const__" citdl="Encoding" />
        <variable name="CP866" attributes="__const__" citdl="Encoding" />
        <variable name="CP869" attributes="__const__" citdl="Encoding" />
        <variable name="CP874" attributes="__const__" citdl="Encoding" />
        <variable name="CP878" attributes="__const__" citdl="Encoding" />
        <variable name="CP932" attributes="__const__" citdl="Encoding" />
        <variable name="CP936" attributes="__const__" citdl="Encoding" />
        <variable name="CP949" attributes="__const__" citdl="Encoding" />
        <variable name="CP950" attributes="__const__" citdl="Encoding" />
        <variable name="CP951" attributes="__const__" citdl="Encoding" />
        <variable name="CSWINDOWS31J" attributes="__const__" citdl="Encoding" />
        <scope name="CompatibilityError" ilk="class" classrefs="EncodingError" >
        </scope>
        <scope name="Converter" ilk="class" classrefs="Data" >
          <scope name="convert" ilk="function" />
          <scope name="convpath" ilk="function" />
          <scope name="destination_encoding" ilk="function" />
          <scope name="finish" ilk="function" />
          <scope name="insert_output" ilk="function" />
          <scope name="last_error" ilk="function" />
          <scope name="primitive_convert" ilk="function" />
          <scope name="primitive_errinfo" ilk="function" />
          <scope name="putback" ilk="function" />
          <scope name="replacement" ilk="function" />
          <scope name="replacement=" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="asciicompat_encoding" ilk="function" attributes="__classmethod__" />
          <scope name="search_convpath" ilk="function" attributes="__classmethod__" />
          <variable name="AFTER_OUTPUT" attributes="__const__" citdl="Fixnum" />
          <variable name="CRLF_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="CR_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="INVALID_MASK" attributes="__const__" citdl="Fixnum" />
          <variable name="INVALID_REPLACE" attributes="__const__" citdl="Fixnum" />
          <variable name="PARTIAL_INPUT" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_HEX_CHARREF" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_MASK" attributes="__const__" citdl="Fixnum" />
          <variable name="UNDEF_REPLACE" attributes="__const__" citdl="Fixnum" />
          <variable name="UNIVERSAL_NEWLINE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_ATTR_CONTENT_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_ATTR_QUOTE_DECORATOR" attributes="__const__" citdl="Fixnum" />
          <variable name="XML_TEXT_DECORATOR" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ConverterNotFoundError" ilk="class" classrefs="EncodingError" >
        </scope>
        <variable name="CsWindows31J" attributes="__const__" citdl="Encoding" />
        <variable name="EMACS_MULE" attributes="__const__" citdl="Encoding" />
        <variable name="EUCCN" attributes="__const__" citdl="Encoding" />
        <variable name="EUCJP" attributes="__const__" citdl="Encoding" />
        <variable name="EUCJP_MS" attributes="__const__" citdl="Encoding" />
        <variable name="EUCKR" attributes="__const__" citdl="Encoding" />
        <variable name="EUCTW" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_CN" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_JP" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_JP_MS" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_KR" attributes="__const__" citdl="Encoding" />
        <variable name="EUC_TW" attributes="__const__" citdl="Encoding" />
        <variable name="Emacs_Mule" attributes="__const__" citdl="Encoding" />
        <variable name="EucCN" attributes="__const__" citdl="Encoding" />
        <variable name="EucJP" attributes="__const__" citdl="Encoding" />
        <variable name="EucJP_ms" attributes="__const__" citdl="Encoding" />
        <variable name="EucKR" attributes="__const__" citdl="Encoding" />
        <variable name="EucTW" attributes="__const__" citdl="Encoding" />
        <variable name="GB12345" attributes="__const__" citdl="Encoding" />
        <variable name="GB18030" attributes="__const__" citdl="Encoding" />
        <variable name="GB1988" attributes="__const__" citdl="Encoding" />
        <variable name="GBK" attributes="__const__" citdl="Encoding" />
        <variable name="IBM437" attributes="__const__" citdl="Encoding" />
        <variable name="IBM737" attributes="__const__" citdl="Encoding" />
        <variable name="IBM775" attributes="__const__" citdl="Encoding" />
        <variable name="IBM850" attributes="__const__" citdl="Encoding" />
        <variable name="IBM852" attributes="__const__" citdl="Encoding" />
        <variable name="IBM855" attributes="__const__" citdl="Encoding" />
        <variable name="IBM857" attributes="__const__" citdl="Encoding" />
        <variable name="IBM860" attributes="__const__" citdl="Encoding" />
        <variable name="IBM861" attributes="__const__" citdl="Encoding" />
        <variable name="IBM862" attributes="__const__" citdl="Encoding" />
        <variable name="IBM863" attributes="__const__" citdl="Encoding" />
        <variable name="IBM864" attributes="__const__" citdl="Encoding" />
        <variable name="IBM865" attributes="__const__" citdl="Encoding" />
        <variable name="IBM866" attributes="__const__" citdl="Encoding" />
        <variable name="IBM869" attributes="__const__" citdl="Encoding" />
        <variable name="ISO2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="ISO2022_JP2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_1" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_10" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_11" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_13" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_14" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_15" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_16" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_3" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_4" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_5" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_6" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_7" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_8" attributes="__const__" citdl="Encoding" />
        <variable name="ISO8859_9" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_1" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_10" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_11" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_13" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_14" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_15" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_16" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_2" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_3" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_4" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_5" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_6" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_7" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_8" attributes="__const__" citdl="Encoding" />
        <variable name="ISO_8859_9" attributes="__const__" citdl="Encoding" />
        <scope name="InvalidByteSequenceError" ilk="class" classrefs="EncodingError" >
          <scope name="destination_encoding" ilk="function" />
          <scope name="destination_encoding_name" ilk="function" />
          <scope name="error_bytes" ilk="function" />
          <scope name="incomplete_input?" ilk="function" />
          <scope name="readagain_bytes" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="source_encoding_name" ilk="function" />
        </scope>
        <variable name="KOI8_R" attributes="__const__" citdl="Encoding" />
        <variable name="KOI8_U" attributes="__const__" citdl="Encoding" />
        <variable name="MACCENTEURO" attributes="__const__" citdl="Encoding" />
        <variable name="MACCROATIAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACCYRILLIC" attributes="__const__" citdl="Encoding" />
        <variable name="MACGREEK" attributes="__const__" citdl="Encoding" />
        <variable name="MACICELAND" attributes="__const__" citdl="Encoding" />
        <variable name="MACJAPAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACJAPANESE" attributes="__const__" citdl="Encoding" />
        <variable name="MACROMAN" attributes="__const__" citdl="Encoding" />
        <variable name="MACROMANIA" attributes="__const__" citdl="Encoding" />
        <variable name="MACTHAI" attributes="__const__" citdl="Encoding" />
        <variable name="MACTURKISH" attributes="__const__" citdl="Encoding" />
        <variable name="MACUKRAINE" attributes="__const__" citdl="Encoding" />
        <variable name="MacCentEuro" attributes="__const__" citdl="Encoding" />
        <variable name="MacCroatian" attributes="__const__" citdl="Encoding" />
        <variable name="MacCyrillic" attributes="__const__" citdl="Encoding" />
        <variable name="MacGreek" attributes="__const__" citdl="Encoding" />
        <variable name="MacIceland" attributes="__const__" citdl="Encoding" />
        <variable name="MacJapan" attributes="__const__" citdl="Encoding" />
        <variable name="MacJapanese" attributes="__const__" citdl="Encoding" />
        <variable name="MacRoman" attributes="__const__" citdl="Encoding" />
        <variable name="MacRomania" attributes="__const__" citdl="Encoding" />
        <variable name="MacThai" attributes="__const__" citdl="Encoding" />
        <variable name="MacTurkish" attributes="__const__" citdl="Encoding" />
        <variable name="MacUkraine" attributes="__const__" citdl="Encoding" />
        <variable name="SHIFT_JIS" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_DOCOMO" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_DoCoMo" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_SOFTBANK" attributes="__const__" citdl="Encoding" />
        <variable name="SJIS_SoftBank" attributes="__const__" citdl="Encoding" />
        <variable name="STATELESS_ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="STATELESS_ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="Shift_JIS" attributes="__const__" citdl="Encoding" />
        <variable name="Stateless_ISO_2022_JP" attributes="__const__" citdl="Encoding" />
        <variable name="Stateless_ISO_2022_JP_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="TIS_620" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_2BE" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_4BE" attributes="__const__" citdl="Encoding" />
        <variable name="UCS_4LE" attributes="__const__" citdl="Encoding" />
        <variable name="US_ASCII" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_DOCOMO" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_DoCoMo" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_KDDI" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_MAC" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_SOFTBANK" attributes="__const__" citdl="Encoding" />
        <variable name="UTF8_SoftBank" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_16BE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_16LE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_32BE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_32LE" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_7" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8_HFS" attributes="__const__" citdl="Encoding" />
        <variable name="UTF_8_MAC" attributes="__const__" citdl="Encoding" />
        <scope name="UndefinedConversionError" ilk="class" classrefs="EncodingError" >
          <scope name="destination_encoding" ilk="function" />
          <scope name="destination_encoding_name" ilk="function" />
          <scope name="error_char" ilk="function" />
          <scope name="source_encoding" ilk="function" />
          <scope name="source_encoding_name" ilk="function" />
        </scope>
        <variable name="WINDOWS_1250" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1251" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1252" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1253" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1254" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1255" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1256" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1257" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_1258" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_31J" attributes="__const__" citdl="Encoding" />
        <variable name="WINDOWS_874" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1250" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1251" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1252" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1253" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1254" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1255" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1256" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1257" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_1258" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_31J" attributes="__const__" citdl="Encoding" />
        <variable name="Windows_874" attributes="__const__" citdl="Encoding" />
      </scope>
      <scope name="Comparable" ilk="namespace" >
        <scope name="between?" ilk="function" signature="between?(p1, p2)" doc="Returns false if obj &lt;=&gt; min is less than zero or if anObject &lt;=&gt; max is greater than zero, true otherwise. &#xA; 3.between?(1, 5)               =&gt; true&#xA;6.between?(1, 5)               =&gt; false&#xA;&apos;cat&apos;.between?(&apos;ant&apos;, &apos;dog&apos;)   =&gt; true&#xA;&apos;gnu&apos;.between?(&apos;ant&apos;, &apos;dog&apos;)   =&gt; false" />
      </scope>
      <scope name="Enumerable" ilk="namespace" >
        <scope name="all?" ilk="function" signature="all?()" doc="Passes each element of the collection to the given block. The method returns true if the block never returns false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is all? will return true only if none of the collection members are false or nil.) &#xA; %w{ant bear cat}.all? {|word| word.length &gt;= 3}   =&gt; true&#xA;%w{ant bear cat}.all? {|word| word.length &gt;= 4}   =&gt; false&#xA;[ nil, true, 99 ].all?                            =&gt; false" />
        <scope name="any?" ilk="function" signature="any?()" doc="Passes each element of the collection to the given block. The method returns true if the block ever returns a value other than false or nil. If the block is not given, Ruby adds an implicit block of {|obj| obj} (that is any? will return true if at least one of the collection members is not false or nil. &#xA; %w{ant bear cat}.any? {|word| word.length &gt;= 3}   =&gt; true&#xA;%w{ant bear cat}.any? {|word| word.length &gt;= 4}   =&gt; true&#xA;[ nil, true, 99 ].any?                            =&gt; true" />
        <scope name="chunk" ilk="function" signature="chunk(p1 = v1)" doc="Creates an enumerator for each chunked elements. The consecutive elements which have same block value are chunked. &#xA; The result enumerator yields the block value and an array of chunked elements. So &quot;each&quot; method can be called as follows. &#xA; enum.chunk {|elt| key }.each {|key, ary| ... }&#xA;enum.chunk(initial_state) {|elt, state| key }.each {|key, ary| ... }&#xA; For example, consecutive even numbers and odd numbers can be splitted as follows. &#xA; [3,1,4,1,5,9,2,6,5,3,5].chunk {|n|&#xA;  n.even?&#xA;}.each {|even, ary|&#xA;  p [even, ary]&#xA;}&#xA;=&gt; [false, [3, 1]]&#xA;#   [true, [4]]&#xA;#   [false, [1, 5, 9]]" />
        <scope name="collect" ilk="function" signature="collect()" doc="Returns a new array with the results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..4).collect {|i| i*i }   =&gt; [1, 4, 9, 16]&#xA;(1..4).collect { &quot;cat&quot;  }   =&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]" />
        <scope name="collect_concat" ilk="function" signature="collect_concat()" doc="Returns a new array with the concatenated results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA; [[1,2],[3,4]].flat_map {|i| i }   =&gt; [1, 2, 3, 4]" />
        <scope name="count" ilk="function" signature="count(p1)" doc="Returns the number of items in enum, where #size is called if it responds to it, otherwise the items are counted through enumeration.  If an argument is given, counts the number of items in enum, for which equals to item.  If a block is given, counts the number of elements yielding a true value. &#xA; ary = [1, 2, 4, 2]&#xA;ary.count             =&gt; 4&#xA;ary.count(2)          =&gt; 2&#xA;ary.count{|x|x%2==0}  =&gt; 3" />
        <scope name="cycle" ilk="function" signature="cycle(p1 = v1)" doc="Calls block for each element of enum repeatedly _n_ times or forever if none or +nil+ is given.  If a non-positive number is given or the collection is empty, does nothing.  Returns +nil+ if the loop has finished without getting interrupted. &#xA; Enumerable#cycle saves elements in an internal array so changes to enum after the first pass have no effect. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;a.cycle {|x| puts x }  # print, a, b, c, a, b, c,.. forever.&#xA;a.cycle(2) {|x| puts x }  # print, a, b, c, a, b, c." />
        <scope name="detect" ilk="function" signature="detect(p1 = v1)" doc="Passes each entry in enum to block. Returns the first for which block is not false.  If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;(1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 35" />
        <scope name="drop" ilk="function" signature="drop(p1)" doc="Drops first n elements from enum, and returns rest elements in an array. &#xA; a = [1, 2, 3, 4, 5, 0]&#xA;a.drop(3)             =&gt; [4, 5, 0]" />
        <scope name="drop_while" ilk="function" signature="drop_while()" doc="Drops elements up to, but not including, the first element for which the block returns +nil+ or +false+ and returns an array containing the remaining elements. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [1, 2, 3, 4, 5, 0]&#xA;a.drop_while {|i| i &lt; 3 }   =&gt; [3, 4, 5, 0]" />
        <scope name="each_cons" ilk="function" signature="each_cons(p1)" doc="Iterates the given block for each array of consecutive &lt;n&gt; elements.  If no block is given, returns an enumerator. &#xA; e.g.: (1..10).each_cons(3) {|a| p a}&#xA;# outputs below&#xA;[1, 2, 3]&#xA;[2, 3, 4]&#xA;[3, 4, 5]&#xA;[4, 5, 6]&#xA;[5, 6, 7]&#xA;[6, 7, 8]&#xA;[7, 8, 9]&#xA;[8, 9, 10]" />
        <scope name="each_entry" ilk="function" signature="each_entry(*args)" doc="Calls block once for each element in +self+, passing that element as a parameter, converting multiple values from yield to an array. &#xA; If no block is given, an enumerator is returned instead. &#xA; class Foo&#xA;  include Enumerable&#xA;  def each&#xA;    yield 1&#xA;    yield 1,2&#xA;    yield&#xA;  end&#xA;end&#xA;Foo.new.each_entry{|o| p o }&#xA; produces: &#xA; 1" />
        <scope name="each_slice" ilk="function" signature="each_slice(p1)" doc="Iterates the given block for each slice of &lt;n&gt; elements.  If no block is given, returns an enumerator. &#xA; e.g.: (1..10).each_slice(3) {|a| p a}&#xA;# outputs below&#xA;[1, 2, 3]&#xA;[4, 5, 6]&#xA;[7, 8, 9]&#xA;[10]" />
        <scope name="each_with_index" ilk="function" signature="each_with_index(*args)" doc="Calls block with two arguments, the item and its index, for each item in enum.  Given arguments are passed through to #each(). &#xA; If no block is given, an enumerator is returned instead. &#xA; hash = Hash.new&#xA;%w(cat dog wombat).each_with_index {|item, index|&#xA;  hash[item] = index&#xA;}&#xA;hash   =&gt; {&quot;cat&quot;=&gt;0, &quot;dog&quot;=&gt;1, &quot;wombat&quot;=&gt;2}" />
        <scope name="each_with_object" ilk="function" signature="each_with_object(p1)" doc="Iterates the given block for each element with an arbitrary object given, and returns the initially given object. &#xA; If no block is given, returns an enumerator. &#xA; e.g.: evens = (1..10).each_with_object([]) {|i, a| a &lt;&lt; i*2 }&#xA;=&gt; [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]" />
        <scope name="entries" ilk="function" signature="entries(*args)" doc="Returns an array containing the items in enum. &#xA; (1..7).to_a                       =&gt; [1, 2, 3, 4, 5, 6, 7]&#xA;{ &apos;a&apos;=&gt;1, &apos;b&apos;=&gt;2, &apos;c&apos;=&gt;3 }.to_a   =&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]" />
        <scope name="find" ilk="function" signature="find(p1 = v1)" doc="Passes each entry in enum to block. Returns the first for which block is not false.  If no object matches, calls ifnone and returns its result when it is specified, or returns nil otherwise. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..10).detect  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;(1..100).detect {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 35" />
        <scope name="find_all" ilk="function" signature="find_all()" doc="Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject). &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..10).find_all {|i|  i % 3 == 0 }   =&gt; [3, 6, 9]" />
        <scope name="find_index" ilk="function" signature="find_index(p1)" doc="Compares each entry in enum with value or passes to block.  Returns the index for the first for which the evaluated value is non-false.  If no object matches, returns nil &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA; (1..10).find_index  {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; nil&#xA;(1..100).find_index {|i| i % 5 == 0 and i % 7 == 0 }   =&gt; 34&#xA;(1..100).find_index(50)                                =&gt; 49" />
        <scope name="first" ilk="function" signature="first(p1 = v1)" doc="Returns the first element, or the first +n+ elements, of the enumerable. If the enumerable is empty, the first form returns nil, and the second form returns an empty array. &#xA; %w[foo bar baz].first     =&gt; &quot;foo&quot;&#xA;%w[foo bar baz].first(2)  =&gt; [&quot;foo&quot;, &quot;bar&quot;]&#xA;%w[foo bar baz].first(10) =&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#xA;[].first                  =&gt; nil" />
        <scope name="flat_map" ilk="function" signature="flat_map()" doc="Returns a new array with the concatenated results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA; [[1,2],[3,4]].flat_map {|i| i }   =&gt; [1, 2, 3, 4]" />
        <scope name="grep" ilk="function" signature="grep(p1)" doc="Returns an array of every element in enum for which Pattern === element. If the optional block is supplied, each matching element is passed to it, and the block&apos;s result is stored in the output array. &#xA; (1..100).grep 38..44   =&gt; [38, 39, 40, 41, 42, 43, 44]&#xA;c = IO.constants&#xA;c.grep(/SEEK/)         =&gt; [:SEEK_SET, :SEEK_CUR, :SEEK_END]&#xA;res = c.grep(/SEEK/) {|v| IO.const_get(v) }&#xA;res                    =&gt; [0, 1, 2]" />
        <scope name="group_by" ilk="function" signature="group_by()" doc="Returns a hash, which keys are evaluated result from the block, and values are arrays of elements in enum corresponding to the key. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..6).group_by {|i| i%3}   =&gt; {0=&gt;[3, 6], 1=&gt;[1, 4], 2=&gt;[2, 5]}" />
        <scope name="inject" ilk="function" signature="inject(p1 = v1, p2 = v2)" doc="Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. &#xA; If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method. &#xA; If you do not explicitly specify an initial value for memo, then uses the first element of collection is used as the initial value of memo. &#xA; Examples: &#xA; # Sum some numbers&#xA;(5..10).reduce(:+)                            =&gt; 45&#xA;# Same using a block and inject&#xA;(5..10).inject {|sum, n| sum + n }            =&gt; 45&#xA;# Multiply some numbers&#xA;(5..10).reduce(1, :*)                         =&gt; 151200&#xA;# Same using a block&#xA;(5..10).inject(1) {|product, n| product * n } =&gt; 151200&#xA;# find the longest word" />
        <scope name="map" ilk="function" signature="map()" doc="Returns a new array with the results of running block once for every element in enum. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..4).collect {|i| i*i }   =&gt; [1, 4, 9, 16]&#xA;(1..4).collect { &quot;cat&quot;  }   =&gt; [&quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;, &quot;cat&quot;]" />
        <scope name="max" ilk="function" signature="max()" doc="Returns the object in _enum_ with the maximum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA; a = %w(albatross dog horse)&#xA;a.max                                  =&gt; &quot;horse&quot;&#xA;a.max {|a,b| a.length &lt;=&gt; b.length }   =&gt; &quot;albatross&quot;" />
        <scope name="max_by" ilk="function" signature="max_by()" doc="Returns the object in enum that gives the maximum value from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = %w(albatross dog horse)&#xA;a.max_by {|x| x.length }   =&gt; &quot;albatross&quot;" />
        <scope name="member?" ilk="function" signature="member?(p1)" doc="Returns true if any member of enum equals obj. Equality is tested using ==. &#xA; IO.constants.include? :SEEK_SET          =&gt; true&#xA;IO.constants.include? :SEEK_NO_FURTHER   =&gt; false" />
        <scope name="min" ilk="function" signature="min()" doc="Returns the object in enum with the minimum value. The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA; a = %w(albatross dog horse)&#xA;a.min                                  =&gt; &quot;albatross&quot;&#xA;a.min {|a,b| a.length &lt;=&gt; b.length }   =&gt; &quot;dog&quot;" />
        <scope name="min_by" ilk="function" signature="min_by()" doc="Returns the object in enum that gives the minimum value from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = %w(albatross dog horse)&#xA;a.min_by {|x| x.length }   =&gt; &quot;dog&quot;" />
        <scope name="minmax" ilk="function" signature="minmax()" doc="Returns two elements array which contains the minimum and the maximum value in the enumerable.  The first form assumes all objects implement Comparable; the second uses the block to return a &lt;=&gt; b. &#xA; a = %w(albatross dog horse)&#xA;a.minmax                                  =&gt; [&quot;albatross&quot;, &quot;horse&quot;]&#xA;a.minmax {|a,b| a.length &lt;=&gt; b.length }   =&gt; [&quot;dog&quot;, &quot;albatross&quot;]" />
        <scope name="minmax_by" ilk="function" signature="minmax_by()" doc="Returns two elements array array containing the objects in enum that gives the minimum and maximum values respectively from the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = %w(albatross dog horse)&#xA;a.minmax_by {|x| x.length }   =&gt; [&quot;dog&quot;, &quot;albatross&quot;]" />
        <scope name="none?" ilk="function" signature="none?()" doc="Passes each element of the collection to the given block. The method returns true if the block never returns true for all elements. If the block is not given, none? will return true only if none of the collection members is true. &#xA; %w{ant bear cat}.none? {|word| word.length == 5}  =&gt; true&#xA;%w{ant bear cat}.none? {|word| word.length &gt;= 4}  =&gt; false&#xA;[].none?                                          =&gt; true&#xA;[nil].none?                                       =&gt; true&#xA;[nil,false].none?                                 =&gt; true" />
        <scope name="one?" ilk="function" signature="one?()" doc="Passes each element of the collection to the given block. The method returns true if the block returns true exactly once. If the block is not given, one? will return true only if exactly one of the collection members is true. &#xA; %w{ant bear cat}.one? {|word| word.length == 4}   =&gt; true&#xA;%w{ant bear cat}.one? {|word| word.length &gt; 4}    =&gt; false&#xA;%w{ant bear cat}.one? {|word| word.length &lt; 4}    =&gt; false&#xA;[ nil, true, 99 ].one?                            =&gt; false&#xA;[ nil, true, false ].one?                         =&gt; true" />
        <scope name="partition" ilk="function" signature="partition()" doc="Returns two arrays, the first containing the elements of enum for which the block evaluates to true, the second containing the rest. &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..6).partition {|v| v.even? }  =&gt; [[2, 4, 6], [1, 3, 5]]" />
        <scope name="reduce" ilk="function" signature="reduce(p1 = v1, p2 = v2)" doc="Combines all elements of enum by applying a binary operation, specified by a block or a symbol that names a method or operator. &#xA; If you specify a block, then for each element in enum the block is passed an accumulator value (memo) and the element. If you specify a symbol instead, then each element in the collection will be passed to the named method of memo. In either case, the result becomes the new value for memo. At the end of the iteration, the final value of memo is the return value for the method. &#xA; If you do not explicitly specify an initial value for memo, then uses the first element of collection is used as the initial value of memo. &#xA; Examples: &#xA; # Sum some numbers&#xA;(5..10).reduce(:+)                            =&gt; 45&#xA;# Same using a block and inject&#xA;(5..10).inject {|sum, n| sum + n }            =&gt; 45&#xA;# Multiply some numbers&#xA;(5..10).reduce(1, :*)                         =&gt; 151200&#xA;# Same using a block&#xA;(5..10).inject(1) {|product, n| product * n } =&gt; 151200&#xA;# find the longest word" />
        <scope name="reject" ilk="function" signature="reject()" doc="Returns an array for all elements of enum for which block is false (see also Enumerable#find_all). &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..10).reject {|i|  i % 3 == 0 }   =&gt; [1, 2, 4, 5, 7, 8, 10]" />
        <scope name="reverse_each" ilk="function" signature="reverse_each(*args)" doc="Builds a temporary array and traverses that array in reverse order. &#xA; If no block is given, an enumerator is returned instead. &#xA;   (1..3).reverse_each {|v| p v }&#xA;&#xA;produces:&#xA;&#xA;  3&#xA;  2&#xA;  1" />
        <scope name="select" ilk="function" signature="select()" doc="Returns an array containing all elements of enum for which block is not false (see also Enumerable#reject). &#xA; If no block is given, an enumerator is returned instead. &#xA; (1..10).find_all {|i|  i % 3 == 0 }   =&gt; [3, 6, 9]" />
        <scope name="slice_before" ilk="function" signature="slice_before(p1 = v1)" doc="Creates an enumerator for each chunked elements.&#xA;The beginnings of chunks are defined by _pattern_ and the block.&#xA;If _pattern_ === _elt_ returns true or&#xA;the block returns true for the element,&#xA;the element is beginning of a chunk.&#xA;The === and block is called from the first element to the last element&#xA;of _enum_.&#xA;The result for the first element is ignored.&#xA;The result enumerator yields the chunked elements as an array for +each+&#xA;method.&#xA;+each+ method can be called as follows.&#xA;  enum.slice_before(pattern).each {|ary| ... }&#xA;  enum.slice_before {|elt| bool }.each {|ary| ... }" />
        <scope name="sort" ilk="function" signature="sort()" doc="Returns an array containing the items in enum sorted, either according to their own &lt;=&gt; method, or by using the results of the supplied block. The block should return -1, 0, or +1 depending on the comparison between a and b. As of Ruby 1.8, the method Enumerable#sort_by implements a built-in Schwartzian Transform, useful when key computation or comparison is expensive. &#xA; %w(rhea kea flea).sort         =&gt; [&quot;flea&quot;, &quot;kea&quot;, &quot;rhea&quot;]&#xA;(1..10).sort {|a,b| b &lt;=&gt; a}   =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]" />
        <scope name="sort_by" ilk="function" signature="sort_by()" doc="Sorts enum using a set of keys generated by mapping the values in enum through the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; %w{ apple pear fig }.sort_by {|word| word.length}&#xA;              =&gt; [&quot;fig&quot;, &quot;pear&quot;, &quot;apple&quot;]&#xA; The current implementation of sort_by generates an array of tuples containing the original collection element and the mapped value. This makes sort_by fairly expensive when the keysets are simple &#xA; require &apos;benchmark&apos;&#xA;a = (1..100000).map {rand(100000)}&#xA;Benchmark.bm(10) do |b|&#xA;  b.report(&quot;Sort&quot;)    { a.sort }&#xA;  b.report(&quot;Sort by&quot;) { a.sort_by {|a| a} }&#xA;end&#xA; produces: &#xA; user     system      total        real" />
        <scope name="take" ilk="function" signature="take(p1)" doc="Returns first n elements from enum. &#xA; a = [1, 2, 3, 4, 5, 0]&#xA;a.take(3)             =&gt; [1, 2, 3]" />
        <scope name="take_while" ilk="function" signature="take_while()" doc="Passes elements to the block until the block returns +nil+ or +false+, then stops iterating and returns an array of all prior elements. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [1, 2, 3, 4, 5, 0]&#xA;a.take_while {|i| i &lt; 3 }   =&gt; [1, 2]" />
        <scope name="to_a" ilk="function" signature="to_a(*args)" doc="Returns an array containing the items in enum. &#xA; (1..7).to_a                       =&gt; [1, 2, 3, 4, 5, 6, 7]&#xA;{ &apos;a&apos;=&gt;1, &apos;b&apos;=&gt;2, &apos;c&apos;=&gt;3 }.to_a   =&gt; [[&quot;a&quot;, 1], [&quot;b&quot;, 2], [&quot;c&quot;, 3]]" />
        <scope name="zip" ilk="function" signature="zip(*args)" doc="Takes one element from enum and merges corresponding elements from each args.  This generates a sequence of n-element arrays, where n is one more than the count of arguments.  The length of the resulting sequence will be enum#size.  If the size of any argument is less than enum#size, nil values are supplied. If a block is given, it is invoked for each output array, otherwise an array of arrays is returned. &#xA; a = [ 4, 5, 6 ]&#xA;b = [ 7, 8, 9 ]&#xA;&#xA;[1,2,3].zip(a, b)      =&gt; [[1, 4, 7], [2, 5, 8], [3, 6, 9]]&#xA;[1,2].zip(a,b)         =&gt; [[1, 4, 7], [2, 5, 8]]&#xA;a.zip([1,2],[8])       =&gt; [[4, 1, 8], [5, 2, nil], [6, nil, nil]]" />
      </scope>
      <scope name="String" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="ascii_only?" ilk="function" signature="ascii_only?()" doc="Returns true for a string which has only ASCII characters. &#xA; &quot;abc&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?          =&gt; true&#xA;&quot;abc\u{6666}&quot;.force_encoding(&quot;UTF-8&quot;).ascii_only?  =&gt; false" />
        <scope name="bytes" ilk="function" signature="bytes()" doc="Passes each byte in str to the given block, or returns an enumerator if no block is given. &#xA; &quot;hello&quot;.each_byte {|c| print c, &apos; &apos; }&#xA; produces: &#xA; 104 101 108 108 111" />
        <scope name="bytesize" ilk="function" signature="bytesize()" doc="Returns the length of str in bytes." />
        <scope name="capitalize" ilk="function" signature="capitalize()" doc="Returns a copy of str with the first character converted to uppercase and the remainder to lowercase. Note: case conversion is effective only in ASCII region. &#xA; &quot;hello&quot;.capitalize    =&gt; &quot;Hello&quot;&#xA;&quot;HELLO&quot;.capitalize    =&gt; &quot;Hello&quot;&#xA;&quot;123ABC&quot;.capitalize   =&gt; &quot;123abc&quot;" />
        <scope name="capitalize!" ilk="function" signature="capitalize!()" doc="Modifies str by converting the first character to uppercase and the remainder to lowercase. Returns nil if no changes are made. Note: case conversion is effective only in ASCII region. &#xA; a = &quot;hello&quot;&#xA;a.capitalize!   =&gt; &quot;Hello&quot;&#xA;a               =&gt; &quot;Hello&quot;&#xA;a.capitalize!   =&gt; nil" />
        <scope name="casecmp" ilk="function" signature="casecmp(p1)" doc="Case-insensitive version of String#&lt;=&gt;. &#xA; &quot;abcdef&quot;.casecmp(&quot;abcde&quot;)     =&gt; 1&#xA;&quot;aBcDeF&quot;.casecmp(&quot;abcdef&quot;)    =&gt; 0&#xA;&quot;abcdef&quot;.casecmp(&quot;abcdefg&quot;)   =&gt; -1&#xA;&quot;abcdef&quot;.casecmp(&quot;ABCDEF&quot;)    =&gt; 0" />
        <scope name="center" ilk="function" signature="center(*args)" doc="If integer is greater than the length of str, returns a new String of length integer with str centered and padded with padstr; otherwise, returns str. &#xA; &quot;hello&quot;.center(4)         =&gt; &quot;hello&quot;&#xA;&quot;hello&quot;.center(20)        =&gt; &quot;       hello        &quot;&#xA;&quot;hello&quot;.center(20, &apos;123&apos;) =&gt; &quot;1231231hello12312312&quot;" />
        <scope name="chars" ilk="function" signature="chars()" doc="Passes each character in str to the given block, or returns an enumerator if no block is given. &#xA; &quot;hello&quot;.each_char {|c| print c, &apos; &apos; }&#xA; produces: &#xA; h e l l o" />
        <scope name="chomp" ilk="function" signature="chomp(*args)" doc="Returns a new String with the given record separator removed from the end of str (if present). If $/ has not been changed from the default Ruby record separator, then chomp also removes carriage return characters (that is it will remove \n, \r, and \r\n). &#xA; &quot;hello&quot;.chomp            =&gt; &quot;hello&quot;&#xA;&quot;hello\n&quot;.chomp          =&gt; &quot;hello&quot;&#xA;&quot;hello\r\n&quot;.chomp        =&gt; &quot;hello&quot;&#xA;&quot;hello\n\r&quot;.chomp        =&gt; &quot;hello\n&quot;&#xA;&quot;hello\r&quot;.chomp          =&gt; &quot;hello&quot;&#xA;&quot;hello \n there&quot;.chomp   =&gt; &quot;hello \n there&quot;&#xA;&quot;hello&quot;.chomp(&quot;llo&quot;)     =&gt; &quot;he&quot;" />
        <scope name="chomp!" ilk="function" signature="chomp!(p1 = v1)" doc="Modifies str in place as described for String#chomp, returning str, or nil if no modifications were made." />
        <scope name="chop" ilk="function" signature="chop()" doc="Returns a new String with the last character removed.  If the string ends with \r\n, both characters are removed. Applying chop to an empty string returns an empty string. String#chomp is often a safer alternative, as it leaves the string unchanged if it doesn&apos;t end in a record separator. &#xA; &quot;string\r\n&quot;.chop   =&gt; &quot;string&quot;&#xA;&quot;string\n\r&quot;.chop   =&gt; &quot;string\n&quot;&#xA;&quot;string\n&quot;.chop     =&gt; &quot;string&quot;&#xA;&quot;string&quot;.chop       =&gt; &quot;strin&quot;&#xA;&quot;x&quot;.chop.chop       =&gt; &quot;&quot;" />
        <scope name="chop!" ilk="function" signature="chop!()" doc="Processes str as for String#chop, returning str, or nil if str is the empty string.  See also String#chomp!." />
        <scope name="chr" ilk="function" signature="chr()" doc="Returns a one-character string at the beginning of the string. &#xA; a = &quot;abcde&quot;&#xA;a.chr    =&gt; &quot;a&quot;" />
        <scope name="clear" ilk="function" signature="clear()" doc="Makes string empty. &#xA; a = &quot;abcde&quot;&#xA;a.clear    =&gt; &quot;&quot;" />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; &quot;hello\u0639&quot;.each_codepoint {|c| print c, &apos; &apos; }&#xA; produces: &#xA; 104 101 108 108 111 1593" />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Append---Concatenates the given object to str. If the object is a Integer, it is considered as a codepoint, and is converted to a character before concatenation. &#xA; a = &quot;hello &quot;&#xA;a &lt;&lt; &quot;world&quot;   =&gt; &quot;hello world&quot;&#xA;a.concat(33)   =&gt; &quot;hello world!&quot;" />
        <scope name="count" ilk="function" signature="count(*args)" doc="Each other_str parameter defines a set of characters to count.  The intersection of these sets defines the characters to count in str. Any other_str that starts with a caret (^) is negated. The sequence c1--c2 means all characters between c1 and c2. &#xA; a = &quot;hello world&quot;&#xA;a.count &quot;lo&quot;            =&gt; 5&#xA;a.count &quot;lo&quot;, &quot;o&quot;       =&gt; 2&#xA;a.count &quot;hello&quot;, &quot;^l&quot;   =&gt; 4&#xA;a.count &quot;ej-m&quot;          =&gt; 4" />
        <scope name="crypt" ilk="function" signature="crypt(p1)" doc="Applies a one-way cryptographic hash to str by invoking the standard library function crypt. The argument is the salt string, which should be two characters long, each character drawn from [a-zA-Z0-9./]." />
        <scope name="delete" ilk="function" signature="delete(*args)" doc="Returns a copy of str with all characters in the intersection of its arguments deleted. Uses the same rules for building the set of characters as String#count. &#xA; &quot;hello&quot;.delete &quot;l&quot;,&quot;lo&quot;        =&gt; &quot;heo&quot;&#xA;&quot;hello&quot;.delete &quot;lo&quot;            =&gt; &quot;he&quot;&#xA;&quot;hello&quot;.delete &quot;aeiou&quot;, &quot;^e&quot;   =&gt; &quot;hell&quot;&#xA;&quot;hello&quot;.delete &quot;ej-m&quot;          =&gt; &quot;ho&quot;" />
        <scope name="delete!" ilk="function" signature="delete!(*args)" doc="Performs a delete operation in place, returning str, or nil if str was not modified." />
        <scope name="downcase" ilk="function" signature="downcase()" doc="Returns a copy of str with all uppercase letters replaced with their lowercase counterparts. The operation is locale insensitive---only characters ``A&apos;&apos; to ``Z&apos;&apos; are affected. Note: case replacement is effective only in ASCII region. &#xA; &quot;hEllO&quot;.downcase   =&gt; &quot;hello&quot;" />
        <scope name="downcase!" ilk="function" signature="downcase!()" doc="Downcases the contents of str, returning nil if no changes were made. Note: case replacement is effective only in ASCII region." />
        <scope name="dump" ilk="function" signature="dump()" doc="Produces a version of str with all nonprinting characters replaced by \nnn notation and all special characters escaped." />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="Passes each byte in str to the given block, or returns an enumerator if no block is given. &#xA; &quot;hello&quot;.each_byte {|c| print c, &apos; &apos; }&#xA; produces: &#xA; 104 101 108 108 111" />
        <scope name="each_char" ilk="function" signature="each_char()" doc="Passes each character in str to the given block, or returns an enumerator if no block is given. &#xA; &quot;hello&quot;.each_char {|c| print c, &apos; &apos; }&#xA; produces: &#xA; h e l l o" />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="Passes the Integer ordinal of each character in str, also known as a codepoint when applied to Unicode strings to the given block. &#xA; If no block is given, an enumerator is returned instead. &#xA; &quot;hello\u0639&quot;.each_codepoint {|c| print c, &apos; &apos; }&#xA; produces: &#xA; 104 101 108 108 111 1593" />
        <scope name="each_line" ilk="function" signature="each_line(p1 = v1)" doc="Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split into paragraphs delimited by multiple successive newlines. &#xA; If no block is given, an enumerator is returned instead. &#xA; print &quot;Example one\n&quot;&#xA;&quot;hello\nworld&quot;.each_line {|s| p s}&#xA;print &quot;Example two\n&quot;&#xA;&quot;hello\nworld&quot;.each_line(&apos;l&apos;) {|s| p s}&#xA;print &quot;Example three\n&quot;&#xA;&quot;hello\n\n\nworld&quot;.each_line(&apos;&apos;) {|s| p s}&#xA; produces: &#xA; Example one&#xA;&quot;hello\n&quot;&#xA;&quot;world&quot;&#xA;Example two" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if str has a length of zero. &#xA; &quot;hello&quot;.empty?   =&gt; false&#xA;&quot;&quot;.empty?        =&gt; true" />
        <scope name="encode" ilk="function" signature="encode(*args)" doc="The first form returns a copy of +str+ transcoded to encoding +encoding+. The second form returns a copy of +str+ transcoded from src_encoding to dst_encoding. The last form returns a copy of +str+ transcoded to Encoding.default_internal. &#xA; By default, the first and second form raise Encoding::UndefinedConversionError for characters that are undefined in the destination encoding, and Encoding::InvalidByteSequenceError for invalid byte sequences in the source encoding. The last form by default does not raise exceptions but uses replacement strings. &#xA; The +options+ Hash gives details for conversion and can have the following keys: &#xA; If the value is +:replace+, #encode replaces invalid byte sequences in +str+ with the replacement character.  The default is to raise the Encoding::InvalidByteSequenceError exception&#xA;If the value is +:replace+, #encode replaces characters which are undefined in the destination encoding with the replacement character. The default is to raise the Encoding::UndefinedConversionError.&#xA;Sets the replacement string to the given value. The default replacement string is &quot;\uFFFD&quot; for Unicode encoding forms, and &quot;?&quot; otherwise.&#xA;Sets the replacement string by the given object for undefined character.  The object should be a Hash, a Proc, a Method, or an object which has [] method. Its key is an undefined character encoded in the source encoding of current transcoder. Its value can be any encoding until it can be converted into the destination encoding of the transcoder.&#xA;The value must be +:text+ or +:attr+. If the value is +:text+ #encode replaces undefined characters with their (upper-case hexadecimal) numeric character references. &apos;&amp;&apos;, &apos;&lt;&apos;, and &apos;&gt;&apos; are converted to &quot;&amp;amp;&quot;, &quot;&amp;lt;&quot;, and &quot;&amp;gt;&quot;, respectively. If the value is +:attr+, #encode also quotes the replacement result (using &apos;&quot;&apos;), and replaces &apos;&quot;&apos; with &quot;&amp;quot;&quot;.&#xA;Replaces LF (&quot;\n&quot;) with CR (&quot;\r&quot;) if value is true.&#xA;Replaces LF (&quot;\n&quot;) with CRLF (&quot;\r\n&quot;) if value is true.&#xA;Replaces CRLF (&quot;\r\n&quot;) and CR (&quot;\r&quot;) with LF (&quot;\n&quot;) if value is true." />
        <scope name="encode!" ilk="function" signature="encode!(*args)" doc="The first form transcodes the contents of str from str.encoding to +encoding+. The second form transcodes the contents of str from src_encoding to dst_encoding. The options Hash gives details for conversion. See String#encode for details. Returns the string even if no changes were made." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of obj." />
        <scope name="end_with?" ilk="function" signature="end_with?(*args)" doc="Returns true if str ends with one of the suffixes given." />
        <scope name="ends_with?" ilk="function" />
        <scope name="force_encoding" ilk="function" signature="force_encoding(p1)" doc="Changes the encoding to +encoding+ and returns self." />
        <scope name="getbyte" ilk="function" signature="getbyte(p1)" doc="returns the indexth byte as an integer." />
        <scope name="gsub" ilk="function" signature="gsub(*args)" doc="Returns a copy of str with the all occurrences of pattern substituted for the second argument. The pattern is typically a Regexp; if given as a String, any regular expression metacharacters it contains will be interpreted literally, e.g. &apos;\\\d&apos; will match a backlash followed by &apos;d&apos;, instead of a digit. &#xA; If replacement is a String it will be substituted for the matched text. It may contain back-references to the pattern&apos;s capture groups of the form \\\d, where d is a group number, or \\\k&lt;n&gt;, where n is a group name. If it is a double-quoted string, both back-references must be preceded by an additional backslash. However, within replacement the special match variables, such as &amp;$, will not refer to the current match. &#xA; If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string. &#xA; In the block form, the current match string is passed in as a parameter, and variables such as $1, $2, $`, $&amp;, and $&apos; will be set appropriately. The value returned by the block will be substituted for the match on each call. &#xA; The result inherits any tainting in the original string or any supplied replacement string. &#xA; When neither a block nor a second argument is supplied, an Enumerator is returned. &#xA; &quot;hello&quot;.gsub(/[aeiou]/, &apos;*&apos;)                  =&gt; &quot;h*ll*&quot;&#xA;&quot;hello&quot;.gsub(/([aeiou])/, &apos;&lt;\1&gt;&apos;)             =&gt; &quot;h&lt;e&gt;ll&lt;o&gt;&quot;&#xA;&quot;hello&quot;.gsub(/./) {|s| s.ord.to_s + &apos; &apos;}      =&gt; &quot;104 101 108 108 111 &quot;&#xA;&quot;hello&quot;.gsub(/(?&lt;foo&gt;[aeiou])/, &apos;{\k&lt;foo&gt;}&apos;)  =&gt; &quot;h{e}ll{o}&quot;&#xA;&apos;hello&apos;.gsub(/[eo]/, &apos;e&apos; =&gt; 3, &apos;o&apos; =&gt; &apos;*&apos;)    =&gt; &quot;h3ll*&quot;" />
        <scope name="gsub!" ilk="function" signature="gsub!(*args)" doc="Performs the substitutions of String#gsub in place, returning str, or nil if no substitutions were performed. If no block and no replacement is given, an enumerator is returned instead." />
        <scope name="hex" ilk="function" signature="hex()" doc="Treats leading characters from str as a string of hexadecimal digits (with an optional sign and an optional 0x) and returns the corresponding number. Zero is returned on error. &#xA; &quot;0x0a&quot;.hex     =&gt; 10&#xA;&quot;-1234&quot;.hex    =&gt; -4660&#xA;&quot;0&quot;.hex        =&gt; 0&#xA;&quot;wombat&quot;.hex   =&gt; 0" />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if str contains the given string or character. &#xA; &quot;hello&quot;.include? &quot;lo&quot;   =&gt; true&#xA;&quot;hello&quot;.include? &quot;ol&quot;   =&gt; false&#xA;&quot;hello&quot;.include? ?h     =&gt; true" />
        <scope name="index" ilk="function" signature="index(p1, p2 = v2)" doc="Returns the index of the first occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to begin the search. &#xA; &quot;hello&quot;.index(&apos;e&apos;)             =&gt; 1&#xA;&quot;hello&quot;.index(&apos;lo&apos;)            =&gt; 3&#xA;&quot;hello&quot;.index(&apos;a&apos;)             =&gt; nil&#xA;&quot;hello&quot;.index(?e)              =&gt; 1&#xA;&quot;hello&quot;.index(/[aeiou]/, -3)   =&gt; 4" />
        <scope name="insert" ilk="function" signature="insert(p1, p2)" doc="Inserts other_str before the character at the given index, modifying str. Negative indices count from the end of the string, and insert after the given character. The intent is insert aString so that it starts at the given index. &#xA; &quot;abcd&quot;.insert(0, &apos;X&apos;)    =&gt; &quot;Xabcd&quot;&#xA;&quot;abcd&quot;.insert(3, &apos;X&apos;)    =&gt; &quot;abcXd&quot;&#xA;&quot;abcd&quot;.insert(4, &apos;X&apos;)    =&gt; &quot;abcdX&quot;&#xA;&quot;abcd&quot;.insert(-3, &apos;X&apos;)   =&gt; &quot;abXcd&quot;&#xA;&quot;abcd&quot;.insert(-1, &apos;X&apos;)   =&gt; &quot;abcdX&quot;" />
        <scope name="intern" ilk="function" signature="intern()" doc="Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name. &#xA; &quot;Koala&quot;.intern         =&gt; :Koala&#xA;s = &apos;cat&apos;.to_sym       =&gt; :cat&#xA;s == :cat              =&gt; true&#xA;s = &apos;@cat&apos;.to_sym      =&gt; :@cat&#xA;s == :@cat             =&gt; true&#xA; This can also be used to create symbols that cannot be represented using the :xxx notation. &#xA; &apos;cat and dog&apos;.to_sym   =&gt; :&quot;cat and dog&quot;" />
        <scope name="is_binary_data?" ilk="function" />
        <scope name="is_complex_yaml?" ilk="function" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the character length of str." />
        <scope name="lines" ilk="function" signature="lines(p1 = v1)" doc="Splits str using the supplied parameter as the record separator ($/ by default), passing each substring in turn to the supplied block. If a zero-length record separator is supplied, the string is split into paragraphs delimited by multiple successive newlines. &#xA; If no block is given, an enumerator is returned instead. &#xA; print &quot;Example one\n&quot;&#xA;&quot;hello\nworld&quot;.each_line {|s| p s}&#xA;print &quot;Example two\n&quot;&#xA;&quot;hello\nworld&quot;.each_line(&apos;l&apos;) {|s| p s}&#xA;print &quot;Example three\n&quot;&#xA;&quot;hello\n\n\nworld&quot;.each_line(&apos;&apos;) {|s| p s}&#xA; produces: &#xA; Example one&#xA;&quot;hello\n&quot;&#xA;&quot;world&quot;&#xA;Example two" />
        <scope name="ljust" ilk="function" signature="ljust(*args)" doc="If integer is greater than the length of str, returns a new String of length integer with str left justified and padded with padstr; otherwise, returns str. &#xA; &quot;hello&quot;.ljust(4)            =&gt; &quot;hello&quot;&#xA;&quot;hello&quot;.ljust(20)           =&gt; &quot;hello               &quot;&#xA;&quot;hello&quot;.ljust(20, &apos;1234&apos;)   =&gt; &quot;hello123412341234123&quot;" />
        <scope name="lstrip" ilk="function" signature="lstrip()" doc="Returns a copy of str with leading whitespace removed. See also String#rstrip and String#strip. &#xA; &quot;  hello  &quot;.lstrip   =&gt; &quot;hello  &quot;&#xA;&quot;hello&quot;.lstrip       =&gt; &quot;hello&quot;" />
        <scope name="lstrip!" ilk="function" signature="lstrip!()" doc="Removes leading whitespace from str, returning nil if no change was made. See also String#rstrip! and String#strip!. &#xA; &quot;  hello  &quot;.lstrip   =&gt; &quot;hello  &quot;&#xA;&quot;hello&quot;.lstrip!      =&gt; nil" />
        <scope name="match" ilk="function" signature="match(*args)" doc="Converts pattern to a Regexp (if it isn&apos;t already one), then invokes its match method on str.  If the second parameter is present, it specifies the position in the string to begin the search. &#xA; &apos;hello&apos;.match(&apos;(.)\1&apos;)      =&gt; #&lt;MatchData &quot;ll&quot; 1:&quot;l&quot;&gt;&#xA;&apos;hello&apos;.match(&apos;(.)\1&apos;)[0]   =&gt; &quot;ll&quot;&#xA;&apos;hello&apos;.match(/(.)\1/)[0]   =&gt; &quot;ll&quot;&#xA;&apos;hello&apos;.match(&apos;xx&apos;)         =&gt; nil&#xA; If a block is given, invoke the block with MatchData if match succeed, so that you can write &#xA; str.match(pat) {|m| ...}&#xA; instead of &#xA; if m = str.match(pat)&#xA;  ...&#xA;end&#xA; The return value is a value from block execution in this case." />
        <scope name="next" ilk="function" signature="next()" doc="Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set&apos;s collating sequence. &#xA; If the increment generates a ``carry,&apos;&apos; the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary. &#xA; &quot;abcd&quot;.succ        =&gt; &quot;abce&quot;&#xA;&quot;THX1138&quot;.succ     =&gt; &quot;THX1139&quot;&#xA;&quot;&lt;&lt;koala&gt;&gt;&quot;.succ   =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;&#xA;&quot;1999zzz&quot;.succ     =&gt; &quot;2000aaa&quot;&#xA;&quot;ZZZ9999&quot;.succ     =&gt; &quot;AAAA0000&quot;&#xA;&quot;***&quot;.succ         =&gt; &quot;**+&quot;" />
        <scope name="next!" ilk="function" signature="next!()" doc="Equivalent to String#succ, but modifies the receiver in place." />
        <scope name="oct" ilk="function" signature="oct()" doc="Treats leading characters of str as a string of octal digits (with an optional sign) and returns the corresponding number.  Returns 0 if the conversion fails. &#xA; &quot;123&quot;.oct       =&gt; 83&#xA;&quot;-377&quot;.oct      =&gt; -255&#xA;&quot;bad&quot;.oct       =&gt; 0&#xA;&quot;0377bad&quot;.oct   =&gt; 255" />
        <scope name="ord" ilk="function" signature="ord()" doc="Return the Integer ordinal of a one-character string. &#xA; &quot;a&quot;.ord         =&gt; 97" />
        <scope name="partition" ilk="function" signature="partition(p1)" doc="Searches sep or pattern (regexp) in the string and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str. &#xA; &quot;hello&quot;.partition(&quot;l&quot;)         =&gt; [&quot;he&quot;, &quot;l&quot;, &quot;lo&quot;]&#xA;&quot;hello&quot;.partition(&quot;x&quot;)         =&gt; [&quot;hello&quot;, &quot;&quot;, &quot;&quot;]&#xA;&quot;hello&quot;.partition(/.l/)        =&gt; [&quot;h&quot;, &quot;el&quot;, &quot;lo&quot;]" />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents and taintedness of str with the corresponding values in other_str. &#xA; s = &quot;hello&quot;         =&gt; &quot;hello&quot;&#xA;s.replace &quot;world&quot;   =&gt; &quot;world&quot;" />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a new string with the characters from str in reverse order. &#xA; &quot;stressed&quot;.reverse   =&gt; &quot;desserts&quot;" />
        <scope name="reverse!" ilk="function" signature="reverse!()" doc="Reverses str in place." />
        <scope name="rindex" ilk="function" signature="rindex(p1, p2 = v2)" doc="Returns the index of the last occurrence of the given substring or pattern (regexp) in str. Returns nil if not found. If the second parameter is present, it specifies the position in the string to end the search---characters beyond this point will not be considered. &#xA; &quot;hello&quot;.rindex(&apos;e&apos;)             =&gt; 1&#xA;&quot;hello&quot;.rindex(&apos;l&apos;)             =&gt; 3&#xA;&quot;hello&quot;.rindex(&apos;a&apos;)             =&gt; nil&#xA;&quot;hello&quot;.rindex(?e)              =&gt; 1&#xA;&quot;hello&quot;.rindex(/[aeiou]/, -2)   =&gt; 1" />
        <scope name="rjust" ilk="function" signature="rjust(*args)" doc="If integer is greater than the length of str, returns a new String of length integer with str right justified and padded with padstr; otherwise, returns str. &#xA; &quot;hello&quot;.rjust(4)            =&gt; &quot;hello&quot;&#xA;&quot;hello&quot;.rjust(20)           =&gt; &quot;               hello&quot;&#xA;&quot;hello&quot;.rjust(20, &apos;1234&apos;)   =&gt; &quot;123412341234123hello&quot;" />
        <scope name="rpartition" ilk="function" signature="rpartition(p1)" doc="Searches sep or pattern (regexp) in the string from the end of the string, and returns the part before it, the match, and the part after it. If it is not found, returns two empty strings and str. &#xA; &quot;hello&quot;.rpartition(&quot;l&quot;)         =&gt; [&quot;hel&quot;, &quot;l&quot;, &quot;o&quot;]&#xA;&quot;hello&quot;.rpartition(&quot;x&quot;)         =&gt; [&quot;&quot;, &quot;&quot;, &quot;hello&quot;]&#xA;&quot;hello&quot;.rpartition(/.l/)        =&gt; [&quot;he&quot;, &quot;ll&quot;, &quot;o&quot;]" />
        <scope name="rstrip" ilk="function" signature="rstrip()" doc="Returns a copy of str with trailing whitespace removed. See also String#lstrip and String#strip. &#xA; &quot;  hello  &quot;.rstrip   =&gt; &quot;  hello&quot;&#xA;&quot;hello&quot;.rstrip       =&gt; &quot;hello&quot;" />
        <scope name="rstrip!" ilk="function" signature="rstrip!()" doc="Removes trailing whitespace from str, returning nil if no change was made. See also String#lstrip! and String#strip!. &#xA; &quot;  hello  &quot;.rstrip   =&gt; &quot;  hello&quot;&#xA;&quot;hello&quot;.rstrip!      =&gt; nil" />
        <scope name="scan" ilk="function" signature="scan(p1)" doc="Both forms iterate through str, matching the pattern (which may be a Regexp or a String). For each match, a result is generated and either added to the result array or passed to the block. If the pattern contains no groups, each individual result consists of the matched string, $&amp;.  If the pattern contains groups, each individual result is itself an array containing one entry per group. &#xA; a = &quot;cruel world&quot;&#xA;a.scan(/\w+/)        =&gt; [&quot;cruel&quot;, &quot;world&quot;]&#xA;a.scan(/.../)        =&gt; [&quot;cru&quot;, &quot;el &quot;, &quot;wor&quot;]&#xA;a.scan(/(...)/)      =&gt; [[&quot;cru&quot;], [&quot;el &quot;], [&quot;wor&quot;]]&#xA;a.scan(/(..)(..)/)   =&gt; [[&quot;cr&quot;, &quot;ue&quot;], [&quot;l &quot;, &quot;wo&quot;]]&#xA; And the block form: &#xA; a.scan(/\w+/) {|w| print &quot;&lt;&lt;#{w}&gt;&gt; &quot; }&#xA;print &quot;\n&quot;&#xA;a.scan(/(.)(.)/) {|x,y| print y, x }&#xA;print &quot;\n&quot;&#xA; produces: &#xA; &lt;&lt;cruel&gt;&gt; &lt;&lt;world&gt;&gt;" />
        <scope name="setbyte" ilk="function" signature="setbyte(p1, p2)" doc="modifies the indexth byte as int." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the character length of str." />
        <scope name="slice" ilk="function" signature="slice(*args)" doc="Element Reference---If passed a single Fixnum, returns a substring of one character at that position. If passed two Fixnum objects, returns a substring starting at the offset given by the first, and a length given by the second. If given a range, a substring containing characters at offsets given by the range is returned. In all three cases, if an offset is negative, it is counted from the end of str. Returns nil if the initial offset falls outside the string, the length is negative, or the beginning of the range is greater than the end of the string. &#xA; If a Regexp is supplied, the matching portion of str is returned. If a numeric or name parameter follows the regular expression, that component of the MatchData is returned instead. If a String is given, that string is returned if it occurs in str. In both cases, nil is returned if there is no match. &#xA; a = &quot;hello there&quot;&#xA;a[1]                   =&gt; &quot;e&quot;&#xA;a[1,3]                 =&gt; &quot;ell&quot;&#xA;a[1..3]                =&gt; &quot;ell&quot;&#xA;a[-3,2]                =&gt; &quot;er&quot;&#xA;a[-4..-2]              =&gt; &quot;her&quot;&#xA;a[12..-1]              =&gt; nil&#xA;a[-2..-4]              =&gt; &quot;&quot;&#xA;a[/[aeiou](.)\1/]      =&gt; &quot;ell&quot;&#xA;a[/[aeiou](.)\1/, 0]   =&gt; &quot;ell&quot;&#xA;a[/[aeiou](.)\1/, 1]   =&gt; &quot;l&quot;" />
        <scope name="slice!" ilk="function" signature="slice!(*args)" doc="Deletes the specified portion from str, and returns the portion deleted. &#xA; string = &quot;this is a string&quot;&#xA;string.slice!(2)        =&gt; &quot;i&quot;&#xA;string.slice!(3..6)     =&gt; &quot; is &quot;&#xA;string.slice!(/s.*t/)   =&gt; &quot;sa st&quot;&#xA;string.slice!(&quot;r&quot;)      =&gt; &quot;r&quot;&#xA;string                  =&gt; &quot;thing&quot;" />
        <scope name="split" ilk="function" signature="split(p1 = v1, p2 = v2)" doc="Divides str into substrings based on a delimiter, returning an array of these substrings. &#xA; If pattern is a String, then its contents are used as the delimiter when splitting str. If pattern is a single space, str is split on whitespace, with leading whitespace and runs of contiguous whitespace characters ignored. &#xA; If pattern is a Regexp, str is divided where the pattern matches. Whenever the pattern matches a zero-length string, str is split into individual characters. If pattern contains groups, the respective matches will be returned in the array as well. &#xA; If pattern is omitted, the value of $; is used.  If $; is nil (which is the default), str is split on whitespace as if ` &apos; were specified. &#xA; If the limit parameter is omitted, trailing null fields are suppressed. If limit is a positive number, at most that number of fields will be returned (if limit is 1, the entire string is returned as the only entry in an array). If negative, there is no limit to the number of fields returned, and trailing null fields are not suppressed. &#xA; &quot; now&apos;s  the time&quot;.split        =&gt; [&quot;now&apos;s&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;&quot; now&apos;s  the time&quot;.split(&apos; &apos;)   =&gt; [&quot;now&apos;s&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;&quot; now&apos;s  the time&quot;.split(/ /)   =&gt; [&quot;&quot;, &quot;now&apos;s&quot;, &quot;&quot;, &quot;the&quot;, &quot;time&quot;]&#xA;&quot;1, 2.34,56, 7&quot;.split(%r{,\s*}) =&gt; [&quot;1&quot;, &quot;2.34&quot;, &quot;56&quot;, &quot;7&quot;]&#xA;&quot;hello&quot;.split(//)               =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]&#xA;&quot;hello&quot;.split(//, 3)            =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;llo&quot;]&#xA;&quot;hi mom&quot;.split(%r{\s*})         =&gt; [&quot;h&quot;, &quot;i&quot;, &quot;m&quot;, &quot;o&quot;, &quot;m&quot;]&#xA;&quot;mellow yellow&quot;.split(&quot;ello&quot;)   =&gt; [&quot;m&quot;, &quot;w y&quot;, &quot;w&quot;]" />
        <scope name="squeeze" ilk="function" signature="squeeze(*args)" doc="Builds a set of characters from the other_str parameter(s) using the procedure described for String#count. Returns a new string where runs of the same character that occur in this set are replaced by a single character. If no arguments are given, all runs of identical characters are replaced by a single character. &#xA; &quot;yellow moon&quot;.squeeze                  =&gt; &quot;yelow mon&quot;&#xA;&quot;  now   is  the&quot;.squeeze(&quot; &quot;)         =&gt; &quot; now is the&quot;&#xA;&quot;putters shoot balls&quot;.squeeze(&quot;m-z&quot;)   =&gt; &quot;puters shot balls&quot;" />
        <scope name="squeeze!" ilk="function" signature="squeeze!(*args)" doc="Squeezes str in place, returning either str, or nil if no changes were made." />
        <scope name="start_with?" ilk="function" signature="start_with?(*args)" doc="Returns true if str starts with one of the prefixes given. &#xA; p &quot;hello&quot;.start_with?(&quot;hell&quot;)               =&gt; true&#xA;&#xA;# returns true if one of the prefixes matches.&#xA;p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;hell&quot;)     =&gt; true&#xA;p &quot;hello&quot;.start_with?(&quot;heaven&quot;, &quot;paradise&quot;) =&gt; false" />
        <scope name="strip" ilk="function" signature="strip()" doc="Returns a copy of str with leading and trailing whitespace removed. &#xA; &quot;    hello    &quot;.strip   =&gt; &quot;hello&quot;&#xA;&quot;\tgoodbye\r\n&quot;.strip   =&gt; &quot;goodbye&quot;" />
        <scope name="strip!" ilk="function" signature="strip!()" doc="Removes leading and trailing whitespace from str. Returns nil if str was not altered." />
        <scope name="sub" ilk="function" signature="sub(*args)" doc="Returns a copy of str with the first occurrence of pattern substituted for the second argument. The pattern is typically a Regexp; if given as a String, any regular expression metacharacters it contains will be interpreted literally, e.g. &apos;\\\d&apos; will match a backlash followed by &apos;d&apos;, instead of a digit. &#xA; If replacement is a String it will be substituted for the matched text. It may contain back-references to the pattern&apos;s capture groups of the form \\\d, where d is a group number, or \\\k&lt;n&gt;, where n is a group name. If it is a double-quoted string, both back-references must be preceded by an additional backslash. However, within replacement the special match variables, such as &amp;$, will not refer to the current match. &#xA; If the second argument is a Hash, and the matched text is one of its keys, the corresponding value is the replacement string. &#xA; In the block form, the current match string is passed in as a parameter, and variables such as $1, $2, $`, $&amp;, and $&apos; will be set appropriately. The value returned by the block will be substituted for the match on each call. &#xA; The result inherits any tainting in the original string or any supplied replacement string. &#xA; &quot;hello&quot;.sub(/[aeiou]/, &apos;*&apos;)                  =&gt; &quot;h*llo&quot;&#xA;&quot;hello&quot;.sub(/([aeiou])/, &apos;&lt;\1&gt;&apos;)             =&gt; &quot;h&lt;e&gt;llo&quot;&#xA;&quot;hello&quot;.sub(/./) {|s| s.ord.to_s + &apos; &apos; }     =&gt; &quot;104 ello&quot;&#xA;&quot;hello&quot;.sub(/(?&lt;foo&gt;[aeiou])/, &apos;*\k&lt;foo&gt;*&apos;)  =&gt; &quot;h*e*llo&quot;&#xA;&apos;Is SHELL your preferred shell?&apos;.sub(/[[:upper:]]{2,}/, ENV)&#xA; =&gt; &quot;Is /bin/bash your preferred shell?&quot;" />
        <scope name="sub!" ilk="function" signature="sub!(*args)" doc="Performs the substitutions of String#sub in place, returning str, or nil if no substitutions were performed." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns the successor to str. The successor is calculated by incrementing characters starting from the rightmost alphanumeric (or the rightmost character if there are no alphanumerics) in the string. Incrementing a digit always results in another digit, and incrementing a letter results in another letter of the same case. Incrementing nonalphanumerics uses the underlying character set&apos;s collating sequence. &#xA; If the increment generates a ``carry,&apos;&apos; the character to the left of it is incremented. This process repeats until there is no carry, adding an additional character if necessary. &#xA; &quot;abcd&quot;.succ        =&gt; &quot;abce&quot;&#xA;&quot;THX1138&quot;.succ     =&gt; &quot;THX1139&quot;&#xA;&quot;&lt;&lt;koala&gt;&gt;&quot;.succ   =&gt; &quot;&lt;&lt;koalb&gt;&gt;&quot;&#xA;&quot;1999zzz&quot;.succ     =&gt; &quot;2000aaa&quot;&#xA;&quot;ZZZ9999&quot;.succ     =&gt; &quot;AAAA0000&quot;&#xA;&quot;***&quot;.succ         =&gt; &quot;**+&quot;" />
        <scope name="succ!" ilk="function" signature="succ!()" doc="Equivalent to String#succ, but modifies the receiver in place." />
        <scope name="sum" ilk="function" signature="sum(p1 = v1)" doc="Returns a basic n-bit checksum of the characters in str, where n is the optional Fixnum parameter, defaulting to 16. The result is simply the sum of the binary value of each character in str modulo 2**n - 1. This is not a particularly good checksum." />
        <scope name="swapcase" ilk="function" signature="swapcase()" doc="Returns a copy of str with uppercase alphabetic characters converted to lowercase and lowercase characters converted to uppercase. Note: case conversion is effective only in ASCII region. &#xA; &quot;Hello&quot;.swapcase          =&gt; &quot;hELLO&quot;&#xA;&quot;cYbEr_PuNk11&quot;.swapcase   =&gt; &quot;CyBeR_pUnK11&quot;" />
        <scope name="swapcase!" ilk="function" signature="swapcase!()" doc="Equivalent to String#swapcase, but modifies the receiver in place, returning str, or nil if no changes were made. Note: case conversion is effective only in ASCII region." />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns a complex which denotes the string form.  The parser ignores leading whitespaces and trailing garbage.  Any digit sequences can be separated by an underscore.  Returns zero for null or garbage string. &#xA; For example: &#xA; &apos;9&apos;.to_c           =&gt; (9+0i)&#xA;&apos;2.5&apos;.to_c         =&gt; (2.5+0i)&#xA;&apos;2.5/1&apos;.to_c       =&gt; ((5/2)+0i)&#xA;&apos;-3/2&apos;.to_c        =&gt; ((-3/2)+0i)&#xA;&apos;-i&apos;.to_c          =&gt; (0-1i)&#xA;&apos;45i&apos;.to_c         =&gt; (0+45i)&#xA;&apos;3-4i&apos;.to_c        =&gt; (3-4i)&#xA;&apos;-4e2-4e-2i&apos;.to_c  =&gt; (-400.0-0.04i)&#xA;&apos;-0.0-0.0i&apos;.to_c   =&gt; (-0.0-0.0i)&#xA;&apos;1/2+3/4i&apos;.to_c    =&gt; ((1/2)+(3/4)*i)&#xA;&apos;ruby&apos;.to_c        =&gt; (0+0i)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the result of interpreting leading characters in str as a floating point number. Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0.0 is returned. This method never raises an exception. &#xA; &quot;123.45e1&quot;.to_f        =&gt; 1234.5&#xA;&quot;45.67 degrees&quot;.to_f   =&gt; 45.67&#xA;&quot;thx1138&quot;.to_f         =&gt; 0.0" />
        <scope name="to_i" ilk="function" signature="to_i(p1 = v1)" doc="Returns the result of interpreting leading characters in str as an integer base base (between 2 and 36). Extraneous characters past the end of a valid number are ignored. If there is not a valid number at the start of str, 0 is returned. This method never raises an exception when base is valid. &#xA; &quot;12345&quot;.to_i             =&gt; 12345&#xA;&quot;99 red balloons&quot;.to_i   =&gt; 99&#xA;&quot;0a&quot;.to_i                =&gt; 0&#xA;&quot;0a&quot;.to_i(16)            =&gt; 10&#xA;&quot;hello&quot;.to_i             =&gt; 0&#xA;&quot;1100101&quot;.to_i(2)        =&gt; 101&#xA;&quot;1100101&quot;.to_i(8)        =&gt; 294977&#xA;&quot;1100101&quot;.to_i(10)       =&gt; 1100101&#xA;&quot;1100101&quot;.to_i(16)       =&gt; 17826049" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns a rational which denotes the string form.  The parser ignores leading whitespaces and trailing garbage.  Any digit sequences can be separated by an underscore.  Returns zero for null or garbage string. &#xA; NOTE: &apos;0.3&apos;.to_r isn&apos;t the same as 0.3.to_r.  The former is equivalent to &apos;3/10&apos;.to_r, but the latter isn&apos;t so. &#xA; For example: &#xA; &apos;  2  &apos;.to_r       =&gt; (2/1)&#xA;&apos;300/2&apos;.to_r       =&gt; (150/1)&#xA;&apos;-9.2&apos;.to_r        =&gt; (-46/5)&#xA;&apos;-9.2e2&apos;.to_r      =&gt; (-920/1)&#xA;&apos;1_234_567&apos;.to_r   =&gt; (1234567/1)&#xA;&apos;21 june 09&apos;.to_r  =&gt; (21/1)&#xA;&apos;21/06/09&apos;.to_r    =&gt; (7/2)&#xA;&apos;bwv 1079&apos;.to_r    =&gt; (0/1)" />
        <scope name="to_str" ilk="function" signature="to_str()" doc="Returns the receiver." />
        <scope name="to_sym" ilk="function" signature="to_sym()" doc="Returns the Symbol corresponding to str, creating the symbol if it did not previously exist. See Symbol#id2name. &#xA; &quot;Koala&quot;.intern         =&gt; :Koala&#xA;s = &apos;cat&apos;.to_sym       =&gt; :cat&#xA;s == :cat              =&gt; true&#xA;s = &apos;@cat&apos;.to_sym      =&gt; :@cat&#xA;s == :@cat             =&gt; true&#xA; This can also be used to create symbols that cannot be represented using the :xxx notation. &#xA; &apos;cat and dog&apos;.to_sym   =&gt; :&quot;cat and dog&quot;" />
        <scope name="tr" ilk="function" signature="tr(p1, p2)" doc="Returns a copy of str with the characters in from_str replaced by the corresponding characters in to_str. If to_str is shorter than from_str, it is padded with its last character in order to maintain the correspondence. &#xA; &quot;hello&quot;.tr(&apos;el&apos;, &apos;ip&apos;)      =&gt; &quot;hippo&quot;&#xA;&quot;hello&quot;.tr(&apos;aeiou&apos;, &apos;*&apos;)    =&gt; &quot;h*ll*&quot;&#xA; Both strings may use the c1-c2 notation to denote ranges of characters, and from_str may start with a ^, which denotes all characters except those listed. &#xA; &quot;hello&quot;.tr(&apos;a-y&apos;, &apos;b-z&apos;)    =&gt; &quot;ifmmp&quot;&#xA;&quot;hello&quot;.tr(&apos;^aeiou&apos;, &apos;*&apos;)   =&gt; &quot;*e**o&quot;" />
        <scope name="tr!" ilk="function" signature="tr!(p1, p2)" doc="Translates str in place, using the same rules as String#tr. Returns str, or nil if no changes were made." />
        <scope name="tr_s" ilk="function" signature="tr_s(p1, p2)" doc="Processes a copy of str as described under String#tr, then removes duplicate characters in regions that were affected by the translation. &#xA; &quot;hello&quot;.tr_s(&apos;l&apos;, &apos;r&apos;)     =&gt; &quot;hero&quot;&#xA;&quot;hello&quot;.tr_s(&apos;el&apos;, &apos;*&apos;)    =&gt; &quot;h*o&quot;&#xA;&quot;hello&quot;.tr_s(&apos;el&apos;, &apos;hx&apos;)   =&gt; &quot;hhxo&quot;" />
        <scope name="tr_s!" ilk="function" signature="tr_s!(p1, p2)" doc="Performs String#tr_s processing on str in place, returning str, or nil if no changes were made." />
        <scope name="unpack" ilk="function" signature="unpack(p1)" doc="Decodes str (which may contain binary data) according to the format string, returning an array of each value extracted. The format string consists of a sequence of single-character directives, summarized in the table at the end of this entry. Each directive may be followed by a number, indicating the number of times to repeat with this directive. An asterisk (``*&apos;&apos;) will use up all remaining elements. The directives sSiIlL may each be followed by an underscore (``_&apos;&apos;) or exclamation mark (``!&apos;&apos;) to use the underlying platform&apos;s native size for the specified type; otherwise, it uses a platform-independent consistent size. Spaces are ignored in the format string. See also Array#pack. &#xA; &quot;abc \0\0abc \0\0&quot;.unpack(&apos;A6Z6&apos;)   =&gt; [&quot;abc&quot;, &quot;abc &quot;]&#xA;&quot;abc \0\0&quot;.unpack(&apos;a3a3&apos;)           =&gt; [&quot;abc&quot;, &quot; \000\000&quot;]&#xA;&quot;abc \0abc \0&quot;.unpack(&apos;Z*Z*&apos;)       =&gt; [&quot;abc &quot;, &quot;abc &quot;]&#xA;&quot;aa&quot;.unpack(&apos;b8B8&apos;)                 =&gt; [&quot;10000110&quot;, &quot;01100001&quot;]&#xA;&quot;aaa&quot;.unpack(&apos;h2H2c&apos;)               =&gt; [&quot;16&quot;, &quot;61&quot;, 97]&#xA;&quot;\xfe\xff\xfe\xff&quot;.unpack(&apos;sS&apos;)     =&gt; [-2, 65534]&#xA;&quot;now=20is&quot;.unpack(&apos;M*&apos;)             =&gt; [&quot;now is&quot;]&#xA;&quot;whole&quot;.unpack(&apos;xax2aX2aX1aX2a&apos;)    =&gt; [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;]&#xA; This table summarizes the various formats and the Ruby classes returned by each. &#xA; Integer      |         |&#xA;Directive    | Returns | Meaning&#xA;-----------------------------------------------------------------" />
        <scope name="upcase" ilk="function" signature="upcase()" doc="Returns a copy of str with all lowercase letters replaced with their uppercase counterparts. The operation is locale insensitive---only characters ``a&apos;&apos; to ``z&apos;&apos; are affected. Note: case replacement is effective only in ASCII region. &#xA; &quot;hEllO&quot;.upcase   =&gt; &quot;HELLO&quot;" />
        <scope name="upcase!" ilk="function" signature="upcase!()" doc="Upcases the contents of str, returning nil if no changes were made. Note: case replacement is effective only in ASCII region." />
        <scope name="upto" ilk="function" signature="upto(p1, p2 = v2)" doc="Iterates through successive values, starting at str and ending at other_str inclusive, passing each value in turn to the block. The String#succ method is used to generate each value.  If optional second argument exclusive is omitted or is false, the last value will be included; otherwise it will be excluded. &#xA; If no block is given, an enumerator is returned instead. &#xA; &quot;a8&quot;.upto(&quot;b6&quot;) {|s| print s, &apos; &apos; }&#xA;for s in &quot;a8&quot;..&quot;b6&quot;&#xA;  print s, &apos; &apos;&#xA;end&#xA; produces: &#xA; a8 a9 b0 b1 b2 b3 b4 b5 b6&#xA;a8 a9 b0 b1 b2 b3 b4 b5 b6&#xA; If str and other_str contains only ascii numeric characters, both are recognized as decimal numbers. In addition, the width of string (e.g. leading zeros) is handled appropriately. &#xA; &quot;9&quot;.upto(&quot;11&quot;).to_a   =&gt; [&quot;9&quot;, &quot;10&quot;, &quot;11&quot;]&#xA;&quot;25&quot;.upto(&quot;5&quot;).to_a   =&gt; []&#xA;&quot;07&quot;.upto(&quot;11&quot;).to_a  =&gt; [&quot;07&quot;, &quot;08&quot;, &quot;09&quot;, &quot;10&quot;, &quot;11&quot;]" />
        <scope name="valid_encoding?" ilk="function" signature="valid_encoding?()" doc="Returns true for a string which encoded correctly. &#xA; &quot;\xc2\xa1&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?  =&gt; true&#xA;&quot;\xc2&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      =&gt; false&#xA;&quot;\x80&quot;.force_encoding(&quot;UTF-8&quot;).valid_encoding?      =&gt; false" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a String, using to_str method. Returns converted string or nil if obj cannot be converted for any reason. &#xA; String.try_convert(&quot;str&quot;)     =&gt; &quot;str&quot;&#xA;String.try_convert(/re/)      =&gt; nil" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Returns a new string object containing a copy of str." />
      </scope>
      <scope name="Symbol" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="capitalize" ilk="function" signature="capitalize()" doc="Same as sym.to_s.capitalize.intern." />
        <scope name="casecmp" ilk="function" signature="casecmp(p1)" doc="Case-insensitive version of Symbol#&lt;=&gt;." />
        <scope name="downcase" ilk="function" signature="downcase()" doc="Same as sym.to_s.downcase.intern." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns that _sym_ is :&quot;&quot; or not." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of _sym_." />
        <scope name="id2name" ilk="function" signature="id2name()" doc="Returns the name or string corresponding to sym. &#xA; :fred.id2name   =&gt; &quot;fred&quot;" />
        <scope name="intern" ilk="function" signature="intern()" doc="In general, to_sym returns the Symbol corresponding to an object. As sym is already a symbol, self is returned in this case." />
        <scope name="length" ilk="function" signature="length()" doc="Same as sym.to_s.length." />
        <scope name="match" ilk="function" signature="match(p1)" doc="Returns sym.to_s =~ obj." />
        <scope name="next" ilk="function" signature="next()" doc="Same as sym.to_s.succ.intern." />
        <scope name="size" ilk="function" signature="size()" doc="Same as sym.to_s.length." />
        <scope name="slice" ilk="function" signature="slice(*args)" doc="Returns sym.to_s[]." />
        <scope name="succ" ilk="function" signature="succ()" doc="Same as sym.to_s.succ.intern." />
        <scope name="swapcase" ilk="function" signature="swapcase()" doc="Same as sym.to_s.swapcase.intern." />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Returns a _Proc_ object which respond to the given method by _sym_. &#xA; (1..3).collect(&amp;:to_s)  =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]" />
        <scope name="to_sym" ilk="function" signature="to_sym()" doc="In general, to_sym returns the Symbol corresponding to an object. As sym is already a symbol, self is returned in this case." />
        <scope name="upcase" ilk="function" signature="upcase()" doc="Same as sym.to_s.upcase.intern." />
        <scope name="all_symbols" ilk="function" attributes="__classmethod__" signature="all_symbols()" doc="Returns an array of all the symbols currently in Ruby&apos;s symbol table. &#xA; Symbol.all_symbols.size    =&gt; 903&#xA;Symbol.all_symbols[1,20]   =&gt; [:floor, :ARGV, :Binding, :symlink,&#xA;                                :chown, :EOFError, :$;, :String,&#xA;                                :LOCK_SH, :&quot;setuid?&quot;, :$&lt;,&#xA;                                :default_proc, :compact, :extend,&#xA;                                :Tms, :getwd, :$=, :ThreadGroup,&#xA;                                :wait2, :$&gt;]" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Exception" ilk="class" classrefs="Object" >
        <scope name="backtrace" ilk="function" signature="backtrace()" doc="Returns any backtrace associated with the exception. The backtrace is an array of strings, each containing either ``filename:lineNo: in `method&apos;&apos;&apos; or ``filename:lineNo.&apos;&apos; &#xA; def a&#xA;  raise &quot;boom&quot;&#xA;end&#xA;def b&#xA;  a()&#xA;end&#xA;begin&#xA;  b()&#xA;rescue =&gt; detail&#xA;  print detail.backtrace.join(&quot;\n&quot;)&#xA;end&#xA; produces: " />
        <scope name="exception" ilk="function" signature="exception(*args)" doc="With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str." />
        <scope name="message" ilk="function" signature="message()" doc="Returns the result of invoking exception.to_s. Normally this returns the exception&apos;s message or name. By supplying a to_str method, exceptions are agreeing to be used where Strings are expected." />
        <scope name="set_backtrace" ilk="function" signature="set_backtrace(p1)" doc="Sets the backtrace information associated with exc. The argument must be an array of String objects in the format described in Exception#backtrace." />
        <scope name="exception" ilk="function" attributes="__classmethod__" signature="exception(*args)" doc="With no argument, or if the argument is the same as the receiver, return the receiver. Otherwise, create a new exception object of the same class as the receiver, but with a message equal to string.to_str." />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Construct a new Exception object, optionally passing in a message." />
      </scope>
      <scope name="SystemExit" ilk="class" classrefs="Exception" >
        <scope name="status" ilk="function" signature="status()" doc="Return the status value associated with this system exit." />
        <scope name="success?" ilk="function" signature="success?()" doc="Returns +true+ if exiting successful, +false+ if not." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Create a new +SystemExit+ exception with the given status." />
      </scope>
      <scope name="SignalException" ilk="class" classrefs="Exception" >
        <scope name="signm" ilk="function" />
        <scope name="signo" ilk="function" signature="signo()" doc="Returns a signal number." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Construct a new SignalException object.  +sig_name+ should be a known signal name." />
      </scope>
      <scope name="Interrupt" ilk="class" classrefs="SignalException" >
      </scope>
      <scope name="StandardError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="TypeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ArgumentError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="IndexError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="KeyError" ilk="class" classrefs="IndexError" >
      </scope>
      <scope name="RangeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ScriptError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="SyntaxError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="LoadError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="NotImplementedError" ilk="class" classrefs="ScriptError" >
      </scope>
      <scope name="NameError" ilk="class" classrefs="StandardError" >
        <scope name="name" ilk="function" signature="name()" doc="Return the name associated with this NameError exception." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Construct a new NameError exception. If given the name parameter may subsequently be examined using the NameError.name method." />
      </scope>
      <scope name="NoMethodError" ilk="class" classrefs="NameError" >
        <scope name="args" ilk="function" signature="args()" doc="Return the arguments passed in as the third parameter to the constructor." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Construct a NoMethodError exception for a method of the given name called with the given arguments. The name may be accessed using the #name method on the resulting object, and the arguments using the #args method." />
      </scope>
      <scope name="RuntimeError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="SecurityError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="NoMemoryError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="EncodingError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="SystemCallError" ilk="class" classrefs="StandardError" >
        <scope name="errno" ilk="function" signature="errno()" doc="Return this SystemCallError&apos;s error number." />
        <scope name="===" ilk="function" attributes="__classmethod__" signature="===(p1)" doc="Return +true+ if the receiver is a generic +SystemCallError+, or if the error numbers +self+ and _other_ are the same." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2 = v2)" doc="If _errno_ corresponds to a known system error code, constructs the appropriate Errno class for that error, otherwise constructs a generic SystemCallError object. The error number is subsequently available via the errno method." />
      </scope>
      <scope name="Errno" ilk="namespace" >
        <scope name="E2BIG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EACCES" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADDRINUSE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADDRNOTAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EADV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAFNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAGAIN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EALREADY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EAUTH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADF" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADFD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADMSG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADRPC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADRQC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBADSLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBFONT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EBUSY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECANCELED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECHILD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECHRNG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECOMM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNABORTED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNREFUSED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ECONNRESET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDEADLK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDEADLOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDESTADDRREQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOOFUS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDOTDOT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EDQUOT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EEXIST" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFAULT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFBIG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EFTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EHOSTDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EHOSTUNREACH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIDRM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EILSEQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINPROGRESS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EINVAL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EIPSEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISCONN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISDIR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EISNAM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYEXPIRED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYREJECTED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EKEYREVOKED" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL2HLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL2NSYNC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL3HLT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EL3RST" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBACC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBBAD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBEXEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBMAX" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELIBSCN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELNRNG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ELOOP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMEDIUMTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMFILE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMLINK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMSGSIZE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EMULTIHOP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENAMETOOLONG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENEEDAUTH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETRESET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENETUNREACH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENFILE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOANO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOATTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOBUFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOCSI" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENODATA" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENODEV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOENT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOEXEC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOKEY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOLCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOLINK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMEDIUM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMEM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOMSG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENONET" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOPKG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOPROTOOPT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSPC" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSTR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOSYS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTBLK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTCONN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTDIR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTEMPTY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTNAM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTRECOVERABLE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTSOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTSUP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTTY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENOTUNIQ" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ENXIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOPNOTSUPP" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOVERFLOW" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EOWNERDEAD" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPERM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPFNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROCLIM" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROCUNAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROGMISMATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROGUNAVAIL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTONOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EPROTOTYPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERANGE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMCHG" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMOTE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EREMOTEIO" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERESTART" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERFKILL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EROFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ERPCMISMATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESHUTDOWN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESOCKTNOSUPPORT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESRCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESRMNT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESTALE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ESTRPIPE" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETIME" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETIMEDOUT" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETOOMANYREFS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="ETXTBSY" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUCLEAN" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUNATCH" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EUSERS" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EWOULDBLOCK" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EXDEV" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="EXFULL" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
        <scope name="NOERROR" ilk="class" classrefs="SystemCallError" >
          <variable name="Errno" attributes="__const__" citdl="Fixnum" />
        </scope>
      </scope>
      <scope name="ZeroDivisionError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="FloatDomainError" ilk="class" classrefs="RangeError" >
      </scope>
      <scope name="Numeric" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="abs" ilk="function" signature="abs()" doc="Returns the absolute value of num. &#xA; 12.abs         =&gt; 12&#xA;(-34.56).abs   =&gt; 34.56&#xA;-34.56.abs     =&gt; 34.56" />
        <scope name="abs2" ilk="function" signature="abs2()" doc="Returns square of self." />
        <scope name="angle" ilk="function" signature="angle()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="arg" ilk="function" signature="arg()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="ceil" ilk="function" signature="ceil()" doc="Returns the smallest Integer greater than or equal to num. Class Numeric achieves this by converting itself to a Float then invoking Float#ceil. &#xA; 1.ceil        =&gt; 1&#xA;1.2.ceil      =&gt; 2&#xA;(-1.2).ceil   =&gt; -1&#xA;(-1.0).ceil   =&gt; -1" />
        <scope name="coerce" ilk="function" signature="coerce(p1)" doc="If aNumeric is the same type as num, returns an array containing aNumeric and num. Otherwise, returns an array with both aNumeric and num represented as Float objects. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. &#xA; 1.coerce(2.5)   =&gt; [2.5, 1.0]&#xA;1.2.coerce(3)   =&gt; [3.0, 1.2]&#xA;1.coerce(2)     =&gt; [2, 1]" />
        <scope name="conj" ilk="function" signature="conj()" doc="Returns self." />
        <scope name="conjugate" ilk="function" signature="conjugate()" doc="Returns self." />
        <scope name="denominator" ilk="function" signature="denominator()" doc="Returns the denominator (always positive)." />
        <scope name="div" ilk="function" signature="div(p1)" doc="Uses / to perform division, then converts the result to an integer. numeric does not define the / operator; this is left to subclasses. &#xA; Equivalent to num.divmod(aNumeric)[0]. &#xA; See Numeric#divmod." />
        <scope name="divmod" ilk="function" signature="divmod(p1)" doc="Returns an array containing the quotient and modulus obtained by dividing num by numeric. If q, r = x.divmod(y), then &#xA; q = floor(x/y)&#xA;x = q*y+r&#xA; The quotient is rounded toward -infinity, as shown in the following table: &#xA;  a    |  b  |  a.divmod(b)  |   a/b   | a.modulo(b) | a.remainder(b)&#xA;------+-----+---------------+---------+-------------+---------------&#xA; 13   |  4  |   3,    1     |   3     |    1        |     1&#xA;------+-----+---------------+---------+-------------+---------------&#xA; 13   | -4  |  -4,   -3     |  -4     |   -3        |     1&#xA;------+-----+---------------+---------+-------------+---------------&#xA;-13   |  4  |  -4,    3     |  -4     |    3        |    -1&#xA;------+-----+---------------+---------+-------------+---------------&#xA;-13   | -4  |   3,   -1     |   3     |   -1        |    -1" />
        <scope name="fdiv" ilk="function" signature="fdiv(p1)" doc="Returns float division." />
        <scope name="floor" ilk="function" signature="floor()" doc="Returns the largest integer less than or equal to num. Numeric implements this by converting anInteger to a Float and invoking Float#floor. &#xA; 1.floor      =&gt; 1&#xA;(-1).floor   =&gt; -1" />
        <scope name="i" ilk="function" signature="i()" doc="Returns the corresponding imaginary number. Not available for complex numbers." />
        <scope name="imag" ilk="function" signature="imag()" doc="Returns zero." />
        <scope name="imaginary" ilk="function" signature="imaginary()" doc="Returns zero." />
        <scope name="integer?" ilk="function" signature="integer?()" doc="Returns true if num is an Integer (including Fixnum and Bignum)." />
        <scope name="magnitude" ilk="function" signature="magnitude()" doc="Returns the absolute value of num. &#xA; 12.abs         =&gt; 12&#xA;(-34.56).abs   =&gt; 34.56&#xA;-34.56.abs     =&gt; 34.56" />
        <scope name="modulo" ilk="function" signature="modulo(p1)" doc="x.modulo(y) means x-y*(x/y).floor&#xA; Equivalent to num.divmod(aNumeric)[1]. &#xA; See Numeric#divmod." />
        <scope name="nonzero?" ilk="function" signature="nonzero?()" doc="Returns +self+ if num is not zero, nil otherwise. This behavior is useful when chaining comparisons: &#xA; a = %w( z Bb bB bb BB a aA Aa AA A )&#xA;b = a.sort {|a,b| (a.downcase &lt;=&gt; b.downcase).nonzero? || a &lt;=&gt; b }&#xA;b   =&gt; [&quot;A&quot;, &quot;a&quot;, &quot;AA&quot;, &quot;Aa&quot;, &quot;aA&quot;, &quot;BB&quot;, &quot;Bb&quot;, &quot;bB&quot;, &quot;bb&quot;, &quot;z&quot;]" />
        <scope name="numerator" ilk="function" signature="numerator()" doc="Returns the numerator." />
        <scope name="phase" ilk="function" signature="phase()" doc="Returns 0 if the value is positive, pi otherwise." />
        <scope name="polar" ilk="function" signature="polar()" doc="Returns an array; [num.abs, num.arg]." />
        <scope name="quo" ilk="function" signature="quo(p1)" doc="Returns most exact division (rational for integers, float for floats)." />
        <scope name="real" ilk="function" signature="real()" doc="Returns self." />
        <scope name="real?" ilk="function" signature="real?()" doc="Returns true if num is a Real (i.e. non Complex)." />
        <scope name="rect" ilk="function" signature="rect()" doc="Returns an array; [num, 0]." />
        <scope name="rectangular" ilk="function" signature="rectangular()" doc="Returns an array; [num, 0]." />
        <scope name="remainder" ilk="function" signature="remainder(p1)" doc="x.remainder(y) means x-y*(x/y).truncate&#xA; See Numeric#divmod." />
        <scope name="round" ilk="function" signature="round(*args)" doc="Rounds num to a given precision in decimal digits (default 0 digits). Precision may be negative.  Returns a floating point number when ndigits is more than zero.  Numeric implements this by converting itself to a Float and invoking Float#round." />
        <scope name="singleton_method_added" ilk="function" signature="singleton_method_added(p1)" doc="Trap attempts to add methods to Numeric objects. Always raises a TypeError" />
        <scope name="step" ilk="function" signature="step(*args)" doc="Invokes block with the sequence of numbers starting at num, incremented by step (default 1) on each call. The loop finishes when the value to be passed to the block is greater than limit (if step is positive) or less than limit (if step is negative). If all the arguments are integers, the loop operates using an integer counter. If any of the arguments are floating point numbers, all are converted to floats, and the loop is executed floor(n + n*epsilon)+ 1 times, where n = (limit - num)/step. Otherwise, the loop starts at num, uses either the &lt; or &gt; operator to compare the counter against limit, and increments itself using the + operator. &#xA; If no block is given, an enumerator is returned instead. &#xA; 1.step(10, 2) { |i| print i, &quot; &quot; }&#xA;Math::E.step(Math::PI, 0.2) { |f| print f, &quot; &quot; }&#xA; produces: &#xA; 1 3 5 7 9&#xA;2.71828182845905 2.91828182845905 3.11828182845905" />
        <scope name="to_c" ilk="function" signature="to_c()" doc="Returns the value as a complex." />
        <scope name="to_int" ilk="function" signature="to_int()" doc="Invokes the child class&apos;s to_i method to convert num to an integer." />
        <scope name="truncate" ilk="function" signature="truncate()" doc="Returns num truncated to an integer. Numeric implements this by converting its value to a float and invoking Float#truncate." />
        <scope name="zero?" ilk="function" signature="zero?()" doc="Returns true if num has a zero value." />
      </scope>
      <scope name="Integer" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="chr" ilk="function" signature="chr(*args)" doc="Returns a string containing the character represented by the receiver&apos;s value according to +encoding+. &#xA; 65.chr    =&gt; &quot;A&quot;&#xA;230.chr   =&gt; &quot;\346&quot;&#xA;255.chr(Encoding::UTF_8)   =&gt; &quot;\303\277&quot;" />
        <scope name="downto" ilk="function" signature="downto(p1)" doc="Iterates block, passing decreasing values from int down to and including limit. &#xA; If no block is given, an enumerator is returned instead. &#xA; 5.downto(1) { |n| print n, &quot;.. &quot; }&#xA;print &quot;  Liftoff!\n&quot;&#xA; produces: &#xA; 5.. 4.. 3.. 2.. 1..   Liftoff!" />
        <scope name="even?" ilk="function" signature="even?()" doc="Returns true if int is an even number." />
        <scope name="gcd" ilk="function" signature="gcd(p1)" doc="Returns the greatest common divisor (always positive).  0.gcd(x) and x.gcd(0) return abs(x). &#xA; For example: &#xA; 2.gcd(2)                    =&gt; 2&#xA;3.gcd(-7)                   =&gt; 1&#xA;((1&lt;&lt;31)-1).gcd((1&lt;&lt;61)-1)  =&gt; 1" />
        <scope name="gcdlcm" ilk="function" signature="gcdlcm(p1)" doc="Returns an array; [int.gcd(int2), int.lcm(int2)]. &#xA; For example: &#xA; 2.gcdlcm(2)                    =&gt; [2, 2]&#xA;3.gcdlcm(-7)                   =&gt; [1, 21]&#xA;((1&lt;&lt;31)-1).gcdlcm((1&lt;&lt;61)-1)  =&gt; [1, 4951760154835678088235319297]" />
        <scope name="lcm" ilk="function" signature="lcm(p1)" doc="Returns the least common multiple (always positive).  0.lcm(x) and x.lcm(0) return zero. &#xA; For example: &#xA; 2.lcm(2)                    =&gt; 2&#xA;3.lcm(-7)                   =&gt; 21&#xA;((1&lt;&lt;31)-1).lcm((1&lt;&lt;61)-1)  =&gt; 4951760154835678088235319297" />
        <scope name="next" ilk="function" signature="next()" doc="Returns the Integer equal to int + 1. &#xA; 1.next      =&gt; 2&#xA;(-1).next   =&gt; 0" />
        <scope name="odd?" ilk="function" signature="odd?()" doc="Returns true if int is an odd number." />
        <scope name="ord" ilk="function" signature="ord()" doc="Returns the int itself. &#xA; ?a.ord    =&gt; 97&#xA; This method is intended for compatibility to character constant in Ruby 1.9. For example, ?a.ord returns 97 both in 1.8 and 1.9." />
        <scope name="pred" ilk="function" signature="pred()" doc="Returns the Integer equal to int - 1. &#xA; 1.pred      =&gt; 0&#xA;(-1).pred   =&gt; -2" />
        <scope name="rationalize" ilk="function" signature="rationalize(p1 = v1)" doc="Returns the value as a rational.  An optional argument eps is always ignored." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns the Integer equal to int + 1. &#xA; 1.next      =&gt; 2&#xA;(-1).next   =&gt; 0" />
        <scope name="times" ilk="function" signature="times()" doc="Iterates block int times, passing in values from zero to int - 1. &#xA; If no block is given, an enumerator is returned instead. &#xA; 5.times do |i|&#xA;  print i, &quot; &quot;&#xA;end&#xA; produces: &#xA; 0 1 2 3 4" />
        <scope name="to_i" ilk="function" signature="to_i()" doc="As int is already an Integer, all these methods simply return the receiver." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value as a rational. &#xA; For example: &#xA; 1.to_r        =&gt; (1/1)&#xA;(1&lt;&lt;64).to_r  =&gt; (18446744073709551616/1)" />
        <scope name="upto" ilk="function" signature="upto(p1)" doc="Iterates block, passing in integer values from int up to and including limit. &#xA; If no block is given, an enumerator is returned instead. &#xA; 5.upto(10) { |i| print i, &quot; &quot; }&#xA; produces: &#xA; 5 6 7 8 9 10" />
      </scope>
      <scope name="Fixnum" ilk="class" classrefs="Integer" >
        <import symbol="Comparable" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of bytes in the machine representation of a Fixnum. &#xA; 1.size            =&gt; 4&#xA;-1.size           =&gt; 4&#xA;2147483647.size   =&gt; 4" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Converts fix to a Float." />
      </scope>
      <scope name="Float" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="finite?" ilk="function" signature="finite?()" doc="Returns true if flt is a valid IEEE floating point number (it is not infinite, and nan? is false)." />
        <scope name="infinite?" ilk="function" signature="infinite?()" doc="Returns nil, -1, or +1 depending on whether flt is finite, -infinity, or +infinity. &#xA; (0.0).infinite?        =&gt; nil&#xA;(-1.0/0.0).infinite?   =&gt; -1&#xA;(+1.0/0.0).infinite?   =&gt; 1" />
        <scope name="nan?" ilk="function" signature="nan?()" doc="Returns true if flt is an invalid IEEE floating point number. &#xA; a = -1.0      =&gt; -1.0&#xA;a.nan?        =&gt; false&#xA;a = 0.0/0.0   =&gt; NaN&#xA;a.nan?        =&gt; true" />
        <scope name="rationalize" ilk="function" signature="rationalize(p1 = v1)" doc="Returns a simpler approximation of the value (flt-|eps| &lt;= result &lt;= flt+|eps|).  if eps is not given, it will be chosen automatically. &#xA; For example: &#xA; 0.3.rationalize          =&gt; (3/10)&#xA;1.333.rationalize        =&gt; (1333/1000)&#xA;1.333.rationalize(0.01)  =&gt; (4/3)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="As flt is already a float, returns +self+." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns flt truncated to an Integer." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value as a rational. &#xA; NOTE: 0.3.to_r isn&apos;t the same as &apos;0.3&apos;.to_r.  The latter is equivalent to &apos;3/10&apos;.to_r, but the former isn&apos;t so. &#xA; For example: &#xA; 2.0.to_r    =&gt; (2/1)&#xA;2.5.to_r    =&gt; (5/2)&#xA;-0.75.to_r  =&gt; (-3/4)&#xA;0.0.to_r    =&gt; (0/1)" />
        <variable name="DIG" attributes="__const__" citdl="Fixnum" />
        <variable name="EPSILON" attributes="__const__" citdl="Float" />
        <variable name="INFINITY" attributes="__const__" citdl="Float" />
        <variable name="MANT_DIG" attributes="__const__" citdl="Fixnum" />
        <variable name="MAX" attributes="__const__" citdl="Float" />
        <variable name="MAX_10_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MAX_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MIN" attributes="__const__" citdl="Float" />
        <variable name="MIN_10_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="MIN_EXP" attributes="__const__" citdl="Fixnum" />
        <variable name="NAN" attributes="__const__" citdl="Float" />
        <variable name="RADIX" attributes="__const__" citdl="Fixnum" />
        <variable name="ROUNDS" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Bignum" ilk="class" classrefs="Integer" >
        <import symbol="Comparable" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of bytes in the machine representation of big. &#xA; (256**10 - 1).size   =&gt; 12&#xA;(256**20 - 1).size   =&gt; 20&#xA;(256**40 - 1).size   =&gt; 40" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Converts big to a Float. If big doesn&apos;t fit in a Float, the result is infinity." />
      </scope>
      <scope name="Array" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="assoc" ilk="function" signature="assoc(p1)" doc="Searches through an array whose elements are also arrays comparing _obj_ with the first element of each contained array using obj.==. Returns the first contained array that matches (that is, the first associated array), or +nil+ if no match is found. See also Array#rassoc. &#xA; s1 = [ &quot;colors&quot;, &quot;red&quot;, &quot;blue&quot;, &quot;green&quot; ]&#xA;s2 = [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;s3 = &quot;foo&quot;&#xA;a  = [ s1, s2, s3 ]&#xA;a.assoc(&quot;letters&quot;)  =&gt; [ &quot;letters&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.assoc(&quot;foo&quot;)      =&gt; nil" />
        <scope name="at" ilk="function" signature="at(p1)" doc="Returns the element at _index_. A negative index counts from the end of +self+.  Returns +nil+ if the index is out of range. See also Array#[]. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;a.at(0)     =&gt; &quot;a&quot;&#xA;a.at(-1)    =&gt; &quot;e&quot;" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all elements from +self+. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;a.clear    =&gt; [ ]" />
        <scope name="collect!" ilk="function" signature="collect!()" doc="Invokes the block once for each element of +self+, replacing the element with the value returned by _block_. See also Enumerable#collect. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.collect! {|x| x + &quot;!&quot; }&#xA;a             =&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]" />
        <scope name="combination" ilk="function" signature="combination(p1)" doc="When invoked with a block, yields all combinations of length n of elements from ary and then returns ary itself. The implementation makes no guarantees about the order in which the combinations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA; a = [1, 2, 3, 4]&#xA;a.combination(1).to_a  =&gt; [[1],[2],[3],[4]]&#xA;a.combination(2).to_a  =&gt; [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]&#xA;a.combination(3).to_a  =&gt; [[1,2,3],[1,2,4],[1,3,4],[2,3,4]]&#xA;a.combination(4).to_a  =&gt; [[1,2,3,4]]&#xA;a.combination(0).to_a  =&gt; [[]] # one combination of length 0&#xA;a.combination(5).to_a  =&gt; []   # no combinations of length 5" />
        <scope name="compact" ilk="function" signature="compact()" doc="Returns a copy of +self+ with all +nil+ elements removed. &#xA; [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot;, nil ].compact&#xA;                  =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]" />
        <scope name="compact!" ilk="function" signature="compact!()" doc="Removes +nil+ elements from the array. Returns +nil+ if no changes were made, otherwise returns ary. &#xA; [ &quot;a&quot;, nil, &quot;b&quot;, nil, &quot;c&quot; ].compact! =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].compact!           =&gt; nil" />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Appends the elements of other_ary to +self+. &#xA; [ &quot;a&quot;, &quot;b&quot; ].concat( [&quot;c&quot;, &quot;d&quot;] ) =&gt; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]" />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Deletes items from +self+ that are equal to obj. If any items are found, returns obj.   If the item is not found, returns nil. If the optional code block is given, returns the result of block if the item is not found.  (To remove nil elements and get an informative return value, use #compact!) &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.delete(&quot;b&quot;)                   =&gt; &quot;b&quot;&#xA;a                               =&gt; [&quot;a&quot;, &quot;c&quot;]&#xA;a.delete(&quot;z&quot;)                   =&gt; nil&#xA;a.delete(&quot;z&quot;) { &quot;not found&quot; }   =&gt; &quot;not found&quot;" />
        <scope name="delete_at" ilk="function" signature="delete_at(p1)" doc="Deletes the element at the specified index, returning that element, or nil if the index is out of range. See also Array#slice!. &#xA; a = %w( ant bat cat dog )&#xA;a.delete_at(2)    =&gt; &quot;cat&quot;&#xA;a                 =&gt; [&quot;ant&quot;, &quot;bat&quot;, &quot;dog&quot;]&#xA;a.delete_at(99)   =&gt; nil" />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every element of +self+ for which block evaluates to true. The array is changed instantly every time the block is called and not after the iteration is over. See also Array#reject! &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.delete_if {|x| x &gt;= &quot;b&quot; }   =&gt; [&quot;a&quot;]" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each element in +self+, passing that element as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.each {|x| print x, &quot; -- &quot; }&#xA; produces: &#xA; a -- b -- c --" />
        <scope name="each_index" ilk="function" signature="each_index()" doc="Same as Array#each, but passes the index of the element instead of the element itself. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.each_index {|x| print x, &quot; -- &quot; }&#xA; produces: &#xA; 0 -- 1 -- 2 --" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if +self+ contains no elements. &#xA; [].empty?   =&gt; true" />
        <scope name="fetch" ilk="function" signature="fetch(p1, p2 = v2)" doc="Tries to return the element at position index. If the index lies outside the array, the first form throws an IndexError exception, the second form returns default, and the third form returns the value of invoking the block, passing in the index. Negative values of index count from the end of the array. &#xA; a = [ 11, 22, 33, 44 ]&#xA;a.fetch(1)               =&gt; 22&#xA;a.fetch(-1)              =&gt; 44&#xA;a.fetch(4, &apos;cat&apos;)        =&gt; &quot;cat&quot;&#xA;a.fetch(4) { |i| i*i }   =&gt; 16" />
        <scope name="fill" ilk="function" signature="fill(p1 = v1, p2 = v2)" doc="The first three forms set the selected elements of +self+ (which may be the entire array) to obj. A start of nil is equivalent to zero. A length of nil is equivalent to self.length. The last three forms fill the array with the value of the block. The block is passed the absolute index of each element to be filled. Negative values of start count from the end of the array. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.fill(&quot;x&quot;)              =&gt; [&quot;x&quot;, &quot;x&quot;, &quot;x&quot;, &quot;x&quot;]&#xA;a.fill(&quot;z&quot;, 2, 2)        =&gt; [&quot;x&quot;, &quot;x&quot;, &quot;z&quot;, &quot;z&quot;]&#xA;a.fill(&quot;y&quot;, 0..1)        =&gt; [&quot;y&quot;, &quot;y&quot;, &quot;z&quot;, &quot;z&quot;]&#xA;a.fill {|i| i*i}         =&gt; [0, 1, 4, 9]&#xA;a.fill(-2) {|i| i*i*i}   =&gt; [0, 1, 8, 27]" />
        <scope name="flatten" ilk="function" signature="flatten(p1 = v1)" doc="Returns a new array that is a one-dimensional flattening of this array (recursively). That is, for every element that is an array, extract its elements into the new array.  If the optional level argument determines the level of recursion to flatten. &#xA; s = [ 1, 2, 3 ]           =&gt; [1, 2, 3]&#xA;t = [ 4, 5, 6, [7, 8] ]   =&gt; [4, 5, 6, [7, 8]]&#xA;a = [ s, t, 9, 10 ]       =&gt; [[1, 2, 3], [4, 5, 6, [7, 8]], 9, 10]&#xA;a.flatten                 =&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&#xA;a = [ 1, 2, [3, [4, 5] ] ]&#xA;a.flatten(1)              =&gt; [1, 2, 3, [4, 5]]" />
        <scope name="flatten!" ilk="function" signature="flatten!(p1 = v1)" doc="Flattens +self+ in place. Returns nil if no modifications were made (i.e., ary contains no subarrays.)  If the optional level argument determines the level of recursion to flatten. &#xA; a = [ 1, 2, [3, [4, 5] ] ]&#xA;a.flatten!   =&gt; [1, 2, 3, 4, 5]&#xA;a.flatten!   =&gt; nil&#xA;a            =&gt; [1, 2, 3, 4, 5]&#xA;a = [ 1, 2, [3, [4, 5] ] ]&#xA;a.flatten!(1) =&gt; [1, 2, 3, [4, 5]]" />
        <scope name="index" ilk="function" signature="index(p1)" doc="Returns the index of the first object in +self+ such that the object is == to obj. If a block is given instead of an argument, returns index of first object for which block is true. Returns nil if no match is found. See also Array#rindex. &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.index(&quot;b&quot;)        =&gt; 1&#xA;a.index(&quot;z&quot;)        =&gt; nil&#xA;a.index{|x|x==&quot;b&quot;}  =&gt; 1&#xA; This is an alias of #find_index." />
        <scope name="insert" ilk="function" signature="insert(*args)" doc="Inserts the given values before the element with the given index (which may be negative). &#xA; a = %w{ a b c d }&#xA;a.insert(2, 99)         =&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, &quot;d&quot;]&#xA;a.insert(-2, 1, 2, 3)   =&gt; [&quot;a&quot;, &quot;b&quot;, 99, &quot;c&quot;, 1, 2, 3, &quot;d&quot;]" />
        <scope name="join" ilk="function" signature="join(p1 = v1)" doc="Returns a string created by converting each element of the array to a string, separated by sep. &#xA; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join        =&gt; &quot;abc&quot;&#xA;[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].join(&quot;-&quot;)   =&gt; &quot;a-b-c&quot;" />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every element of +self+ for which block evaluates to false. See also Array#select! &#xA; If no block is given, an enumerator is returned instead. &#xA; a = %w{ a b c d e f }&#xA;a.keep_if {|v| v =~ /[aeiou]/}   =&gt; [&quot;a&quot;, &quot;e&quot;]" />
        <scope name="last" ilk="function" signature="last(*args)" doc="Returns the last element(s) of +self+. If the array is empty, the first form returns nil. &#xA; a = [ &quot;w&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ]&#xA;a.last     =&gt; &quot;z&quot;&#xA;a.last(2)  =&gt; [&quot;y&quot;, &quot;z&quot;]" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of elements in +self+. May be zero. &#xA; [ 1, 2, 3, 4, 5 ].length   =&gt; 5" />
        <scope name="map!" ilk="function" signature="map!()" doc="Invokes the block once for each element of +self+, replacing the element with the value returned by _block_. See also Enumerable#collect. &#xA; If no block is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.collect! {|x| x + &quot;!&quot; }&#xA;a             =&gt;  [ &quot;a!&quot;, &quot;b!&quot;, &quot;c!&quot;, &quot;d!&quot; ]" />
        <scope name="pack" ilk="function" signature="pack(p1)" doc="Packs the contents of arr into a binary sequence according to the directives in aTemplateString (see the table below) Directives ``A,&apos;&apos; ``a,&apos;&apos; and ``Z&apos;&apos; may be followed by a count, which gives the width of the resulting field. The remaining directives also may take a count, indicating the number of array elements to convert. If the count is an asterisk (``*&apos;&apos;), all remaining array elements will be converted. Any of the directives ``sSiIlL&apos;&apos; may be followed by an underscore (``_&apos;&apos;) or exclamation mark (``!&apos;&apos;) to use the underlying platform&apos;s native size for the specified type; otherwise, they use a platform-independent size. Spaces are ignored in the template string. See also String#unpack. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;n = [ 65, 66, 67 ]&#xA;a.pack(&quot;A3A3A3&quot;)   =&gt; &quot;a  b  c  &quot;&#xA;a.pack(&quot;a3a3a3&quot;)   =&gt; &quot;a\000\000b\000\000c\000\000&quot;&#xA;n.pack(&quot;ccc&quot;)      =&gt; &quot;ABC&quot;&#xA; Directives for +pack+. &#xA; Integer      | Array   |&#xA;Directive    | Element | Meaning&#xA;---------------------------------------------------------------------------&#xA;   C         | Integer | 8-bit unsigned (unsigned char)&#xA;   S         | Integer | 16-bit unsigned, native endian (uint16_t)&#xA;   L         | Integer | 32-bit unsigned, native endian (uint32_t)" />
        <scope name="permutation" ilk="function" signature="permutation(p1 = v1)" doc="When invoked with a block, yield all permutations of length n of the elements of ary, then return the array itself. If n is not specified, yield all permutations of all elements. The implementation makes no guarantees about the order in which the permutations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA; a = [1, 2, 3]&#xA;a.permutation.to_a     =&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&#xA;a.permutation(1).to_a  =&gt; [[1],[2],[3]]&#xA;a.permutation(2).to_a  =&gt; [[1,2],[1,3],[2,1],[2,3],[3,1],[3,2]]&#xA;a.permutation(3).to_a  =&gt; [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]&#xA;a.permutation(0).to_a  =&gt; [[]] # one permutation of length 0&#xA;a.permutation(4).to_a  =&gt; []   # no permutations of length 4" />
        <scope name="pop" ilk="function" signature="pop(*args)" doc="Removes the last element from +self+ and returns it, or nil if the array is empty. &#xA; If a number _n_ is given, returns an array of the last n elements (or less) just like array.slice!(-n, n) does. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.pop     =&gt; &quot;d&quot;&#xA;a.pop(2)  =&gt; [&quot;b&quot;, &quot;c&quot;]&#xA;a         =&gt; [&quot;a&quot;]" />
        <scope name="product" ilk="function" signature="product(*args)" doc="Returns an array of all combinations of elements from all arrays. The length of the returned array is the product of the length of +self+ and the argument arrays. If given a block, product will yield all combinations and return +self+ instead. &#xA; [1,2,3].product([4,5])     =&gt; [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]&#xA;[1,2].product([1,2])       =&gt; [[1,1],[1,2],[2,1],[2,2]]&#xA;[1,2].product([3,4],[5,6]) =&gt; [[1,3,5],[1,3,6],[1,4,5],[1,4,6],&#xA;                           #     [2,3,5],[2,3,6],[2,4,5],[2,4,6]]&#xA;[1,2].product()            =&gt; [[1],[2]]&#xA;[1,2].product([])          =&gt; []" />
        <scope name="push" ilk="function" signature="push(*args)" doc="Append---Pushes the given object(s) on to the end of this array. This expression returns the array itself, so several appends may be chained together. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.push(&quot;d&quot;, &quot;e&quot;, &quot;f&quot;)&#xA;        =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;]" />
        <scope name="rassoc" ilk="function" signature="rassoc(p1)" doc="Searches through the array whose elements are also arrays. Compares _obj_ with the second element of each contained array using ==. Returns the first contained array that matches. See also Array#assoc. &#xA; a = [ [ 1, &quot;one&quot;], [2, &quot;two&quot;], [3, &quot;three&quot;], [&quot;ii&quot;, &quot;two&quot;] ]&#xA;a.rassoc(&quot;two&quot;)    =&gt; [2, &quot;two&quot;]&#xA;a.rassoc(&quot;four&quot;)   =&gt; nil" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Array#delete_if, deleting elements from +self+ for which the block evaluates to true, but returns nil if no changes were made. The array is changed instantly every time the block is called and not after the iteration is over. See also Enumerable#reject and Array#delete_if. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="repeated_combination" ilk="function" signature="repeated_combination(p1)" doc="When invoked with a block, yields all repeated combinations of length n of elements from ary and then returns ary itself. The implementation makes no guarantees about the order in which the repeated combinations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA; a = [1, 2, 3]&#xA;a.repeated_combination(1).to_a  =&gt; [[1], [2], [3]]&#xA;a.repeated_combination(2).to_a  =&gt; [[1,1],[1,2],[1,3],[2,2],[2,3],[3,3]]&#xA;a.repeated_combination(3).to_a  =&gt; [[1,1,1],[1,1,2],[1,1,3],[1,2,2],[1,2,3],&#xA;                                #    [1,3,3],[2,2,2],[2,2,3],[2,3,3],[3,3,3]]&#xA;a.repeated_combination(4).to_a  =&gt; [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,2],[1,1,2,3],&#xA;                                #    [1,1,3,3],[1,2,2,2],[1,2,2,3],[1,2,3,3],[1,3,3,3],&#xA;                                #    [2,2,2,2],[2,2,2,3],[2,2,3,3],[2,3,3,3],[3,3,3,3]]&#xA;a.repeated_combination(0).to_a  =&gt; [[]] # one combination of length 0" />
        <scope name="repeated_permutation" ilk="function" signature="repeated_permutation(p1)" doc="When invoked with a block, yield all repeated permutations of length n of the elements of ary, then return the array itself. The implementation makes no guarantees about the order in which the repeated permutations are yielded. &#xA; If no block is given, an enumerator is returned instead. &#xA; Examples: &#xA; a = [1, 2]&#xA;a.repeated_permutation(1).to_a  =&gt; [[1], [2]]&#xA;a.repeated_permutation(2).to_a  =&gt; [[1,1],[1,2],[2,1],[2,2]]&#xA;a.repeated_permutation(3).to_a  =&gt; [[1,1,1],[1,1,2],[1,2,1],[1,2,2],&#xA;                                #    [2,1,1],[2,1,2],[2,2,1],[2,2,2]]&#xA;a.repeated_permutation(0).to_a  =&gt; [[]] # one permutation of length 0" />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents of +self+ with the contents of other_ary, truncating or expanding if necessary. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;a.replace([ &quot;x&quot;, &quot;y&quot;, &quot;z&quot; ])   =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]&#xA;a                              =&gt; [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]" />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a new array containing +self+&apos;s elements in reverse order. &#xA; [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ].reverse   =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]&#xA;[ 1 ].reverse               =&gt; [1]" />
        <scope name="reverse!" ilk="function" signature="reverse!()" doc="Reverses +self+ in place. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.reverse!       =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]&#xA;a                =&gt; [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]" />
        <scope name="rindex" ilk="function" signature="rindex(p1)" doc="Returns the index of the last object in +self+ == to obj. If a block is given instead of an argument, returns index of first object for which block is true, starting from the last object. Returns nil if no match is found. See also Array#index. &#xA; If neither block nor argument is given, an enumerator is returned instead. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.rindex(&quot;b&quot;)        =&gt; 3&#xA;a.rindex(&quot;z&quot;)        =&gt; nil&#xA;a.rindex{|x|x==&quot;b&quot;}  =&gt; 3" />
        <scope name="rotate" ilk="function" signature="rotate(p1 = v1)" doc="Returns new array by rotating +self+ so that the element at +cnt+ in +self+ is the first element of the new array. If +cnt+ is negative then it rotates in the opposite direction. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.rotate         =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;a                =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#xA;a.rotate(2)      =&gt; [&quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;b&quot;]&#xA;a.rotate(-3)     =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]" />
        <scope name="rotate!" ilk="function" signature="rotate!(p1 = v1)" doc="Rotates +self+ in place so that the element at +cnt+ comes first, and returns +self+.  If +cnt+ is negative then it rotates in the opposite direction. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.rotate!        =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;a                =&gt; [&quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;]&#xA;a.rotate!(2)     =&gt; [&quot;d&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;a.rotate!(-3)    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="sample" ilk="function" signature="sample(p1)" doc="Choose a random element or +n+ random elements from the array. The elements are chosen by using random and unique indices into the array in order to ensure that an element doesn&apos;t repeat itself unless the array already contained duplicate elements. If the array is empty the first form returns nil and the second form returns an empty array. &#xA; If +rng+ is given, it will be used as the random number generator." />
        <scope name="select!" ilk="function" signature="select!()" doc="Invokes the block passing in successive elements from +self+, deleting elements for which the block returns a false value. It returns +self+ if changes were made, otherwise it returns nil. See also Array#keep_if &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="shift" ilk="function" signature="shift(*args)" doc="Returns the first element of +self+ and removes it (shifting all other elements down by one). Returns nil if the array is empty. &#xA; If a number _n_ is given, returns an array of the first n elements (or less) just like array.slice!(0, n) does. &#xA; args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]&#xA;args.shift     =&gt; &quot;-m&quot;&#xA;args           =&gt; [&quot;-q&quot;, &quot;filename&quot;]&#xA;&#xA;args = [ &quot;-m&quot;, &quot;-q&quot;, &quot;filename&quot; ]&#xA;args.shift(2)  =&gt; [&quot;-m&quot;, &quot;-q&quot;]&#xA;args           =&gt; [&quot;filename&quot;]" />
        <scope name="shuffle" ilk="function" signature="shuffle(*args)" doc="Returns a new array with elements of this array shuffled. &#xA; a = [ 1, 2, 3 ]           =&gt; [1, 2, 3]&#xA;a.shuffle                 =&gt; [2, 3, 1]&#xA; If +rng+ is given, it will be used as the random number generator. &#xA; a.shuffle(random: Random.new(1))  =&gt; [1, 3, 2]" />
        <scope name="shuffle!" ilk="function" signature="shuffle!(*args)" doc="Shuffles elements in +self+ in place. If +rng+ is given, it will be used as the random number generator." />
        <scope name="size" ilk="function" signature="size()" />
        <scope name="slice" ilk="function" signature="slice(p1, p2 = v2)" doc="Element Reference---Returns the element at _index_, or returns a subarray starting at _start_ and continuing for _length_ elements, or returns a subarray specified by _range_. Negative indices count backward from the end of the array (-1 is the last element). Returns +nil+ if the index (or starting index) are out of range. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;a[2] +  a[0] + a[1]    =&gt; &quot;cab&quot;&#xA;a[6]                   =&gt; nil&#xA;a[1, 2]                =&gt; [ &quot;b&quot;, &quot;c&quot; ]&#xA;a[1..3]                =&gt; [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a[4..7]                =&gt; [ &quot;e&quot; ]&#xA;a[6..10]               =&gt; nil&#xA;a[-3, 3]               =&gt; [ &quot;c&quot;, &quot;d&quot;, &quot;e&quot; ]&#xA;# special cases&#xA;a[5]                   =&gt; nil&#xA;a[5, 1]                =&gt; []&#xA;a[5..10]               =&gt; []" />
        <scope name="slice!" ilk="function" signature="slice!(p1, p2 = v2)" doc="Deletes the element(s) given by an index (optionally with a length) or by a range. Returns the deleted object (or objects), or nil if the index is out of range. &#xA; a = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.slice!(1)     =&gt; &quot;b&quot;&#xA;a               =&gt; [&quot;a&quot;, &quot;c&quot;]&#xA;a.slice!(-1)    =&gt; &quot;c&quot;&#xA;a               =&gt; [&quot;a&quot;]&#xA;a.slice!(100)   =&gt; nil&#xA;a               =&gt; [&quot;a&quot;]" />
        <scope name="sort!" ilk="function" signature="sort!()" doc="Sorts +self+. Comparisons for the sort will be done using the &lt;=&gt; operator or using an optional code block. The block implements a comparison between a and b, returning -1, 0, or +1. See also Enumerable#sort_by. &#xA; a = [ &quot;d&quot;, &quot;a&quot;, &quot;e&quot;, &quot;c&quot;, &quot;b&quot; ]&#xA;a.sort!                    =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;]&#xA;a.sort! {|x,y| y &lt;=&gt; x }   =&gt; [&quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;]" />
        <scope name="sort_by!" ilk="function" signature="sort_by!()" doc="Sorts +self+ in place using a set of keys generated by mapping the values in +self+ through the given block. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="to_ary" ilk="function" signature="to_ary()" doc="Returns +self+." />
        <scope name="transpose" ilk="function" signature="transpose()" doc="Assumes that +self+ is an array of arrays and transposes the rows and columns. &#xA; a = [[1,2], [3,4], [5,6]]&#xA;a.transpose   =&gt; [[1, 3, 5], [2, 4, 6]]" />
        <scope name="uniq" ilk="function" signature="uniq()" doc="Returns a new array by removing duplicate values in +self+. &#xA; a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.uniq   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]&#xA;c.uniq {|s| s[/^\w+/]}  =&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]" />
        <scope name="uniq!" ilk="function" signature="uniq!()" doc="Removes duplicate elements from +self+. Returns nil if no changes are made (that is, no duplicates are found). &#xA; a = [ &quot;a&quot;, &quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;a.uniq!   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#xA;b = [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]&#xA;b.uniq!   =&gt; nil&#xA;c = [ &quot;a:def&quot;, &quot;a:xyz&quot;, &quot;b:abc&quot;, &quot;b:xyz&quot;, &quot;c:jkl&quot; ]&#xA;c.uniq! {|s| s[/^\w+/]}  =&gt; [ &quot;a:def&quot;, &quot;b:abc&quot;, &quot;c:jkl&quot; ]" />
        <scope name="unshift" ilk="function" signature="unshift(*args)" doc="Prepends objects to the front of +self+, moving other elements upwards. &#xA; a = [ &quot;b&quot;, &quot;c&quot;, &quot;d&quot; ]&#xA;a.unshift(&quot;a&quot;)   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]&#xA;a.unshift(1, 2)  =&gt; [ 1, 2, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Returns an array containing the elements in +self+ corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also Array#select. &#xA; a = %w{ a b c d e f }&#xA;a.values_at(1, 3, 5)&#xA;a.values_at(1, 3, 5, 7)&#xA;a.values_at(-1, -3, -5, -7)&#xA;a.values_at(1..3, 2...5)" />
        <scope name="yaml_initialize" ilk="function" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](*args)" doc="Returns a new array populated with the given objects. &#xA; Array.[]( 1, &apos;a&apos;, /^A/ )&#xA;Array[ 1, &apos;a&apos;, /^A/ ]&#xA;[ 1, &apos;a&apos;, /^A/ ]" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into an array, using +to_ary+ method. Returns converted array or +nil+ if obj cannot be converted for any reason. This method can be used to check if an argument is an array. &#xA; Array.try_convert([1])   =&gt; [1]&#xA;Array.try_convert(&quot;1&quot;)   =&gt; nil&#xA;&#xA;if tmp = Array.try_convert(arg)&#xA;  # the argument is an array&#xA;elsif tmp = String.try_convert(arg)&#xA;  # the argument is a string&#xA;end" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1, p2 = v2)" doc="Returns a new array. In the first form, the new array is empty. In the second it is created with _size_ copies of _obj_ (that is, _size_ references to the same _obj_). The third form creates a copy of the array passed as a parameter (the array is generated by calling to_ary  on the parameter). In the last form, an array of the given size is created. Each element in this array is calculated by passing the element&apos;s index to the given block and storing the return value. &#xA; Array.new&#xA;Array.new(2)&#xA;Array.new(5, &quot;A&quot;)&#xA;# only one copy of the object is created&#xA;a = Array.new(2, Hash.new)&#xA;a[0][&apos;cat&apos;] = &apos;feline&apos;&#xA;a&#xA;a[1][&apos;cat&apos;] = &apos;Felix&apos;&#xA;a&#xA;# here multiple copies are created&#xA;a = Array.new(2) { Hash.new }&#xA;a[0][&apos;cat&apos;] = &apos;feline&apos;" />
      </scope>
      <scope name="Hash" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="assoc" ilk="function" signature="assoc(p1)" doc="Searches through the hash comparing _obj_ with the key using ==. Returns the key-value pair (two elements array) or +nil+ if no match is found.  See Array#assoc. &#xA; h = {&quot;colors&quot;  =&gt; [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;],&#xA;     &quot;letters&quot; =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot; ]}&#xA;h.assoc(&quot;letters&quot;)  =&gt; [&quot;letters&quot;, [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]]&#xA;h.assoc(&quot;foo&quot;)      =&gt; nil" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all key-value pairs from hsh. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;h.clear                          =&gt; {}" />
        <scope name="compare_by_identity" ilk="function" signature="compare_by_identity()" doc="Makes hsh compare its keys by their identity, i.e. it will consider exact same objects as same keys. &#xA; h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, :c =&gt; &quot;c&quot; }&#xA;h1[&quot;a&quot;]        =&gt; 100&#xA;h1.compare_by_identity&#xA;h1.compare_by_identity? =&gt; true&#xA;h1[&quot;a&quot;]        =&gt; nil  # different objects.&#xA;h1[:c]         =&gt; &quot;c&quot;  # same symbols are all same." />
        <scope name="compare_by_identity?" ilk="function" signature="compare_by_identity?()" doc="Returns true if hsh will compare its keys by their identity.  Also see Hash#compare_by_identity." />
        <scope name="default" ilk="function" signature="default(p1 = v1)" doc="Returns the default value, the value that would be returned by hsh[key] if key did not exist in hsh. See also Hash::new and Hash#default=. &#xA; h = Hash.new                            =&gt; {}&#xA;h.default                               =&gt; nil&#xA;h.default(2)                            =&gt; nil&#xA;&#xA;h = Hash.new(&quot;cat&quot;)                     =&gt; {}&#xA;h.default                               =&gt; &quot;cat&quot;&#xA;h.default(2)                            =&gt; &quot;cat&quot;&#xA;&#xA;h = Hash.new {|h,k| h[k] = k.to_i*10}   =&gt; {}&#xA;h.default                               =&gt; nil&#xA;h.default(2)                            =&gt; 20" />
        <scope name="default=" ilk="function" signature="default=(p1)" doc="Sets the default value, the value returned for a key that does not exist in the hash. It is not possible to set the default to a Proc that will be executed on each key lookup. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.default = &quot;Go fish&quot;&#xA;h[&quot;a&quot;]     =&gt; 100&#xA;h[&quot;z&quot;]     =&gt; &quot;Go fish&quot;&#xA;# This doesn&apos;t do what you might hope...&#xA;h.default = proc do |hash, key|&#xA;  hash[key] = key + key&#xA;end&#xA;h[2]       =&gt; #&lt;Proc:0x401b3948@-:6&gt;&#xA;h[&quot;cat&quot;]   =&gt; #&lt;Proc:0x401b3948@-:6&gt;" />
        <scope name="default_proc" ilk="function" signature="default_proc()" doc="If Hash::new was invoked with a block, return that block, otherwise return nil. &#xA; h = Hash.new {|h,k| h[k] = k*k }   =&gt; {}&#xA;p = h.default_proc                 =&gt; #&lt;Proc:0x401b3d08@-:1&gt;&#xA;a = []                             =&gt; []&#xA;p.call(a, 2)&#xA;a                                  =&gt; [nil, nil, 4]" />
        <scope name="default_proc=" ilk="function" signature="default_proc=(p1)" doc="Sets the default proc to be executed on each key lookup. &#xA; h.default_proc = proc do |hash, key|&#xA;  hash[key] = key + key&#xA;end&#xA;h[2]       =&gt; 4&#xA;h[&quot;cat&quot;]   =&gt; &quot;catcat&quot;" />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Deletes and returns a key-value pair from hsh whose key is equal to key. If the key is not found, returns the default value. If the optional code block is given and the key is not found, pass in the key and return the result of block. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.delete(&quot;a&quot;)                              =&gt; 100&#xA;h.delete(&quot;z&quot;)                              =&gt; nil&#xA;h.delete(&quot;z&quot;) { |el| &quot;#{el} not found&quot; }   =&gt; &quot;z not found&quot;" />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every key-value pair from hsh for which block evaluates to true. &#xA; If no block is given, an enumerator is returned instead. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300 }&#xA;h.delete_if {|key, value| key &gt;= &quot;b&quot; }   =&gt; {&quot;a&quot;=&gt;100}" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each key in hsh, passing the key-value pair as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.each {|key, value| puts &quot;#{key} is #{value}&quot; }&#xA; produces: &#xA; a is 100&#xA;b is 200" />
        <scope name="each_key" ilk="function" signature="each_key()" doc="Calls block once for each key in hsh, passing the key as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.each_key {|key| puts key }&#xA; produces: &#xA; a&#xA;b" />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Calls block once for each key in hsh, passing the key-value pair as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.each {|key, value| puts &quot;#{key} is #{value}&quot; }&#xA; produces: &#xA; a is 100&#xA;b is 200" />
        <scope name="each_value" ilk="function" signature="each_value()" doc="Calls block once for each key in hsh, passing the value as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.each_value {|value| puts value }&#xA; produces: &#xA; 100&#xA;200" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if hsh contains no key-value pairs. &#xA; {}.empty?   =&gt; true" />
        <scope name="fetch" ilk="function" signature="fetch(p1, p2 = v2)" doc="Returns a value from the hash for the given key. If the key can&apos;t be found, there are several options: With no other arguments, it will raise an KeyError exception; if default is given, then that will be returned; if the optional code block is specified, then that will be run and its result returned. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.fetch(&quot;a&quot;)                            =&gt; 100&#xA;h.fetch(&quot;z&quot;, &quot;go fish&quot;)                 =&gt; &quot;go fish&quot;&#xA;h.fetch(&quot;z&quot;) { |el| &quot;go fish, #{el}&quot;}   =&gt; &quot;go fish, z&quot;&#xA; The following example shows that an exception is raised if the key is not found and a default value is not supplied. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.fetch(&quot;z&quot;)&#xA; produces: &#xA; prog.rb:2:in `fetch&apos;: key not found (KeyError)&#xA; from prog.rb:2" />
        <scope name="flatten" ilk="function" signature="flatten(*args)" doc="Returns a new array that is a one-dimensional flattening of this hash. That is, for every key or value that is an array, extract its elements into the new array.  Unlike Array#flatten, this method does not flatten recursively by default.  The optional level argument determines the level of recursion to flatten. &#xA; a =  {1=&gt; &quot;one&quot;, 2 =&gt; [2,&quot;two&quot;], 3 =&gt; &quot;three&quot;}&#xA;a.flatten    # =&gt; [1, &quot;one&quot;, 2, [2, &quot;two&quot;], 3, &quot;three&quot;]&#xA;a.flatten(2) # =&gt; [1, &quot;one&quot;, 2, 2, &quot;two&quot;, 3, &quot;three&quot;]" />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" doc="Returns true if the given key is present in hsh. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.has_key?(&quot;a&quot;)   =&gt; true&#xA;h.has_key?(&quot;z&quot;)   =&gt; false" />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" doc="Returns true if the given value is present for some key in hsh. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.has_value?(100)   =&gt; true&#xA;h.has_value?(999)   =&gt; false" />
        <scope name="index" ilk="function" />
        <scope name="invert" ilk="function" signature="invert()" doc="Returns a new hash created by using hsh&apos;s values as keys, and the keys as values. &#xA; h = { &quot;n&quot; =&gt; 100, &quot;m&quot; =&gt; 100, &quot;y&quot; =&gt; 300, &quot;d&quot; =&gt; 200, &quot;a&quot; =&gt; 0 }&#xA;h.invert   =&gt; {0=&gt;&quot;a&quot;, 100=&gt;&quot;m&quot;, 200=&gt;&quot;d&quot;, 300=&gt;&quot;y&quot;}" />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every key-value pair from hsh for which block evaluates to false. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="key" ilk="function" signature="key(p1)" doc="Returns the key of an occurrence of a given value. If the value is not found, returns nil. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 300 }&#xA;h.key(200)   =&gt; &quot;b&quot;&#xA;h.key(300)   =&gt; &quot;c&quot;&#xA;h.key(999)   =&gt; nil" />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given key is present in hsh. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.has_key?(&quot;a&quot;)   =&gt; true&#xA;h.has_key?(&quot;z&quot;)   =&gt; false" />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns a new array populated with the keys from this hash. See also Hash#values. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 }&#xA;h.keys   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of key-value pairs in the hash. &#xA; h = { &quot;d&quot; =&gt; 100, &quot;a&quot; =&gt; 200, &quot;v&quot; =&gt; 300, &quot;e&quot; =&gt; 400 }&#xA;h.length        =&gt; 4&#xA;h.delete(&quot;a&quot;)   =&gt; 200&#xA;h.length        =&gt; 3" />
        <scope name="merge" ilk="function" signature="merge(p1)" doc="Returns a new hash containing the contents of other_hash and the contents of hsh. If no block is specified, the value for entries with duplicate keys will be that of other_hash. Otherwise the value for each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA; h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;h1.merge(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;h1.merge(h2){|key, oldval, newval| newval - oldval}&#xA;               =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;54,  &quot;c&quot;=&gt;300}&#xA;h1             =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}" />
        <scope name="merge!" ilk="function" signature="merge!(p1)" doc="Adds the contents of other_hash to hsh.  If no block is specified, entries with duplicate keys are overwritten with the values from other_hash, otherwise the value of each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA; h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;h1.merge!(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;&#xA;h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;h1.merge!(h2) { |key, v1, v2| v1 }&#xA;                =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;300}" />
        <scope name="rassoc" ilk="function" signature="rassoc(p1)" doc="Searches through the hash comparing _obj_ with the value using ==. Returns the first key-value pair (two-element array) that matches. See also Array#rassoc. &#xA; a = {1=&gt; &quot;one&quot;, 2 =&gt; &quot;two&quot;, 3 =&gt; &quot;three&quot;, &quot;ii&quot; =&gt; &quot;two&quot;}&#xA;a.rassoc(&quot;two&quot;)    =&gt; [2, &quot;two&quot;]&#xA;a.rassoc(&quot;four&quot;)   =&gt; nil" />
        <scope name="rehash" ilk="function" signature="rehash()" doc="Rebuilds the hash based on the current hash values for each key. If values of key objects have changed since they were inserted, this method will reindex hsh. If Hash#rehash is called while an iterator is traversing the hash, an RuntimeError will be raised in the iterator. &#xA; a = [ &quot;a&quot;, &quot;b&quot; ]&#xA;c = [ &quot;c&quot;, &quot;d&quot; ]&#xA;h = { a =&gt; 100, c =&gt; 300 }&#xA;h[a]       =&gt; 100&#xA;a[0] = &quot;z&quot;&#xA;h[a]       =&gt; nil&#xA;h.rehash   =&gt; {[&quot;z&quot;, &quot;b&quot;]=&gt;100, [&quot;c&quot;, &quot;d&quot;]=&gt;300}&#xA;h[a]       =&gt; 100" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Hash#delete_if, but returns nil if no changes were made." />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents of hsh with the contents of other_hash. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.replace({ &quot;c&quot; =&gt; 300, &quot;d&quot; =&gt; 400 })   =&gt; {&quot;c&quot;=&gt;300, &quot;d&quot;=&gt;400}" />
        <scope name="select!" ilk="function" signature="select!()" doc="Equivalent to Hash#keep_if, but returns nil if no changes were made." />
        <scope name="shift" ilk="function" signature="shift()" doc="Removes a key-value pair from hsh and returns it as the two-item array [ key, value ], or the hash&apos;s default value if the hash is empty. &#xA; h = { 1 =&gt; &quot;a&quot;, 2 =&gt; &quot;b&quot;, 3 =&gt; &quot;c&quot; }&#xA;h.shift   =&gt; [1, &quot;a&quot;]&#xA;h         =&gt; {2=&gt;&quot;b&quot;, 3=&gt;&quot;c&quot;}" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of key-value pairs in the hash. &#xA; h = { &quot;d&quot; =&gt; 100, &quot;a&quot; =&gt; 200, &quot;v&quot; =&gt; 300, &quot;e&quot; =&gt; 400 }&#xA;h.length        =&gt; 4&#xA;h.delete(&quot;a&quot;)   =&gt; 200&#xA;h.length        =&gt; 3" />
        <scope name="store" ilk="function" signature="store(p1, p2)" doc="Element Assignment---Associates the value given by value with the key given by key. key should not have its value changed while it is in use as a key (a String passed as a key will be duplicated and frozen). &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h[&quot;a&quot;] = 9&#xA;h[&quot;c&quot;] = 4&#xA;h   =&gt; {&quot;a&quot;=&gt;9, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;4}" />
        <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns +self+." />
        <scope name="update" ilk="function" signature="update(p1)" doc="Adds the contents of other_hash to hsh.  If no block is specified, entries with duplicate keys are overwritten with the values from other_hash, otherwise the value of each duplicate key is determined by calling the block with the key, its value in hsh and its value in other_hash. &#xA; h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;h1.merge!(h2)   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;254, &quot;c&quot;=&gt;300}&#xA;&#xA;h1 = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h2 = { &quot;b&quot; =&gt; 254, &quot;c&quot; =&gt; 300 }&#xA;h1.merge!(h2) { |key, v1, v2| v1 }&#xA;                =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200, &quot;c&quot;=&gt;300}" />
        <scope name="value?" ilk="function" signature="value?(p1)" doc="Returns true if the given value is present for some key in hsh. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200 }&#xA;h.has_value?(100)   =&gt; true&#xA;h.has_value?(999)   =&gt; false" />
        <scope name="values" ilk="function" signature="values()" doc="Returns a new array populated with the values from hsh. See also Hash#keys. &#xA; h = { &quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200, &quot;c&quot; =&gt; 300 }&#xA;h.values   =&gt; [100, 200, 300]" />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Return an array containing the values associated with the given keys. Also see Hash.select. &#xA; h = { &quot;cat&quot; =&gt; &quot;feline&quot;, &quot;dog&quot; =&gt; &quot;canine&quot;, &quot;cow&quot; =&gt; &quot;bovine&quot; }&#xA;h.values_at(&quot;cow&quot;, &quot;cat&quot;)  =&gt; [&quot;bovine&quot;, &quot;feline&quot;]" />
        <scope name="yaml_initialize" ilk="function" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](*args)" doc="Creates a new hash populated with the given objects. Equivalent to the literal { key =&gt; value, ... }. In the first form, keys and values occur in pairs, so there must be an even number of arguments. The second and third form take a single argument which is either an array of key-value pairs or an object convertible to a hash. &#xA; Hash[&quot;a&quot;, 100, &quot;b&quot;, 200]             =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;Hash[ [ [&quot;a&quot;, 100], [&quot;b&quot;, 200] ] ]   =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}&#xA;Hash[&quot;a&quot; =&gt; 100, &quot;b&quot; =&gt; 200]         =&gt; {&quot;a&quot;=&gt;100, &quot;b&quot;=&gt;200}" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a hash, using to_hash method. Returns converted hash or nil if obj cannot be converted for any reason. &#xA; Hash.try_convert({1=&gt;2})   # =&gt; {1=&gt;2}&#xA;Hash.try_convert(&quot;1=&gt;2&quot;)   # =&gt; nil" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Returns a new, empty hash. If this hash is subsequently accessed by a key that doesn&apos;t correspond to a hash entry, the value returned depends on the style of new used to create the hash. In the first form, the access returns nil. If obj is specified, this single object will be used for all default values. If a block is specified, it will be called with the hash object and the key, and should return the default value. It is the block&apos;s responsibility to store the value in the hash if required. &#xA; h = Hash.new(&quot;Go Fish&quot;)&#xA;h[&quot;a&quot;] = 100&#xA;h[&quot;b&quot;] = 200&#xA;h[&quot;a&quot;]           =&gt; 100&#xA;h[&quot;c&quot;]           =&gt; &quot;Go Fish&quot;&#xA;# The following alters the single default object&#xA;h[&quot;c&quot;].upcase!   =&gt; &quot;GO FISH&quot;&#xA;h[&quot;d&quot;]           =&gt; &quot;GO FISH&quot;&#xA;h.keys           =&gt; [&quot;a&quot;, &quot;b&quot;]&#xA;# While this creates a new default object each time&#xA;h = Hash.new { |hash, key| hash[key] = &quot;Go Fish: #{key}&quot; }&#xA;h[&quot;c&quot;]           =&gt; &quot;Go Fish: c&quot;" />
      </scope>
      <variable name="ENV" attributes="__const__" citdl="Object" />
      <scope name="Struct" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="each" ilk="function" signature="each()" doc="Calls block once for each instance variable, passing the value as a parameter. &#xA; If no block is given, an enumerator is returned instead. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.each {|x| puts(x) }&#xA; produces: &#xA; Joe Smith&#xA;123 Maple, Anytown NC&#xA;12345" />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Calls block once for each instance variable, passing the name (as a symbol) and the value as parameters. &#xA; If no block is given, an enumerator is returned instead. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.each_pair {|name, value| puts(&quot;#{name} =&gt; #{value}&quot;) }&#xA; produces: &#xA; name =&gt; Joe Smith&#xA;address =&gt; 123 Maple, Anytown NC&#xA;zip =&gt; 12345" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of instance variables. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.length   =&gt; 3" />
        <scope name="members" ilk="function" signature="members()" doc="Returns an array of strings representing the names of the instance variables. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.members   =&gt; [:name, :address, :zip]" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of instance variables. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.length   =&gt; 3" />
        <scope name="values" ilk="function" signature="values()" doc="Returns the values for this instance as an array. &#xA; Customer = Struct.new(:name, :address, :zip)&#xA;joe = Customer.new(&quot;Joe Smith&quot;, &quot;123 Maple, Anytown NC&quot;, 12345)&#xA;joe.to_a[1]   =&gt; &quot;123 Maple, Anytown NC&quot;" />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Returns an array containing the elements in +self+ corresponding to the given selector(s). The selectors may be either integer indices or ranges. See also .select. &#xA; a = %w{ a b c d e f }&#xA;a.values_at(1, 3, 5)&#xA;a.values_at(1, 3, 5, 7)&#xA;a.values_at(-1, -3, -5, -7)&#xA;a.values_at(1..3, 2...5)" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, *args)" doc="Creates a new class, named by aString, containing accessor methods for the given symbols. If the name aString is omitted, an anonymous structure class will be created. Otherwise, the name of this struct will appear as a constant in class Struct, so it must be unique for all Structs in the system and should start with a capital letter. Assigning a structure class to a constant effectively gives the class the name of the constant. &#xA; Struct::new returns a new Class object, which can then be used to create specific instances of the new structure. The number of actual parameters must be less than or equal to the number of attributes defined for this class; unset parameters default to nil.  Passing too many parameters will raise an ArgumentError. &#xA; The remaining methods listed in this section (class and instance) are defined for this generated class. &#xA; # Create a structure with a name in Struct&#xA;Struct.new(&quot;Customer&quot;, :name, :address)    =&gt; Struct::Customer&#xA;Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   =&gt; #&lt;struct Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;&#xA;&#xA;# Create a structure named by its constant&#xA;Customer = Struct.new(:name, :address)     =&gt; Customer&#xA;Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           =&gt; #&lt;struct Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, *args)" doc="Creates a new class, named by aString, containing accessor methods for the given symbols. If the name aString is omitted, an anonymous structure class will be created. Otherwise, the name of this struct will appear as a constant in class Struct, so it must be unique for all Structs in the system and should start with a capital letter. Assigning a structure class to a constant effectively gives the class the name of the constant. &#xA; Struct::new returns a new Class object, which can then be used to create specific instances of the new structure. The number of actual parameters must be less than or equal to the number of attributes defined for this class; unset parameters default to nil.  Passing too many parameters will raise an ArgumentError. &#xA; The remaining methods listed in this section (class and instance) are defined for this generated class. &#xA; # Create a structure with a name in Struct&#xA;Struct.new(&quot;Customer&quot;, :name, :address)    =&gt; Struct::Customer&#xA;Struct::Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)   =&gt; #&lt;struct Struct::Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;&#xA;&#xA;# Create a structure named by its constant&#xA;Customer = Struct.new(:name, :address)     =&gt; Customer&#xA;Customer.new(&quot;Dave&quot;, &quot;123 Main&quot;)           =&gt; #&lt;struct Customer name=&quot;Dave&quot;, address=&quot;123 Main&quot;&gt;" />
        <scope name="Group" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="gid" ilk="function" />
          <scope name="gid=" ilk="function" />
          <scope name="mem" ilk="function" />
          <scope name="mem=" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="passwd" ilk="function" />
          <scope name="passwd=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="all?" ilk="function" attributes="__classmethod__" />
          <scope name="any?" ilk="function" attributes="__classmethod__" />
          <scope name="chunk" ilk="function" attributes="__classmethod__" />
          <scope name="collect" ilk="function" attributes="__classmethod__" />
          <scope name="collect_concat" ilk="function" attributes="__classmethod__" />
          <scope name="count" ilk="function" attributes="__classmethod__" />
          <scope name="cycle" ilk="function" attributes="__classmethod__" />
          <scope name="detect" ilk="function" attributes="__classmethod__" />
          <scope name="drop" ilk="function" attributes="__classmethod__" />
          <scope name="drop_while" ilk="function" attributes="__classmethod__" />
          <scope name="each" ilk="function" attributes="__classmethod__" />
          <scope name="each_cons" ilk="function" attributes="__classmethod__" />
          <scope name="each_entry" ilk="function" attributes="__classmethod__" />
          <scope name="each_slice" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_index" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_object" ilk="function" attributes="__classmethod__" />
          <scope name="entries" ilk="function" attributes="__classmethod__" />
          <scope name="find" ilk="function" attributes="__classmethod__" />
          <scope name="find_all" ilk="function" attributes="__classmethod__" />
          <scope name="find_index" ilk="function" attributes="__classmethod__" />
          <scope name="first" ilk="function" attributes="__classmethod__" />
          <scope name="flat_map" ilk="function" attributes="__classmethod__" />
          <scope name="grep" ilk="function" attributes="__classmethod__" />
          <scope name="group_by" ilk="function" attributes="__classmethod__" />
          <scope name="inject" ilk="function" attributes="__classmethod__" />
          <scope name="map" ilk="function" attributes="__classmethod__" />
          <scope name="max" ilk="function" attributes="__classmethod__" />
          <scope name="max_by" ilk="function" attributes="__classmethod__" />
          <scope name="member?" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
          <scope name="min" ilk="function" attributes="__classmethod__" />
          <scope name="min_by" ilk="function" attributes="__classmethod__" />
          <scope name="minmax" ilk="function" attributes="__classmethod__" />
          <scope name="minmax_by" ilk="function" attributes="__classmethod__" />
          <scope name="none?" ilk="function" attributes="__classmethod__" />
          <scope name="one?" ilk="function" attributes="__classmethod__" />
          <scope name="partition" ilk="function" attributes="__classmethod__" />
          <scope name="reduce" ilk="function" attributes="__classmethod__" />
          <scope name="reject" ilk="function" attributes="__classmethod__" />
          <scope name="reverse_each" ilk="function" attributes="__classmethod__" />
          <scope name="select" ilk="function" attributes="__classmethod__" />
          <scope name="slice_before" ilk="function" attributes="__classmethod__" />
          <scope name="sort" ilk="function" attributes="__classmethod__" />
          <scope name="sort_by" ilk="function" attributes="__classmethod__" />
          <scope name="take" ilk="function" attributes="__classmethod__" />
          <scope name="take_while" ilk="function" attributes="__classmethod__" />
          <scope name="to_a" ilk="function" attributes="__classmethod__" />
          <scope name="zip" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Passwd" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="dir" ilk="function" />
          <scope name="dir=" ilk="function" />
          <scope name="gecos" ilk="function" />
          <scope name="gecos=" ilk="function" />
          <scope name="gid" ilk="function" />
          <scope name="gid=" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="passwd" ilk="function" />
          <scope name="passwd=" ilk="function" />
          <scope name="shell" ilk="function" />
          <scope name="shell=" ilk="function" />
          <scope name="uid" ilk="function" />
          <scope name="uid=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="all?" ilk="function" attributes="__classmethod__" />
          <scope name="any?" ilk="function" attributes="__classmethod__" />
          <scope name="chunk" ilk="function" attributes="__classmethod__" />
          <scope name="collect" ilk="function" attributes="__classmethod__" />
          <scope name="collect_concat" ilk="function" attributes="__classmethod__" />
          <scope name="count" ilk="function" attributes="__classmethod__" />
          <scope name="cycle" ilk="function" attributes="__classmethod__" />
          <scope name="detect" ilk="function" attributes="__classmethod__" />
          <scope name="drop" ilk="function" attributes="__classmethod__" />
          <scope name="drop_while" ilk="function" attributes="__classmethod__" />
          <scope name="each" ilk="function" attributes="__classmethod__" />
          <scope name="each_cons" ilk="function" attributes="__classmethod__" />
          <scope name="each_entry" ilk="function" attributes="__classmethod__" />
          <scope name="each_slice" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_index" ilk="function" attributes="__classmethod__" />
          <scope name="each_with_object" ilk="function" attributes="__classmethod__" />
          <scope name="entries" ilk="function" attributes="__classmethod__" />
          <scope name="find" ilk="function" attributes="__classmethod__" />
          <scope name="find_all" ilk="function" attributes="__classmethod__" />
          <scope name="find_index" ilk="function" attributes="__classmethod__" />
          <scope name="first" ilk="function" attributes="__classmethod__" />
          <scope name="flat_map" ilk="function" attributes="__classmethod__" />
          <scope name="grep" ilk="function" attributes="__classmethod__" />
          <scope name="group_by" ilk="function" attributes="__classmethod__" />
          <scope name="inject" ilk="function" attributes="__classmethod__" />
          <scope name="map" ilk="function" attributes="__classmethod__" />
          <scope name="max" ilk="function" attributes="__classmethod__" />
          <scope name="max_by" ilk="function" attributes="__classmethod__" />
          <scope name="member?" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
          <scope name="min" ilk="function" attributes="__classmethod__" />
          <scope name="min_by" ilk="function" attributes="__classmethod__" />
          <scope name="minmax" ilk="function" attributes="__classmethod__" />
          <scope name="minmax_by" ilk="function" attributes="__classmethod__" />
          <scope name="none?" ilk="function" attributes="__classmethod__" />
          <scope name="one?" ilk="function" attributes="__classmethod__" />
          <scope name="partition" ilk="function" attributes="__classmethod__" />
          <scope name="reduce" ilk="function" attributes="__classmethod__" />
          <scope name="reject" ilk="function" attributes="__classmethod__" />
          <scope name="reverse_each" ilk="function" attributes="__classmethod__" />
          <scope name="select" ilk="function" attributes="__classmethod__" />
          <scope name="slice_before" ilk="function" attributes="__classmethod__" />
          <scope name="sort" ilk="function" attributes="__classmethod__" />
          <scope name="sort_by" ilk="function" attributes="__classmethod__" />
          <scope name="take" ilk="function" attributes="__classmethod__" />
          <scope name="take_while" ilk="function" attributes="__classmethod__" />
          <scope name="to_a" ilk="function" attributes="__classmethod__" />
          <scope name="zip" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Tms" ilk="class" classrefs="Struct" >
          <import symbol="Enumerable" />
          <scope name="cstime" ilk="function" />
          <scope name="cstime=" ilk="function" />
          <scope name="cutime" ilk="function" />
          <scope name="cutime=" ilk="function" />
          <scope name="stime" ilk="function" />
          <scope name="stime=" ilk="function" />
          <scope name="utime" ilk="function" />
          <scope name="utime=" ilk="function" />
          <scope name="[]" ilk="function" attributes="__classmethod__" />
          <scope name="members" ilk="function" attributes="__classmethod__" />
        </scope>
      </scope>
      <scope name="RegexpError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Regexp" ilk="class" classrefs="Object" >
        <scope name="casefold?" ilk="function" signature="casefold?()" doc="Returns the value of the case-insensitive flag. &#xA; /a/.casefold?           =&gt; false&#xA;/a/i.casefold?          =&gt; true&#xA;/(?i:a)/.casefold?      =&gt; false" />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Returns the Encoding object that represents the encoding of obj." />
        <scope name="fixed_encoding?" ilk="function" signature="fixed_encoding?()" doc="Returns false if rxp is applicable to a string with any ASCII compatible encoding. Returns true otherwise. &#xA; r = /a/&#xA;r.fixed_encoding?                               =&gt; false&#xA;r =~ &quot;\u{6666} a&quot;                               =&gt; 2&#xA;r =~ &quot;\xa1\xa2 a&quot;.force_encoding(&quot;euc-jp&quot;)      =&gt; 2&#xA;r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             =&gt; 0&#xA;r = /a/u&#xA;r.fixed_encoding?                               =&gt; true&#xA;r.encoding                                      =&gt; #&lt;Encoding:UTF-8&gt;&#xA;r =~ &quot;\u{6666} a&quot;                               =&gt; 2&#xA;r =~ &quot;\xa1\xa2&quot;.force_encoding(&quot;euc-jp&quot;)        =&gt; ArgumentError&#xA;r =~ &quot;abc&quot;.force_encoding(&quot;euc-jp&quot;)             =&gt; 0&#xA;r = /\u{6666}/" />
        <scope name="match" ilk="function" signature="match(p1, p2 = v2)" doc="Returns a MatchData object describing the match, or nil if there was no match. This is equivalent to retrieving the value of the special variable $~ following a normal match. If the second parameter is present, it specifies the position in the string to begin the search. &#xA; /(.)(.)(.)/.match(&quot;abc&quot;)[2]   =&gt; &quot;b&quot;&#xA;/(.)(.)/.match(&quot;abc&quot;, 1)[2]   =&gt; &quot;c&quot;&#xA; If a block is given, invoke the block with MatchData if match succeed, so that you can write &#xA; pat.match(str) {|m| ...}&#xA; instead of &#xA; if m = pat.match(str)&#xA;  ...&#xA;end&#xA; The return value is a value from block execution in this case." />
        <scope name="named_captures" ilk="function" signature="named_captures()" doc="Returns a hash representing information about named captures of rxp. &#xA; A key of the hash is a name of the named captures. A value of the hash is an array which is list of indexes of corresponding named captures. &#xA; /(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.named_captures&#xA;=&gt; {&quot;foo&quot;=&gt;[1], &quot;bar&quot;=&gt;[2]}&#xA;&#xA;/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.named_captures&#xA;=&gt; {&quot;foo&quot;=&gt;[1, 2]}&#xA; If there are no named captures, an empty hash is returned. &#xA; /(.)(.)/.named_captures&#xA;=&gt; {}" />
        <scope name="names" ilk="function" signature="names()" doc="Returns a list of names of captures as an array of strings. &#xA; /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.names&#xA;=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#xA;&#xA;/(?&lt;foo&gt;.)(?&lt;foo&gt;.)/.names&#xA;=&gt; [&quot;foo&quot;]&#xA;&#xA;/(.)(.)/.names&#xA;=&gt; []" />
        <scope name="options" ilk="function" signature="options()" doc="Returns the set of bits corresponding to the options used when creating this Regexp (see Regexp::new for details. Note that additional bits may be set in the returned options: these are used internally by the regular expression code. These extra bits are ignored if the options are passed to Regexp::new. &#xA; Regexp::IGNORECASE                  =&gt; 1&#xA;Regexp::EXTENDED                    =&gt; 2&#xA;Regexp::MULTILINE                   =&gt; 4&#xA;&#xA;/cat/.options                       =&gt; 0&#xA;/cat/ix.options                     =&gt; 3&#xA;Regexp.new(&apos;cat&apos;, true).options     =&gt; 1&#xA;/\xa1\xa2/e.options                 =&gt; 16&#xA;&#xA;r = /cat/ix&#xA;Regexp.new(r.source, r.options)     =&gt; /cat/ix" />
        <scope name="source" ilk="function" signature="source()" doc="Returns the original string of the pattern. &#xA; /ab+c/ix.source =&gt; &quot;ab+c&quot;&#xA; Note that escape sequences are retained as is. &#xA; /\x20\+/.source  =&gt; &quot;\\x20\\+&quot;" />
        <scope name="compile" ilk="function" attributes="__classmethod__" signature="compile(*args)" doc="Synonym for Regexp.new" />
        <scope name="escape" ilk="function" attributes="__classmethod__" signature="escape(p1)" doc="Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped.  For any string, Regexp.new(Regexp.escape(str))=~str will be true. &#xA; Regexp.escape(&apos;\*?{}.&apos;)   =&gt; \\\*\?\{\}\." />
        <scope name="last_match" ilk="function" attributes="__classmethod__" signature="last_match(p1 = v1)" doc="The first form returns the MatchData object generated by the last successful pattern match. Equivalent to reading the global variable $~. The second form returns the nth field in this MatchData object. n can be a string or symbol to reference a named capture. &#xA; Note that the last_match is local to the thread and method scope of the method that did the pattern match. &#xA; /c(.)t/ =~ &apos;cat&apos;        =&gt; 0&#xA;Regexp.last_match       =&gt; #&lt;MatchData &quot;cat&quot; 1:&quot;a&quot;&gt;&#xA;Regexp.last_match(0)    =&gt; &quot;cat&quot;&#xA;Regexp.last_match(1)    =&gt; &quot;a&quot;&#xA;Regexp.last_match(2)    =&gt; nil&#xA;&#xA;/(?&lt;lhs&gt;\w+)\s*=\s*(?&lt;rhs&gt;\w+)/ =~ &quot;var = val&quot;&#xA;Regexp.last_match       =&gt; #&lt;MatchData &quot;var = val&quot; lhs:&quot;var&quot; rhs:&quot;val&quot;&gt;&#xA;Regexp.last_match(:lhs) =&gt; &quot;var&quot;&#xA;Regexp.last_match(:rhs) =&gt; &quot;val&quot;" />
        <scope name="quote" ilk="function" attributes="__classmethod__" signature="quote(p1)" doc="Escapes any characters that would have special meaning in a regular expression. Returns a new escaped string, or self if no characters are escaped.  For any string, Regexp.new(Regexp.escape(str))=~str will be true. &#xA; Regexp.escape(&apos;\*?{}.&apos;)   =&gt; \\\*\?\{\}\." />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into a Regexp, using to_regexp method. Returns converted regexp or nil if obj cannot be converted for any reason. &#xA; Regexp.try_convert(/re/)         =&gt; /re/&#xA;Regexp.try_convert(&quot;re&quot;)         =&gt; nil&#xA;&#xA;o = Object.new&#xA;Regexp.try_convert(o)            =&gt; nil&#xA;def o.to_regexp() /foo/ end&#xA;Regexp.try_convert(o)            =&gt; /foo/" />
        <scope name="union" ilk="function" attributes="__classmethod__" signature="union(*args)" doc="Return a Regexp object that is the union of the given patterns, i.e., will match any of its parts. The patterns can be Regexp objects, in which case their options will be preserved, or Strings. If no patterns are given, returns /(?!)/. The behavior is unspecified if any given pattern contains capture. &#xA; Regexp.union                         =&gt; /(?!)/&#xA;Regexp.union(&quot;penzance&quot;)             =&gt; /penzance/&#xA;Regexp.union(&quot;a+b*c&quot;)                =&gt; /a\+b\*c/&#xA;Regexp.union(&quot;skiing&quot;, &quot;sledding&quot;)   =&gt; /skiing|sledding/&#xA;Regexp.union([&quot;skiing&quot;, &quot;sledding&quot;]) =&gt; /skiing|sledding/&#xA;Regexp.union(/dogs/, /cats/i)        =&gt; /(?-mix:dogs)|(?i-mx:cats)/" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Constructs a new regular expression from pattern, which can be either a String or a Regexp (in which case that regexp&apos;s options are propagated, and new options may not be specified (a change as of Ruby 1.8). If options is a Fixnum, it should be one or more of the constants Regexp::EXTENDED, Regexp::IGNORECASE, and Regexp::MULTILINE, or-ed together. Otherwise, if options is not nil, the regexp will be case insensitive. When the lang parameter is `n&apos; or `N&apos; sets the regexp no encoding. &#xA; r1 = Regexp.new(&apos;^a-z+:\\s+\w+&apos;)           =&gt; /^a-z+:\s+\w+/&#xA;r2 = Regexp.new(&apos;cat&apos;, true)               =&gt; /cat/i&#xA;r3 = Regexp.new(&apos;dog&apos;, Regexp::EXTENDED)   =&gt; /dog/x&#xA;r4 = Regexp.new(r2)                        =&gt; /cat/i" />
        <variable name="EXTENDED" attributes="__const__" citdl="Fixnum" />
        <variable name="FIXEDENCODING" attributes="__const__" citdl="Fixnum" />
        <variable name="IGNORECASE" attributes="__const__" citdl="Fixnum" />
        <variable name="MULTILINE" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="MatchData" ilk="class" classrefs="Object" >
        <scope name="begin" ilk="function" signature="begin(p1)" doc="Returns the offset of the start of the nth element of the match array in the string. n can be a string or symbol to reference a named capture. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.begin(0)       =&gt; 1&#xA;m.begin(2)       =&gt; 2&#xA;&#xA;m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;p m.begin(:foo)  =&gt; 0&#xA;p m.begin(:bar)  =&gt; 2" />
        <scope name="captures" ilk="function" signature="captures()" doc="Returns the array of captures; equivalent to mtch.to_a[1..-1]. &#xA; f1,f2,f3,f4 = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;).captures&#xA;f1    =&gt; &quot;H&quot;&#xA;f2    =&gt; &quot;X&quot;&#xA;f3    =&gt; &quot;113&quot;&#xA;f4    =&gt; &quot;8&quot;" />
        <scope name="end" ilk="function" signature="end(p1)" doc="Returns the offset of the character immediately following the end of the nth element of the match array in the string. n can be a string or symbol to reference a named capture. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.end(0)         =&gt; 7&#xA;m.end(2)         =&gt; 3&#xA;&#xA;m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;p m.end(:foo)    =&gt; 1&#xA;p m.end(:bar)    =&gt; 3" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of elements in the match array. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.length   =&gt; 5&#xA;m.size     =&gt; 5" />
        <scope name="names" ilk="function" signature="names()" doc="Returns a list of names of captures as an array of strings. It is same as mtch.regexp.names. &#xA; /(?&lt;foo&gt;.)(?&lt;bar&gt;.)(?&lt;baz&gt;.)/.match(&quot;hoge&quot;).names&#xA;=&gt; [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]&#xA;&#xA;m = /(?&lt;x&gt;.)(?&lt;y&gt;.)?/.match(&quot;a&quot;) =&gt; #&lt;MatchData &quot;a&quot; x:&quot;a&quot; y:nil&gt;&#xA;m.names                          =&gt; [&quot;x&quot;, &quot;y&quot;]" />
        <scope name="offset" ilk="function" signature="offset(p1)" doc="Returns a two-element array containing the beginning and ending offsets of the nth match. n can be a string or symbol to reference a named capture. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.offset(0)      =&gt; [1, 7]&#xA;m.offset(4)      =&gt; [6, 7]&#xA;&#xA;m = /(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)/.match(&quot;hoge&quot;)&#xA;p m.offset(:foo) =&gt; [0, 1]&#xA;p m.offset(:bar) =&gt; [2, 3]" />
        <scope name="post_match" ilk="function" signature="post_match()" doc="Returns the portion of the original string after the current match. Equivalent to the special variable $&apos;. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)&#xA;m.post_match   =&gt; &quot;: The Movie&quot;" />
        <scope name="pre_match" ilk="function" signature="pre_match()" doc="Returns the portion of the original string before the current match. Equivalent to the special variable $`. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.pre_match   =&gt; &quot;T&quot;" />
        <scope name="regexp" ilk="function" signature="regexp()" doc="Returns the regexp. &#xA; m = /a.*b/.match(&quot;abc&quot;)&#xA;m.regexp =&gt; /a.*b/" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of elements in the match array. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.length   =&gt; 5&#xA;m.size     =&gt; 5" />
        <scope name="string" ilk="function" signature="string()" doc="Returns a frozen copy of the string passed in to match. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.string   =&gt; &quot;THX1138.&quot;" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns the array of matches. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;)&#xA;m.to_a   =&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]&#xA; Because to_a is called when expanding *variable, there&apos;s a useful assignment shortcut for extracting matched fields. This is slightly slower than accessing the fields directly (as an intermediate array is generated). &#xA; all,f1,f2,f3 = *(/(.)(.)(\d+)(\d)/.match(&quot;THX1138.&quot;))&#xA;all   =&gt; &quot;HX1138&quot;&#xA;f1    =&gt; &quot;H&quot;&#xA;f2    =&gt; &quot;X&quot;&#xA;f3    =&gt; &quot;113&quot;" />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Uses each index to access the matching values, returning an array of the corresponding matches. &#xA; m = /(.)(.)(\d+)(\d)/.match(&quot;THX1138: The Movie&quot;)&#xA;m.to_a               =&gt; [&quot;HX1138&quot;, &quot;H&quot;, &quot;X&quot;, &quot;113&quot;, &quot;8&quot;]&#xA;m.values_at(0, 2, -2)   =&gt; [&quot;HX1138&quot;, &quot;X&quot;, &quot;113&quot;]" />
      </scope>
      <scope name="Marshal" ilk="namespace" >
        <scope name="dump" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="restore" ilk="function" />
        <variable name="MAJOR_VERSION" attributes="__const__" citdl="Fixnum" />
        <variable name="MINOR_VERSION" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Range" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="begin" ilk="function" signature="begin()" doc="Returns the first object in rng." />
        <scope name="cover?" ilk="function" signature="cover?(p1)" doc="Returns true if obj is between beg and end, i.e beg &lt;= obj &lt;= end (or end exclusive when exclude_end? is true). &#xA; (&quot;a&quot;..&quot;z&quot;).cover?(&quot;c&quot;)    =&gt; true&#xA;(&quot;a&quot;..&quot;z&quot;).cover?(&quot;5&quot;)    =&gt; false" />
        <scope name="each" ilk="function" signature="each()" doc="Iterates over the elements rng, passing each in turn to the block. You can only iterate if the start object of the range supports the +succ+ method (which means that you can&apos;t iterate over ranges of +Float+ objects). &#xA; If no block is given, an enumerator is returned instead. &#xA; (10..15).each do |n|&#xA;   print n, &apos; &apos;&#xA;end&#xA; produces: &#xA; 10 11 12 13 14 15" />
        <scope name="end" ilk="function" signature="end()" doc="Returns the object that defines the end of rng. &#xA; (1..10).end    =&gt; 10&#xA;(1...10).end   =&gt; 10" />
        <scope name="exclude_end?" ilk="function" signature="exclude_end?()" doc="Returns true if rng excludes its end value." />
        <scope name="last" ilk="function" signature="last(*args)" doc="Returns the last object in rng, or the last +n+ elements." />
        <scope name="step" ilk="function" signature="step(p1 = v1)" doc="Iterates over rng, passing each nth element to the block. If the range contains numbers, n is added for each iteration.  Otherwise step invokes succ to iterate through range elements. The following code uses class Xs, which is defined in the class-level documentation. &#xA; If no block is given, an enumerator is returned instead. &#xA; range = Xs.new(1)..Xs.new(10)&#xA;range.step(2) {|x| puts x}&#xA;range.step(3) {|x| puts x}&#xA; produces: &#xA;  1 x&#xA; 3 xxx&#xA; 5 xxxxx&#xA; 7 xxxxxxx&#xA; 9 xxxxxxxxx&#xA; 1 x&#xA; 4 xxxx" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2, p3 = v3)" doc="Constructs a range using the given start and end. If the third parameter is omitted or is false, the range will include the end object; otherwise, it will be excluded." />
      </scope>
      <scope name="IOError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="EOFError" ilk="class" classrefs="IOError" >
      </scope>
      <scope name="IO" ilk="class" classrefs="Object" >
        <import symbol="File::Constants" />
        <import symbol="Enumerable" />
        <scope name="autoclose=" ilk="function" signature="autoclose=(p1)" doc="Sets auto-close flag. &#xA; f = open(&quot;/dev/null&quot;)&#xA;IO.for_fd(f.fileno)&#xA;# ...&#xA;f.gets # may cause IOError&#xA;&#xA;f = open(&quot;/dev/null&quot;)&#xA;IO.for_fd(f.fileno).autoclose = true&#xA;# ...&#xA;f.gets # won&apos;t cause IOError" />
        <scope name="autoclose?" ilk="function" signature="autoclose?()" doc="Returns +true+ if the underlying file descriptor of _ios_ will be closed automatically at its finalization, otherwise +false+." />
        <scope name="binmode" ilk="function" signature="binmode()" doc="Puts ios into binary mode. Once a stream is in binary mode, it cannot be reset to nonbinary mode. &#xA; newline conversion disabled&#xA;encoding conversion disabled&#xA;content is treated as ASCII-8BIT" />
        <scope name="binmode?" ilk="function" signature="binmode?()" doc="Returns true if ios is binmode." />
        <scope name="bytes" ilk="function" signature="bytes()" doc="Calls the given block once for each byte (0..255) in ios, passing the byte as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;checksum = 0&#xA;f.each_byte {|x| checksum ^= x }   =&gt; #&lt;File:testfile&gt;&#xA;checksum                           =&gt; 12" />
        <scope name="chars" ilk="function" signature="chars()" doc="Calls the given block once for each character in ios, passing the character as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.each_char {|c| print c, &apos; &apos; }   =&gt; #&lt;File:testfile&gt;" />
        <scope name="close" ilk="function" signature="close()" doc="Closes ios and flushes any pending writes to the operating system. The stream is unavailable for any further data operations; an IOError is raised if such an attempt is made. I/O streams are automatically closed when they are claimed by the garbage collector. &#xA; If ios is opened by IO.popen, close sets $?." />
        <scope name="close_on_exec=" ilk="function" signature="close_on_exec=(p1)" doc="Sets a close-on-exec flag. &#xA; f = open(&quot;/dev/null&quot;)&#xA;f.close_on_exec = true&#xA;system(&quot;cat&quot;, &quot;/proc/self/fd/#{f.fileno}&quot;) # cat: /proc/self/fd/3: No such file or directory&#xA;f.closed?                =&gt; false" />
        <scope name="close_on_exec?" ilk="function" signature="close_on_exec?()" doc="Returns true if ios will be closed on exec. &#xA; f = open(&quot;/dev/null&quot;)&#xA;f.close_on_exec?                 =&gt; false&#xA;f.close_on_exec = true&#xA;f.close_on_exec?                 =&gt; true&#xA;f.close_on_exec = false&#xA;f.close_on_exec?                 =&gt; false" />
        <scope name="close_read" ilk="function" signature="close_read()" doc="Closes the read end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed. &#xA; f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;f.close_read&#xA;f.readlines&#xA; produces: &#xA; prog.rb:3:in `readlines&apos;: not opened for reading (IOError)&#xA; from prog.rb:3" />
        <scope name="close_write" ilk="function" signature="close_write()" doc="Closes the write end of a duplex I/O stream (i.e., one that contains both a read and a write stream, such as a pipe). Will raise an IOError if the stream is not duplexed. &#xA; f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;f.close_write&#xA;f.print &quot;nowhere&quot;&#xA; produces: &#xA; prog.rb:3:in `write&apos;: not opened for writing (IOError)&#xA; from prog.rb:3:in `print&apos;&#xA; from prog.rb:3" />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if ios is completely closed (for duplex streams, both reader and writer), false otherwise. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.close         =&gt; nil&#xA;f.closed?       =&gt; true&#xA;f = IO.popen(&quot;/bin/sh&quot;,&quot;r+&quot;)&#xA;f.close_write   =&gt; nil&#xA;f.closed?       =&gt; false&#xA;f.close_read    =&gt; nil&#xA;f.closed?       =&gt; true" />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="Passes the Integer ordinal of each character in ios, passing the codepoint as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="each" ilk="function" signature="each(*args)" doc="Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: &#xA; 1: This is line one&#xA;2: This is line two&#xA;3: This is line three&#xA;4: And so on..." />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="Calls the given block once for each byte (0..255) in ios, passing the byte as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;checksum = 0&#xA;f.each_byte {|x| checksum ^= x }   =&gt; #&lt;File:testfile&gt;&#xA;checksum                           =&gt; 12" />
        <scope name="each_char" ilk="function" signature="each_char()" doc="Calls the given block once for each character in ios, passing the character as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.each_char {|c| print c, &apos; &apos; }   =&gt; #&lt;File:testfile&gt;" />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="Passes the Integer ordinal of each character in ios, passing the codepoint as an argument. The stream must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead." />
        <scope name="each_line" ilk="function" signature="each_line(*args)" doc="Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: &#xA; 1: This is line one&#xA;2: This is line two&#xA;3: This is line three&#xA;4: And so on..." />
        <scope name="eof" ilk="function" signature="eof()" doc="Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised. &#xA; f = File.new(&quot;testfile&quot;)&#xA;dummy = f.readlines&#xA;f.eof   =&gt; true&#xA; If ios is a stream such as pipe or socket, IO#eof? blocks until the other end sends some data or closes it. &#xA; r, w = IO.pipe&#xA;Thread.new { sleep 1; w.close }&#xA;r.eof?  =&gt; true after 1 second blocking&#xA;r, w = IO.pipe&#xA;Thread.new { sleep 1; w.puts &quot;a&quot; }&#xA;r.eof?  =&gt; false after 1 second blocking&#xA;r, w = IO.pipe&#xA;r.eof?  # blocks forever" />
        <scope name="eof?" ilk="function" signature="eof?()" doc="Returns true if ios is at end of file that means there are no more data to read. The stream must be opened for reading or an IOError will be raised. &#xA; f = File.new(&quot;testfile&quot;)&#xA;dummy = f.readlines&#xA;f.eof   =&gt; true&#xA; If ios is a stream such as pipe or socket, IO#eof? blocks until the other end sends some data or closes it. &#xA; r, w = IO.pipe&#xA;Thread.new { sleep 1; w.close }&#xA;r.eof?  =&gt; true after 1 second blocking&#xA;r, w = IO.pipe&#xA;Thread.new { sleep 1; w.puts &quot;a&quot; }&#xA;r.eof?  =&gt; false after 1 second blocking&#xA;r, w = IO.pipe&#xA;r.eof?  # blocks forever" />
        <scope name="external_encoding" ilk="function" signature="external_encoding()" doc="Returns the Encoding object that represents the encoding of the file. If io is write mode and no encoding is specified, returns nil." />
        <scope name="fcntl" ilk="function" signature="fcntl(p1, p2 = v2)" doc="Provides a mechanism for issuing low-level commands to control or query file-oriented I/O streams. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes (Array#pack might be a useful way to build this string). On Unix platforms, see fcntl(2) for details. Not implemented on all platforms." />
        <scope name="fdatasync" ilk="function" signature="fdatasync()" doc="Immediately writes all buffered data in ios to disk. &#xA; If the underlying operating system does not support fdatasync(2), IO#fsync is called instead (which might raise a NotImplementedError)." />
        <scope name="fileno" ilk="function" signature="fileno()" doc="Returns an integer representing the numeric file descriptor for ios. &#xA; $stdin.fileno    =&gt; 0&#xA;$stdout.fileno   =&gt; 1" />
        <scope name="flush" ilk="function" signature="flush()" doc="Flushes any buffered data within ios to the underlying operating system (note that this is Ruby internal buffering only; the OS may buffer the data as well). &#xA; $stdout.print &quot;no newline&quot;&#xA;$stdout.flush&#xA; produces: &#xA; no newline" />
        <scope name="fsync" ilk="function" signature="fsync()" doc="Immediately writes all buffered data in ios to disk. Note that fsync differs from using IO#sync=. The latter ensures that data is flushed from Ruby&apos;s buffers, but doesn&apos;t not guarantee that the underlying operating system actually writes it to disk. &#xA; NotImplementedError is raised if the underlying operating system does not support fsync(2)." />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="Gets the next 8-bit byte (0..255) from ios. Returns nil if called at end of file. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.getbyte   =&gt; 84&#xA;f.getbyte   =&gt; 104" />
        <scope name="getc" ilk="function" signature="getc()" doc="Reads a one-character string from ios. Returns nil if called at end of file. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.getc   =&gt; &quot;h&quot;&#xA;f.getc   =&gt; &quot;e&quot;" />
        <scope name="gets" ilk="function" signature="gets(*args)" doc="Reads the next ``line&apos;&apos; from the I/O stream; lines are separated by sep. A separator of nil reads the entire contents, and a zero-length separator reads the input a paragraph at a time (two successive newlines in the input separate paragraphs). The stream must be opened for reading or an IOError will be raised. The line read in will be returned and also assigned to $_. Returns nil if called at end of file.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes. &#xA; File.new(&quot;testfile&quot;).gets   =&gt; &quot;This is line one\n&quot;&#xA;$_                          =&gt; &quot;This is line one\n&quot;" />
        <scope name="internal_encoding" ilk="function" signature="internal_encoding()" doc="Returns the Encoding of the internal string if conversion is specified.  Otherwise returns nil." />
        <scope name="ioctl" ilk="function" signature="ioctl(p1, p2 = v2)" doc="Provides a mechanism for issuing low-level commands to control or query I/O devices. Arguments and results are platform dependent. If arg is a number, its value is passed directly. If it is a string, it is interpreted as a binary sequence of bytes. On Unix platforms, see ioctl(2) for details. Not implemented on all platforms." />
        <scope name="isatty" ilk="function" signature="isatty()" doc="Returns true if ios is associated with a terminal device (tty), false otherwise. &#xA; File.new(&quot;testfile&quot;).isatty   =&gt; false&#xA;File.new(&quot;/dev/tty&quot;).isatty   =&gt; true" />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Returns the current line number in ios.  The stream must be opened for reading. lineno counts the number of times #gets is called rather than the number of newlines encountered.  The two values will differ if #gets is called with a separator other than newline. &#xA; Methods that use $/ like #each, #lines and #readline will also increment lineno. &#xA; See also the $. variable. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.lineno   =&gt; 0&#xA;f.gets     =&gt; &quot;This is line one\n&quot;&#xA;f.lineno   =&gt; 1&#xA;f.gets     =&gt; &quot;This is line two\n&quot;&#xA;f.lineno   =&gt; 2" />
        <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="Manually sets the current line number to the given value. $. is updated only on the next read. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.gets                     =&gt; &quot;This is line one\n&quot;&#xA;$.                         =&gt; 1&#xA;f.lineno = 1000&#xA;f.lineno                   =&gt; 1000&#xA;$.                         =&gt; 1         # lineno of last read&#xA;f.gets                     =&gt; &quot;This is line two\n&quot;&#xA;$.                         =&gt; 1001      # lineno of last read" />
        <scope name="lines" ilk="function" signature="lines(*args)" doc="Executes the block for every line in ios, where lines are separated by sep. ios must be opened for reading or an IOError will be raised. &#xA; If no block is given, an enumerator is returned instead. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.each {|line| puts &quot;#{f.lineno}: #{line}&quot; }&#xA; produces: &#xA; 1: This is line one&#xA;2: This is line two&#xA;3: This is line three&#xA;4: And so on..." />
        <scope name="pid" ilk="function" signature="pid()" doc="Returns the process ID of a child process associated with ios. This will be set by IO.popen. &#xA; pipe = IO.popen(&quot;-&quot;)&#xA;if pipe&#xA;  $stderr.puts &quot;In parent, child pid is #{pipe.pid}&quot;&#xA;else&#xA;  $stderr.puts &quot;In child, pid is #{$$}&quot;&#xA;end&#xA; produces: &#xA; In child, pid is 26209&#xA;In parent, child pid is 26209" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current offset (in bytes) of ios. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.pos    =&gt; 0&#xA;f.gets   =&gt; &quot;This is line one\n&quot;&#xA;f.pos    =&gt; 17" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Seeks to the given position (in bytes) in ios. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.pos = 17&#xA;f.gets   =&gt; &quot;This is line two\n&quot;" />
        <scope name="print" ilk="function" signature="print(*args)" doc="Writes the given object(s) to ios. The stream must be opened for writing. If the output field separator ($,) is not nil, it will be inserted between each object. If the output record separator ($\\) is not nil, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. With no argument, prints the contents of the variable $_. Returns nil. &#xA; $stdout.print(&quot;This is &quot;, 100, &quot; percent.\n&quot;)&#xA; produces: &#xA; This is 100 percent." />
        <scope name="printf" ilk="function" signature="printf(*args)" doc="Formats and writes to ios, converting parameters under control of the format string. See Kernel#sprintf for details." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc="If obj is Numeric, write the character whose code is the least-significant byte of obj, otherwise write the first byte of the string representation of obj to ios. Note: This method is not safe for use with multi-byte characters as it will truncate them. &#xA; $stdout.putc &quot;A&quot;&#xA;$stdout.putc 65&#xA; produces: &#xA; AA" />
        <scope name="puts" ilk="function" signature="puts(*args)" doc="Writes the given objects to ios as with IO#print. Writes a record separator (typically a newline) after any that do not already end with a newline sequence. If called with an array argument, writes each element on a new line. If called without arguments, outputs a single record separator. &#xA; $stdout.puts(&quot;this&quot;, &quot;is&quot;, &quot;a&quot;, &quot;test&quot;)&#xA; produces: &#xA; this&#xA;is&#xA;a&#xA;test" />
        <scope name="read" ilk="function" signature="read(p1 = v1, p2 = v2)" doc="Reads length bytes from the I/O stream. &#xA; length must be a non-negative integer or nil. &#xA; If length is a positive integer, it try to read length bytes without any conversion (binary mode). It returns nil or a string whose length is 1 to length bytes. nil means it met EOF at beginning. The 1 to length-1 bytes string means it met EOF after reading the result. The length bytes string means it doesn&apos;t meet EOF. The resulted string is always ASCII-8BIT encoding. &#xA; If length is omitted or is nil, it reads until EOF and the encoding conversion is applied. It returns a string even if EOF is met at beginning. &#xA; If length is zero, it returns &quot;&quot;. &#xA; If the optional buffer argument is present, it must reference a String, which will receive the data. &#xA; At end of file, it returns nil or &quot;&quot; depend on length. ios.read() and ios.read(nil) returns &quot;&quot;. ios.read(positive-integer) returns nil. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.read(16)   =&gt; &quot;This is line one&quot;&#xA;# reads whole file&#xA;open(&quot;file&quot;) {|f|&#xA;  data = f.read # This returns a string even if the file is empty.&#xA;  ..." />
        <scope name="read_nonblock" ilk="function" signature="read_nonblock(*args)" doc="Reads at most maxlen bytes from ios using the read(2) system call after O_NONBLOCK is set for the underlying file descriptor. &#xA; If the optional outbuf argument is present, it must reference a String, which will receive the data. &#xA; read_nonblock just calls the read(2) system call. It causes all errors the read(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The caller should care such errors. &#xA; If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for retrying read_nonblock. &#xA; read_nonblock causes EOFError on EOF. &#xA; If the read byte buffer is not empty, read_nonblock reads from the buffer like readpartial. In this case, the read(2) system call is not called. &#xA; When read_nonblock raises an exception kind of IO::WaitReadable, read_nonblock should not be called until io is readable for avoiding busy loop. This can be done as follows. &#xA; # emulates blocking read (readpartial).&#xA;begin&#xA;  result = io.read_nonblock(maxlen)&#xA;rescue IO::WaitReadable&#xA;  IO.select([io])&#xA;  retry" />
        <scope name="readbyte" ilk="function" signature="readbyte()" doc="Reads a byte as with IO#getbyte, but raises an EOFError on end of file." />
        <scope name="readchar" ilk="function" signature="readchar()" doc="Reads a one-character string from ios. Raises an EOFError on end of file. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.readchar   =&gt; &quot;h&quot;&#xA;f.readchar   =&gt; &quot;e&quot;" />
        <scope name="readline" ilk="function" signature="readline(*args)" doc="Reads a line as with IO#gets, but raises an EOFError on end of file." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" doc="Reads all of the lines in ios, and returns them in anArray. Lines are separated by the optional sep. If sep is nil, the rest of the stream is returned as a single record.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes. The stream must be opened for reading or an IOError will be raised. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.readlines[0]   =&gt; &quot;This is line one\n&quot;" />
        <scope name="readpartial" ilk="function" signature="readpartial(*args)" doc="Reads at most maxlen bytes from the I/O stream. It blocks only if ios has no data immediately available. It doesn&apos;t block if some data available. If the optional outbuf argument is present, it must reference a String, which will receive the data. It raises EOFError on end of file. &#xA; readpartial is designed for streams such as pipe, socket, tty, etc. It blocks only when no data immediately available. This means that it blocks only when following all conditions hold. the byte buffer in the IO object is empty.&#xA;the content of the stream is empty.&#xA;the stream is not reached to EOF. &#xA; When readpartial blocks, it waits data or EOF on the stream. If some data is reached, readpartial returns with the data. If EOF is reached, readpartial raises EOFError. &#xA; When readpartial doesn&apos;t blocks, it returns or raises immediately. If the byte buffer is not empty, it returns the data in the buffer. Otherwise if the stream has some content, it returns the data in the stream. Otherwise if the stream is reached to EOF, it raises EOFError. &#xA; r, w = IO.pipe           #               buffer          pipe content&#xA;w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;.&#xA;r.readpartial(4096)      =&gt; &quot;abc&quot;       &quot;&quot;              &quot;&quot;&#xA;r.readpartial(4096)      # blocks because buffer and pipe is empty.&#xA;r, w = IO.pipe           #               buffer          pipe content&#xA;w &lt;&lt; &quot;abc&quot;               #               &quot;&quot;              &quot;abc&quot;&#xA;w.close                  #               &quot;&quot;              &quot;abc&quot; EOF" />
        <scope name="reopen" ilk="function" signature="reopen(p1, p2 = v2)" doc="Reassociates ios with the I/O stream given in other_IO or to a new stream opened on path. This may dynamically change the actual class of this stream. &#xA; f1 = File.new(&quot;testfile&quot;)&#xA;f2 = File.new(&quot;testfile&quot;)&#xA;f2.readlines[0]   =&gt; &quot;This is line one\n&quot;&#xA;f2.reopen(f1)     =&gt; #&lt;File:testfile&gt;&#xA;f2.readlines[0]   =&gt; &quot;This is line one\n&quot;" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Positions ios to the beginning of input, resetting lineno to zero. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.readline   =&gt; &quot;This is line one\n&quot;&#xA;f.rewind     =&gt; 0&#xA;f.lineno     =&gt; 0&#xA;f.readline   =&gt; &quot;This is line one\n&quot;&#xA; Note that it cannot be used with streams such as pipes, ttys, and sockets." />
        <scope name="seek" ilk="function" signature="seek(p1, p2 = v2)" doc="Seeks to a given offset anInteger in the stream according to the value of whence: &#xA; IO::SEEK_CUR  | Seeks to _amount_ plus current position&#xA;--------------+----------------------------------------------------&#xA;IO::SEEK_END  | Seeks to _amount_ plus end of stream (you probably&#xA;              | want a negative value for _amount_)&#xA;--------------+----------------------------------------------------&#xA;IO::SEEK_SET  | Seeks to the absolute location given by _amount_&#xA; Example: &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.seek(-13, IO::SEEK_END)   =&gt; 0&#xA;f.readline                  =&gt; &quot;And so on...\n&quot;" />
        <scope name="set_encoding" ilk="function" signature="set_encoding(p1, p2 = v2, p3 = {})" doc="If single argument is specified, read string from io is tagged with the encoding specified.  If encoding is a colon separated two encoding names &quot;A:B&quot;, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B.  If two arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option." />
        <scope name="stat" ilk="function" signature="stat()" doc="Returns status information for ios as an object of type File::Stat. &#xA; f = File.new(&quot;testfile&quot;)&#xA;s = f.stat&#xA;&quot;%o&quot; % s.mode   =&gt; &quot;100644&quot;&#xA;s.blksize       =&gt; 4096&#xA;s.atime         =&gt; Wed Apr 09 08:53:54 CDT 2003" />
        <scope name="sync" ilk="function" signature="sync()" doc="Returns the current ``sync mode&apos;&apos; of ios. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered by Ruby internally. See also IO#fsync. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.sync   =&gt; false" />
        <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Sets the ``sync mode&apos;&apos; to true or false. When sync mode is true, all output is immediately flushed to the underlying operating system and is not buffered internally. Returns the new state. See also IO#fsync. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.sync = true&#xA; (produces no output)" />
        <scope name="sysread" ilk="function" signature="sysread(p1, p2 = v2)" doc="Reads maxlen bytes from ios using a low-level read and returns them as a string.  Do not mix with other methods that read from ios or you may get unpredictable results. If the optional outbuf argument is present, it must reference a String, which will receive the data. Raises SystemCallError on error and EOFError at end of file. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.sysread(16)   =&gt; &quot;This is line one&quot;" />
        <scope name="sysseek" ilk="function" signature="sysseek(p1, p2 = v2)" doc="Seeks to a given offset in the stream according to the value of whence (see IO#seek for values of whence). Returns the new offset into the file. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.sysseek(-13, IO::SEEK_END)   =&gt; 53&#xA;f.sysread(10)                  =&gt; &quot;And so on.&quot;" />
        <scope name="syswrite" ilk="function" signature="syswrite(p1)" doc="Writes the given string to ios using a low-level write. Returns the number of bytes written. Do not mix with other methods that write to ios or you may get unpredictable results. Raises SystemCallError on error. &#xA; f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;f.syswrite(&quot;ABCDEF&quot;)   =&gt; 6" />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current offset (in bytes) of ios. &#xA; f = File.new(&quot;testfile&quot;)&#xA;f.pos    =&gt; 0&#xA;f.gets   =&gt; &quot;This is line one\n&quot;&#xA;f.pos    =&gt; 17" />
        <scope name="to_i" ilk="function" signature="to_i()" />
        <scope name="to_io" ilk="function" signature="to_io()" doc="Returns ios." />
        <scope name="tty?" ilk="function" signature="tty?()" doc="Returns true if ios is associated with a terminal device (tty), false otherwise. &#xA; File.new(&quot;testfile&quot;).isatty   =&gt; false&#xA;File.new(&quot;/dev/tty&quot;).isatty   =&gt; true" />
        <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="Pushes back bytes (passed as a parameter) onto ios, such that a subsequent buffered read will return it. Only one byte may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several bytes that have been pushed back). Has no effect with unbuffered reads (such as IO#sysread). &#xA; f = File.new(&quot;testfile&quot;)   =&gt; #&lt;File:testfile&gt;&#xA;b = f.getbyte              =&gt; 0x38&#xA;f.ungetbyte(b)             =&gt; nil&#xA;f.getbyte                  =&gt; 0x38" />
        <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="Pushes back one character (passed as a parameter) onto ios, such that a subsequent buffered character read will return it. Only one character may be pushed back before a subsequent read operation (that is, you will be able to read only the last of several characters that have been pushed back). Has no effect with unbuffered reads (such as IO#sysread). &#xA; f = File.new(&quot;testfile&quot;)   =&gt; #&lt;File:testfile&gt;&#xA;c = f.getc                 =&gt; &quot;8&quot;&#xA;f.ungetc(c)                =&gt; nil&#xA;f.getc                     =&gt; &quot;8&quot;" />
        <scope name="write" ilk="function" signature="write(p1)" doc="Writes the given string to ios. The stream must be opened for writing. If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written. &#xA; count = $stdout.write(&quot;This is a test\n&quot;)&#xA;puts &quot;That was #{count} bytes of data&quot;&#xA; produces: &#xA; This is a test&#xA;That was 15 bytes of data" />
        <scope name="write_nonblock" ilk="function" signature="write_nonblock(p1)" doc="Writes the given string to ios using the write(2) system call after O_NONBLOCK is set for the underlying file descriptor. &#xA; It returns the number of bytes written. &#xA; write_nonblock just calls the write(2) system call. It causes all errors the write(2) system call causes: Errno::EWOULDBLOCK, Errno::EINTR, etc. The result may also be smaller than string.length (partial write). The caller should care such errors and partial write. &#xA; If the exception is Errno::EWOULDBLOCK or Errno::AGAIN, it is extended by IO::WaitWritable. So IO::WaitWritable can be used to rescue the exceptions for retrying write_nonblock. &#xA; # Creates a pipe.&#xA;r, w = IO.pipe&#xA;# write_nonblock writes only 65536 bytes and return 65536.&#xA;# (The pipe size is 65536 bytes on this environment.)&#xA;s = &quot;a&quot; * 100000&#xA;p w.write_nonblock(s)     =&gt; 65536&#xA;# write_nonblock cannot write a byte and raise EWOULDBLOCK (EAGAIN).&#xA;p w.write_nonblock(&quot;b&quot;)   # Resource temporarily unavailable (Errno::EAGAIN)&#xA; If the write buffer is not empty, it is flushed at first. " />
        <scope name="binread" ilk="function" attributes="__classmethod__" signature="binread(p1, p2 = v2, p3 = v3)" doc="Opens the file, optionally seeks to the given offset, then returns length bytes (defaulting to the rest of the file). binread ensures the file is closed before returning. The open mode would be &quot;rb:ASCII-8BIT&quot;. &#xA; IO.binread(&quot;testfile&quot;)           =&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;&#xA;IO.binread(&quot;testfile&quot;, 20)       =&gt; &quot;This is line one\nThi&quot;&#xA;IO.binread(&quot;testfile&quot;, 20, 10)   =&gt; &quot;ne one\nThis is line &quot;" />
        <scope name="copy_stream" ilk="function" attributes="__classmethod__" signature="copy_stream(p1, p2, p3 = v3, p4 = v4)" doc="IO.copy_stream copies src to dst. src and dst is either a filename or an IO. &#xA; This method returns the number of bytes copied. &#xA; If optional arguments are not given, the start position of the copy is the beginning of the filename or the current file offset of the IO. The end position of the copy is the end of file. &#xA; If copy_length is given, No more than copy_length bytes are copied. &#xA; If src_offset is given, it specifies the start position of the copy. &#xA; When src_offset is specified and src is an IO, IO.copy_stream doesn&apos;t move the current file offset." />
        <scope name="for_fd" ilk="function" attributes="__classmethod__" signature="for_fd(*args)" doc="Synonym for IO.new." />
        <scope name="foreach" ilk="function" attributes="__classmethod__" signature="foreach(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})" doc="Executes the block for every line in the named I/O port, where lines are separated by sep. &#xA; If no block is given, an enumerator is returned instead. &#xA; IO.foreach(&quot;testfile&quot;) {|x| print &quot;GOT &quot;, x }&#xA; produces: &#xA; GOT This is line one&#xA;GOT This is line two&#xA;GOT This is line three&#xA;GOT And so on...&#xA; If the last argument is a hash, it&apos;s the keyword argument to open. See IO.read for detail." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2 = v2, p3 = {})" doc="Returns a new IO object (a stream) for the given IO object or integer file descriptor and mode string.  See also IO.sysopen and IO.for_fd. &#xA; Parameters &#xA; numeric file descriptor or IO object&#xA;file mode. a string or an integer&#xA;hash for specifying +mode+ by name. &#xA; Mode &#xA; When mode is an integer it must be combination of the modes defined in File::Constants. &#xA; When mode is a string it must be in one of the following forms: &quot;fmode&quot;,&#xA;&quot;fmode:extern&quot;,&#xA;&quot;fmode:extern:intern&quot;. extern is the external encoding name for the IO. intern is the internal encoding. fmode must be a file open mode string. See the description of class IO for mode string directives. &#xA; When the mode of original IO is read only, the mode cannot be changed to be writable.  Similarly, the mode cannot be changed from write only to readable. &#xA; When such a change is attempted the error is raised in different locations according to the platform. &#xA; Options +opt+ can have the following keys Same as +mode+ parameter" />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(*args)" doc="With no associated block, IO.open is a synonym for IO.new. If the optional code block is given, it will be passed +io+ as an argument, and the IO object will automatically be closed when the block terminates. In this instance, IO.open returns the value of the block. &#xA; See IO.new for a description of values for the +opt+ parameter." />
        <scope name="pipe" ilk="function" attributes="__classmethod__" signature="pipe(p1 = v1, p2 = v2, p3 = {})" doc="Creates a pair of pipe endpoints (connected to each other) and returns them as a two-element array of IO objects: [ read_io, write_io ]. &#xA; If a block is given, the block is called and returns the value of the block. read_io and write_io are sent to the block as arguments. If read_io and write_io are not closed when the block exits, they are closed. i.e. closing read_io and/or write_io doesn&apos;t cause an error. &#xA; Not available on all platforms. &#xA; If an encoding (encoding name or encoding object) is specified as an optional argument, read string from pipe is tagged with the encoding specified. If the argument is a colon separated two encoding names &quot;A:B&quot;, the read string is converted from encoding A (external encoding) to encoding B (internal encoding), then tagged with B. If two optional arguments are specified, those must be encoding objects or encoding names, and the first one is the external encoding, and the second one is the internal encoding. If the external encoding and the internal encoding is specified, optional hash argument specify the conversion option. &#xA; In the example below, the two processes close the ends of the pipe that they are not using. This is not just a cosmetic nicety. The read end of a pipe will not generate an end of file condition if there are any writers with the pipe still open. In the case of the parent process, the rd.read will never return if it does not first issue a wr.close. &#xA; rd, wr = IO.pipe&#xA;if fork&#xA;  wr.close&#xA;  puts &quot;Parent got: &lt;#{rd.read}&gt;&quot;&#xA;  rd.close&#xA;  Process.wait&#xA;else&#xA;  rd.close" />
        <scope name="popen" ilk="function" attributes="__classmethod__" signature="popen(p1, p2 = v2, p3 = {})" doc="Runs the specified command as a subprocess; the subprocess&apos;s standard input and output will be connected to the returned IO object. &#xA; The PID of the started process can be obtained by IO#pid method. &#xA; _cmd_ is a string or an array as follows. &#xA; cmd:&#xA;  &quot;-&quot;                                      : fork&#xA;  commandline                              : command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          : command name and zero or more arguments (no shell)&#xA;  [env, [cmdname, argv0], arg1, ..., opts] : command name, argv[0] and zero or more arguments (no shell)&#xA;(env and opts are optional.)&#xA; If _cmd_ is a +String+ ``-&apos;&apos;, then a new instance of Ruby is started as the subprocess. &#xA; If cmd is an +Array+ of +String+, then it will be used as the subprocess&apos;s +argv+ bypassing a shell. The array can contains a hash at first for environments and a hash at last for options similar to spawn. &#xA; The default mode for the new file object is ``r&apos;&apos;, but mode may be set to any of the modes listed in the description for class IO. The last argument opt qualifies mode. &#xA; # set IO encoding" />
        <scope name="read" ilk="function" attributes="__classmethod__" signature="read(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})" doc="Opens the file, optionally seeks to the given offset, then returns length bytes (defaulting to the rest of the file). read ensures the file is closed before returning. &#xA; If the last argument is a hash, it specifies option for internal open().  The key would be the following.  open_args: is exclusive to others. &#xA; encoding: string or encoding&#xA; specifies encoding of the read string.  encoding will be ignored&#xA; if length is specified.&#xA;mode: string&#xA; specifies mode argument for open().  it should start with &quot;r&quot;&#xA; otherwise it would cause error.&#xA;open_args: array of strings&#xA; specifies arguments for open() as an array.&#xA;  IO.read(&quot;testfile&quot;)           =&gt; &quot;This is line one\nThis is line two\nThis is line three\nAnd so on...\n&quot;&#xA;  IO.read(&quot;testfile&quot;, 20)       =&gt; &quot;This is line one\nThi&quot;&#xA;  IO.read(&quot;testfile&quot;, 20, 10)   =&gt; &quot;ne one\nThis is line &quot;" />
        <scope name="readlines" ilk="function" attributes="__classmethod__" signature="readlines(p1, p2 = v2, p3 = v3, p4 = v4, p5 = {})" doc="Reads the entire file specified by name as individual lines, and returns those lines in an array. Lines are separated by sep. &#xA; a = IO.readlines(&quot;testfile&quot;)&#xA;a[0]   =&gt; &quot;This is line one\n&quot;&#xA; If the last argument is a hash, it&apos;s the keyword argument to open. See IO.read for detail." />
        <scope name="select" ilk="function" attributes="__classmethod__" signature="select(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Calls select(2) system call. It monitors given arrays of IO objects, waits one or more of IO objects ready for reading, are ready for writing, and have pending exceptions respectably, and returns an array that contains arrays of those IO objects.  It will return nil if optional timeout value is given and no IO object is ready in timeout seconds. &#xA; Parameters an array of IO objects that wait until ready for read&#xA;an array of IO objects that wait until ready for write&#xA;an array of IO objects that wait for exceptions&#xA;a numeric value in second &#xA; Example &#xA; rp, wp = IO.pipe&#xA;mesg = &quot;ping &quot;&#xA;100.times {&#xA;  rs, ws, = IO.select([rp], [wp])&#xA;  if r = rs[0]&#xA;    ret = r.read(5)&#xA;    print ret" />
        <scope name="sysopen" ilk="function" attributes="__classmethod__" signature="sysopen(p1, p2 = v2, p3 = v3)" doc="Opens the given path, returning the underlying file descriptor as a Fixnum. &#xA; IO.sysopen(&quot;testfile&quot;)   =&gt; 3" />
        <scope name="try_convert" ilk="function" attributes="__classmethod__" signature="try_convert(p1)" doc="Try to convert obj into an IO, using to_io method. Returns converted IO or nil if obj cannot be converted for any reason. &#xA; IO.try_convert(STDOUT)     =&gt; STDOUT&#xA;IO.try_convert(&quot;STDOUT&quot;)   =&gt; nil&#xA;&#xA;require &apos;zlib&apos;&#xA;f = open(&quot;/tmp/zz.gz&quot;)       =&gt; #&lt;File:/tmp/zz.gz&gt;&#xA;z = Zlib::GzipReader.open(f) =&gt; #&lt;Zlib::GzipReader:0x81d8744&gt;&#xA;IO.try_convert(z)            =&gt; #&lt;File:/tmp/zz.gz&gt;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2 = v2, p3 = {})" doc="Returns a new IO object (a stream) for the given IO object or integer file descriptor and mode string.  See also IO.sysopen and IO.for_fd. &#xA; Parameters &#xA; numeric file descriptor or IO object&#xA;file mode. a string or an integer&#xA;hash for specifying +mode+ by name. &#xA; Mode &#xA; When mode is an integer it must be combination of the modes defined in File::Constants. &#xA; When mode is a string it must be in one of the following forms: &quot;fmode&quot;,&#xA;&quot;fmode:extern&quot;,&#xA;&quot;fmode:extern:intern&quot;. extern is the external encoding name for the IO. intern is the internal encoding. fmode must be a file open mode string. See the description of class IO for mode string directives. &#xA; When the mode of original IO is read only, the mode cannot be changed to be writable.  Similarly, the mode cannot be changed from write only to readable. &#xA; When such a change is attempted the error is raised in different locations according to the platform. &#xA; Options +opt+ can have the following keys Same as +mode+ parameter" />
        <variable name="APPEND" attributes="__const__" citdl="Fixnum" />
        <variable name="BINARY" attributes="__const__" citdl="Fixnum" />
        <variable name="CREAT" attributes="__const__" citdl="Fixnum" />
        <variable name="DSYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="EXCL" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_CASEFOLD" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_DOTMATCH" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_NOESCAPE" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_PATHNAME" attributes="__const__" citdl="Fixnum" />
        <variable name="FNM_SYSCASE" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_EX" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_NB" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_SH" attributes="__const__" citdl="Fixnum" />
        <variable name="LOCK_UN" attributes="__const__" citdl="Fixnum" />
        <variable name="NOATIME" attributes="__const__" citdl="Fixnum" />
        <variable name="NOCTTY" attributes="__const__" citdl="Fixnum" />
        <variable name="NOFOLLOW" attributes="__const__" citdl="Fixnum" />
        <variable name="NONBLOCK" attributes="__const__" citdl="Fixnum" />
        <variable name="RDONLY" attributes="__const__" citdl="Fixnum" />
        <variable name="RDWR" attributes="__const__" citdl="Fixnum" />
        <variable name="RSYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_CUR" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_END" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_SET" attributes="__const__" citdl="Fixnum" />
        <variable name="SYNC" attributes="__const__" citdl="Fixnum" />
        <variable name="TRUNC" attributes="__const__" citdl="Fixnum" />
        <variable name="WRONLY" attributes="__const__" citdl="Fixnum" />
        <scope name="WaitReadable" ilk="namespace" >
        </scope>
        <scope name="WaitWritable" ilk="namespace" >
        </scope>
      </scope>
      <variable name="STDIN" attributes="__const__" citdl="IO" />
      <variable name="STDOUT" attributes="__const__" citdl="IO" />
      <variable name="STDERR" attributes="__const__" citdl="IO" />
      <variable name="ARGF" attributes="__const__" citdl="ARGF.class" />
      <scope name="FileTest" ilk="namespace" >
        <scope name="blockdev?" ilk="function" signature="blockdev?(p1)" doc="Returns true if the named file is a block device." />
        <scope name="chardev?" ilk="function" signature="chardev?(p1)" doc="Returns true if the named file is a character device." />
        <scope name="directory?" ilk="function" signature="directory?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA; File.directory?(&quot;.&quot;)" />
        <scope name="executable?" ilk="function" signature="executable?(p1)" doc="Returns true if the named file is executable by the effective user id of this process." />
        <scope name="executable_real?" ilk="function" signature="executable_real?(p1)" doc="Returns true if the named file is executable by the real user id of this process." />
        <scope name="exist?" ilk="function" signature="exist?(p1)" doc="Returns true if the named file is a directory, false otherwise." />
        <scope name="exists?" ilk="function" signature="exists?(p1)" doc="Return true if the named file exists." />
        <scope name="file?" ilk="function" signature="file?(p1)" doc="Returns true if the named file exists and is a regular file." />
        <scope name="grpowned?" ilk="function" signature="grpowned?(p1)" doc="Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows." />
        <scope name="identical?" ilk="function" signature="identical?(p1, p2)" doc="Returns true if the named files are identical. &#xA; open(&quot;a&quot;, &quot;w&quot;) {}&#xA;p File.identical?(&quot;a&quot;, &quot;a&quot;)      =&gt; true&#xA;p File.identical?(&quot;a&quot;, &quot;./a&quot;)    =&gt; true&#xA;File.link(&quot;a&quot;, &quot;b&quot;)&#xA;p File.identical?(&quot;a&quot;, &quot;b&quot;)      =&gt; true&#xA;File.symlink(&quot;a&quot;, &quot;c&quot;)&#xA;p File.identical?(&quot;a&quot;, &quot;c&quot;)      =&gt; true&#xA;open(&quot;d&quot;, &quot;w&quot;) {}&#xA;p File.identical?(&quot;a&quot;, &quot;d&quot;)      =&gt; false" />
        <scope name="owned?" ilk="function" signature="owned?(p1)" doc="Returns true if the named file exists and the effective used id of the calling process is the owner of the file." />
        <scope name="pipe?" ilk="function" signature="pipe?(p1)" doc="Returns true if the named file is a pipe." />
        <scope name="readable?" ilk="function" signature="readable?(p1)" doc="Returns true if the named file is readable by the effective user id of this process." />
        <scope name="readable_real?" ilk="function" signature="readable_real?(p1)" doc="Returns true if the named file is readable by the real user id of this process." />
        <scope name="setgid?" ilk="function" signature="setgid?(p1)" doc="Returns true if the named file has the setgid bit set." />
        <scope name="setuid?" ilk="function" signature="setuid?(p1)" doc="Returns true if the named file has the setuid bit set." />
        <scope name="size" ilk="function" signature="size(p1)" doc="Returns the size of file_name." />
        <scope name="size?" ilk="function" signature="size?(p1)" doc="Returns +nil+ if +file_name+ doesn&apos;t exist or has zero size, the size of the file otherwise." />
        <scope name="socket?" ilk="function" signature="socket?(p1)" doc="Returns true if the named file is a socket." />
        <scope name="sticky?" ilk="function" signature="sticky?(p1)" doc="Returns true if the named file has the sticky bit set." />
        <scope name="symlink?" ilk="function" signature="symlink?(p1)" doc="Returns true if the named file is a symbolic link." />
        <scope name="world_readable?" ilk="function" signature="world_readable?(p1)" doc="If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA; File.world_readable?(&quot;/etc/passwd&quot;)           =&gt; 420&#xA;m = File.world_readable?(&quot;/etc/passwd&quot;)&#xA;sprintf(&quot;%o&quot;, m)                              =&gt; &quot;644&quot;" />
        <scope name="world_writable?" ilk="function" signature="world_writable?(p1)" doc="If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA; File.world_writable?(&quot;/tmp&quot;)                  =&gt; 511&#xA;m = File.world_writable?(&quot;/tmp&quot;)&#xA;sprintf(&quot;%o&quot;, m)                              =&gt; &quot;777&quot;" />
        <scope name="writable?" ilk="function" signature="writable?(p1)" doc="Returns true if the named file is writable by the effective user id of this process." />
        <scope name="writable_real?" ilk="function" signature="writable_real?(p1)" doc="Returns true if the named file is writable by the real user id of this process." />
        <scope name="zero?" ilk="function" signature="zero?(p1)" doc="Returns true if the named file exists and has a zero size." />
      </scope>
      <scope name="File" ilk="class" classrefs="IO" >
        <import symbol="File::Constants" />
        <import symbol="Enumerable" />
        <scope name="atime" ilk="function" signature="atime()" doc="Returns the last access time (a Time object) for file, or epoch if file has not been accessed.&#xA;&#xA;  File.new(&quot;testfile&quot;).atime   =&gt; Wed Dec 31 18:00:00 CST 1969" />
        <scope name="chmod" ilk="function" signature="chmod(p1)" doc="Changes permission bits on file to the bit pattern represented by mode_int. Actual effects are platform dependent; on Unix systems, see chmod(2) for details. Follows symbolic links. Also see File#lchmod. &#xA; f = File.new(&quot;out&quot;, &quot;w&quot;);&#xA;f.chmod(0644)   =&gt; 0" />
        <scope name="chown" ilk="function" signature="chown(p1, p2)" doc="Changes the owner and group of file to the given numeric owner and group id&apos;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&apos;s group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Follows symbolic links. See also File#lchown. &#xA; File.new(&quot;testfile&quot;).chown(502, 1000)" />
        <scope name="ctime" ilk="function" signature="ctime()" doc="Returns the change time for file (that is, the time directory information about the file was changed, not the file itself). &#xA; Note that on Windows (NTFS), returns creation time (birth time). &#xA; File.new(&quot;testfile&quot;).ctime   =&gt; Wed Apr 09 08:53:14 CDT 2003" />
        <scope name="flock" ilk="function" signature="flock(p1)" doc="Locks or unlocks a file according to locking_constant (a logical or of the values in the table below). Returns false if File::LOCK_NB is specified and the operation would otherwise have blocked. Not available on all platforms. &#xA; Locking constants (in class File): &#xA; LOCK_EX   | Exclusive lock. Only one process may hold an&#xA;          | exclusive lock for a given file at a time.&#xA;----------+------------------------------------------------&#xA;LOCK_NB   | Don&apos;t block when locking. May be combined&#xA;          | with other lock options using logical or.&#xA;----------+------------------------------------------------&#xA;LOCK_SH   | Shared lock. Multiple processes may each hold a&#xA;          | shared lock for a given file at the same time.&#xA;----------+------------------------------------------------&#xA;LOCK_UN   | Unlock.&#xA; Example: " />
        <scope name="lstat" ilk="function" signature="lstat()" doc="Same as IO#stat, but does not follow the last symbolic link. Instead, reports on the link itself. &#xA; File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;File.stat(&quot;testfile&quot;).size              =&gt; 66&#xA;f = File.new(&quot;link2test&quot;)&#xA;f.lstat.size                            =&gt; 8&#xA;f.stat.size                             =&gt; 66" />
        <scope name="mtime" ilk="function" signature="mtime()" doc="Returns the modification time for file. &#xA; File.new(&quot;testfile&quot;).mtime   =&gt; Wed Apr 09 08:53:14 CDT 2003" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the pathname used to create file as a string. Does not normalize the name. &#xA; File.new(&quot;testfile&quot;).path               =&gt; &quot;testfile&quot;&#xA;File.new(&quot;/tmp/../tmp/xxx&quot;, &quot;w&quot;).path   =&gt; &quot;/tmp/../tmp/xxx&quot;" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of file in bytes. &#xA; File.new(&quot;testfile&quot;).size   =&gt; 66" />
        <scope name="to_path" ilk="function" signature="to_path()" doc="Returns the pathname used to create file as a string. Does not normalize the name. &#xA; File.new(&quot;testfile&quot;).path               =&gt; &quot;testfile&quot;&#xA;File.new(&quot;/tmp/../tmp/xxx&quot;, &quot;w&quot;).path   =&gt; &quot;/tmp/../tmp/xxx&quot;" />
        <scope name="truncate" ilk="function" signature="truncate(p1)" doc="Truncates file to at most integer bytes. The file must be opened for writing. Not available on all platforms. &#xA; f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;f.syswrite(&quot;1234567890&quot;)   =&gt; 10&#xA;f.truncate(5)              =&gt; 0&#xA;f.close()                  =&gt; nil&#xA;File.size(&quot;out&quot;)           =&gt; 5" />
        <scope name="absolute_path" ilk="function" attributes="__classmethod__" signature="absolute_path(p1, p2 = v2)" doc="Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. If the given pathname starts with a ``~&apos;&apos; it is NOT expanded, it is treated as a normal directory name. &#xA; File.absolute_path(&quot;~oracle/bin&quot;)       =&gt; &quot;&lt;relative_path&gt;/~oracle/bin&quot;" />
        <scope name="atime" ilk="function" attributes="__classmethod__" signature="atime(p1)" doc="Returns the last access time for the named file as a Time object). &#xA; File.atime(&quot;testfile&quot;)   =&gt; Wed Apr 09 08:51:48 CDT 2003" />
        <scope name="basename" ilk="function" attributes="__classmethod__" signature="basename(p1, p2 = v2)" doc="Returns the last component of the filename given in file_name, which must be formed using forward slashes (``/&apos;&apos;) regardless of the separator used on the local file system. If suffix is given and present at the end of file_name, it is removed. &#xA; File.basename(&quot;/home/gumby/work/ruby.rb&quot;)          =&gt; &quot;ruby.rb&quot;&#xA;File.basename(&quot;/home/gumby/work/ruby.rb&quot;, &quot;.rb&quot;)   =&gt; &quot;ruby&quot;" />
        <scope name="blockdev?" ilk="function" attributes="__classmethod__" signature="blockdev?(p1)" doc="Returns true if the named file is a block device." />
        <scope name="chardev?" ilk="function" attributes="__classmethod__" signature="chardev?(p1)" doc="Returns true if the named file is a character device." />
        <scope name="chmod" ilk="function" attributes="__classmethod__" signature="chmod(p1, *args)" doc="Changes permission bits on the named file(s) to the bit pattern represented by mode_int. Actual effects are operating system dependent (see the beginning of this section). On Unix systems, see chmod(2) for details. Returns the number of files processed. &#xA; File.chmod(0644, &quot;testfile&quot;, &quot;out&quot;)   =&gt; 2" />
        <scope name="chown" ilk="function" attributes="__classmethod__" signature="chown(p1, p2, *args)" doc="Changes the owner and group of the named file(s) to the given numeric owner and group id&apos;s. Only a process with superuser privileges may change the owner of a file. The current owner of a file may change the file&apos;s group to any group to which the owner belongs. A nil or -1 owner or group id is ignored. Returns the number of files processed. &#xA; File.chown(nil, 100, &quot;testfile&quot;)" />
        <scope name="ctime" ilk="function" attributes="__classmethod__" signature="ctime(p1)" doc="Returns the change time for the named file (the time at which directory information about the file was changed, not the file itself). &#xA; Note that on Windows (NTFS), returns creation time (birth time). &#xA; File.ctime(&quot;testfile&quot;)   =&gt; Wed Apr 09 08:53:13 CDT 2003" />
        <scope name="delete" ilk="function" attributes="__classmethod__" signature="delete(*args)" doc="Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir." />
        <scope name="directory?" ilk="function" attributes="__classmethod__" signature="directory?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA; File.directory?(&quot;.&quot;)" />
        <scope name="dirname" ilk="function" attributes="__classmethod__" signature="dirname(p1)" doc="Returns all components of the filename given in file_name except the last one. The filename must be formed using forward slashes (``/&apos;&apos;) regardless of the separator used on the local file system. &#xA; File.dirname(&quot;/home/gumby/work/ruby.rb&quot;)   =&gt; &quot;/home/gumby/work&quot;" />
        <scope name="executable?" ilk="function" attributes="__classmethod__" signature="executable?(p1)" doc="Returns true if the named file is executable by the effective user id of this process." />
        <scope name="executable_real?" ilk="function" attributes="__classmethod__" signature="executable_real?(p1)" doc="Returns true if the named file is executable by the real user id of this process." />
        <scope name="exist?" ilk="function" attributes="__classmethod__" signature="exist?(p1)" doc="Returns true if the named file is a directory, false otherwise." />
        <scope name="exists?" ilk="function" attributes="__classmethod__" signature="exists?(p1)" doc="Return true if the named file exists." />
        <scope name="expand_path" ilk="function" attributes="__classmethod__" signature="expand_path(p1, p2 = v2)" doc="Converts a pathname to an absolute pathname. Relative paths are referenced from the current working directory of the process unless dir_string is given, in which case it will be used as the starting point. The given pathname may start with a ``~&apos;&apos;, which expands to the process owner&apos;s home directory (the environment variable HOME must be set correctly). ``~user&apos;&apos; expands to the named user&apos;s home directory. &#xA; File.expand_path(&quot;~oracle/bin&quot;)           =&gt; &quot;/home/oracle/bin&quot;&#xA;File.expand_path(&quot;../../bin&quot;, &quot;/tmp/x&quot;)   =&gt; &quot;/bin&quot;" />
        <scope name="extname" ilk="function" attributes="__classmethod__" signature="extname(p1)" doc="Returns the extension (the portion of file name in path after the period). &#xA; File.extname(&quot;test.rb&quot;)         =&gt; &quot;.rb&quot;&#xA;File.extname(&quot;a/b/d/test.rb&quot;)   =&gt; &quot;.rb&quot;&#xA;File.extname(&quot;test&quot;)            =&gt; &quot;&quot;&#xA;File.extname(&quot;.profile&quot;)        =&gt; &quot;&quot;" />
        <scope name="file?" ilk="function" attributes="__classmethod__" signature="file?(p1)" doc="Returns true if the named file exists and is a regular file." />
        <scope name="fnmatch" ilk="function" attributes="__classmethod__" signature="fnmatch(p1, p2, p3 = v3)" doc="Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters: &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and \*c* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp.&#xA;Matches directories recursively or files expansively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Escapes the next metacharacter. &#xA; flags is a bitwise OR of the FNM_xxx parameters. The same glob pattern and flags are used by Dir::glob. &#xA; File.fnmatch(&apos;cat&apos;,       &apos;cat&apos;)        =&gt; true  # match entire string&#xA;File.fnmatch(&apos;cat&apos;,       &apos;category&apos;)   =&gt; false # only match partial string&#xA;File.fnmatch(&apos;c{at,ub}s&apos;, &apos;cats&apos;)       =&gt; false # { } isn&apos;t supported&#xA;File.fnmatch(&apos;c?t&apos;,     &apos;cat&apos;)          =&gt; true  # &apos;?&apos; match only 1 character&#xA;File.fnmatch(&apos;c??t&apos;,    &apos;cat&apos;)          =&gt; false # ditto&#xA;File.fnmatch(&apos;c*&apos;,      &apos;cats&apos;)         =&gt; true  # &apos;*&apos; match 0 or more characters" />
        <scope name="fnmatch?" ilk="function" attributes="__classmethod__" signature="fnmatch?(p1, p2, p3 = v3)" doc="Returns true if path matches against pattern The pattern is not a regular expression; instead it follows rules similar to shell filename globbing. It may contain the following metacharacters: &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and \*c* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp.&#xA;Matches directories recursively or files expansively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Escapes the next metacharacter. &#xA; flags is a bitwise OR of the FNM_xxx parameters. The same glob pattern and flags are used by Dir::glob. &#xA; File.fnmatch(&apos;cat&apos;,       &apos;cat&apos;)        =&gt; true  # match entire string&#xA;File.fnmatch(&apos;cat&apos;,       &apos;category&apos;)   =&gt; false # only match partial string&#xA;File.fnmatch(&apos;c{at,ub}s&apos;, &apos;cats&apos;)       =&gt; false # { } isn&apos;t supported&#xA;File.fnmatch(&apos;c?t&apos;,     &apos;cat&apos;)          =&gt; true  # &apos;?&apos; match only 1 character&#xA;File.fnmatch(&apos;c??t&apos;,    &apos;cat&apos;)          =&gt; false # ditto&#xA;File.fnmatch(&apos;c*&apos;,      &apos;cats&apos;)         =&gt; true  # &apos;*&apos; match 0 or more characters" />
        <scope name="ftype" ilk="function" attributes="__classmethod__" signature="ftype(p1)" doc="Identifies the type of the named file; the return string is one of ``file&apos;&apos;, ``directory&apos;&apos;, ``characterSpecial&apos;&apos;, ``blockSpecial&apos;&apos;, ``fifo&apos;&apos;, ``link&apos;&apos;, ``socket&apos;&apos;, or ``unknown&apos;&apos;. &#xA; File.ftype(&quot;testfile&quot;)            =&gt; &quot;file&quot;&#xA;File.ftype(&quot;/dev/tty&quot;)            =&gt; &quot;characterSpecial&quot;&#xA;File.ftype(&quot;/tmp/.X11-unix/X0&quot;)   =&gt; &quot;socket&quot;" />
        <scope name="grpowned?" ilk="function" attributes="__classmethod__" signature="grpowned?(p1)" doc="Returns true if the named file exists and the effective group id of the calling process is the owner of the file. Returns false on Windows." />
        <scope name="identical?" ilk="function" attributes="__classmethod__" signature="identical?(p1, p2)" doc="Returns true if the named files are identical. &#xA; open(&quot;a&quot;, &quot;w&quot;) {}&#xA;p File.identical?(&quot;a&quot;, &quot;a&quot;)      =&gt; true&#xA;p File.identical?(&quot;a&quot;, &quot;./a&quot;)    =&gt; true&#xA;File.link(&quot;a&quot;, &quot;b&quot;)&#xA;p File.identical?(&quot;a&quot;, &quot;b&quot;)      =&gt; true&#xA;File.symlink(&quot;a&quot;, &quot;c&quot;)&#xA;p File.identical?(&quot;a&quot;, &quot;c&quot;)      =&gt; true&#xA;open(&quot;d&quot;, &quot;w&quot;) {}&#xA;p File.identical?(&quot;a&quot;, &quot;d&quot;)      =&gt; false" />
        <scope name="join" ilk="function" attributes="__classmethod__" signature="join(*args)" doc="Returns a new string formed by joining the strings using File::SEPARATOR. &#xA; File.join(&quot;usr&quot;, &quot;mail&quot;, &quot;gumby&quot;)   =&gt; &quot;usr/mail/gumby&quot;" />
        <scope name="lchmod" ilk="function" attributes="__classmethod__" signature="lchmod(p1, *args)" doc="Equivalent to File::chmod, but does not follow symbolic links (so it will change the permissions associated with the link, not the file referenced by the link). Often not available." />
        <scope name="lchown" ilk="function" attributes="__classmethod__" signature="lchown(p1, p2, *args)" doc="Equivalent to File::chown, but does not follow symbolic links (so it will change the owner associated with the link, not the file referenced by the link). Often not available. Returns number of files in the argument list." />
        <scope name="link" ilk="function" attributes="__classmethod__" signature="link(p1, p2)" doc="Creates a new name for an existing file using a hard link. Will not overwrite new_name if it already exists (raising a subclass of SystemCallError). Not available on all platforms. &#xA; File.link(&quot;testfile&quot;, &quot;.testfile&quot;)   =&gt; 0&#xA;IO.readlines(&quot;.testfile&quot;)[0]         =&gt; &quot;This is line one\n&quot;" />
        <scope name="lstat" ilk="function" attributes="__classmethod__" signature="lstat(p1)" doc="Same as File::stat, but does not follow the last symbolic link. Instead, reports on the link itself. &#xA; File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;File.stat(&quot;testfile&quot;).size              =&gt; 66&#xA;File.lstat(&quot;link2test&quot;).size            =&gt; 8&#xA;File.stat(&quot;link2test&quot;).size             =&gt; 66" />
        <scope name="mtime" ilk="function" attributes="__classmethod__" signature="mtime(p1)" doc="Returns the modification time for the named file as a Time object. &#xA; File.mtime(&quot;testfile&quot;)   =&gt; Tue Apr 08 12:58:04 CDT 2003" />
        <scope name="owned?" ilk="function" attributes="__classmethod__" signature="owned?(p1)" doc="Returns true if the named file exists and the effective used id of the calling process is the owner of the file." />
        <scope name="path" ilk="function" attributes="__classmethod__" signature="path(p1)" doc="Returns the string representation of the path &#xA; File.path(&quot;/dev/null&quot;)          =&gt; &quot;/dev/null&quot;&#xA;File.path(Pathname.new(&quot;/tmp&quot;)) =&gt; &quot;/tmp&quot;" />
        <scope name="pipe?" ilk="function" attributes="__classmethod__" signature="pipe?(p1)" doc="Returns true if the named file is a pipe." />
        <scope name="readable?" ilk="function" attributes="__classmethod__" signature="readable?(p1)" doc="Returns true if the named file is readable by the effective user id of this process." />
        <scope name="readable_real?" ilk="function" attributes="__classmethod__" signature="readable_real?(p1)" doc="Returns true if the named file is readable by the real user id of this process." />
        <scope name="readlink" ilk="function" attributes="__classmethod__" signature="readlink(p1)" doc="Returns the name of the file referenced by the given link. Not available on all platforms. &#xA; File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0&#xA;File.readlink(&quot;link2test&quot;)              =&gt; &quot;testfile&quot;" />
        <scope name="realdirpath" ilk="function" attributes="__classmethod__" signature="realdirpath(p1, p2 = v2)" doc="Returns the real (absolute) pathname of _pathname_ in the actual filesystem. The real pathname doesn&apos;t contain symlinks or useless dots. &#xA; If _dir_string_ is given, it is used as a base directory for interpreting relative pathname instead of the current directory. &#xA; The last component of the real pathname can be nonexistent." />
        <scope name="realpath" ilk="function" attributes="__classmethod__" signature="realpath(p1, p2 = v2)" doc="Returns the real (absolute) pathname of _pathname_ in the actual filesystem not containing symlinks or useless dots. &#xA; If _dir_string_ is given, it is used as a base directory for interpreting relative pathname instead of the current directory. &#xA; All components of the pathname must exist when this method is called." />
        <scope name="rename" ilk="function" attributes="__classmethod__" signature="rename(p1, p2)" doc="Renames the given file to the new name. Raises a SystemCallError if the file cannot be renamed. &#xA; File.rename(&quot;afile&quot;, &quot;afile.bak&quot;)   =&gt; 0" />
        <scope name="setgid?" ilk="function" attributes="__classmethod__" signature="setgid?(p1)" doc="Returns true if the named file has the setgid bit set." />
        <scope name="setuid?" ilk="function" attributes="__classmethod__" signature="setuid?(p1)" doc="Returns true if the named file has the setuid bit set." />
        <scope name="size" ilk="function" attributes="__classmethod__" signature="size(p1)" doc="Returns the size of file_name." />
        <scope name="size?" ilk="function" attributes="__classmethod__" signature="size?(p1)" doc="Returns +nil+ if +file_name+ doesn&apos;t exist or has zero size, the size of the file otherwise." />
        <scope name="socket?" ilk="function" attributes="__classmethod__" signature="socket?(p1)" doc="Returns true if the named file is a socket." />
        <scope name="split" ilk="function" attributes="__classmethod__" signature="split(p1)" doc="Splits the given string into a directory and a file component and returns them in a two-element array. See also File::dirname and File::basename. &#xA; File.split(&quot;/home/gumby/.profile&quot;)   =&gt; [&quot;/home/gumby&quot;, &quot;.profile&quot;]" />
        <scope name="stat" ilk="function" attributes="__classmethod__" signature="stat(p1)" doc="Returns a File::Stat object for the named file (see File::Stat). &#xA; File.stat(&quot;testfile&quot;).mtime   =&gt; Tue Apr 08 12:58:04 CDT 2003" />
        <scope name="sticky?" ilk="function" attributes="__classmethod__" signature="sticky?(p1)" doc="Returns true if the named file has the sticky bit set." />
        <scope name="symlink" ilk="function" attributes="__classmethod__" signature="symlink(p1, p2)" doc="Creates a symbolic link called new_name for the existing file old_name. Raises a NotImplemented exception on platforms that do not support symbolic links. &#xA; File.symlink(&quot;testfile&quot;, &quot;link2test&quot;)   =&gt; 0" />
        <scope name="symlink?" ilk="function" attributes="__classmethod__" signature="symlink?(p1)" doc="Returns true if the named file is a symbolic link." />
        <scope name="truncate" ilk="function" attributes="__classmethod__" signature="truncate(p1, p2)" doc="Truncates the file file_name to be at most integer bytes long. Not available on all platforms. &#xA; f = File.new(&quot;out&quot;, &quot;w&quot;)&#xA;f.write(&quot;1234567890&quot;)     =&gt; 10&#xA;f.close                   =&gt; nil&#xA;File.truncate(&quot;out&quot;, 5)   =&gt; 0&#xA;File.size(&quot;out&quot;)          =&gt; 5" />
        <scope name="umask" ilk="function" attributes="__classmethod__" signature="umask(*args)" doc="Returns the current umask value for this process. If the optional argument is given, set the umask to that value and return the previous value. Umask values are subtracted from the default permissions, so a umask of 0222 would make a file read-only for everyone. &#xA; File.umask(0006)   =&gt; 18&#xA;File.umask         =&gt; 6" />
        <scope name="unlink" ilk="function" attributes="__classmethod__" signature="unlink(*args)" doc="Deletes the named files, returning the number of names passed as arguments. Raises an exception on any error. See also Dir::rmdir." />
        <scope name="utime" ilk="function" attributes="__classmethod__" signature="utime(p1, p2, *args)" doc="Sets the access and modification times of each named file to the first two arguments. Returns the number of file names in the argument list." />
        <scope name="world_readable?" ilk="function" attributes="__classmethod__" signature="world_readable?(p1)" doc="If file_name is readable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA; File.world_readable?(&quot;/etc/passwd&quot;)           =&gt; 420&#xA;m = File.world_readable?(&quot;/etc/passwd&quot;)&#xA;sprintf(&quot;%o&quot;, m)                              =&gt; &quot;644&quot;" />
        <scope name="world_writable?" ilk="function" attributes="__classmethod__" signature="world_writable?(p1)" doc="If file_name is writable by others, returns an integer representing the file permission bits of file_name. Returns nil otherwise. The meaning of the bits is platform dependent; on Unix systems, see stat(2). &#xA; File.world_writable?(&quot;/tmp&quot;)                  =&gt; 511&#xA;m = File.world_writable?(&quot;/tmp&quot;)&#xA;sprintf(&quot;%o&quot;, m)                              =&gt; &quot;777&quot;" />
        <scope name="writable?" ilk="function" attributes="__classmethod__" signature="writable?(p1)" doc="Returns true if the named file is writable by the effective user id of this process." />
        <scope name="writable_real?" ilk="function" attributes="__classmethod__" signature="writable_real?(p1)" doc="Returns true if the named file is writable by the real user id of this process." />
        <scope name="zero?" ilk="function" attributes="__classmethod__" signature="zero?(p1)" doc="Returns true if the named file exists and has a zero size." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Opens the file named by +filename+ according to +mode+ (default is &quot;r&quot;) and returns a new File object. &#xA; Parameters &#xA; See the description of class IO for a description of +mode+.  The file mode may optionally be specified as a Fixnum by +or+-ing together the flags (O_RDONLY etc, again described under +IO+). &#xA; Optional permission bits may be given in +perm+.  These mode and permission bits are platform dependent; on Unix systems, see open(2) for details. &#xA; Optional +opt+ parameter is same as in IO.open. &#xA; Examples &#xA; f = File.new(&quot;testfile&quot;, &quot;r&quot;)&#xA;f = File.new(&quot;newfile&quot;,  &quot;w+&quot;)&#xA;f = File.new(&quot;newfile&quot;, File::CREAT|File::TRUNC|File::RDWR, 0644)" />
        <variable name="ALT_SEPARATOR" attributes="__const__" citdl="NilClass" />
        <scope name="Constants" ilk="namespace" >
          <variable name="APPEND" attributes="__const__" citdl="Fixnum" />
          <variable name="BINARY" attributes="__const__" citdl="Fixnum" />
          <variable name="CREAT" attributes="__const__" citdl="Fixnum" />
          <variable name="DSYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="EXCL" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_CASEFOLD" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_DOTMATCH" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_NOESCAPE" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_PATHNAME" attributes="__const__" citdl="Fixnum" />
          <variable name="FNM_SYSCASE" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_EX" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_NB" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_SH" attributes="__const__" citdl="Fixnum" />
          <variable name="LOCK_UN" attributes="__const__" citdl="Fixnum" />
          <variable name="NOATIME" attributes="__const__" citdl="Fixnum" />
          <variable name="NOCTTY" attributes="__const__" citdl="Fixnum" />
          <variable name="NOFOLLOW" attributes="__const__" citdl="Fixnum" />
          <variable name="NONBLOCK" attributes="__const__" citdl="Fixnum" />
          <variable name="RDONLY" attributes="__const__" citdl="Fixnum" />
          <variable name="RDWR" attributes="__const__" citdl="Fixnum" />
          <variable name="RSYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="SYNC" attributes="__const__" citdl="Fixnum" />
          <variable name="TRUNC" attributes="__const__" citdl="Fixnum" />
          <variable name="WRONLY" attributes="__const__" citdl="Fixnum" />
        </scope>
        <variable name="PATH_SEPARATOR" attributes="__const__" citdl="String" />
        <variable name="SEEK_CUR" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_END" attributes="__const__" citdl="Fixnum" />
        <variable name="SEEK_SET" attributes="__const__" citdl="Fixnum" />
        <variable name="SEPARATOR" attributes="__const__" citdl="String" />
        <variable name="Separator" attributes="__const__" citdl="String" />
        <scope name="Stat" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="atime" ilk="function" />
          <scope name="blksize" ilk="function" />
          <scope name="blockdev?" ilk="function" />
          <scope name="blocks" ilk="function" />
          <scope name="chardev?" ilk="function" />
          <scope name="ctime" ilk="function" />
          <scope name="dev" ilk="function" />
          <scope name="dev_major" ilk="function" />
          <scope name="dev_minor" ilk="function" />
          <scope name="directory?" ilk="function" />
          <scope name="executable?" ilk="function" />
          <scope name="executable_real?" ilk="function" />
          <scope name="file?" ilk="function" />
          <scope name="ftype" ilk="function" />
          <scope name="gid" ilk="function" />
          <scope name="grpowned?" ilk="function" />
          <scope name="ino" ilk="function" />
          <scope name="mode" ilk="function" />
          <scope name="mtime" ilk="function" />
          <scope name="nlink" ilk="function" />
          <scope name="owned?" ilk="function" />
          <scope name="pipe?" ilk="function" />
          <scope name="rdev" ilk="function" />
          <scope name="rdev_major" ilk="function" />
          <scope name="rdev_minor" ilk="function" />
          <scope name="readable?" ilk="function" />
          <scope name="readable_real?" ilk="function" />
          <scope name="setgid?" ilk="function" />
          <scope name="setuid?" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="size?" ilk="function" />
          <scope name="socket?" ilk="function" />
          <scope name="sticky?" ilk="function" />
          <scope name="symlink?" ilk="function" />
          <scope name="uid" ilk="function" />
          <scope name="world_readable?" ilk="function" />
          <scope name="world_writable?" ilk="function" />
          <scope name="writable?" ilk="function" />
          <scope name="writable_real?" ilk="function" />
          <scope name="zero?" ilk="function" />
        </scope>
        <scope name="WaitReadable" ilk="namespace" >
        </scope>
        <scope name="WaitWritable" ilk="namespace" >
        </scope>
      </scope>
      <scope name="Dir" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="close" ilk="function" signature="close()" doc="Closes the directory stream. Any further attempts to access dir will raise an IOError. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.close   =&gt; nil" />
        <scope name="each" ilk="function" signature="each()" doc="Calls the block once for each entry in this directory, passing the filename of each entry as a parameter to the block. &#xA; If no block is given, an enumerator is returned instead. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.each  {|x| puts &quot;Got #{x}&quot; }&#xA; produces: &#xA; Got .&#xA;Got ..&#xA;Got config.h&#xA;Got main.rb" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the path parameter passed to dir&apos;s constructor. &#xA; d = Dir.new(&quot;..&quot;)&#xA;d.path   =&gt; &quot;..&quot;" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current position in dir. See also Dir#seek. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.tell   =&gt; 0&#xA;d.read   =&gt; &quot;.&quot;&#xA;d.tell   =&gt; 12" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Synonym for Dir#seek, but returns the position parameter. &#xA; d = Dir.new(&quot;testdir&quot;)   =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;d.read                   =&gt; &quot;.&quot;&#xA;i = d.pos                =&gt; 12&#xA;d.read                   =&gt; &quot;..&quot;&#xA;d.pos = i                =&gt; 12&#xA;d.read                   =&gt; &quot;..&quot;" />
        <scope name="read" ilk="function" signature="read()" doc="Reads the next entry from dir and returns it as a string. Returns nil at the end of the stream. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.read   =&gt; &quot;.&quot;&#xA;d.read   =&gt; &quot;..&quot;&#xA;d.read   =&gt; &quot;config.h&quot;" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Repositions dir to the first entry. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.read     =&gt; &quot;.&quot;&#xA;d.rewind   =&gt; #&lt;Dir:0x401b3fb0&gt;&#xA;d.read     =&gt; &quot;.&quot;" />
        <scope name="seek" ilk="function" signature="seek(p1)" doc="Seeks to a particular location in dir. integer must be a value returned by Dir#tell. &#xA; d = Dir.new(&quot;testdir&quot;)   =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;d.read                   =&gt; &quot;.&quot;&#xA;i = d.tell               =&gt; 12&#xA;d.read                   =&gt; &quot;..&quot;&#xA;d.seek(i)                =&gt; #&lt;Dir:0x401b3c40&gt;&#xA;d.read                   =&gt; &quot;..&quot;" />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current position in dir. See also Dir#seek. &#xA; d = Dir.new(&quot;testdir&quot;)&#xA;d.tell   =&gt; 0&#xA;d.read   =&gt; &quot;.&quot;&#xA;d.tell   =&gt; 12" />
        <scope name="to_path" ilk="function" signature="to_path()" doc="Returns the path parameter passed to dir&apos;s constructor. &#xA; d = Dir.new(&quot;..&quot;)&#xA;d.path   =&gt; &quot;..&quot;" />
        <scope name="[]" ilk="function" attributes="__classmethod__" signature="[](*args)" doc="Equivalent to calling Dir.glob(array,0) and Dir.glob([string,...],0)." />
        <scope name="chdir" ilk="function" attributes="__classmethod__" signature="chdir(p1 = v1)" doc="Changes the current working directory of the process to the given string. When called without an argument, changes the directory to the value of the environment variable HOME, or LOGDIR. SystemCallError (probably Errno::ENOENT) if the target directory does not exist. &#xA; If a block is given, it is passed the name of the new current directory, and the block is executed with that as the current directory. The original working directory is restored when the block exits. The return value of chdir is the value of the block. chdir blocks can be nested, but in a multi-threaded program an error will be raised if a thread attempts to open a chdir block while another thread has one open. &#xA; Dir.chdir(&quot;/var/spool/mail&quot;)&#xA;puts Dir.pwd&#xA;Dir.chdir(&quot;/tmp&quot;) do&#xA;  puts Dir.pwd&#xA;  Dir.chdir(&quot;/usr&quot;) do&#xA;    puts Dir.pwd&#xA;  end&#xA;  puts Dir.pwd&#xA;end&#xA;puts Dir.pwd&#xA; produces: " />
        <scope name="chroot" ilk="function" attributes="__classmethod__" signature="chroot(p1)" doc="Changes this process&apos;s idea of the file system root. Only a privileged process may make this call. Not available on all platforms. On Unix systems, see chroot(2) for more information." />
        <scope name="delete" ilk="function" attributes="__classmethod__" signature="delete(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="entries" ilk="function" attributes="__classmethod__" signature="entries(*args)" doc="Returns an array containing all of the filenames in the given directory. Will raise a SystemCallError if the named directory doesn&apos;t exist. &#xA; Dir.entries(&quot;testdir&quot;)   =&gt; [&quot;.&quot;, &quot;..&quot;, &quot;config.h&quot;, &quot;main.rb&quot;]" />
        <scope name="exist?" ilk="function" attributes="__classmethod__" signature="exist?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA; File.directory?(&quot;.&quot;)" />
        <scope name="exists?" ilk="function" attributes="__classmethod__" signature="exists?(p1)" doc="Returns true if the named file is a directory, or a symlink that points at a directory, and false otherwise. &#xA; File.directory?(&quot;.&quot;)" />
        <scope name="foreach" ilk="function" attributes="__classmethod__" signature="foreach(*args)" doc="Calls the block once for each entry in the named directory, passing the filename of each entry as a parameter to the block. &#xA; If no block is given, an enumerator is returned instead. &#xA; Dir.foreach(&quot;testdir&quot;) {|x| puts &quot;Got #{x}&quot; }&#xA; produces: &#xA; Got .&#xA;Got ..&#xA;Got config.h&#xA;Got main.rb" />
        <scope name="getwd" ilk="function" attributes="__classmethod__" signature="getwd()" doc="Returns the path to the current working directory of this process as a string. &#xA; Dir.chdir(&quot;/tmp&quot;)   =&gt; 0&#xA;Dir.getwd           =&gt; &quot;/tmp&quot;" />
        <scope name="glob" ilk="function" attributes="__classmethod__" signature="glob(p1, p2 = v2)" doc="Returns the filenames found by expanding pattern which is an +Array+ of the patterns or the pattern +String+, either as an array or as parameters to the block. Note that this pattern is not a regexp (it&apos;s closer to a shell glob). See File::fnmatch for the meaning of the flags parameter. Note that case sensitivity depends on your system (so File::FNM_CASEFOLD is ignored), as does the order in which the results are returned. &#xA; Matches any file. Can be restricted by other values in the glob. * will match all files; c* will match all files beginning with c; *c will match all files ending with c; and \*c\* will match all files that have c in them (including at the beginning or end). Equivalent to / .* /x in regexp. Note, this will not match Unix-like hidden files (dotfiles). In order to include those in the match results, you must use something like &quot;{*,.*}&quot;.&#xA;Matches directories recursively.&#xA;Matches any one character. Equivalent to /.{1}/ in regexp.&#xA;Matches any one character in +set+. Behaves exactly like character sets in Regexp, including set negation ([^a-z]).&#xA;Matches either literal p or literal q. Matching literals may be more than one character in length. More than two literals may be specified. Equivalent to pattern alternation in regexp.&#xA;Escapes the next metacharacter. Note that this means you cannot use backslash in windows as part of a glob, i.e. Dir[&quot;c:\\foo*&quot;] will not work use Dir[&quot;c:/foo*&quot;] instead &#xA; Dir[&quot;config.?&quot;]                     =&gt; [&quot;config.h&quot;]&#xA;Dir.glob(&quot;config.?&quot;)                =&gt; [&quot;config.h&quot;]&#xA;Dir.glob(&quot;*.[a-z][a-z]&quot;)            =&gt; [&quot;main.rb&quot;]&#xA;Dir.glob(&quot;*.[^r]*&quot;)                 =&gt; [&quot;config.h&quot;]&#xA;Dir.glob(&quot;*.{rb,h}&quot;)                =&gt; [&quot;main.rb&quot;, &quot;config.h&quot;]&#xA;Dir.glob(&quot;*&quot;)                       =&gt; [&quot;config.h&quot;, &quot;main.rb&quot;]" />
        <scope name="home" ilk="function" attributes="__classmethod__" signature="home(p1 = v1)" doc="Returns the home directory of the current user or the named user if given." />
        <scope name="mkdir" ilk="function" attributes="__classmethod__" signature="mkdir(p1, p2 = v2)" doc="Makes a new directory named by string, with permissions specified by the optional parameter anInteger. The permissions may be modified by the value of File::umask, and are ignored on NT. Raises a SystemCallError if the directory cannot be created. See also the discussion of permissions in the class documentation for File. &#xA; Dir.mkdir(File.join(Dir.home, &quot;.foo&quot;), 0700) =&gt; 0" />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(*args)" doc="With no block, open is a synonym for Dir::new. If a block is present, it is passed aDir as a parameter. The directory is closed at the end of the block, and Dir::open returns the value of the block." />
        <scope name="pwd" ilk="function" attributes="__classmethod__" signature="pwd()" doc="Returns the path to the current working directory of this process as a string. &#xA; Dir.chdir(&quot;/tmp&quot;)   =&gt; 0&#xA;Dir.getwd           =&gt; &quot;/tmp&quot;" />
        <scope name="rmdir" ilk="function" attributes="__classmethod__" signature="rmdir(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="unlink" ilk="function" attributes="__classmethod__" signature="unlink(p1)" doc="Deletes the named directory. Raises a subclass of SystemCallError if the directory isn&apos;t empty." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2 = {})" doc="Returns a new directory object for the named directory." />
      </scope>
      <scope name="Time" ilk="class" classrefs="Object" >
        <import symbol="Comparable" />
        <scope name="_dump" ilk="function" signature="_dump(p1 = v1)" doc="Dump _time_ for marshaling." />
        <scope name="asctime" ilk="function" signature="asctime()" doc="Returns a canonical string representation of time. &#xA; Time.now.asctime   =&gt; &quot;Wed Apr  9 08:56:03 2003&quot;" />
        <scope name="ctime" ilk="function" signature="ctime()" doc="Returns a canonical string representation of time. &#xA; Time.now.asctime   =&gt; &quot;Wed Apr  9 08:56:03 2003&quot;" />
        <scope name="day" ilk="function" signature="day()" doc="Returns the day of the month (1..n) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:27:03 -0600&#xA;t.day          =&gt; 19&#xA;t.mday         =&gt; 19" />
        <scope name="dst?" ilk="function" signature="dst?()" doc="Returns true if time occurs during Daylight Saving Time in its time zone. &#xA; # CST6CDT:&#xA;  Time.local(2000, 1, 1).zone    =&gt; &quot;CST&quot;&#xA;  Time.local(2000, 1, 1).isdst   =&gt; false&#xA;  Time.local(2000, 1, 1).dst?    =&gt; false&#xA;  Time.local(2000, 7, 1).zone    =&gt; &quot;CDT&quot;&#xA;  Time.local(2000, 7, 1).isdst   =&gt; true&#xA;  Time.local(2000, 7, 1).dst?    =&gt; true&#xA;# Asia/Tokyo:&#xA;  Time.local(2000, 1, 1).zone    =&gt; &quot;JST&quot;&#xA;  Time.local(2000, 1, 1).isdst   =&gt; false&#xA;  Time.local(2000, 1, 1).dst?    =&gt; false&#xA;  Time.local(2000, 7, 1).zone    =&gt; &quot;JST&quot;" />
        <scope name="friday?" ilk="function" signature="friday?()" doc="Returns true if time represents Friday. &#xA; t = Time.local(1987, 12, 18)     =&gt; 1987-12-18 00:00:00 -0600&#xA;t.friday?                        =&gt; true" />
        <scope name="getgm" ilk="function" signature="getgm()" doc="Returns a new new_time object representing time in UTC. &#xA; t = Time.local(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600&#xA;t.gmt?                             =&gt; false&#xA;y = t.getgm                        =&gt; 2000-01-02 02:15:01 UTC&#xA;y.gmt?                             =&gt; true&#xA;t == y                             =&gt; true" />
        <scope name="getlocal" ilk="function" signature="getlocal(p1 = v1)" doc="Returns a new new_time object representing time in local time (using the local time zone in effect for this process). &#xA; If _utc_offset_ is given, it is used instead of the local time. &#xA; t = Time.utc(2000,1,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;t.utc?                          =&gt; true&#xA;&#xA;l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;l.utc?                          =&gt; false&#xA;t == l                          =&gt; true&#xA;&#xA;j = t.getlocal(&quot;+09:00&quot;)        =&gt; 2000-01-02 05:15:01 +0900&#xA;j.utc?                          =&gt; false&#xA;t == j                          =&gt; true" />
        <scope name="getutc" ilk="function" signature="getutc()" doc="Returns a new new_time object representing time in UTC. &#xA; t = Time.local(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600&#xA;t.gmt?                             =&gt; false&#xA;y = t.getgm                        =&gt; 2000-01-02 02:15:01 UTC&#xA;y.gmt?                             =&gt; true&#xA;t == y                             =&gt; true" />
        <scope name="gmt?" ilk="function" signature="gmt?()" doc="Returns true if time represents a time in UTC (GMT). &#xA; t = Time.now                        =&gt; 2007-11-19 08:15:23 -0600&#xA;t.utc?                              =&gt; false&#xA;t = Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;t.utc?                              =&gt; true&#xA;&#xA;t = Time.now                        =&gt; 2007-11-19 08:16:03 -0600&#xA;t.gmt?                              =&gt; false&#xA;t = Time.gm(2000,1,1,20,15,1)       =&gt; 2000-01-01 20:15:01 UTC&#xA;t.gmt?                              =&gt; true" />
        <scope name="gmt_offset" ilk="function" signature="gmt_offset()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA; t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;t.gmt_offset                    =&gt; 0&#xA;l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;l.gmt_offset                    =&gt; -21600" />
        <scope name="gmtime" ilk="function" signature="gmtime()" doc="Converts time to UTC (GMT), modifying the receiver. &#xA; t = Time.now   =&gt; 2007-11-19 08:18:31 -0600&#xA;t.gmt?         =&gt; false&#xA;t.gmtime       =&gt; 2007-11-19 14:18:31 UTC&#xA;t.gmt?         =&gt; true&#xA;&#xA;t = Time.now   =&gt; 2007-11-19 08:18:51 -0600&#xA;t.utc?         =&gt; false&#xA;t.utc          =&gt; 2007-11-19 14:18:51 UTC&#xA;t.utc?         =&gt; true" />
        <scope name="gmtoff" ilk="function" signature="gmtoff()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA; t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;t.gmt_offset                    =&gt; 0&#xA;l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;l.gmt_offset                    =&gt; -21600" />
        <scope name="hour" ilk="function" signature="hour()" doc="Returns the hour of the day (0..23) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:26:20 -0600&#xA;t.hour         =&gt; 8" />
        <scope name="isdst" ilk="function" signature="isdst()" doc="Returns true if time occurs during Daylight Saving Time in its time zone. &#xA; # CST6CDT:&#xA;  Time.local(2000, 1, 1).zone    =&gt; &quot;CST&quot;&#xA;  Time.local(2000, 1, 1).isdst   =&gt; false&#xA;  Time.local(2000, 1, 1).dst?    =&gt; false&#xA;  Time.local(2000, 7, 1).zone    =&gt; &quot;CDT&quot;&#xA;  Time.local(2000, 7, 1).isdst   =&gt; true&#xA;  Time.local(2000, 7, 1).dst?    =&gt; true&#xA;# Asia/Tokyo:&#xA;  Time.local(2000, 1, 1).zone    =&gt; &quot;JST&quot;&#xA;  Time.local(2000, 1, 1).isdst   =&gt; false&#xA;  Time.local(2000, 1, 1).dst?    =&gt; false&#xA;  Time.local(2000, 7, 1).zone    =&gt; &quot;JST&quot;" />
        <scope name="localtime" ilk="function" signature="localtime(p1 = v1)" doc="Converts time to local time (using the local time zone in effect for this process) modifying the receiver. &#xA; If _utc_offset_ is given, it is used instead of the local time. &#xA; t = Time.utc(2000, &quot;jan&quot;, 1, 20, 15, 1) =&gt; 2000-01-01 20:15:01 UTC&#xA;t.utc?                                  =&gt; true&#xA;&#xA;t.localtime                             =&gt; 2000-01-01 14:15:01 -0600&#xA;t.utc?                                  =&gt; false&#xA;&#xA;t.localtime(&quot;+09:00&quot;)                   =&gt; 2000-01-02 05:15:01 +0900&#xA;t.utc?                                  =&gt; false" />
        <scope name="mday" ilk="function" signature="mday()" doc="Returns the day of the month (1..n) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:27:03 -0600&#xA;t.day          =&gt; 19&#xA;t.mday         =&gt; 19" />
        <scope name="min" ilk="function" signature="min()" doc="Returns the minute of the hour (0..59) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:25:51 -0600&#xA;t.min          =&gt; 25" />
        <scope name="mon" ilk="function" signature="mon()" doc="Returns the month of the year (1..12) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:27:30 -0600&#xA;t.mon          =&gt; 11&#xA;t.month        =&gt; 11" />
        <scope name="monday?" ilk="function" signature="monday?()" doc="Returns true if time represents Monday. &#xA; t = Time.local(2003, 8, 4)       =&gt; 2003-08-04 00:00:00 -0500&#xA;p t.monday?                      =&gt; true" />
        <scope name="month" ilk="function" signature="month()" doc="Returns the month of the year (1..12) for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:27:30 -0600&#xA;t.mon          =&gt; 11&#xA;t.month        =&gt; 11" />
        <scope name="nsec" ilk="function" signature="nsec()" doc="Returns just the number of nanoseconds for time. &#xA; t = Time.now        =&gt; 2007-11-17 15:18:03 +0900&#xA;&quot;%10.9f&quot; % t.to_f   =&gt; &quot;1195280283.536151409&quot;&#xA;t.nsec              =&gt; 536151406&#xA; The lowest digit of to_f and nsec is different because IEEE 754 double is not accurate enough to represent nanoseconds from the Epoch. The accurate value is returned by nsec." />
        <scope name="round" ilk="function" signature="round(p1 = v1)" doc="Rounds sub seconds to a given precision in decimal digits (0 digits by default). It returns a new time object. _ndigits_ should be zero or positive integer. &#xA; require &apos;time&apos;&#xA;t = Time.utc(2010,3,30, 5,43,&quot;25.123456789&quot;.to_r)&#xA;p t.iso8601(10)           =&gt; &quot;2010-03-30T05:43:25.1234567890Z&quot;&#xA;p t.round.iso8601(10)     =&gt; &quot;2010-03-30T05:43:25.0000000000Z&quot;&#xA;p t.round(0).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.0000000000Z&quot;&#xA;p t.round(1).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1000000000Z&quot;&#xA;p t.round(2).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1200000000Z&quot;&#xA;p t.round(3).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1230000000Z&quot;&#xA;p t.round(4).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1235000000Z&quot;&#xA;p t.round(5).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234600000Z&quot;&#xA;p t.round(6).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234570000Z&quot;&#xA;p t.round(7).iso8601(10)  =&gt; &quot;2010-03-30T05:43:25.1234568000Z&quot;" />
        <scope name="saturday?" ilk="function" signature="saturday?()" doc="Returns true if time represents Saturday. &#xA; t = Time.local(2006, 6, 10)      =&gt; 2006-06-10 00:00:00 -0500&#xA;t.saturday?                      =&gt; true" />
        <scope name="sec" ilk="function" signature="sec()" doc="Returns the second of the minute (0..60)[Yes, seconds really can range from zero to 60. This allows the system to inject leap seconds every now and then to correct for the fact that years are not really a convenient number of hours long.] for time. &#xA; t = Time.now   =&gt; 2007-11-19 08:25:02 -0600&#xA;t.sec          =&gt; 2" />
        <scope name="strftime" ilk="function" signature="strftime(p1)" doc="Formats time according to the directives in the given format string. The directives begins with a percent (%) character. Any text not listed as a directive will be passed through to the output string. &#xA; The directive consists of a percent (%) character, zero or more flags, optional minimum field width, optional modifier and a conversion specifier as follows. &#xA; %&lt;flags&gt;&lt;width&gt;&lt;modifier&gt;&lt;conversion&gt;&#xA; Flags: -  don&apos;t pad a numerical output.&#xA;_  use spaces for padding.&#xA;0  use zeros for padding.&#xA;^  upcase the result string.&#xA;#  change case.&#xA;:  use colons for %z.&#xA; The minimum field width specifies the minimum width. &#xA; The modifier is &quot;E&quot; and &quot;O&quot;. They are ignored. &#xA; Format directives: &#xA; Date (Year, Month, Day):" />
        <scope name="subsec" ilk="function" signature="subsec()" doc="Returns just the fraction for time. &#xA; The result is possibly rational. &#xA; t = Time.now        =&gt; 2009-03-26 22:33:12 +0900&#xA;&quot;%10.9f&quot; % t.to_f   =&gt; &quot;1238074392.940563917&quot;&#xA;t.subsec            =&gt; (94056401/100000000)&#xA; The lowest digit of to_f and subsec is different because IEEE 754 double is not accurate enough to represent the rational. The accurate value is returned by subsec." />
        <scope name="succ" ilk="function" signature="succ()" doc="Return a new time object, one second later than time. Time#succ is obsolete since 1.9.2 for time is not a discrete value. &#xA; t = Time.now       =&gt; 2007-11-19 08:23:57 -0600&#xA;t.succ             =&gt; 2007-11-19 08:23:58 -0600" />
        <scope name="sunday?" ilk="function" signature="sunday?()" doc="Returns true if time represents Sunday. &#xA; t = Time.local(1990, 4, 1)       =&gt; 1990-04-01 00:00:00 -0600&#xA;t.sunday?                        =&gt; true" />
        <scope name="thursday?" ilk="function" signature="thursday?()" doc="Returns true if time represents Thursday. &#xA; t = Time.local(1995, 12, 21)     =&gt; 1995-12-21 00:00:00 -0600&#xA;p t.thursday?                    =&gt; true" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns a ten-element array of values for time: {[ sec, min, hour, day, month, year, wday, yday, isdst, zone ]}. See the individual methods for an explanation of the valid ranges of each value. The ten elements can be passed directly to Time::utc or Time::local to create a new Time. &#xA; t = Time.now     =&gt; 2007-11-19 08:36:01 -0600&#xA;now = t.to_a     =&gt; [1, 36, 8, 19, 11, 2007, 1, 323, false, &quot;CST&quot;]" />
        <scope name="to_date" ilk="function" signature="to_date()" doc="Returns a Date object which denotes self." />
        <scope name="to_datetime" ilk="function" signature="to_datetime()" doc="Returns a DateTime object which denotes self." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the value of time as a floating point number of seconds since the Epoch. &#xA; t = Time.now&#xA;&quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968744.77658&quot;&#xA;t.to_i              =&gt; 1270968744&#xA; Note that IEEE 754 double is not accurate enough to represent number of nanoseconds from the Epoch." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value of time as an integer number of seconds since the Epoch. &#xA; t = Time.now&#xA;&quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968656.89607&quot;&#xA;t.to_i              =&gt; 1270968656" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns the value of time as a rational number of seconds since the Epoch. &#xA; t = Time.now&#xA;p t.to_r            =&gt; (1270968792716287611/1000000000)&#xA; This methods is intended to be used to get an accurate value representing nanoseconds from the Epoch.  You can use this to convert time to another Epoch." />
        <scope name="to_time" ilk="function" signature="to_time()" doc="Returns a copy of self as local mode." />
        <scope name="tuesday?" ilk="function" signature="tuesday?()" doc="Returns true if time represents Tuesday. &#xA; t = Time.local(1991, 2, 19)      =&gt; 1991-02-19 00:00:00 -0600&#xA;p t.tuesday?                     =&gt; true" />
        <scope name="tv_nsec" ilk="function" signature="tv_nsec()" doc="Returns just the number of nanoseconds for time. &#xA; t = Time.now        =&gt; 2007-11-17 15:18:03 +0900&#xA;&quot;%10.9f&quot; % t.to_f   =&gt; &quot;1195280283.536151409&quot;&#xA;t.nsec              =&gt; 536151406&#xA; The lowest digit of to_f and nsec is different because IEEE 754 double is not accurate enough to represent nanoseconds from the Epoch. The accurate value is returned by nsec." />
        <scope name="tv_sec" ilk="function" signature="tv_sec()" doc="Returns the value of time as an integer number of seconds since the Epoch. &#xA; t = Time.now&#xA;&quot;%10.5f&quot; % t.to_f   =&gt; &quot;1270968656.89607&quot;&#xA;t.to_i              =&gt; 1270968656" />
        <scope name="tv_usec" ilk="function" signature="tv_usec()" doc="Returns just the number of microseconds for time. &#xA; t = Time.now        =&gt; 2007-11-19 08:03:26 -0600&#xA;&quot;%10.6f&quot; % t.to_f   =&gt; &quot;1195481006.775195&quot;&#xA;t.usec              =&gt; 775195" />
        <scope name="usec" ilk="function" signature="usec()" doc="Returns just the number of microseconds for time. &#xA; t = Time.now        =&gt; 2007-11-19 08:03:26 -0600&#xA;&quot;%10.6f&quot; % t.to_f   =&gt; &quot;1195481006.775195&quot;&#xA;t.usec              =&gt; 775195" />
        <scope name="utc" ilk="function" signature="utc()" doc="Converts time to UTC (GMT), modifying the receiver. &#xA; t = Time.now   =&gt; 2007-11-19 08:18:31 -0600&#xA;t.gmt?         =&gt; false&#xA;t.gmtime       =&gt; 2007-11-19 14:18:31 UTC&#xA;t.gmt?         =&gt; true&#xA;&#xA;t = Time.now   =&gt; 2007-11-19 08:18:51 -0600&#xA;t.utc?         =&gt; false&#xA;t.utc          =&gt; 2007-11-19 14:18:51 UTC&#xA;t.utc?         =&gt; true" />
        <scope name="utc?" ilk="function" signature="utc?()" doc="Returns true if time represents a time in UTC (GMT). &#xA; t = Time.now                        =&gt; 2007-11-19 08:15:23 -0600&#xA;t.utc?                              =&gt; false&#xA;t = Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;t.utc?                              =&gt; true&#xA;&#xA;t = Time.now                        =&gt; 2007-11-19 08:16:03 -0600&#xA;t.gmt?                              =&gt; false&#xA;t = Time.gm(2000,1,1,20,15,1)       =&gt; 2000-01-01 20:15:01 UTC&#xA;t.gmt?                              =&gt; true" />
        <scope name="utc_offset" ilk="function" signature="utc_offset()" doc="Returns the offset in seconds between the timezone of time and UTC. &#xA; t = Time.gm(2000,1,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC&#xA;t.gmt_offset                    =&gt; 0&#xA;l = t.getlocal                  =&gt; 2000-01-01 14:15:01 -0600&#xA;l.gmt_offset                    =&gt; -21600" />
        <scope name="wday" ilk="function" signature="wday()" doc="Returns an integer representing the day of the week, 0..6, with Sunday == 0. &#xA; t = Time.now   =&gt; 2007-11-20 02:35:35 -0600&#xA;t.wday         =&gt; 2&#xA;t.sunday?      =&gt; false&#xA;t.monday?      =&gt; false&#xA;t.tuesday?     =&gt; true&#xA;t.wednesday?   =&gt; false&#xA;t.thursday?    =&gt; false&#xA;t.friday?      =&gt; false&#xA;t.saturday?    =&gt; false" />
        <scope name="wednesday?" ilk="function" signature="wednesday?()" doc="Returns true if time represents Wednesday. &#xA; t = Time.local(1993, 2, 24)      =&gt; 1993-02-24 00:00:00 -0600&#xA;p t.wednesday?                   =&gt; true" />
        <scope name="yday" ilk="function" signature="yday()" doc="Returns an integer representing the day of the year, 1..366. &#xA; t = Time.now   =&gt; 2007-11-19 08:32:31 -0600&#xA;t.yday         =&gt; 323" />
        <scope name="year" ilk="function" signature="year()" doc="Returns the year for time (including the century). &#xA; t = Time.now   =&gt; 2007-11-19 08:27:51 -0600&#xA;t.year         =&gt; 2007" />
        <scope name="zone" ilk="function" signature="zone()" doc="Returns the name of the time zone used for time. As of Ruby 1.8, returns ``UTC&apos;&apos; rather than ``GMT&apos;&apos; for UTC times. &#xA; t = Time.gm(2000, &quot;jan&quot;, 1, 20, 15, 1)&#xA;t.zone   =&gt; &quot;UTC&quot;&#xA;t = Time.local(2000, &quot;jan&quot;, 1, 20, 15, 1)&#xA;t.zone   =&gt; &quot;CST&quot;" />
        <scope name="_load" ilk="function" attributes="__classmethod__" signature="_load(p1)" doc="Unmarshal a dumped +Time+ object." />
        <scope name="at" ilk="function" attributes="__classmethod__" signature="at(p1, p2 = v2)" doc="Creates a new time object with the value given by time, the given number of seconds_with_frac, or seconds and microseconds_with_frac from the Epoch. seconds_with_frac and microseconds_with_frac can be Integer, Float, Rational, or other Numeric. non-portable feature allows the offset to be negative on some systems. &#xA; Time.at(0)            =&gt; 1969-12-31 18:00:00 -0600&#xA;Time.at(Time.at(0))   =&gt; 1969-12-31 18:00:00 -0600&#xA;Time.at(946702800)    =&gt; 1999-12-31 23:00:00 -0600&#xA;Time.at(-284061600)   =&gt; 1960-12-31 00:00:00 -0600&#xA;Time.at(946684800.2).usec =&gt; 200000&#xA;Time.at(946684800, 123456.789).nsec =&gt; 123456789" />
        <scope name="gm" ilk="function" attributes="__classmethod__" signature="gm(*args)" doc="Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a. sec_with_frac and usec_with_frac can have a fractional part. &#xA; Time.utc(2000,&quot;jan&quot;,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC" />
        <scope name="local" ilk="function" attributes="__classmethod__" signature="local(*args)" doc="Same as Time::gm, but interprets the values in the local time zone. &#xA; Time.local(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600" />
        <scope name="mktime" ilk="function" attributes="__classmethod__" signature="mktime(*args)" doc="Same as Time::gm, but interprets the values in the local time zone. &#xA; Time.local(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 -0600" />
        <scope name="now" ilk="function" attributes="__classmethod__" signature="now()" doc="Synonym for Time.new. Returns a +Time+ object initialized to the current system time." />
        <scope name="utc" ilk="function" attributes="__classmethod__" signature="utc(*args)" doc="Creates a time based on given values, interpreted as UTC (GMT). The year must be specified. Other values default to the minimum value for that field (and may be nil or omitted). Months may be specified by numbers from 1 to 12, or by the three-letter English month names. Hours are specified on a 24-hour clock (0..23). Raises an ArgumentError if any values are out of range. Will also accept ten arguments in the order output by Time#to_a. sec_with_frac and usec_with_frac can have a fractional part. &#xA; Time.utc(2000,&quot;jan&quot;,1,20,15,1)  =&gt; 2000-01-01 20:15:01 UTC&#xA;Time.gm(2000,&quot;jan&quot;,1,20,15,1)   =&gt; 2000-01-01 20:15:01 UTC" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Returns a Time object. &#xA; It is initialized to the current system time if no argument. &lt;b&gt;Note:&lt;/b&gt; The object created will be created using the resolution available on your system clock, and so may include fractional seconds. &#xA; If one or more arguments specified, the time is initialized to the specified time. _sec_ may have fraction if it is a rational. &#xA; _utc_offset_ is the offset from UTC. It is a string such as &quot;+09:00&quot; or a number of seconds such as 32400. &#xA; a = Time.new      =&gt; 2007-11-19 07:50:02 -0600&#xA;b = Time.new      =&gt; 2007-11-19 07:50:02 -0600&#xA;a == b            =&gt; false&#xA;&quot;%.6f&quot; % a.to_f   =&gt; &quot;1195480202.282373&quot;&#xA;&quot;%.6f&quot; % b.to_f   =&gt; &quot;1195480202.283415&quot;&#xA;Time.new(2008,6,21, 13,30,0, &quot;+09:00&quot;) =&gt; 2008-06-21 13:30:00 +0900&#xA;# A trip for RubyConf 2007&#xA;t1 = Time.new(2007,11,1,15,25,0, &quot;+09:00&quot;) # JST (Narita)&#xA;t2 = Time.new(2007,11,1,12, 5,0, &quot;-05:00&quot;) # CDT (Minneapolis)" />
      </scope>
      <scope name="Random" ilk="class" classrefs="Object" >
        <scope name="bytes" ilk="function" signature="bytes(p1)" doc="Returns a random binary string.  The argument size specified the length of the result string." />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rand" ilk="function" signature="rand(*args)" doc="When the argument is an +Integer+ or a +Bignum+, it returns a random integer greater than or equal to zero and less than the argument.  Unlike Random.rand, when the argument is a negative integer or zero, it raises an ArgumentError. &#xA; When the argument is a +Float+, it returns a random floating point number between 0.0 and _max_, including 0.0 and excluding _max_. &#xA; When the argument _limit_ is a +Range+, it returns a random number where range.member?(number) == true. prng.rand(5..9)  =&gt; one of [5, 6, 7, 8, 9]&#xA;prng.rand(5...9) =&gt; one of [5, 6, 7, 8]&#xA;prng.rand(5.0..9.0) =&gt; between 5.0 and 9.0, including 9.0&#xA;prng.rand(5.0...9.0) =&gt; between 5.0 and 9.0, excluding 9.0&#xA; +begin+/+end+ of the range have to have subtract and add methods. &#xA; Otherwise, it raises an ArgumentError." />
        <scope name="seed" ilk="function" signature="seed()" doc="Returns the seed of the generator." />
        <scope name="new_seed" ilk="function" attributes="__classmethod__" signature="new_seed()" doc="Returns arbitrary value for seed." />
        <scope name="rand" ilk="function" attributes="__classmethod__" signature="rand(*args)" doc="Alias of _Random::DEFAULT.rand_." />
        <scope name="srand" ilk="function" attributes="__classmethod__" signature="srand(p1 = v1)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Creates new Mersenne Twister based pseudorandom number generator with seed.  When the argument seed is omitted, the generator is initialized with Random.new_seed. &#xA; The argument seed is used to ensure repeatable sequences of random numbers between different runs of the program. &#xA; prng = Random.new(1234)&#xA;[ prng.rand, prng.rand ]   =&gt; [0.191519450378892, 0.622108771039832]&#xA;[ prng.integer(10), prng.integer(1000) ]  =&gt; [4, 664]&#xA;prng = Random.new(1234)&#xA;[ prng.rand, prng.rand ]   =&gt; [0.191519450378892, 0.622108771039832]" />
      </scope>
      <scope name="Signal" ilk="namespace" >
        <scope name="list" ilk="function" />
        <scope name="trap" ilk="function" />
      </scope>
      <scope name="Process" ilk="namespace" >
        <scope name="abort" ilk="function" />
        <scope name="daemon" ilk="function" />
        <scope name="detach" ilk="function" />
        <scope name="egid" ilk="function" />
        <scope name="egid=" ilk="function" />
        <scope name="euid" ilk="function" />
        <scope name="euid=" ilk="function" />
        <scope name="exec" ilk="function" />
        <scope name="exit" ilk="function" />
        <scope name="exit!" ilk="function" />
        <scope name="fork" ilk="function" />
        <scope name="getpgid" ilk="function" />
        <scope name="getpgrp" ilk="function" />
        <scope name="getpriority" ilk="function" />
        <scope name="getrlimit" ilk="function" />
        <scope name="gid" ilk="function" />
        <scope name="gid=" ilk="function" />
        <scope name="groups" ilk="function" />
        <scope name="groups=" ilk="function" />
        <scope name="initgroups" ilk="function" />
        <scope name="kill" ilk="function" />
        <scope name="maxgroups" ilk="function" />
        <scope name="maxgroups=" ilk="function" />
        <scope name="pid" ilk="function" />
        <scope name="ppid" ilk="function" />
        <scope name="setpgid" ilk="function" />
        <scope name="setpgrp" ilk="function" />
        <scope name="setpriority" ilk="function" />
        <scope name="setrlimit" ilk="function" />
        <scope name="setsid" ilk="function" />
        <scope name="spawn" ilk="function" />
        <scope name="times" ilk="function" />
        <scope name="uid" ilk="function" />
        <scope name="uid=" ilk="function" />
        <scope name="wait" ilk="function" />
        <scope name="wait2" ilk="function" />
        <scope name="waitall" ilk="function" />
        <scope name="waitpid" ilk="function" />
        <scope name="waitpid2" ilk="function" />
        <scope name="GID" ilk="namespace" >
          <scope name="change_privilege" ilk="function" />
          <scope name="eid" ilk="function" />
          <scope name="eid=" ilk="function" />
          <scope name="grant_privilege" ilk="function" />
          <scope name="re_exchange" ilk="function" />
          <scope name="re_exchangeable?" ilk="function" />
          <scope name="rid" ilk="function" />
          <scope name="sid_available?" ilk="function" />
          <scope name="switch" ilk="function" />
        </scope>
        <variable name="PRIO_PGRP" attributes="__const__" citdl="Fixnum" />
        <variable name="PRIO_PROCESS" attributes="__const__" citdl="Fixnum" />
        <variable name="PRIO_USER" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_AS" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_CORE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_CPU" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_DATA" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_FSIZE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_MEMLOCK" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_NOFILE" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_NPROC" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_RSS" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIMIT_STACK" attributes="__const__" citdl="Fixnum" />
        <variable name="RLIM_INFINITY" attributes="__const__" citdl="Bignum" />
        <variable name="RLIM_SAVED_CUR" attributes="__const__" citdl="Bignum" />
        <variable name="RLIM_SAVED_MAX" attributes="__const__" citdl="Bignum" />
        <scope name="Status" ilk="class" classrefs="Object" >
          <scope name="coredump?" ilk="function" />
          <scope name="exited?" ilk="function" />
          <scope name="exitstatus" ilk="function" />
          <scope name="pid" ilk="function" />
          <scope name="signaled?" ilk="function" />
          <scope name="stopped?" ilk="function" />
          <scope name="stopsig" ilk="function" />
          <scope name="success?" ilk="function" />
          <scope name="termsig" ilk="function" />
          <scope name="to_i" ilk="function" />
        </scope>
        <scope name="Sys" ilk="namespace" >
          <scope name="getegid" ilk="function" />
          <scope name="geteuid" ilk="function" />
          <scope name="getgid" ilk="function" />
          <scope name="getuid" ilk="function" />
          <scope name="issetugid" ilk="function" />
          <scope name="setegid" ilk="function" />
          <scope name="seteuid" ilk="function" />
          <scope name="setgid" ilk="function" />
          <scope name="setregid" ilk="function" />
          <scope name="setresgid" ilk="function" />
          <scope name="setresuid" ilk="function" />
          <scope name="setreuid" ilk="function" />
          <scope name="setrgid" ilk="function" />
          <scope name="setruid" ilk="function" />
          <scope name="setuid" ilk="function" />
        </scope>
        <scope name="UID" ilk="namespace" >
          <scope name="change_privilege" ilk="function" />
          <scope name="eid" ilk="function" />
          <scope name="eid=" ilk="function" />
          <scope name="grant_privilege" ilk="function" />
          <scope name="re_exchange" ilk="function" />
          <scope name="re_exchangeable?" ilk="function" />
          <scope name="rid" ilk="function" />
          <scope name="sid_available?" ilk="function" />
          <scope name="switch" ilk="function" />
        </scope>
        <variable name="WNOHANG" attributes="__const__" citdl="Fixnum" />
        <variable name="WUNTRACED" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Proc" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns the number of arguments that would not be ignored. If the block is declared to take no arguments, returns 0. If the block is known to take exactly n arguments, returns n. If the block has optional arguments, return -n-1, where n is the number of mandatory arguments. A proc with no argument declarations is the same a block declaring || as its arguments. &#xA; Proc.new {}.arity          =&gt;  0&#xA;Proc.new {||}.arity        =&gt;  0&#xA;Proc.new {|a|}.arity       =&gt;  1&#xA;Proc.new {|a,b|}.arity     =&gt;  2&#xA;Proc.new {|a,b,c|}.arity   =&gt;  3&#xA;Proc.new {|*a|}.arity      =&gt; -1&#xA;Proc.new {|a,*b|}.arity    =&gt; -2&#xA;Proc.new {|a,*b, c|}.arity    =&gt; -3" />
        <scope name="binding" ilk="function" signature="binding()" doc="Returns the binding associated with prc. Note that Kernel#eval accepts either a Proc or a Binding object as its second parameter. &#xA; def fred(param)&#xA;  proc {}&#xA;end&#xA;&#xA;b = fred(99)&#xA;eval(&quot;param&quot;, b.binding)   =&gt; 99" />
        <scope name="call" ilk="function" signature="call(*args)" doc="Invokes the block, setting the block&apos;s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array).  Note that prc.() invokes prc.call() with the parameters given.  It&apos;s a syntax sugar to hide &quot;call&quot;. &#xA; For procs created using lambda or -&gt;() an error is generated if the wrong number of parameters are passed to a Proc with multiple parameters.  For procs created using Proc.new or Kernel.proc, extra parameters are silently discarded. &#xA; Returns the value of the last expression evaluated in the block. See also Proc#yield. &#xA; a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}&#xA;a_proc.call(9, 1, 2, 3)   =&gt; [9, 18, 27]&#xA;a_proc[9, 1, 2, 3]        =&gt; [9, 18, 27]&#xA;a_proc = lambda {|a,b| a}&#xA;a_proc.call(1,2,3)&#xA; produces: &#xA; prog.rb:4:in `block in &lt;main&gt;&apos;: wrong number of arguments (3 for 2) (ArgumentError)&#xA; from prog.rb:5:in `call&apos;&#xA; from prog.rb:5:in `&lt;main&gt;&apos;" />
        <scope name="curry" ilk="function" signature="curry(p1 = v1)" doc="Returns a curried proc. If the optional arity argument is given, it determines the number of arguments. A curried proc receives some arguments. If a sufficient number of arguments are supplied, it passes the supplied arguments to the original proc and returns the result. Otherwise, returns another curried proc that takes the rest of arguments. &#xA; b = proc {|x, y, z| (x||0) + (y||0) + (z||0) }&#xA;p b.curry[1][2][3]           =&gt; 6&#xA;p b.curry[1, 2][3, 4]        =&gt; 6&#xA;p b.curry(5)[1][2][3][4][5]  =&gt; 6&#xA;p b.curry(5)[1, 2][3, 4][5]  =&gt; 6&#xA;p b.curry(1)[1]              =&gt; 1&#xA;b = proc {|x, y, z, *w| (x||0) + (y||0) + (z||0) + w.inject(0, &amp;:+) }&#xA;p b.curry[1][2][3]           =&gt; 6&#xA;p b.curry[1, 2][3, 4]        =&gt; 10&#xA;p b.curry(5)[1][2][3][4][5]  =&gt; 15&#xA;p b.curry(5)[1, 2][3, 4][5]  =&gt; 15&#xA;p b.curry(1)[1]              =&gt; 1" />
        <scope name="lambda?" ilk="function" signature="lambda?()" doc="Returns +true+ for a Proc object for which argument handling is rigid. Such procs are typically generated by +lambda+. &#xA; A Proc object generated by +proc+ ignores extra arguments. &#xA; proc {|a,b| [a,b] }.call(1,2,3)    =&gt; [1,2]&#xA; It provides +nil+ for missing arguments. &#xA; proc {|a,b| [a,b] }.call(1)        =&gt; [1,nil]&#xA; It expands a single array argument. &#xA; proc {|a,b| [a,b] }.call([1,2])    =&gt; [1,2]&#xA; A Proc object generated by +lambda+ doesn&apos;t have such tricks. &#xA; lambda {|a,b| [a,b] }.call(1,2,3)  =&gt; ArgumentError&#xA;lambda {|a,b| [a,b] }.call(1)      =&gt; ArgumentError&#xA;lambda {|a,b| [a,b] }.call([1,2])  =&gt; ArgumentError&#xA; Proc#lambda? is a predicate for the tricks. It returns +true+ if no tricks apply. &#xA; lambda {}.lambda?            =&gt; true" />
        <scope name="parameters" ilk="function" signature="parameters()" doc="Returns the parameter information of this proc. &#xA; prc = lambda{|x, y=42, *other|}&#xA;prc.parameters  =&gt; [[:req, :x], [:opt, :y], [:rest, :other]]" />
        <scope name="source_location" ilk="function" signature="source_location()" doc="Returns the Ruby source filename and line number containing this proc or +nil+ if this proc was not defined in Ruby (i.e. native)" />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Part of the protocol for converting objects to Proc objects. Instances of class Proc simply return themselves." />
        <scope name="yield" ilk="function" signature="yield(*args)" doc="Invokes the block, setting the block&apos;s parameters to the values in params using something close to method calling semantics. Generates a warning if multiple values are passed to a proc that expects just one (previously this silently converted the parameters to an array).  Note that prc.() invokes prc.call() with the parameters given.  It&apos;s a syntax sugar to hide &quot;call&quot;. &#xA; For procs created using lambda or -&gt;() an error is generated if the wrong number of parameters are passed to a Proc with multiple parameters.  For procs created using Proc.new or Kernel.proc, extra parameters are silently discarded. &#xA; Returns the value of the last expression evaluated in the block. See also Proc#yield. &#xA; a_proc = Proc.new {|a, *b| b.collect {|i| i*a }}&#xA;a_proc.call(9, 1, 2, 3)   =&gt; [9, 18, 27]&#xA;a_proc[9, 1, 2, 3]        =&gt; [9, 18, 27]&#xA;a_proc = lambda {|a,b| a}&#xA;a_proc.call(1,2,3)&#xA; produces: &#xA; prog.rb:4:in `block in &lt;main&gt;&apos;: wrong number of arguments (3 for 2) (ArgumentError)&#xA; from prog.rb:5:in `call&apos;&#xA; from prog.rb:5:in `&lt;main&gt;&apos;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Creates a new Proc object, bound to the current context. Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object. &#xA; def proc_from&#xA;  Proc.new&#xA;end&#xA;proc = proc_from { &quot;hello&quot; }&#xA;proc.call   =&gt; &quot;hello&quot;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Creates a new Proc object, bound to the current context. Proc::new may be called without a block only within a method with an attached block, in which case that block is converted to the Proc object. &#xA; def proc_from&#xA;  Proc.new&#xA;end&#xA;proc = proc_from { &quot;hello&quot; }&#xA;proc.call   =&gt; &quot;hello&quot;" />
      </scope>
      <scope name="LocalJumpError" ilk="class" classrefs="StandardError" >
        <scope name="exit_value" ilk="function" signature="exit_value()" doc="call_seq: local_jump_error.exit_value  -&gt; obj&#xA; Returns the exit value associated with this +LocalJumpError+." />
        <scope name="reason" ilk="function" signature="reason()" doc="The reason this block was terminated: :break, :redo, :retry, :next, :return, or :noreason." />
      </scope>
      <scope name="SystemStackError" ilk="class" classrefs="Exception" >
      </scope>
      <scope name="Method" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments. &#xA; class C&#xA;  def one;    end&#xA;  def two(a); end&#xA;  def three(*a);  end&#xA;  def four(a, b); end&#xA;  def five(a, b, *c);    end&#xA;  def six(a, b, *c, &amp;d); end&#xA;end&#xA;c = C.new&#xA;c.method(:one).arity     =&gt; 0&#xA;c.method(:two).arity     =&gt; 1&#xA;c.method(:three).arity   =&gt; -1" />
        <scope name="call" ilk="function" signature="call(*args)" doc="Invokes the meth with the specified arguments, returning the method&apos;s return value. &#xA; m = 12.method(&quot;+&quot;)&#xA;m.call(3)    =&gt; 15&#xA;m.call(20)   =&gt; 32" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the method." />
        <scope name="owner" ilk="function" signature="owner()" doc="Returns the class or module that defines the method." />
        <scope name="parameters" ilk="function" signature="parameters()" doc="Returns the parameter information of this method." />
        <scope name="receiver" ilk="function" signature="receiver()" doc="Returns the bound receiver of the method object." />
        <scope name="source_location" ilk="function" signature="source_location()" doc="Returns the Ruby source filename and line number containing this method or nil if this method was not defined in Ruby (i.e. native)" />
        <scope name="to_proc" ilk="function" signature="to_proc()" doc="Returns a Proc object corresponding to this method." />
        <scope name="unbind" ilk="function" signature="unbind()" doc="Dissociates meth from its current receiver. The resulting UnboundMethod can subsequently be bound to a new object of the same class (see UnboundMethod)." />
      </scope>
      <scope name="UnboundMethod" ilk="class" classrefs="Object" >
        <scope name="arity" ilk="function" signature="arity()" doc="Returns an indication of the number of arguments accepted by a method. Returns a nonnegative integer for methods that take a fixed number of arguments. For Ruby methods that take a variable number of arguments, returns -n-1, where n is the number of required arguments. For methods written in C, returns -1 if the call takes a variable number of arguments. &#xA; class C&#xA;  def one;    end&#xA;  def two(a); end&#xA;  def three(*a);  end&#xA;  def four(a, b); end&#xA;  def five(a, b, *c);    end&#xA;  def six(a, b, *c, &amp;d); end&#xA;end&#xA;c = C.new&#xA;c.method(:one).arity     =&gt; 0&#xA;c.method(:two).arity     =&gt; 1&#xA;c.method(:three).arity   =&gt; -1" />
        <scope name="bind" ilk="function" signature="bind(p1)" doc="Bind umeth to obj. If Klass was the class from which umeth was obtained, obj.kind_of?(Klass) must be true. &#xA; class A&#xA;  def test&#xA;    puts &quot;In test, class = #{self.class}&quot;&#xA;  end&#xA;end&#xA;class B &lt; A&#xA;end&#xA;class C &lt; B&#xA;end&#xA;um = B.instance_method(:test)&#xA;bm = um.bind(C.new)&#xA;bm.call" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of the method." />
        <scope name="owner" ilk="function" signature="owner()" doc="Returns the class or module that defines the method." />
        <scope name="parameters" ilk="function" signature="parameters()" doc="Returns the parameter information of this method." />
        <scope name="source_location" ilk="function" signature="source_location()" doc="Returns the Ruby source filename and line number containing this method or nil if this method was not defined in Ruby (i.e. native)" />
      </scope>
      <scope name="Binding" ilk="class" classrefs="Object" >
        <scope name="eval" ilk="function" signature="eval(p1, p2 = v2, p3 = v3)" doc="Evaluates the Ruby expression(s) in string, in the binding&apos;s context.  If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA; def get_binding(param)&#xA;  return binding&#xA;end&#xA;b = get_binding(&quot;hello&quot;)&#xA;b.eval(&quot;param&quot;)   =&gt; &quot;hello&quot;" />
      </scope>
      <scope name="Math" ilk="namespace" >
        <scope name="acos" ilk="function" />
        <scope name="acosh" ilk="function" />
        <scope name="asin" ilk="function" />
        <scope name="asinh" ilk="function" />
        <scope name="atan" ilk="function" />
        <scope name="atan2" ilk="function" />
        <scope name="atanh" ilk="function" />
        <scope name="cbrt" ilk="function" />
        <scope name="cos" ilk="function" />
        <scope name="cosh" ilk="function" />
        <scope name="erf" ilk="function" />
        <scope name="erfc" ilk="function" />
        <scope name="exp" ilk="function" />
        <scope name="frexp" ilk="function" />
        <scope name="gamma" ilk="function" />
        <scope name="hypot" ilk="function" />
        <scope name="ldexp" ilk="function" />
        <scope name="lgamma" ilk="function" />
        <scope name="log" ilk="function" />
        <scope name="log10" ilk="function" />
        <scope name="log2" ilk="function" />
        <scope name="sin" ilk="function" />
        <scope name="sinh" ilk="function" />
        <scope name="sqrt" ilk="function" signature="sqrt(a)" doc="Computes the square root of +a+.  It makes use of Complex and Rational to have no rounding errors if possible. &#xA; Math.sqrt(4/9)      # =&gt; 2/3&#xA;Math.sqrt(- 4/9)    # =&gt; Complex(0, 2/3)&#xA;Math.sqrt(4.0/9.0)  # =&gt; 0.666666666666667" />
        <scope name="tan" ilk="function" />
        <scope name="tanh" ilk="function" />
        <scope name="DomainError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="E" attributes="__const__" citdl="Float" />
        <variable name="PI" attributes="__const__" citdl="Float" />
      </scope>
      <scope name="GC" ilk="namespace" >
        <scope name="count" ilk="function" />
        <scope name="disable" ilk="function" />
        <scope name="enable" ilk="function" />
        <scope name="garbage_collect" ilk="function" signature="garbage_collect()" doc="Initiates garbage collection, unless manually disabled." />
        <scope name="start" ilk="function" />
        <scope name="stress" ilk="function" />
        <scope name="stress=" ilk="function" />
        <scope name="Profiler" ilk="namespace" >
          <scope name="clear" ilk="function" />
          <scope name="disable" ilk="function" />
          <scope name="enable" ilk="function" />
          <scope name="enabled?" ilk="function" />
          <scope name="report" ilk="function" />
          <scope name="result" ilk="function" />
          <scope name="total_time" ilk="function" />
        </scope>
      </scope>
      <scope name="ObjectSpace" ilk="namespace" >
        <scope name="_id2ref" ilk="function" />
        <scope name="count_objects" ilk="function" />
        <scope name="define_finalizer" ilk="function" />
        <scope name="each_object" ilk="function" />
        <scope name="garbage_collect" ilk="function" />
        <scope name="undefine_finalizer" ilk="function" />
      </scope>
      <scope name="Enumerator" ilk="class" classrefs="Object" >
        <import symbol="Enumerable" />
        <scope name="each" ilk="function" signature="each()" doc="Iterates over the block according to how this Enumerable was constructed. If no block is given, returns self." />
        <scope name="feed" ilk="function" signature="feed(p1)" doc="Sets the value to be returned by the next yield inside +e+. &#xA; If the value is not set, the yield returns nil. &#xA; This value is cleared after being yielded. &#xA; o = Object.new&#xA;def o.each&#xA;  x = yield         # (2) blocks&#xA;  p x               # (5) =&gt; &quot;foo&quot;&#xA;  x = yield         # (6) blocks&#xA;  p x               # (8) =&gt; nil&#xA;  x = yield         # (9) blocks&#xA;  p x               # not reached w/o another e.next&#xA;end&#xA;e = o.to_enum" />
        <scope name="next" ilk="function" signature="next()" doc="Returns the next object in the enumerator, and move the internal position forward.  When the position reached at the end, StopIteration is raised. &#xA; Example &#xA; a = [1,2,3]&#xA;e = a.to_enum&#xA;p e.next   =&gt; 1&#xA;p e.next   =&gt; 2&#xA;p e.next   =&gt; 3&#xA;p e.next   #raises StopIteration&#xA; Note that enumeration sequence by +next+ does not affect other non-external enumeration methods, unless the underlying iteration methods itself has side-effect, e.g. IO#each_line." />
        <scope name="next_values" ilk="function" signature="next_values()" doc="Returns the next object as an array in the enumerator, and move the internal position forward.  When the position reached at the end, StopIteration is raised. &#xA; This method can be used to distinguish yield and yield nil. &#xA; Example &#xA; o = Object.new&#xA;def o.each&#xA;  yield&#xA;  yield 1&#xA;  yield 1, 2&#xA;  yield nil&#xA;  yield [1, 2]&#xA;end&#xA;e = o.to_enum&#xA;p e.next_values" />
        <scope name="peek" ilk="function" signature="peek()" doc="Returns the next object in the enumerator, but doesn&apos;t move the internal position forward.  If the position is already at the end, StopIteration is raised. &#xA; Example &#xA; a = [1,2,3]&#xA;e = a.to_enum&#xA;p e.next   =&gt; 1&#xA;p e.peek   =&gt; 2&#xA;p e.peek   =&gt; 2&#xA;p e.peek   =&gt; 2&#xA;p e.next   =&gt; 2&#xA;p e.next   =&gt; 3&#xA;p e.next   #raises StopIteration" />
        <scope name="peek_values" ilk="function" signature="peek_values()" doc="Returns the next object as an array, similar to Enumerator#next_values, but doesn&apos;t move the internal position forward.  If the position is already at the end, StopIteration is raised. &#xA; Example &#xA; o = Object.new&#xA;def o.each&#xA;  yield&#xA;  yield 1&#xA;  yield 1, 2&#xA;end&#xA;e = o.to_enum&#xA;p e.peek_values    =&gt; []&#xA;e.next&#xA;p e.peek_values    =&gt; [1]&#xA;p e.peek_values    =&gt; [1]" />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the enumeration sequence by one step. &#xA; If the enclosed object responds to a &quot;rewind&quot; method, it is called." />
        <scope name="with_index" ilk="function" signature="with_index(p1 = v1)" doc="Iterates the given block for each element with an index, which starts from +offset+.  If no block is given, returns a new Enumerator that includes the index, starting from +offset+ &#xA; the starting index to use" />
        <scope name="with_object" ilk="function" signature="with_object(p1)" doc="Iterates the given block for each element with an arbitrary object, +obj+, and returns +obj+ &#xA; If no block is given, returns a new Enumerator. &#xA; Example &#xA; to_three = Enumerator.new do |y|&#xA;  3.times do |x|&#xA;    y &lt;&lt; x&#xA;  end&#xA;end&#xA;to_three_with_string = to_three.with_object(&quot;foo&quot;)&#xA;to_three_with_string.each do |x,string|&#xA;  puts &quot;#{string}: #{x}&quot;&#xA;end&#xA;# =&gt; foo:0" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Creates a new Enumerator object, which can be used as an Enumerable. &#xA; In the first form, iteration is defined by the given block, in which a &quot;yielder&quot; object, given as block parameter, can be used to yield a value by calling the +yield+ method (aliased as +&lt;&lt;+): &#xA; fib = Enumerator.new do |y|&#xA;  a = b = 1&#xA;  loop do&#xA;    y &lt;&lt; a&#xA;    a, b = b, a + b&#xA;  end&#xA;end&#xA;p fib.take(10) # =&gt; [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]&#xA; In the second, deprecated, form, a generated Enumerator iterates over the given object using the given method with the given arguments passed. &#xA; Use of this form is discouraged.  Use Kernel#enum_for or Kernel#to_enum instead. &#xA; e = Enumerator.new(ObjectSpace, :each_object)" />
        <scope name="Generator" ilk="class" classrefs="Object" >
          <import symbol="Enumerable" />
          <scope name="each" ilk="function" />
        </scope>
        <scope name="Yielder" ilk="class" classrefs="Object" >
          <scope name="yield" ilk="function" />
        </scope>
      </scope>
      <scope name="StopIteration" ilk="class" classrefs="IndexError" >
        <scope name="result" ilk="function" signature="result()" doc="Returns the return value of the iterator. &#xA; o = Object.new&#xA;def o.each&#xA;  yield 1&#xA;  yield 2&#xA;  yield 3&#xA;  100&#xA;end&#xA;e = o.to_enum&#xA;puts e.next                   =&gt; 1&#xA;puts e.next                   =&gt; 2&#xA;puts e.next                   =&gt; 3&#xA;begin" />
      </scope>
      <scope name="RubyVM" ilk="class" classrefs="Object" >
        <scope name="Env" ilk="class" classrefs="Object" >
        </scope>
        <variable name="INSTRUCTION_NAMES" attributes="__const__" citdl="Array" />
        <scope name="InstructionSequence" ilk="class" classrefs="Object" >
          <scope name="disasm" ilk="function" />
          <scope name="disassemble" ilk="function" />
          <scope name="eval" ilk="function" />
          <scope name="to_a" ilk="function" />
          <scope name="compile" ilk="function" attributes="__classmethod__" />
          <scope name="compile_file" ilk="function" attributes="__classmethod__" />
          <scope name="compile_option" ilk="function" attributes="__classmethod__" />
          <scope name="compile_option=" ilk="function" attributes="__classmethod__" />
          <scope name="disasm" ilk="function" attributes="__classmethod__" />
          <scope name="disassemble" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="OPTS" attributes="__const__" citdl="Array" />
        <variable name="USAGE_ANALYSIS_INSN" attributes="__const__" citdl="Hash" />
        <variable name="USAGE_ANALYSIS_INSN_BIGRAM" attributes="__const__" citdl="Hash" />
        <variable name="USAGE_ANALYSIS_REGS" attributes="__const__" citdl="Hash" />
      </scope>
      <scope name="Thread" ilk="class" classrefs="Object" >
        <scope name="abort_on_exception" ilk="function" signature="abort_on_exception()" doc="Returns the status of the thread-local ``abort on exception&apos;&apos; condition for thr. The default is false. See also Thread::abort_on_exception=." />
        <scope name="abort_on_exception=" ilk="function" signature="abort_on_exception=(p1)" doc="When set to true, causes all threads (including the main program) to abort if an exception is raised in thr. The process will effectively exit(0)." />
        <scope name="add_trace_func" ilk="function" signature="add_trace_func(p1)" doc="Adds _proc_ as a handler for tracing. See Thread#set_trace_func and +set_trace_func+." />
        <scope name="alive?" ilk="function" signature="alive?()" doc="Returns true if thr is running or sleeping. &#xA; thr = Thread.new { }&#xA;thr.join                =&gt; #&lt;Thread:0x401b3fb0 dead&gt;&#xA;Thread.current.alive?   =&gt; true&#xA;thr.alive?              =&gt; false" />
        <scope name="backtrace" ilk="function" signature="backtrace()" doc="Returns the current back trace of the _thr_." />
        <scope name="exit" ilk="function" signature="exit()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="group" ilk="function" signature="group()" doc="Returns the ThreadGroup which contains thr, or nil if the thread is not a member of any group. &#xA; Thread.main.group   =&gt; #&lt;ThreadGroup:0x4029d914&gt;" />
        <scope name="join" ilk="function" signature="join(p1 = v1)" doc="The calling thread will suspend execution and run thr. Does not return until thr exits or until limit seconds have passed. If the time limit expires, nil will be returned, otherwise thr is returned. &#xA; Any threads not joined will be killed when the main program exits.  If thr had previously raised an exception and the abort_on_exception and $DEBUG flags are not set (so the exception has not yet been processed) it will be processed at this time. &#xA; a = Thread.new { print &quot;a&quot;; sleep(10); print &quot;b&quot;; print &quot;c&quot; }&#xA;x = Thread.new { print &quot;x&quot;; Thread.pass; print &quot;y&quot;; print &quot;z&quot; }&#xA;x.join # Let x thread finish, a will be killed on exit.&#xA; produces: &#xA; axyz&#xA; The following example illustrates the limit parameter. &#xA; y = Thread.new { 4.times { sleep 0.1; puts &apos;tick... &apos; }}&#xA;puts &quot;Waiting&quot; until y.join(0.15)&#xA; produces: &#xA; tick...&#xA;Waiting" />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given string (or symbol) exists as a thread-local variable. &#xA; me = Thread.current&#xA;me[:oliver] = &quot;a&quot;&#xA;me.key?(:oliver)    =&gt; true&#xA;me.key?(:stanley)   =&gt; false" />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns an an array of the names of the thread-local variables (as Symbols). &#xA; thr = Thread.new do&#xA;  Thread.current[:cat] = &apos;meow&apos;&#xA;  Thread.current[&quot;dog&quot;] = &apos;woof&apos;&#xA;end&#xA;thr.join   =&gt; #&lt;Thread:0x401b3f10 dead&gt;&#xA;thr.keys   =&gt; [:dog, :cat]" />
        <scope name="kill" ilk="function" signature="kill()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="priority" ilk="function" signature="priority()" doc="Returns the priority of thr. Default is inherited from the current thread which creating the new thread, or zero for the initial main thread; higher-priority thread will run more frequently than lower-priority threads (but lower-priority threads can also run). &#xA; This is just hint for Ruby thread scheduler.  It may be ignored on some platform. &#xA; Thread.current.priority   =&gt; 0" />
        <scope name="priority=" ilk="function" signature="priority=(p1)" doc="Sets the priority of thr to integer. Higher-priority threads will run more frequently than lower-priority threads (but lower-priority threads can also run). &#xA; This is just hint for Ruby thread scheduler.  It may be ignored on some platform. &#xA; count1 = count2 = 0&#xA;a = Thread.new do&#xA;      loop { count1 += 1 }&#xA;    end&#xA;a.priority = -1&#xA;b = Thread.new do&#xA;      loop { count2 += 1 }&#xA;    end&#xA;b.priority = -2&#xA;sleep 1   =&gt; 1&#xA;count1    =&gt; 622504" />
        <scope name="raise" ilk="function" signature="raise(*args)" doc="Raises an exception (see Kernel::raise) from thr. The caller does not have to be thr. &#xA; Thread.abort_on_exception = true&#xA;a = Thread.new { sleep(200) }&#xA;a.raise(&quot;Gotcha&quot;)&#xA; produces: &#xA; prog.rb:3: Gotcha (RuntimeError)&#xA; from prog.rb:2:in `initialize&apos;&#xA; from prog.rb:2:in `new&apos;&#xA; from prog.rb:2" />
        <scope name="run" ilk="function" signature="run()" doc="Wakes up thr, making it eligible for scheduling. &#xA; a = Thread.new { puts &quot;a&quot;; Thread.stop; puts &quot;c&quot; }&#xA;sleep 0.1 while a.status!=&apos;sleep&apos;&#xA;puts &quot;Got here&quot;&#xA;a.run&#xA;a.join&#xA; produces: &#xA; a&#xA;Got here&#xA;c" />
        <scope name="safe_level" ilk="function" signature="safe_level()" doc="Returns the safe level in effect for thr. Setting thread-local safe levels can help when implementing sandboxes which run insecure code. &#xA; thr = Thread.new { $SAFE = 3; sleep }&#xA;Thread.current.safe_level   =&gt; 0&#xA;thr.safe_level              =&gt; 3" />
        <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ on _thr_ as the handler for tracing, or disables tracing if the parameter is +nil+. See +set_trace_func+." />
        <scope name="status" ilk="function" signature="status()" doc="Returns the status of thr: ``sleep&apos;&apos; if thr is sleeping or waiting on I/O, ``run&apos;&apos; if thr is executing, ``aborting&apos;&apos; if thr is aborting, false if thr terminated normally, and nil if thr terminated with an exception. &#xA; a = Thread.new { raise(&quot;die now&quot;) }&#xA;b = Thread.new { Thread.stop }&#xA;c = Thread.new { Thread.exit }&#xA;d = Thread.new { sleep }&#xA;d.kill                  =&gt; #&lt;Thread:0x401b3678 aborting&gt;&#xA;a.status                =&gt; nil&#xA;b.status                =&gt; &quot;sleep&quot;&#xA;c.status                =&gt; false&#xA;d.status                =&gt; &quot;aborting&quot;&#xA;Thread.current.status   =&gt; &quot;run&quot;" />
        <scope name="stop?" ilk="function" signature="stop?()" doc="Returns true if thr is dead or sleeping. &#xA; a = Thread.new { Thread.stop }&#xA;b = Thread.current&#xA;a.stop?   =&gt; true&#xA;b.stop?   =&gt; false" />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Terminates thr and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exits the process." />
        <scope name="value" ilk="function" signature="value()" doc="Waits for thr to complete (via Thread#join) and returns its value. &#xA; a = Thread.new { 2 + 2 }&#xA;a.value   =&gt; 4" />
        <scope name="wakeup" ilk="function" signature="wakeup()" doc="Marks thr as eligible for scheduling (it may still remain blocked on I/O, however). Does not invoke the scheduler (see Thread#run). &#xA; c = Thread.new { Thread.stop; puts &quot;hey!&quot; }&#xA;sleep 0.1 while c.status!=&apos;sleep&apos;&#xA;c.wakeup&#xA;c.join&#xA; produces: &#xA; hey!" />
        <scope name="abort_on_exception" ilk="function" attributes="__classmethod__" signature="abort_on_exception()" doc="Returns the status of the global ``abort on exception&apos;&apos; condition.  The default is false. When set to true, or if the global $DEBUG flag is true (perhaps because the command line option -d was specified) all threads will abort (the process will exit(0)) if an exception is raised in any thread. See also Thread::abort_on_exception=." />
        <scope name="abort_on_exception=" ilk="function" attributes="__classmethod__" signature="abort_on_exception=(p1)" doc="When set to true, all threads will abort if an exception is raised. Returns the new state. &#xA; Thread.abort_on_exception = true&#xA;t1 = Thread.new do&#xA;  puts  &quot;In new thread&quot;&#xA;  raise &quot;Exception from thread&quot;&#xA;end&#xA;sleep(1)&#xA;puts &quot;not reached&quot;&#xA; produces: &#xA; In new thread&#xA;prog.rb:4: Exception from thread (RuntimeError)&#xA; from prog.rb:2:in `initialize&apos;&#xA; from prog.rb:2:in `new&apos;" />
        <scope name="current" ilk="function" attributes="__classmethod__" signature="current()" doc="Returns the currently executing thread. &#xA; Thread.current   =&gt; #&lt;Thread:0x401bdf4c run&gt;" />
        <scope name="exclusive" ilk="function" attributes="__classmethod__" signature="exclusive()" doc="Wraps a block in Thread.critical, restoring the original value upon exit from the critical section, and returns the value of the block." />
        <scope name="exit" ilk="function" attributes="__classmethod__" signature="exit()" doc="Terminates the currently running thread and schedules another thread to be run. If this thread is already marked to be killed, exit returns the Thread. If this is the main thread, or the last thread, exit the process." />
        <scope name="fork" ilk="function" attributes="__classmethod__" signature="fork(*args)" doc="Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass&apos;s initialize method." />
        <scope name="kill" ilk="function" attributes="__classmethod__" signature="kill(p1)" doc="Causes the given thread to exit (see Thread::exit). &#xA; count = 0&#xA;a = Thread.new { loop { count += 1 } }&#xA;sleep(0.1)       =&gt; 0&#xA;Thread.kill(a)   =&gt; #&lt;Thread:0x401b3d30 dead&gt;&#xA;count            =&gt; 93947&#xA;a.alive?         =&gt; false" />
        <scope name="list" ilk="function" attributes="__classmethod__" signature="list()" doc="Returns an array of Thread objects for all threads that are either runnable or stopped. &#xA; Thread.new { sleep(200) }&#xA;Thread.new { 1000000.times {|i| i*i } }&#xA;Thread.new { Thread.stop }&#xA;Thread.list.each {|t| p t}&#xA; produces: &#xA; #&lt;Thread:0x401b3e84 sleep&gt;&#xA;#&lt;Thread:0x401b3f38 run&gt;&#xA;#&lt;Thread:0x401b3fb0 sleep&gt;&#xA;#&lt;Thread:0x401bdf4c run&gt;" />
        <scope name="main" ilk="function" attributes="__classmethod__" signature="main()" doc="Returns the main thread." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*arg, &amp;block)" />
        <scope name="pass" ilk="function" attributes="__classmethod__" signature="pass()" doc="Give the thread scheduler a hint to pass execution to another thread. A running thread may or may not switch, it depends on OS and processor." />
        <scope name="start" ilk="function" attributes="__classmethod__" signature="start(*args)" doc="Basically the same as Thread::new. However, if class Thread is subclassed, then calling start in that subclass will not invoke the subclass&apos;s initialize method." />
        <scope name="stop" ilk="function" attributes="__classmethod__" signature="stop()" doc="Stops execution of the current thread, putting it into a ``sleep&apos;&apos; state, and schedules execution of another thread. &#xA; a = Thread.new { print &quot;a&quot;; Thread.stop; print &quot;c&quot; }&#xA;sleep 0.1 while a.status!=&apos;sleep&apos;&#xA;print &quot;b&quot;&#xA;a.run&#xA;a.join&#xA; produces: &#xA; abc" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*arg, &amp;block)" />
        <variable name="MUTEX_FOR_THREAD_EXCLUSIVE" attributes="__const__" citdl="Mutex" />
      </scope>
      <variable name="TOPLEVEL_BINDING" attributes="__const__" citdl="Binding" />
      <scope name="ThreadGroup" ilk="class" classrefs="Object" >
        <scope name="add" ilk="function" signature="add(p1)" doc="Adds the given thread to this group, removing it from any other group to which it may have previously belonged. &#xA; puts &quot;Initial group is #{ThreadGroup::Default.list}&quot;&#xA;tg = ThreadGroup.new&#xA;t1 = Thread.new { sleep }&#xA;t2 = Thread.new { sleep }&#xA;puts &quot;t1 is #{t1}&quot;&#xA;puts &quot;t2 is #{t2}&quot;&#xA;tg.add(t1)&#xA;puts &quot;Initial group now #{ThreadGroup::Default.list}&quot;&#xA;puts &quot;tg group now #{tg.list}&quot;&#xA; produces: &#xA; Initial group is #&lt;Thread:0x401bdf4c&gt;&#xA;t1 is #&lt;Thread:0x401b3c90&gt;" />
        <scope name="enclose" ilk="function" signature="enclose()" doc="Prevents threads from being added to or removed from the receiving ThreadGroup. New threads can still be started in an enclosed ThreadGroup. &#xA; ThreadGroup::Default.enclose        =&gt; #&lt;ThreadGroup:0x4029d914&gt;&#xA;thr = Thread::new { Thread.stop }   =&gt; #&lt;Thread:0x402a7210 sleep&gt;&#xA;tg = ThreadGroup::new               =&gt; #&lt;ThreadGroup:0x402752d4&gt;&#xA;tg.add thr&#xA; produces: &#xA; ThreadError: can&apos;t move from the enclosed thread group" />
        <scope name="enclosed?" ilk="function" signature="enclosed?()" doc="Returns true if thgrp is enclosed. See also ThreadGroup#enclose." />
        <scope name="list" ilk="function" signature="list()" doc="Returns an array of all existing Thread objects that belong to this group. &#xA; ThreadGroup::Default.list   =&gt; [#&lt;Thread:0x401bdf4c run&gt;]" />
        <variable name="Default" attributes="__const__" citdl="ThreadGroup" />
      </scope>
      <scope name="Mutex" ilk="class" classrefs="Object" >
        <scope name="lock" ilk="function" signature="lock()" doc="Attempts to grab the lock and waits if it isn&apos;t available. Raises +ThreadError+ if +mutex+ was locked by the current thread." />
        <scope name="locked?" ilk="function" signature="locked?()" doc="Returns +true+ if this lock is currently held by some thread." />
        <scope name="sleep" ilk="function" signature="sleep(p1 = v1)" doc="Releases the lock and sleeps +timeout+ seconds if it is given and non-nil or forever.  Raises +ThreadError+ if +mutex+ wasn&apos;t locked by the current thread." />
        <scope name="synchronize" ilk="function" signature="synchronize()" doc="Obtains a lock, runs the block, and releases the lock when the block completes.  See the example under Mutex." />
        <scope name="try_lock" ilk="function" signature="try_lock()" doc="Attempts to obtain the lock and returns immediately. Returns +true+ if the lock was granted." />
        <scope name="unlock" ilk="function" signature="unlock()" doc="Releases the lock. Raises +ThreadError+ if +mutex+ wasn&apos;t locked by the current thread." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new Mutex" />
      </scope>
      <scope name="ThreadError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Fiber" ilk="class" classrefs="Object" >
        <scope name="resume" ilk="function" signature="resume(*args)" doc="Resumes the fiber from the point at which the last Fiber.yield was called, or starts running it if it is the first call to resume. Arguments passed to resume will be the value of the Fiber.yield expression or will be passed as block parameters to the fiber&apos;s block if this is the first resume. &#xA; Alternatively, when resume is called it evaluates to the arguments passed to the next Fiber.yield statement inside the fiber&apos;s block or to the block value if it runs to completion without any Fiber.yield" />
        <scope name="yield" ilk="function" attributes="__classmethod__" signature="yield(*args)" doc="Yields control back to the context that resumed the fiber, passing along any arguments that were passed to it. The fiber will resume processing at this point when resume is called next. Any arguments passed to the next resume will be the value that this Fiber.yield expression evaluates to." />
      </scope>
      <scope name="FiberError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="Rational" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rationalize" ilk="function" signature="rationalize(p1 = v1)" doc="Returns a simpler approximation of the value if an optional argument eps is given (rat-|eps| &lt;= result &lt;= rat+|eps|), self otherwise. &#xA; For example: &#xA; r = Rational(5033165, 16777216)&#xA;r.rationalize                    =&gt; (5033165/16777216)&#xA;r.rationalize(Rational(&apos;0.01&apos;))  =&gt; (3/10)&#xA;r.rationalize(Rational(&apos;0.1&apos;))   =&gt; (1/3)" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Return the value as a float. &#xA; For example: &#xA; Rational(2).to_f      =&gt; 2.0&#xA;Rational(9, 4).to_f   =&gt; 2.25&#xA;Rational(-3, 4).to_f  =&gt; -0.75&#xA;Rational(20, 3).to_f  =&gt; 6.666666666666667" />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the truncated value as an integer. &#xA; Equivalent to rat.truncate.&#xA; For example: &#xA; Rational(2, 3).to_i   =&gt; 0&#xA;Rational(3).to_i      =&gt; 3&#xA;Rational(300.6).to_i  =&gt; 300&#xA;Rational(98,71).to_i  =&gt; 1&#xA;Rational(-30,2).to_i  =&gt; -15" />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Returns self. &#xA; For example: &#xA; Rational(2).to_r      =&gt; (2/1)&#xA;Rational(-8, 6).to_r  =&gt; (-4/3)" />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
      </scope>
      <scope name="Complex" ilk="class" classrefs="Numeric" >
        <import symbol="Comparable" />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="rationalize" ilk="function" signature="rationalize(p1 = v1)" doc="If the imaginary part is exactly 0, returns the real part as a Rational, otherwise a RangeError is raised." />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns the value as a float if possible." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value as an integer if possible." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="If the imaginary part is exactly 0, returns the real part as a Rational, otherwise a RangeError is raised." />
        <scope name="polar" ilk="function" attributes="__classmethod__" signature="polar(p1, p2 = v2)" doc="Returns a complex object which denotes the given polar form. &#xA; Complex.polar(3, 0)           =&gt; (3.0+0.0i)&#xA;Complex.polar(3, Math::PI/2)  =&gt; (1.836909530733566e-16+3.0i)&#xA;Complex.polar(3, Math::PI)    =&gt; (-3.0+3.673819061467132e-16i)&#xA;Complex.polar(3, -Math::PI/2) =&gt; (1.836909530733566e-16-3.0i)" />
        <scope name="rect" ilk="function" attributes="__classmethod__" signature="rect(p1, p2 = v2)" doc="Returns a complex object which denotes the given rectangular form." />
        <scope name="rectangular" ilk="function" attributes="__classmethod__" signature="rectangular(p1, p2 = v2)" doc="Returns a complex object which denotes the given rectangular form." />
        <scope name="yaml_new" ilk="function" attributes="__classmethod__" />
        <variable name="I" attributes="__const__" citdl="Complex" />
      </scope>
      <variable name="RUBY_VERSION" attributes="__const__" citdl="String" />
      <variable name="RUBY_RELEASE_DATE" attributes="__const__" citdl="String" />
      <variable name="RUBY_PLATFORM" attributes="__const__" citdl="String" />
      <variable name="RUBY_PATCHLEVEL" attributes="__const__" citdl="Fixnum" />
      <variable name="RUBY_REVISION" attributes="__const__" citdl="Fixnum" />
      <variable name="RUBY_DESCRIPTION" attributes="__const__" citdl="String" />
      <variable name="RUBY_COPYRIGHT" attributes="__const__" citdl="String" />
      <variable name="RUBY_ENGINE" attributes="__const__" citdl="String" />
      <variable name="ARGV" attributes="__const__" citdl="Array" />
      <scope name="Gem" ilk="namespace" >
        <scope name="activate" ilk="function" />
        <scope name="all_load_paths" ilk="function" />
        <scope name="available?" ilk="function" />
        <scope name="bin_path" ilk="function" />
        <scope name="binary_mode" ilk="function" />
        <scope name="bindir" ilk="function" />
        <scope name="cache" ilk="function" />
        <scope name="clear_paths" ilk="function" />
        <scope name="config_file" ilk="function" />
        <scope name="configuration" ilk="function" />
        <scope name="configuration=" ilk="function" />
        <scope name="datadir" ilk="function" />
        <scope name="default_bindir" ilk="function" />
        <scope name="default_dir" ilk="function" />
        <scope name="default_exec_format" ilk="function" />
        <scope name="default_path" ilk="function" />
        <scope name="default_sources" ilk="function" />
        <scope name="default_system_source_cache_dir" ilk="function" />
        <scope name="default_user_source_cache_dir" ilk="function" />
        <scope name="deflate" ilk="function" />
        <scope name="dir" ilk="function" />
        <scope name="ensure_gem_subdirectories" ilk="function" />
        <scope name="find_files" ilk="function" />
        <scope name="gunzip" ilk="function" />
        <scope name="gzip" ilk="function" />
        <scope name="inflate" ilk="function" />
        <scope name="latest_load_paths" ilk="function" />
        <scope name="load_path_insert_index" ilk="function" />
        <scope name="load_plugins" ilk="function" />
        <scope name="loaded_specs" ilk="function" />
        <scope name="location_of_caller" ilk="function" />
        <scope name="marshal_version" ilk="function" />
        <scope name="path" ilk="function" />
        <scope name="platforms" ilk="function" />
        <scope name="platforms=" ilk="function" />
        <scope name="post_install" ilk="function" />
        <scope name="post_install_hooks" ilk="function" />
        <scope name="post_uninstall" ilk="function" />
        <scope name="post_uninstall_hooks" ilk="function" />
        <scope name="pre_install" ilk="function" />
        <scope name="pre_install_hooks" ilk="function" />
        <scope name="pre_uninstall" ilk="function" />
        <scope name="pre_uninstall_hooks" ilk="function" />
        <scope name="prefix" ilk="function" />
        <scope name="promote_load_path" ilk="function" />
        <scope name="read_binary" ilk="function" />
        <scope name="refresh" ilk="function" />
        <scope name="remove_prelude_paths" ilk="function" />
        <scope name="required_location" ilk="function" />
        <scope name="ruby" ilk="function" />
        <scope name="ruby_engine" ilk="function" />
        <scope name="ruby_version" ilk="function" />
        <scope name="searcher" ilk="function" />
        <scope name="source_index" ilk="function" />
        <scope name="sources" ilk="function" />
        <scope name="sources=" ilk="function" />
        <scope name="suffix_pattern" ilk="function" />
        <scope name="suffixes" ilk="function" />
        <scope name="time" ilk="function" />
        <scope name="try_activate" ilk="function" />
        <scope name="ui" ilk="function" />
        <scope name="use_paths" ilk="function" />
        <scope name="user_dir" ilk="function" />
        <scope name="user_home" ilk="function" />
        <scope name="win_platform?" ilk="function" />
        <scope name="Builder" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="build" ilk="function" />
          <scope name="success" ilk="function" />
        </scope>
        <scope name="Cache" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <import symbol="Enumerable" />
          <scope name="add_spec" ilk="function" />
          <scope name="add_specs" ilk="function" />
          <scope name="all_gems" ilk="function" />
          <scope name="dump" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="find_name" ilk="function" />
          <scope name="gem_signature" ilk="function" />
          <scope name="gems" ilk="function" />
          <scope name="index_signature" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="length" ilk="function" />
          <scope name="load_gems_in" ilk="function" />
          <scope name="outdated" ilk="function" />
          <scope name="prerelease_gems" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="refresh!" ilk="function" />
          <scope name="released_gems" ilk="function" />
          <scope name="released_specs" ilk="function" />
          <scope name="remove_spec" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="spec_dirs" ilk="function" />
          <scope name="spec_dirs=" ilk="function" />
          <scope name="specification" ilk="function" />
          <scope name="update" ilk="function" />
          <scope name="alert" ilk="function" attributes="__classmethod__" />
          <scope name="alert_error" ilk="function" attributes="__classmethod__" />
          <scope name="alert_warning" ilk="function" attributes="__classmethod__" />
          <scope name="ask" ilk="function" attributes="__classmethod__" />
          <scope name="ask_for_password" ilk="function" attributes="__classmethod__" />
          <scope name="ask_yes_no" ilk="function" attributes="__classmethod__" />
          <scope name="choose_from_list" ilk="function" attributes="__classmethod__" />
          <scope name="from_gems_in" ilk="function" attributes="__classmethod__" />
          <scope name="from_installed_gems" ilk="function" attributes="__classmethod__" />
          <scope name="installed_spec_directories" ilk="function" attributes="__classmethod__" />
          <scope name="load_specification" ilk="function" attributes="__classmethod__" />
          <scope name="say" ilk="function" attributes="__classmethod__" />
          <scope name="terminate_interaction" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="CommandLineError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="ConfigFile" ilk="class" classrefs="Object" >
          <scope name="args" ilk="function" />
          <scope name="backtrace" ilk="function" />
          <scope name="backtrace=" ilk="function" />
          <scope name="benchmark" ilk="function" />
          <scope name="benchmark=" ilk="function" />
          <scope name="bulk_threshold" ilk="function" />
          <scope name="bulk_threshold=" ilk="function" />
          <scope name="config_file_name" ilk="function" />
          <scope name="credentials_path" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="handle_arguments" ilk="function" />
          <scope name="home" ilk="function" />
          <scope name="home=" ilk="function" />
          <scope name="load_file" ilk="function" />
          <scope name="load_rubygems_api_key" ilk="function" />
          <scope name="path" ilk="function" />
          <scope name="path=" ilk="function" />
          <scope name="really_verbose" ilk="function" />
          <scope name="rubygems_api_key" ilk="function" />
          <scope name="rubygems_api_key=" ilk="function" />
          <scope name="update_sources" ilk="function" />
          <scope name="update_sources=" ilk="function" />
          <scope name="verbose" ilk="function" />
          <scope name="verbose=" ilk="function" />
          <scope name="write" ilk="function" />
          <variable name="DEFAULT_BACKTRACE" attributes="__const__" citdl="FalseClass" />
          <variable name="DEFAULT_BENCHMARK" attributes="__const__" citdl="FalseClass" />
          <variable name="DEFAULT_BULK_THRESHOLD" attributes="__const__" citdl="Fixnum" />
          <variable name="DEFAULT_UPDATE_SOURCES" attributes="__const__" citdl="TrueClass" />
          <variable name="DEFAULT_VERBOSITY" attributes="__const__" citdl="TrueClass" />
          <variable name="OPERATING_SYSTEM_DEFAULTS" attributes="__const__" citdl="Hash" />
          <variable name="PLATFORM_DEFAULTS" attributes="__const__" citdl="Hash" />
          <variable name="SYSTEM_WIDE_CONFIG_FILE" attributes="__const__" citdl="String" />
        </scope>
        <variable name="ConfigMap" attributes="__const__" citdl="Hash" />
        <scope name="ConsoleUI" ilk="class" classrefs="Gem::StreamUI" >
          <scope name="SilentProgressReporter" ilk="class" classrefs="Object" >
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="SimpleProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="VerboseProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
        </scope>
        <variable name="DIRECTORIES" attributes="__const__" citdl="Array" />
        <scope name="DefaultUserInteraction" ilk="namespace" >
          <scope name="ui" ilk="function" />
          <scope name="ui" ilk="function" />
          <scope name="ui=" ilk="function" />
          <scope name="ui=" ilk="function" />
          <scope name="use_ui" ilk="function" />
          <scope name="use_ui" ilk="function" />
        </scope>
        <scope name="Dependency" ilk="class" classrefs="Object" >
          <scope name="__requirement" ilk="function" />
          <scope name="match?" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="prerelease=" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="requirement" ilk="function" />
          <scope name="requirements_list" ilk="function" />
          <scope name="type" ilk="function" />
          <scope name="version_requirement" ilk="function" />
          <scope name="version_requirements" ilk="function" />
          <scope name="version_requirements=" ilk="function" />
          <scope name="warned_version_requirement" ilk="function" attributes="__classmethod__" />
          <scope name="warned_version_requirement=" ilk="function" attributes="__classmethod__" />
          <variable name="TYPES" attributes="__const__" citdl="Array" />
        </scope>
        <scope name="DependencyError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="DependencyRemovalException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="DocumentError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="EndOfYAMLException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Exception" ilk="class" classrefs="RuntimeError" >
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1)" doc="Construct a new Exception object, optionally passing in a message." />
        </scope>
        <scope name="FilePermissionError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="FormatException" ilk="class" classrefs="Gem::Exception" >
          <scope name="file_path" ilk="function" />
          <scope name="file_path=" ilk="function" />
        </scope>
        <variable name="GEM_PRELUDE_METHODS" attributes="__const__" citdl="Array" />
        <scope name="GemNotFoundException" ilk="class" classrefs="Gem::Exception" >
          <scope name="errors" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="version" ilk="function" />
        </scope>
        <scope name="GemNotInHomeException" ilk="class" classrefs="Gem::Exception" >
          <scope name="spec" ilk="function" />
          <scope name="spec=" ilk="function" />
        </scope>
        <scope name="GemPathSearcher" ilk="class" classrefs="Object" >
          <scope name="find" ilk="function" />
          <scope name="find_all" ilk="function" />
          <scope name="init_gemspecs" ilk="function" />
          <scope name="lib_dirs_for" ilk="function" />
          <scope name="matching_file?" ilk="function" />
          <scope name="matching_files" ilk="function" />
        </scope>
        <scope name="InstallError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="InvalidSpecificationException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="LoadError" ilk="class" classrefs="LoadError" >
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="version_requirement" ilk="function" />
          <scope name="version_requirement=" ilk="function" />
        </scope>
        <variable name="MARSHAL_SPEC_DIR" attributes="__const__" citdl="String" />
        <variable name="MUTEX" attributes="__const__" citdl="Mutex" />
        <scope name="OperationNotSupportedError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Platform" ilk="class" classrefs="Object" >
          <scope name="cpu" ilk="function" />
          <scope name="cpu=" ilk="function" />
          <scope name="empty?" ilk="function" />
          <scope name="os" ilk="function" />
          <scope name="os=" ilk="function" />
          <scope name="to_a" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="version=" ilk="function" />
          <scope name="local" ilk="function" attributes="__classmethod__" />
          <scope name="match" ilk="function" attributes="__classmethod__" />
          <scope name="new" ilk="function" attributes="__classmethod__" />
          <variable name="CURRENT" attributes="__const__" citdl="String" />
          <variable name="RUBY" attributes="__const__" citdl="String" />
        </scope>
        <scope name="QuickLoader" ilk="namespace" >
          <scope name="load_full_rubygems_library" ilk="function" />
          <scope name="path_to_full_rubygems_library" ilk="function" />
          <scope name="remove" ilk="function" />
        </scope>
        <scope name="RemoteError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteInstallationCancelled" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteInstallationSkipped" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="RemoteSourceException" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Requirement" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="as_list" ilk="function" />
          <scope name="marshal_dump" ilk="function" />
          <scope name="marshal_load" ilk="function" />
          <scope name="none?" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="requirements" ilk="function" />
          <scope name="satisfied_by?" ilk="function" />
          <scope name="create" ilk="function" attributes="__classmethod__" />
          <scope name="default" ilk="function" attributes="__classmethod__" />
          <scope name="parse" ilk="function" attributes="__classmethod__" />
          <variable name="OPS" attributes="__const__" citdl="Hash" />
          <variable name="PATTERN" attributes="__const__" citdl="Regexp" />
        </scope>
        <variable name="RubyGemsPackageVersion" attributes="__const__" citdl="String" />
        <variable name="RubyGemsVersion" attributes="__const__" citdl="String" />
        <scope name="SilentUI" ilk="class" classrefs="Object" >
          <scope name="method_missing" ilk="function" />
        </scope>
        <scope name="SourceIndex" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <import symbol="Enumerable" />
          <scope name="add_spec" ilk="function" />
          <scope name="add_specs" ilk="function" />
          <scope name="all_gems" ilk="function" />
          <scope name="dump" ilk="function" />
          <scope name="each" ilk="function" />
          <scope name="find_name" ilk="function" />
          <scope name="gem_signature" ilk="function" />
          <scope name="gems" ilk="function" />
          <scope name="index_signature" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="length" ilk="function" />
          <scope name="load_gems_in" ilk="function" />
          <scope name="outdated" ilk="function" />
          <scope name="prerelease_gems" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="refresh!" ilk="function" />
          <scope name="released_gems" ilk="function" />
          <scope name="released_specs" ilk="function" />
          <scope name="remove_spec" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="size" ilk="function" />
          <scope name="spec_dirs" ilk="function" />
          <scope name="spec_dirs=" ilk="function" />
          <scope name="specification" ilk="function" />
          <scope name="update" ilk="function" />
          <scope name="alert" ilk="function" attributes="__classmethod__" />
          <scope name="alert_error" ilk="function" attributes="__classmethod__" />
          <scope name="alert_warning" ilk="function" attributes="__classmethod__" />
          <scope name="ask" ilk="function" attributes="__classmethod__" />
          <scope name="ask_for_password" ilk="function" attributes="__classmethod__" />
          <scope name="ask_yes_no" ilk="function" attributes="__classmethod__" />
          <scope name="choose_from_list" ilk="function" attributes="__classmethod__" />
          <scope name="from_gems_in" ilk="function" attributes="__classmethod__" />
          <scope name="from_installed_gems" ilk="function" attributes="__classmethod__" />
          <scope name="installed_spec_directories" ilk="function" attributes="__classmethod__" />
          <scope name="load_specification" ilk="function" attributes="__classmethod__" />
          <scope name="say" ilk="function" attributes="__classmethod__" />
          <scope name="terminate_interaction" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="SpecFetcher" ilk="class" classrefs="Object" >
          <import symbol="Gem::UserInteraction" />
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="cache_dir" ilk="function" />
          <scope name="dir" ilk="function" />
          <scope name="fetch" ilk="function" />
          <scope name="fetch_spec" ilk="function" />
          <scope name="fetch_with_errors" ilk="function" />
          <scope name="find_matching" ilk="function" />
          <scope name="find_matching_with_errors" ilk="function" />
          <scope name="latest_specs" ilk="function" />
          <scope name="legacy_repos" ilk="function" />
          <scope name="list" ilk="function" />
          <scope name="load_specs" ilk="function" />
          <scope name="prerelease_specs" ilk="function" />
          <scope name="specs" ilk="function" />
          <scope name="warn_legacy" ilk="function" />
          <scope name="fetcher" ilk="function" attributes="__classmethod__" />
          <scope name="fetcher=" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Specification" ilk="class" classrefs="Object" >
          <scope name="_dump" ilk="function" />
          <scope name="add_bindir" ilk="function" />
          <scope name="add_dependency" ilk="function" />
          <scope name="add_development_dependency" ilk="function" />
          <scope name="add_runtime_dependency" ilk="function" />
          <scope name="assign_defaults" ilk="function" />
          <scope name="author" ilk="function" />
          <scope name="author=" ilk="function" />
          <scope name="authors" ilk="function" />
          <scope name="authors=" ilk="function" />
          <scope name="autorequire" ilk="function" />
          <scope name="autorequire=" ilk="function" />
          <scope name="bindir" ilk="function" />
          <scope name="bindir=" ilk="function" />
          <scope name="cert_chain" ilk="function" />
          <scope name="cert_chain=" ilk="function" />
          <scope name="date" ilk="function" />
          <scope name="date=" ilk="function" />
          <scope name="default_executable" ilk="function" />
          <scope name="default_executable=" ilk="function" />
          <scope name="dependencies" ilk="function" />
          <scope name="dependent_gems" ilk="function" />
          <scope name="description" ilk="function" />
          <scope name="description=" ilk="function" />
          <scope name="development_dependencies" ilk="function" />
          <scope name="email" ilk="function" />
          <scope name="email=" ilk="function" />
          <scope name="encode_with" ilk="function" />
          <scope name="executable" ilk="function" />
          <scope name="executable=" ilk="function" />
          <scope name="executables" ilk="function" />
          <scope name="executables=" ilk="function" />
          <scope name="extensions" ilk="function" />
          <scope name="extensions=" ilk="function" />
          <scope name="extra_rdoc_files" ilk="function" />
          <scope name="extra_rdoc_files=" ilk="function" />
          <scope name="file_name" ilk="function" />
          <scope name="files" ilk="function" />
          <scope name="files=" ilk="function" />
          <scope name="full_gem_path" ilk="function" />
          <scope name="full_name" ilk="function" />
          <scope name="has_rdoc" ilk="function" />
          <scope name="has_rdoc=" ilk="function" />
          <scope name="has_rdoc?" ilk="function" />
          <scope name="has_test_suite?" ilk="function" />
          <scope name="has_unit_tests?" ilk="function" />
          <scope name="homepage" ilk="function" />
          <scope name="homepage=" ilk="function" />
          <scope name="init_with" ilk="function" />
          <scope name="installation_path" ilk="function" />
          <scope name="lib_files" ilk="function" />
          <scope name="license" ilk="function" />
          <scope name="license=" ilk="function" />
          <scope name="licenses" ilk="function" />
          <scope name="licenses=" ilk="function" />
          <scope name="loaded" ilk="function" />
          <scope name="loaded=" ilk="function" />
          <scope name="loaded?" ilk="function" />
          <scope name="loaded_from" ilk="function" />
          <scope name="loaded_from=" ilk="function" />
          <scope name="mark_version" ilk="function" />
          <scope name="method_missing" ilk="function" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
          <scope name="normalize" ilk="function" />
          <scope name="original_name" ilk="function" />
          <scope name="original_platform" ilk="function" />
          <scope name="original_platform=" ilk="function" />
          <scope name="platform" ilk="function" />
          <scope name="platform=" ilk="function" />
          <scope name="post_install_message" ilk="function" />
          <scope name="post_install_message=" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="rdoc_options" ilk="function" />
          <scope name="rdoc_options=" ilk="function" />
          <scope name="require_path" ilk="function" />
          <scope name="require_path=" ilk="function" />
          <scope name="require_paths" ilk="function" />
          <scope name="require_paths=" ilk="function" />
          <scope name="required_ruby_version" ilk="function" />
          <scope name="required_ruby_version=" ilk="function" />
          <scope name="required_rubygems_version" ilk="function" />
          <scope name="required_rubygems_version=" ilk="function" />
          <scope name="requirements" ilk="function" />
          <scope name="requirements=" ilk="function" />
          <scope name="rubyforge_project" ilk="function" />
          <scope name="rubyforge_project=" ilk="function" />
          <scope name="rubygems_version" ilk="function" />
          <scope name="rubygems_version=" ilk="function" />
          <scope name="runtime_dependencies" ilk="function" />
          <scope name="satisfies_requirement?" ilk="function" />
          <scope name="signing_key" ilk="function" />
          <scope name="signing_key=" ilk="function" />
          <scope name="sort_obj" ilk="function" />
          <scope name="spec_name" ilk="function" />
          <scope name="specification_version" ilk="function" />
          <scope name="specification_version=" ilk="function" />
          <scope name="summary" ilk="function" />
          <scope name="summary=" ilk="function" />
          <scope name="test_file" ilk="function" />
          <scope name="test_file=" ilk="function" />
          <scope name="test_files" ilk="function" />
          <scope name="test_files=" ilk="function" />
          <scope name="test_suite_file" ilk="function" />
          <scope name="test_suite_file=" ilk="function" />
          <scope name="to_ruby" ilk="function" />
          <scope name="validate" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="version=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="_load" ilk="function" attributes="__classmethod__" />
          <scope name="array_attribute" ilk="function" attributes="__classmethod__" />
          <scope name="array_attributes" ilk="function" attributes="__classmethod__" />
          <scope name="attribute" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_alias_singular" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_defaults" ilk="function" attributes="__classmethod__" />
          <scope name="attribute_names" ilk="function" attributes="__classmethod__" />
          <scope name="attributes" ilk="function" attributes="__classmethod__" />
          <scope name="default_value" ilk="function" attributes="__classmethod__" />
          <scope name="from_yaml" ilk="function" attributes="__classmethod__" />
          <scope name="load" ilk="function" attributes="__classmethod__" />
          <scope name="normalize_yaml_input" ilk="function" attributes="__classmethod__" />
          <scope name="overwrite_accessor" ilk="function" attributes="__classmethod__" />
          <scope name="read_only" ilk="function" attributes="__classmethod__" />
          <scope name="required_attribute" ilk="function" attributes="__classmethod__" />
          <scope name="required_attribute?" ilk="function" attributes="__classmethod__" />
          <scope name="required_attributes" ilk="function" attributes="__classmethod__" />
          <variable name="CURRENT_SPECIFICATION_VERSION" attributes="__const__" citdl="Fixnum" />
          <variable name="MARSHAL_FIELDS" attributes="__const__" citdl="Hash" />
          <variable name="NONEXISTENT_SPECIFICATION_VERSION" attributes="__const__" citdl="Fixnum" />
          <variable name="SPECIFICATION_VERSION_HISTORY" attributes="__const__" citdl="Hash" />
          <variable name="TODAY" attributes="__const__" citdl="Time" />
        </scope>
        <scope name="StreamUI" ilk="class" classrefs="Object" >
          <scope name="alert" ilk="function" />
          <scope name="alert_error" ilk="function" />
          <scope name="alert_warning" ilk="function" />
          <scope name="ask" ilk="function" />
          <scope name="ask_for_password" ilk="function" />
          <scope name="ask_for_password_on_unix" ilk="function" />
          <scope name="ask_for_password_on_windows" ilk="function" />
          <scope name="ask_yes_no" ilk="function" />
          <scope name="choose_from_list" ilk="function" />
          <scope name="debug" ilk="function" />
          <scope name="errs" ilk="function" />
          <scope name="ins" ilk="function" />
          <scope name="outs" ilk="function" />
          <scope name="progress_reporter" ilk="function" />
          <scope name="say" ilk="function" />
          <scope name="terminate_interaction" ilk="function" />
          <scope name="SilentProgressReporter" ilk="class" classrefs="Object" >
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="SimpleProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
          <scope name="VerboseProgressReporter" ilk="class" classrefs="Object" >
            <import symbol="Gem::DefaultUserInteraction" />
            <scope name="count" ilk="function" />
            <scope name="done" ilk="function" />
            <scope name="updated" ilk="function" />
          </scope>
        </scope>
        <scope name="SystemExitException" ilk="class" classrefs="SystemExit" >
          <scope name="exit_code" ilk="function" />
          <scope name="exit_code=" ilk="function" />
        </scope>
        <scope name="UserInteraction" ilk="namespace" >
          <import symbol="Gem::DefaultUserInteraction" />
          <scope name="alert" ilk="function" />
          <scope name="alert_error" ilk="function" />
          <scope name="alert_warning" ilk="function" />
          <scope name="ask" ilk="function" />
          <scope name="ask_for_password" ilk="function" />
          <scope name="ask_yes_no" ilk="function" />
          <scope name="choose_from_list" ilk="function" />
          <scope name="say" ilk="function" />
          <scope name="terminate_interaction" ilk="function" />
        </scope>
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <scope name="VerificationError" ilk="class" classrefs="Gem::Exception" >
        </scope>
        <scope name="Version" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="bump" ilk="function" />
          <scope name="marshal_dump" ilk="function" />
          <scope name="marshal_load" ilk="function" />
          <scope name="prerelease?" ilk="function" />
          <scope name="pretty_print" ilk="function" />
          <scope name="release" ilk="function" />
          <scope name="segments" ilk="function" />
          <scope name="spermy_recommendation" ilk="function" />
          <scope name="version" ilk="function" />
          <scope name="correct?" ilk="function" attributes="__classmethod__" />
          <scope name="create" ilk="function" attributes="__classmethod__" />
          <variable name="ANCHORED_VERSION_PATTERN" attributes="__const__" citdl="Regexp" />
          <scope name="Requirement" ilk="class" classrefs="Object" >
            <import symbol="Comparable" />
            <scope name="as_list" ilk="function" />
            <scope name="marshal_dump" ilk="function" />
            <scope name="marshal_load" ilk="function" />
            <scope name="none?" ilk="function" />
            <scope name="prerelease?" ilk="function" />
            <scope name="pretty_print" ilk="function" />
            <scope name="requirements" ilk="function" />
            <scope name="satisfied_by?" ilk="function" />
            <scope name="create" ilk="function" attributes="__classmethod__" />
            <scope name="default" ilk="function" attributes="__classmethod__" />
            <scope name="parse" ilk="function" attributes="__classmethod__" />
            <variable name="OPS" attributes="__const__" citdl="Hash" />
            <variable name="PATTERN" attributes="__const__" citdl="Regexp" />
          </scope>
          <variable name="VERSION_PATTERN" attributes="__const__" citdl="String" />
        </scope>
        <variable name="WIN_PATTERNS" attributes="__const__" citdl="Array" />
        <variable name="YAML_SPEC_DIR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="StringScanner" ilk="class" classrefs="Object" >
        <scope name="beginning_of_line?" ilk="function" signature="beginning_of_line?()" doc="Returns +true+ iff the scan pointer is at the beginning of the line. &#xA; s = StringScanner.new(&quot;test\ntest\n&quot;)&#xA;s.bol?           # =&gt; true&#xA;s.scan(/te/)&#xA;s.bol?           # =&gt; false&#xA;s.scan(/st\n/)&#xA;s.bol?           # =&gt; true&#xA;s.terminate&#xA;s.bol?           # =&gt; true" />
        <scope name="bol?" ilk="function" />
        <scope name="check" ilk="function" signature="check(p1)" doc="This returns the value that #scan would return, without advancing the scan pointer.  The match register is affected, though. &#xA; s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;s.check /Fri/               # -&gt; &quot;Fri&quot;&#xA;s.pos                       # -&gt; 0&#xA;s.matched                   # -&gt; &quot;Fri&quot;&#xA;s.check /12/                # -&gt; nil&#xA;s.matched                   # -&gt; nil&#xA; Mnemonic: it &quot;checks&quot; to see whether a #scan will return a value." />
        <scope name="check_until" ilk="function" signature="check_until(p1)" doc="This returns the value that #scan_until would return, without advancing the scan pointer.  The match register is affected, though. &#xA; s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;s.check_until /12/          # -&gt; &quot;Fri Dec 12&quot;&#xA;s.pos                       # -&gt; 0&#xA;s.matched                   # -&gt; 12&#xA; Mnemonic: it &quot;checks&quot; to see whether a #scan_until will return a value." />
        <scope name="clear" ilk="function" signature="clear()" doc="Equivalent to #terminate. This method is obsolete; use #terminate instead." />
        <scope name="concat" ilk="function" signature="concat(p1)" doc="Appends +str+ to the string being scanned. This method does not affect scan pointer. &#xA; s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;s.scan(/Fri /)&#xA;s &lt;&lt; &quot; +1000 GMT&quot;&#xA;s.string            # -&gt; &quot;Fri Dec 12 1975 14:39 +1000 GMT&quot;&#xA;s.scan(/Dec/)       # -&gt; &quot;Dec&quot;" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Equivalent to #eos?. This method is obsolete, use #eos? instead." />
        <scope name="eos?" ilk="function" signature="eos?()" doc="Returns +true+ if the scan pointer is at the end of the string. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;p s.eos?          # =&gt; false&#xA;s.scan(/test/)&#xA;p s.eos?          # =&gt; false&#xA;s.terminate&#xA;p s.eos?          # =&gt; true" />
        <scope name="exist?" ilk="function" signature="exist?(p1)" doc="Looks _ahead_ to see if the +pattern+ exists _anywhere_ in the string, without advancing the scan pointer.  This predicates whether a #scan_until will return a value. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.exist? /s/            # -&gt; 3&#xA;s.scan /test/           # -&gt; &quot;test&quot;&#xA;s.exist? /s/            # -&gt; 2&#xA;s.exist? /e/            # -&gt; nil" />
        <scope name="get_byte" ilk="function" signature="get_byte()" doc="Scans one byte and returns it. This method is not multibyte character sensitive. See also: #getch. &#xA; s = StringScanner.new(&apos;ab&apos;)&#xA;s.get_byte         # =&gt; &quot;a&quot;&#xA;s.get_byte         # =&gt; &quot;b&quot;&#xA;s.get_byte         # =&gt; nil&#xA;&#xA;$KCODE = &apos;EUC&apos;&#xA;s = StringScanner.new(&quot;\244\242&quot;)&#xA;s.get_byte         # =&gt; &quot;\244&quot;&#xA;s.get_byte         # =&gt; &quot;\242&quot;&#xA;s.get_byte         # =&gt; nil" />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="Equivalent to #get_byte. This method is obsolete; use #get_byte instead." />
        <scope name="getch" ilk="function" signature="getch()" doc="Scans one character and returns it. This method is multibyte character sensitive. &#xA; s = StringScanner.new(&quot;ab&quot;)&#xA;s.getch           # =&gt; &quot;a&quot;&#xA;s.getch           # =&gt; &quot;b&quot;&#xA;s.getch           # =&gt; nil&#xA;&#xA;$KCODE = &apos;EUC&apos;&#xA;s = StringScanner.new(&quot;\244\242&quot;)&#xA;s.getch           # =&gt; &quot;\244\242&quot;   # Japanese hira-kana &quot;A&quot; in EUC-JP&#xA;s.getch           # =&gt; nil" />
        <scope name="match?" ilk="function" signature="match?(p1)" doc="Tests whether the given +pattern+ is matched from the current scan pointer. Returns the length of the match, or +nil+.  The scan pointer is not advanced. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;p s.match?(/\w+/)   # -&gt; 4&#xA;p s.match?(/\w+/)   # -&gt; 4&#xA;p s.match?(/\s+/)   # -&gt; nil" />
        <scope name="matched" ilk="function" signature="matched()" doc="Returns the last matched string. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.match?(/\w+/)     # -&gt; 4&#xA;s.matched           # -&gt; &quot;test&quot;" />
        <scope name="matched?" ilk="function" signature="matched?()" doc="Returns +true+ iff the last match was successful. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.match?(/\w+/)     # =&gt; 4&#xA;s.matched?          # =&gt; true&#xA;s.match?(/\d+/)     # =&gt; nil&#xA;s.matched?          # =&gt; false" />
        <scope name="matched_size" ilk="function" signature="matched_size()" doc="Returns the size of the most recent match (see #matched), or +nil+ if there was no recent match. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.check /\w+/           # -&gt; &quot;test&quot;&#xA;s.matched_size          # -&gt; 4&#xA;s.check /\d+/           # -&gt; nil&#xA;s.matched_size          # -&gt; nil" />
        <scope name="peek" ilk="function" signature="peek(p1)" doc="Extracts a string corresponding to string[pos,len], without advancing the scan pointer. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.peek(7)          # =&gt; &quot;test st&quot;&#xA;s.peek(7)          # =&gt; &quot;test st&quot;" />
        <scope name="peep" ilk="function" signature="peep(p1)" doc="Equivalent to #peek. This method is obsolete; use #peek instead." />
        <scope name="pointer" ilk="function" signature="pointer()" doc="Returns the byte position of the scan pointer.  In the &apos;reset&apos; position, this value is zero.  In the &apos;terminated&apos; position (i.e. the string is exhausted), this value is the bytesize of the string. &#xA; In short, it&apos;s a 0-based index into the string. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.pos               # -&gt; 0&#xA;s.scan_until /str/  # -&gt; &quot;test str&quot;&#xA;s.pos               # -&gt; 8&#xA;s.terminate         # -&gt; #&lt;StringScanner fin&gt;&#xA;s.pos               # -&gt; 11" />
        <scope name="pointer=" ilk="function" signature="pointer=(p1)" doc="Set the byte position of the scan pointer. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.pos = 7            # -&gt; 7&#xA;s.rest               # -&gt; &quot;ring&quot;" />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the byte position of the scan pointer.  In the &apos;reset&apos; position, this value is zero.  In the &apos;terminated&apos; position (i.e. the string is exhausted), this value is the bytesize of the string. &#xA; In short, it&apos;s a 0-based index into the string. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.pos               # -&gt; 0&#xA;s.scan_until /str/  # -&gt; &quot;test str&quot;&#xA;s.pos               # -&gt; 8&#xA;s.terminate         # -&gt; #&lt;StringScanner fin&gt;&#xA;s.pos               # -&gt; 11" />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Set the byte position of the scan pointer. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.pos = 7            # -&gt; 7&#xA;s.rest               # -&gt; &quot;ring&quot;" />
        <scope name="post_match" ilk="function" signature="post_match()" doc="Return the &lt;b&gt;post&lt;/b&gt;-match (in the regular expression sense) of the last scan. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.scan(/\w+/)           # -&gt; &quot;test&quot;&#xA;s.scan(/\s+/)           # -&gt; &quot; &quot;&#xA;s.pre_match             # -&gt; &quot;test&quot;&#xA;s.post_match            # -&gt; &quot;string&quot;" />
        <scope name="pre_match" ilk="function" signature="pre_match()" doc="Return the &lt;b&gt;pre&lt;/b&gt;-match (in the regular expression sense) of the last scan. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.scan(/\w+/)           # -&gt; &quot;test&quot;&#xA;s.scan(/\s+/)           # -&gt; &quot; &quot;&#xA;s.pre_match             # -&gt; &quot;test&quot;&#xA;s.post_match            # -&gt; &quot;string&quot;" />
        <scope name="reset" ilk="function" signature="reset()" doc="Reset the scan pointer (index 0) and clear matching data." />
        <scope name="rest" ilk="function" signature="rest()" doc="Returns the &quot;rest&quot; of the string (i.e. everything after the scan pointer). If there is no more data (eos? = true), it returns &quot;&quot;." />
        <scope name="rest?" ilk="function" signature="rest?()" doc="Returns true iff there is more data in the string.  See #eos?. This method is obsolete; use #eos? instead. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.eos?              # These two&#xA;s.rest?             # are opposites." />
        <scope name="rest_size" ilk="function" signature="rest_size()" doc="s.rest_size is equivalent to s.rest.size." />
        <scope name="restsize" ilk="function" signature="restsize()" doc="s.restsize is equivalent to s.rest_size. This method is obsolete; use #rest_size instead." />
        <scope name="scan" ilk="function" signature="scan(p1)" doc="Tries to match with +pattern+ at the current position. If there&apos;s a match, the scanner advances the &quot;scan pointer&quot; and returns the matched string. Otherwise, the scanner returns +nil+. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;p s.scan(/\w+/)   # -&gt; &quot;test&quot;&#xA;p s.scan(/\w+/)   # -&gt; nil&#xA;p s.scan(/\s+/)   # -&gt; &quot; &quot;&#xA;p s.scan(/\w+/)   # -&gt; &quot;string&quot;&#xA;p s.scan(/./)     # -&gt; nil" />
        <scope name="scan_full" ilk="function" signature="scan_full(p1, p2, p3)" doc="Tests whether the given +pattern+ is matched from the current scan pointer. Advances the scan pointer if +advance_pointer_p+ is true. Returns the matched string if +return_string_p+ is true. The match register is affected. &#xA; &quot;full&quot; means &quot;#scan with full parameters&quot;." />
        <scope name="scan_until" ilk="function" signature="scan_until(p1)" doc="Scans the string _until_ the +pattern+ is matched.  Returns the substring up to and including the end of the match, advancing the scan pointer to that location. If there is no match, +nil+ is returned. &#xA; s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;s.scan_until(/1/)        # -&gt; &quot;Fri Dec 1&quot;&#xA;s.pre_match              # -&gt; &quot;Fri Dec &quot;&#xA;s.scan_until(/XYZ/)      # -&gt; nil" />
        <scope name="search_full" ilk="function" signature="search_full(p1, p2, p3)" doc="Scans the string _until_ the +pattern+ is matched. Advances the scan pointer if +advance_pointer_p+, otherwise not. Returns the matched string if +return_string_p+ is true, otherwise returns the number of bytes advanced. This method does affect the match register." />
        <scope name="skip" ilk="function" signature="skip(p1)" doc="Attempts to skip over the given +pattern+ beginning with the scan pointer. If it matches, the scan pointer is advanced to the end of the match, and the length of the match is returned.  Otherwise, +nil+ is returned. &#xA; It&apos;s similar to #scan, but without returning the matched string. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;p s.skip(/\w+/)   # -&gt; 4&#xA;p s.skip(/\w+/)   # -&gt; nil&#xA;p s.skip(/\s+/)   # -&gt; 1&#xA;p s.skip(/\w+/)   # -&gt; 6&#xA;p s.skip(/./)     # -&gt; nil" />
        <scope name="skip_until" ilk="function" signature="skip_until(p1)" doc="Advances the scan pointer until +pattern+ is matched and consumed.  Returns the number of bytes advanced, or +nil+ if no match was found. &#xA; Look ahead to match +pattern+, and advance the scan pointer to the _end_ of the match.  Return the number of characters advanced, or +nil+ if the match was unsuccessful. &#xA; It&apos;s similar to #scan_until, but without returning the intervening string. &#xA; s = StringScanner.new(&quot;Fri Dec 12 1975 14:39&quot;)&#xA;s.skip_until /12/           # -&gt; 10&#xA;s                           #" />
        <scope name="string" ilk="function" signature="string()" doc="Returns the string being scanned." />
        <scope name="string=" ilk="function" signature="string=(p1)" doc="Changes the string being scanned to +str+ and resets the scanner. Returns +str+." />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Set the scan pointer to the end of the string and clear matching data." />
        <scope name="unscan" ilk="function" signature="unscan()" doc="Set the scan pointer to the previous position.  Only one previous position is remembered, and it changes with each scanning operation. &#xA; s = StringScanner.new(&apos;test string&apos;)&#xA;s.scan(/\w+/)        # =&gt; &quot;test&quot;&#xA;s.unscan&#xA;s.scan(/../)         # =&gt; &quot;te&quot;&#xA;s.scan(/\d/)         # =&gt; nil&#xA;s.unscan             # ScanError: unscan failed: previous match record not exist" />
        <scope name="must_C_version" ilk="function" attributes="__classmethod__" signature="must_C_version()" doc="This method is defined for backward compatibility." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1, p2 = v2)" doc="Creates a new StringScanner object to scan over the given +string+. +dup+ argument is obsolete and not used now." />
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="Id" attributes="__const__" citdl="String" />
        <variable name="Version" attributes="__const__" citdl="String" />
      </scope>
      <scope name="ScanError" ilk="class" classrefs="StandardError" >
      </scope>
      <scope name="ConditionVariable" ilk="class" classrefs="Object" >
        <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
        <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
        <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
      </scope>
      <scope name="Queue" ilk="class" classrefs="Object" >
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all objects from the queue." />
        <scope name="deq" ilk="function" signature="deq(non_block=false)" doc="Alias of pop" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if the queue is empty." />
        <scope name="enq" ilk="function" signature="enq(obj)" doc="Alias of push" />
        <scope name="length" ilk="function" signature="length()" doc="Returns the length of the queue." />
        <scope name="num_waiting" ilk="function" signature="num_waiting()" doc="Returns the number of threads waiting on the queue." />
        <scope name="pop" ilk="function" signature="pop(non_block=false)" doc="Retrieves data from the queue.  If the queue is empty, the calling thread is suspended until data is pushed onto the queue.  If +non_block+ is true, the thread isn&apos;t suspended, and an exception is raised." />
        <scope name="push" ilk="function" signature="push(obj)" doc="Pushes +obj+ to the queue." />
        <scope name="shift" ilk="function" signature="shift(non_block=false)" doc="Alias of pop" />
        <scope name="size" ilk="function" signature="size()" doc="Alias of length." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new queue." />
      </scope>
      <scope name="SizedQueue" ilk="class" classrefs="Queue" >
        <scope name="max" ilk="function" signature="max()" doc="Returns the maximum size of the queue." />
        <scope name="max=" ilk="function" signature="max=(max)" doc="Sets the maximum size of the queue." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(max)" doc="Creates a fixed-length queue with a maximum size of +max+." />
      </scope>
      <scope name="RbConfig" ilk="namespace" >
        <scope name="datadir" ilk="function" />
        <scope name="expand" ilk="function" />
        <scope name="ruby" ilk="function" />
        <variable name="CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="DESTDIR" attributes="__const__" citdl="String" />
        <variable name="MAKEFILE_CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="TOPDIR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Config" ilk="namespace" >
        <scope name="datadir" ilk="function" />
        <scope name="expand" ilk="function" />
        <scope name="ruby" ilk="function" />
        <variable name="CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="DESTDIR" attributes="__const__" citdl="String" />
        <variable name="MAKEFILE_CONFIG" attributes="__const__" citdl="Hash" />
        <variable name="TOPDIR" attributes="__const__" citdl="String" />
      </scope>
      <variable name="CROSS_COMPILING" attributes="__const__" citdl="NilClass" />
      <scope name="Date" ilk="class" classrefs="Object" >
        <scope name="ajd" ilk="function" signature="ajd()" doc="Returns the astronomical Julian day number.  This is a fractional number, which is not adjusted by the offset. &#xA; For example: &#xA; DateTime.new(2001,2,3,4,5,6,&apos;+7&apos;).ajd     =&gt; (11769328217/4800)&#xA;DateTime.new(2001,2,2,14,5,6,&apos;-7&apos;).ajd    =&gt; (11769328217/4800)" />
        <scope name="amjd" ilk="function" signature="amjd()" doc="Returns the astronomical modified Julian day number.  This is a fractional number, which is not adjusted by the offset. &#xA; For example: &#xA; DateTime.new(2001,2,3,4,5,6,&apos;+7&apos;).amjd    =&gt; (249325817/4800)&#xA;DateTime.new(2001,2,2,14,5,6,&apos;-7&apos;).amjd   =&gt; (249325817/4800)" />
        <scope name="asctime" ilk="function" signature="asctime()" doc="Returns a string in asctime(3) format (but without &quot;\n\0&quot; at the end).  This method is equivalent to strftime(&apos;%c&apos;). &#xA; See also asctime(3) or ctime(3)." />
        <scope name="ctime" ilk="function" signature="ctime()" doc="Returns a string in asctime(3) format (but without &quot;\n\0&quot; at the end).  This method is equivalent to strftime(&apos;%c&apos;). &#xA; See also asctime(3) or ctime(3)." />
        <scope name="cwday" ilk="function" signature="cwday()" doc="Returns the day of calendar week (1-7, Monday is 1). &#xA; For example: &#xA; Date.new(2001,2,3).cwday          =&gt; 6" />
        <scope name="cweek" ilk="function" signature="cweek()" doc="Returns the calendar week number (1-53). &#xA; For example: &#xA; Date.new(2001,2,3).cweek          =&gt; 5" />
        <scope name="cwyear" ilk="function" signature="cwyear()" doc="Returns the calendar week based year. &#xA; For example: &#xA; Date.new(2001,2,3).cwyear         =&gt; 2001&#xA;Date.new(2000,1,1).cwyear         =&gt; 1999" />
        <scope name="day" ilk="function" signature="day()" doc="Returns the day of the month (1-31). &#xA; For example: &#xA; Date.new(2001,2,3).mday           =&gt; 3" />
        <scope name="day_fraction" ilk="function" signature="day_fraction()" doc="Returns the fractional part of the day. &#xA; For example: &#xA; DateTime.new(2001,2,3,12).day_fraction    =&gt; (1/2)" />
        <scope name="downto" ilk="function" signature="downto(p1)" doc="This method is equivalent to step(min, -1){|date| ...}." />
        <scope name="england" ilk="function" signature="england()" doc="This method is equivalent to new_start(Date::ENGLAND)." />
        <scope name="friday?" ilk="function" signature="friday?()" doc="Returns true if the date is Friday." />
        <scope name="gregorian" ilk="function" signature="gregorian()" doc="This method is equivalent to new_start(Date::GREGORIAN)." />
        <scope name="gregorian?" ilk="function" signature="gregorian?()" doc="Retunrs true if the date is on or after the day of calendar reform. &#xA; For example: &#xA; Date.new(1582,10,15).gregorian?          =&gt; true&#xA;(Date.new(1582,10,15) - 1).gregorian?    =&gt; false" />
        <scope name="httpdate" ilk="function" signature="httpdate()" doc="This method is equivalent to strftime(&apos;%a, %d %b %Y %T GMT&apos;). See also RFC 2616." />
        <scope name="iso8601" ilk="function" signature="iso8601()" doc="This method is equivalent to strftime(&apos;%F&apos;)." />
        <scope name="italy" ilk="function" signature="italy()" doc="This method is equivalent to new_start(Date::ITALY)." />
        <scope name="jd" ilk="function" signature="jd()" doc="Returns the Julian day number.  This is a whole number, which is adjusted by the offset as the local time. &#xA; For example: &#xA; DateTime.new(2001,2,3,4,5,6,&apos;+7&apos;).jd      =&gt; 2451944&#xA;DateTime.new(2001,2,3,4,5,6,&apos;-7&apos;).jd      =&gt; 2451944" />
        <scope name="jisx0301" ilk="function" signature="jisx0301()" doc="Returns a string in a JIS X 0301 format. &#xA; For example: &#xA; Date.new(2001,2,3).jisx0301       =&gt; &quot;H13.02.03&quot;" />
        <scope name="julian" ilk="function" signature="julian()" doc="This method is equivalent to new_start(Date::JULIAN)." />
        <scope name="julian?" ilk="function" signature="julian?()" doc="Retruns true if the date is before the day of calendar reform. &#xA; For example: &#xA; Date.new(1582,10,15).julian?             =&gt; false&#xA;(Date.new(1582,10,15) - 1).julian?       =&gt; true" />
        <scope name="ld" ilk="function" signature="ld()" doc="Returns the Lilian day number.  This is a whole number, which is adjusted by the offset as the local time. &#xA; For example: &#xA; Date.new(2001,2,3).ld            =&gt; 152784" />
        <scope name="leap?" ilk="function" signature="leap?()" doc="Returns true if the year is a leap year. &#xA; For example: &#xA; Date.new(2000).leap?      =&gt; true&#xA;Date.new(2001).leap?      =&gt; false" />
        <scope name="marshal_dump" ilk="function" />
        <scope name="marshal_load" ilk="function" />
        <scope name="mday" ilk="function" signature="mday()" doc="Returns the day of the month (1-31). &#xA; For example: &#xA; Date.new(2001,2,3).mday           =&gt; 3" />
        <scope name="mjd" ilk="function" signature="mjd()" doc="Returns the modified Julian day number.  This is a whole number, which is adjusted by the offset as the local time. &#xA; For example: &#xA; DateTime.new(2001,2,3,4,5,6,&apos;+7&apos;).mjd     =&gt; 51943&#xA;DateTime.new(2001,2,3,4,5,6,&apos;-7&apos;).mjd     =&gt; 51943" />
        <scope name="mon" ilk="function" signature="mon()" doc="Returns the month (1-12). &#xA; For example: &#xA; Date.new(2001,2,3).mon            =&gt; 2" />
        <scope name="monday?" ilk="function" signature="monday?()" doc="Returns true if the date is Monday." />
        <scope name="month" ilk="function" signature="month()" doc="Returns the month (1-12). &#xA; For example: &#xA; Date.new(2001,2,3).mon            =&gt; 2" />
        <scope name="new_start" ilk="function" signature="new_start(p1 = v1)" doc="Duplicates self and resets its the day of calendar reform. &#xA; For example: &#xA; d = Date.new(1582,10,15)&#xA;d.new_start(Date::JULIAN)         =&gt; #&lt;Date: 1582-10-05 ...&gt;" />
        <scope name="next" ilk="function" signature="next()" doc="Returns a date object denoting the following day." />
        <scope name="next_day" ilk="function" signature="next_day(p1 = v1)" doc="This method is equivalent to d + n." />
        <scope name="next_month" ilk="function" signature="next_month(p1 = v1)" doc="This method is equivalent to d &gt;&gt; n" />
        <scope name="next_year" ilk="function" signature="next_year(p1 = v1)" doc="This method is equivalent to d &gt;&gt; (n * 12)" />
        <scope name="prev_day" ilk="function" signature="prev_day(p1 = v1)" doc="This method is equivalent to d - n." />
        <scope name="prev_month" ilk="function" signature="prev_month(p1 = v1)" doc="This method is equivalent to d &lt;&lt; n" />
        <scope name="prev_year" ilk="function" signature="prev_year(p1 = v1)" doc="This method is equivalent to d &lt;&lt; (n * 12)" />
        <scope name="rfc2822" ilk="function" signature="rfc2822()" doc="This method is equivalent to strftime(&apos;%a, %-d %b %Y %T %z&apos;)." />
        <scope name="rfc3339" ilk="function" signature="rfc3339()" doc="This method is equivalent to strftime(&apos;%FT%T%:z&apos;)." />
        <scope name="rfc822" ilk="function" signature="rfc822()" doc="This method is equivalent to strftime(&apos;%a, %-d %b %Y %T %z&apos;)." />
        <scope name="saturday?" ilk="function" signature="saturday?()" doc="Returns true if the date is Saturday." />
        <scope name="start" ilk="function" signature="start()" doc="Returns the Julian day number denoting the day of calendar reform. &#xA; For example: &#xA; Date.new(2001,2,3).start                  =&gt; 2299161.0&#xA;Date.new(2001,2,3,Date::GREGORIAN).start  =&gt; -Infinity" />
        <scope name="step" ilk="function" signature="step(p1, p2 = v2)" doc="Iterates evaluation of the given block, which takes a date object. The limit should be a date object. &#xA; For example: &#xA; Date.new(2001).step(Date.new(2001,-1,-1)).select{|d| d.sunday?}.size&#xA;                          =&gt; 52" />
        <scope name="strftime" ilk="function" signature="strftime(*args)" doc="Formats date according to the directives in the given format&#xA;string.&#xA;The directives begins with a percent (%) character.&#xA;Any text not listed as a directive will be passed through to the&#xA;output string.&#xA;The directive consists of a percent (%) character,&#xA;zero or more flags, optional minimum field width,&#xA;optional modifier and a conversion specifier&#xA;as follows.&#xA;  %&lt;flags&gt;&lt;width&gt;&lt;modifier&gt;&lt;conversion&gt;&#xA;Flags:&#xA;  -  don&apos;t pad a numerical output.&#xA;  _  use spaces for padding." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns a date object denoting the following day." />
        <scope name="sunday?" ilk="function" signature="sunday?()" doc="Returns true if the date is Sunday." />
        <scope name="thursday?" ilk="function" signature="thursday?()" doc="Returns true if the date is Thursday." />
        <scope name="to_date" ilk="function" signature="to_date()" doc="Returns self;" />
        <scope name="to_datetime" ilk="function" signature="to_datetime()" doc="Returns a DateTime object which denotes self." />
        <scope name="to_time" ilk="function" signature="to_time()" doc="Returns a Time object which denotes self." />
        <scope name="tuesday?" ilk="function" signature="tuesday?()" doc="Returns true if the date is Tuesday." />
        <scope name="upto" ilk="function" signature="upto(p1)" doc="This method is equivalent to step(max, 1){|date| ...}." />
        <scope name="wday" ilk="function" signature="wday()" doc="Returns the day of week (0-6, Sunday is zero). &#xA; For example: &#xA; Date.new(2001,2,3).wday           =&gt; 6" />
        <scope name="wednesday?" ilk="function" signature="wednesday?()" doc="Returns true if the date is Wednesday." />
        <scope name="xmlschema" ilk="function" signature="xmlschema()" doc="This method is equivalent to strftime(&apos;%F&apos;)." />
        <scope name="yday" ilk="function" signature="yday()" doc="Returns the day of the year (1-366). &#xA; For example: &#xA; Date.new(2001,2,3).yday           =&gt; 34" />
        <scope name="year" ilk="function" signature="year()" doc="Returns the year. &#xA; For example: &#xA; Date.new(2001,2,3).year           =&gt; 2001&#xA;(Date.new(1,1,1) - 1).year        =&gt; 0" />
        <scope name="_httpdate" ilk="function" attributes="__classmethod__" signature="_httpdate(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_iso8601" ilk="function" attributes="__classmethod__" signature="_iso8601(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_jisx0301" ilk="function" attributes="__classmethod__" signature="_jisx0301(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_parse" ilk="function" attributes="__classmethod__" signature="_parse(*args)" doc="Parses the given representation of date and time, and returns a hash of parsed elements. &#xA; If the optional second argument is true and the detected year is in the range &quot;00&quot; to &quot;99&quot;, considers the year a 2-digit form and makes it full. &#xA; For example: &#xA; Date._parse(&apos;2001-02-03&apos;) =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}" />
        <scope name="_rfc2822" ilk="function" attributes="__classmethod__" signature="_rfc2822(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_rfc3339" ilk="function" attributes="__classmethod__" signature="_rfc3339(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_rfc822" ilk="function" attributes="__classmethod__" signature="_rfc822(p1)" doc="Returns a hash of parsed elements." />
        <scope name="_strptime" ilk="function" attributes="__classmethod__" signature="_strptime(*args)" doc="Parses the given representation of date and time with the given template, and returns a hash of parsed elements. &#xA; For example: &#xA;   Date._strptime(&apos;2001-02-03&apos;, &apos;%Y-%m-%d&apos;)&#xA;                            =&gt; {:year=&gt;2001, :mon=&gt;2, :mday=&gt;3}&#xA;&#xA;See also strptime(3) and strftime." />
        <scope name="_xmlschema" ilk="function" attributes="__classmethod__" signature="_xmlschema(p1)" doc="Returns a hash of parsed elements." />
        <scope name="civil" ilk="function" attributes="__classmethod__" signature="civil(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" doc="Creates a date object denoting the given calendar date. &#xA; In this class, BCE years are counted astronomically.  Thus, the year before the year 1 is the year zero, and the year preceding the year zero is the year -1.  The month and the day of month should be a negative or a positive number (as a relative month/day from the end of year/month when negative).  They should not be zero. &#xA; The last argument should be a Julian day number which denotes the day of calendar reform.  Date::ITALY (2299161=1582-10-15), Date::ENGLAND (2361222=1752-09-14), Date::GREGORIAN (the proleptic Gregorian calendar) and Date::JULIAN (the proleptic Julian calendar) can be specified as a day of calendar reform. &#xA; For example: &#xA; Date.new(2001)            =&gt; #&lt;Date: 2001-01-01 ...&gt;&#xA;Date.new(2001,2,3)        =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.new(2001,2,-1)       =&gt; #&lt;Date: 2001-02-28 ...&gt;&#xA; See also jd." />
        <scope name="commercial" ilk="function" attributes="__classmethod__" signature="commercial(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" doc="Creates a date object denoting the given week date. &#xA; The week and the day of week should be a negative or a positive number (as a relative week/day from the end of year/week when negative).  They should not be zero. &#xA; For example: &#xA; Date.commercial(2001)     =&gt; #&lt;Date: 2001-01-01 ...&gt;&#xA;Date.commercial(2002)     =&gt; #&lt;Date: 2001-12-31 ...&gt;&#xA;Date.commercial(2001,5,6) =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA; See also jd and new." />
        <scope name="gregorian_leap?" ilk="function" attributes="__classmethod__" signature="gregorian_leap?(p1)" doc="Returns true if the given year is a leap year of the proleptic Gregorian calendar. &#xA; For example: &#xA; Date.gregorian_leap?(1900)        =&gt; false&#xA;Date.gregorian_leap?(2000)        =&gt; true" />
        <scope name="httpdate" ilk="function" attributes="__classmethod__" signature="httpdate(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some RFC 2616 format. &#xA; For example: &#xA; Date.httpdate(&apos;Sat, 03 Feb 2001 00:00:00 GMT&apos;)&#xA;                                          =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="iso8601" ilk="function" attributes="__classmethod__" signature="iso8601(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical ISO 8601 formats. &#xA; For example: &#xA; Date.iso8601(&apos;2001-02-03&apos;)        =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.iso8601(&apos;20010203&apos;)          =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.iso8601(&apos;2001-W05-6&apos;)        =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="jd" ilk="function" attributes="__classmethod__" signature="jd(p1 = v1, p2 = v2)" doc="Creates a date object denoting the given chronological Julian day number. &#xA; For example: &#xA; Date.jd(2451944)          =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.jd(2451945)          =&gt; #&lt;Date: 2001-02-04 ...&gt;&#xA;Date.jd(0)                =&gt; #&lt;Date: -4712-01-01 ...&gt;&#xA; See also new." />
        <scope name="jisx0301" ilk="function" attributes="__classmethod__" signature="jisx0301(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical JIS X 0301 formats. &#xA; For example: &#xA; Date.jisx0301(&apos;H13.02.03&apos;)                =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="julian_leap?" ilk="function" attributes="__classmethod__" signature="julian_leap?(p1)" doc="Returns true if the given year is a leap year of the proleptic Julian calendar. &#xA; For example: &#xA; Date.julian_leap?(1900)           =&gt; true&#xA;Date.julian_leap?(1901)           =&gt; false" />
        <scope name="leap?" ilk="function" attributes="__classmethod__" signature="leap?(p1)" doc="Returns true if the given year is a leap year of the proleptic Gregorian calendar. &#xA; For example: &#xA; Date.gregorian_leap?(1900)        =&gt; false&#xA;Date.gregorian_leap?(2000)        =&gt; true" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" doc="Creates a date object denoting the given calendar date. &#xA; In this class, BCE years are counted astronomically.  Thus, the year before the year 1 is the year zero, and the year preceding the year zero is the year -1.  The month and the day of month should be a negative or a positive number (as a relative month/day from the end of year/month when negative).  They should not be zero. &#xA; The last argument should be a Julian day number which denotes the day of calendar reform.  Date::ITALY (2299161=1582-10-15), Date::ENGLAND (2361222=1752-09-14), Date::GREGORIAN (the proleptic Gregorian calendar) and Date::JULIAN (the proleptic Julian calendar) can be specified as a day of calendar reform. &#xA; For example: &#xA; Date.new(2001)            =&gt; #&lt;Date: 2001-01-01 ...&gt;&#xA;Date.new(2001,2,3)        =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.new(2001,2,-1)       =&gt; #&lt;Date: 2001-02-28 ...&gt;&#xA; See also jd." />
        <scope name="new!" ilk="function" attributes="__classmethod__" />
        <scope name="ordinal" ilk="function" attributes="__classmethod__" signature="ordinal(p1 = v1, p2 = v2, p3 = v3)" doc="Creates a date object denoting the given ordinal date. &#xA; The day of year should be a negative or a positive number (as a relative day from the end of year when negative).  It should not be zero. &#xA; For example: &#xA; Date.ordinal(2001)        =&gt; #&lt;Date: 2001-01-01 ...&gt;&#xA;Date.ordinal(2001,34)     =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.ordinal(2001,-1)     =&gt; #&lt;Date: 2001-12-31 ...&gt;&#xA; See also jd and new." />
        <scope name="parse" ilk="function" attributes="__classmethod__" signature="parse(p1 = v1, p2 = v2, p3 = v3)" doc="Parses the given representation of date and time, and creates a date object. &#xA; If the optional second argument is true and the detected year is in the range &quot;00&quot; to &quot;99&quot;, considers the year a 2-digit form and makes it full. &#xA; For example: &#xA; Date.parse(&apos;2001-02-03&apos;)          =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.parse(&apos;20010203&apos;)            =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.parse(&apos;3rd Feb 2001&apos;)        =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="rfc2822" ilk="function" attributes="__classmethod__" signature="rfc2822(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical RFC 2822 formats. &#xA; For example: &#xA; Date.rfc2822(&apos;Sat, 3 Feb 2001 00:00:00 +0000&apos;)&#xA;                                          =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="rfc3339" ilk="function" attributes="__classmethod__" signature="rfc3339(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical RFC 3339 formats. &#xA; For example: &#xA; Date.rfc3339(&apos;2001-02-03T04:05:06+07:00&apos;) =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="rfc822" ilk="function" attributes="__classmethod__" signature="rfc822(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical RFC 2822 formats. &#xA; For example: &#xA; Date.rfc2822(&apos;Sat, 3 Feb 2001 00:00:00 +0000&apos;)&#xA;                                          =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="strptime" ilk="function" attributes="__classmethod__" signature="strptime(p1 = v1, p2 = v2, p3 = v3)" doc="Parses the given representation of date and time with the given template, and creates a date object. &#xA; For example: &#xA; Date.strptime(&apos;2001-02-03&apos;, &apos;%Y-%m-%d&apos;)   =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;03-02-2001&apos;, &apos;%d-%m-%Y&apos;)   =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;2001-034&apos;, &apos;%Y-%j&apos;)        =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;2001-W05-6&apos;, &apos;%G-W%V-%u&apos;)  =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;2001 04 6&apos;, &apos;%Y %U %w&apos;)    =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;2001 05 6&apos;, &apos;%Y %W %u&apos;)    =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.strptime(&apos;sat3feb01&apos;, &apos;%a%d%b%y&apos;)    =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA; See also strptime(3) and strftime." />
        <scope name="today" ilk="function" attributes="__classmethod__" signature="today(p1 = v1)" doc="For example: &#xA; Date.today                =&gt; #&lt;Date: 2011-06-11 ..&gt;&#xA; Creates a date object denoting the present day." />
        <scope name="valid_civil?" ilk="function" attributes="__classmethod__" signature="valid_civil?(p1, p2, p3, p4 = v4)" doc="Returns true if the given calendar date is valid, and false if not. &#xA; For example: &#xA; Date.valid_date?(2001,2,3)        =&gt; true&#xA;Date.valid_date?(2001,2,29)       =&gt; false&#xA; See also jd and civil." />
        <scope name="valid_commercial?" ilk="function" attributes="__classmethod__" signature="valid_commercial?(p1, p2, p3, p4 = v4)" doc="Returns true if the given week date is valid, and false if not. &#xA; For example: &#xA; Date.valid_commercial?(2001,5,6)  =&gt; true&#xA;Date.valid_commercial?(2001,5,8)  =&gt; false&#xA; See also jd and commercial." />
        <scope name="valid_date?" ilk="function" attributes="__classmethod__" signature="valid_date?(p1, p2, p3, p4 = v4)" doc="Returns true if the given calendar date is valid, and false if not. &#xA; For example: &#xA; Date.valid_date?(2001,2,3)        =&gt; true&#xA;Date.valid_date?(2001,2,29)       =&gt; false&#xA; See also jd and civil." />
        <scope name="valid_jd?" ilk="function" attributes="__classmethod__" signature="valid_jd?(p1, p2 = v2)" doc="Just returns true.  It&apos;s nonsense, but is for symmetry. &#xA; For example: &#xA; Date.valid_jd?(2451944)           =&gt; true&#xA; See also jd." />
        <scope name="valid_ordinal?" ilk="function" attributes="__classmethod__" signature="valid_ordinal?(p1, p2, p3 = v3)" doc="Returns true if the given ordinal date is valid, and false if not. &#xA; For example: &#xA; Date.valid_ordinal?(2001,34)      =&gt; true&#xA;Date.valid_ordinal?(2001,366)     =&gt; false&#xA; See also jd and ordinal." />
        <scope name="xmlschema" ilk="function" attributes="__classmethod__" signature="xmlschema(p1 = v1, p2 = v2)" doc="Creates a new Date object by parsing from a string according to some typical XML Schema formats. &#xA; For example: &#xA; Date.xmlschema(&apos;2001-02-03&apos;)      =&gt; #&lt;Date: 2001-02-03 ...&gt;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" doc="Creates a date object denoting the given calendar date. &#xA; In this class, BCE years are counted astronomically.  Thus, the year before the year 1 is the year zero, and the year preceding the year zero is the year -1.  The month and the day of month should be a negative or a positive number (as a relative month/day from the end of year/month when negative).  They should not be zero. &#xA; The last argument should be a Julian day number which denotes the day of calendar reform.  Date::ITALY (2299161=1582-10-15), Date::ENGLAND (2361222=1752-09-14), Date::GREGORIAN (the proleptic Gregorian calendar) and Date::JULIAN (the proleptic Julian calendar) can be specified as a day of calendar reform. &#xA; For example: &#xA; Date.new(2001)            =&gt; #&lt;Date: 2001-01-01 ...&gt;&#xA;Date.new(2001,2,3)        =&gt; #&lt;Date: 2001-02-03 ...&gt;&#xA;Date.new(2001,2,-1)       =&gt; #&lt;Date: 2001-02-28 ...&gt;&#xA; See also jd." />
        <variable name="ABBR_DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ABBR_MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ENGLAND" attributes="__const__" citdl="Fixnum" />
        <scope name="Format" ilk="namespace" >
          <variable name="ABBR_DAYS" attributes="__const__" citdl="Hash" />
          <variable name="ABBR_MONTHS" attributes="__const__" citdl="Hash" />
          <scope name="Bag" ilk="class" classrefs="Object" >
            <scope name="method_missing" ilk="function" />
            <scope name="to_hash" ilk="function" />
          </scope>
          <variable name="DAYS" attributes="__const__" citdl="Hash" />
          <variable name="MONTHS" attributes="__const__" citdl="Hash" />
          <variable name="ZONES" attributes="__const__" citdl="Hash" />
        </scope>
        <variable name="GREGORIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="HALF_DAYS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="HOURS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="ITALY" attributes="__const__" citdl="Fixnum" />
        <scope name="Infinity" ilk="class" classrefs="Numeric" >
          <import symbol="Comparable" />
          <scope name="d" ilk="function" />
          <scope name="finite?" ilk="function" />
          <scope name="infinite?" ilk="function" />
          <scope name="nan?" ilk="function" />
        </scope>
        <variable name="JULIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="LD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MILLISECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MILLISECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="MINUTES_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="NANOSECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="NANOSECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="SECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="Syck" ilk="namespace" >
        <scope name="add_builtin_type" ilk="function" />
        <scope name="add_domain_type" ilk="function" />
        <scope name="add_private_type" ilk="function" />
        <scope name="add_ruby_type" ilk="function" />
        <scope name="compile" ilk="function" />
        <scope name="detect_implicit" ilk="function" />
        <scope name="dump" ilk="function" />
        <scope name="dump_stream" ilk="function" />
        <scope name="each_document" ilk="function" />
        <scope name="each_node" ilk="function" />
        <scope name="emitter" ilk="function" />
        <scope name="generic_parser" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="load_documents" ilk="function" />
        <scope name="load_file" ilk="function" />
        <scope name="load_stream" ilk="function" />
        <scope name="object_maker" ilk="function" />
        <scope name="parse" ilk="function" />
        <scope name="parse_documents" ilk="function" />
        <scope name="parse_file" ilk="function" />
        <scope name="parser" ilk="function" />
        <scope name="quick_emit" ilk="function" />
        <scope name="read_type_class" ilk="function" />
        <scope name="resolver" ilk="function" />
        <scope name="tag_class" ilk="function" />
        <scope name="tagged_classes" ilk="function" />
        <scope name="tagurize" ilk="function" />
        <scope name="transfer" ilk="function" />
        <scope name="try_implicit" ilk="function" />
        <scope name="BadAlias" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
        </scope>
        <scope name="BaseNode" ilk="namespace" >
          <scope name="at" ilk="function" />
          <scope name="children" ilk="function" />
          <scope name="children_with_index" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="match_path" ilk="function" />
          <scope name="match_segment" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="select" ilk="function" />
          <scope name="select!" ilk="function" />
        </scope>
        <variable name="DEFAULTS" attributes="__const__" citdl="Hash" />
        <variable name="DNS_COMP_RE" attributes="__const__" citdl="String" />
        <variable name="DNS_NAME_RE" attributes="__const__" citdl="String" />
        <scope name="DefaultKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="DefaultResolver" attributes="__const__" citdl="Syck::Resolver" />
        <scope name="DomainType" ilk="class" classrefs="Object" >
          <scope name="domain" ilk="function" />
          <scope name="domain=" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
        <variable name="ERROR_ANCHOR_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_IMPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_NEED_HEADER" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_HEADER_NODE" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_ENCODING" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_VERSION" attributes="__const__" citdl="String" />
        <variable name="ERROR_ZERO_INDENT" attributes="__const__" citdl="String" />
        <variable name="ESCAPES" attributes="__const__" citdl="Array" />
        <variable name="ESCAPE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Emitter" ilk="class" classrefs="Object" >
          <scope name="emit" ilk="function" />
          <scope name="level" ilk="function" />
          <scope name="level=" ilk="function" />
          <scope name="node_export" ilk="function" />
          <scope name="reset" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="GenericResolver" attributes="__const__" citdl="Syck::Resolver" />
        <variable name="INDICATOR_CHAR" attributes="__const__" citdl="String" />
        <scope name="Map" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="MergeKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="NOT_PLAIN_CHAR" attributes="__const__" citdl="String" />
        <scope name="Node" ilk="class" classrefs="Object" >
          <import symbol="Syck::BaseNode" />
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="kind" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="transform" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
        </scope>
        <scope name="Object" ilk="class" >
          <scope name="class=" ilk="function" />
          <scope name="ivars" ilk="function" />
          <scope name="ivars=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Omap" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="Out" ilk="class" classrefs="Object" >
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="map" ilk="function" />
          <scope name="scalar" ilk="function" />
          <scope name="seq" ilk="function" />
        </scope>
        <variable name="PRINTABLE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Pairs" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="ParseError" ilk="class" classrefs="Syck::Error" >
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object" >
          <scope name="bufsize" ilk="function" />
          <scope name="bufsize=" ilk="function" />
          <scope name="input" ilk="function" />
          <scope name="input=" ilk="function" />
          <scope name="load" ilk="function" />
          <scope name="load_documents" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="PrivateType" ilk="class" classrefs="Object" >
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="RESTRICTED_INDICATORS" attributes="__const__" citdl="String" />
        <scope name="Resolver" ilk="class" classrefs="Object" >
          <scope name="add_type" ilk="function" />
          <scope name="detect_implicit" ilk="function" />
          <scope name="node_import" ilk="function" />
          <scope name="tags" ilk="function" />
          <scope name="tags=" ilk="function" />
          <scope name="tagurize" ilk="function" />
          <scope name="transfer" ilk="function" />
          <scope name="use_types_at" ilk="function" />
        </scope>
        <variable name="SPACE_INDICATORS" attributes="__const__" citdl="String" />
        <variable name="SUPPORTED_YAML_VERSIONS" attributes="__const__" citdl="Array" />
        <scope name="Scalar" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Seq" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Set" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(enum = nil)" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        </scope>
        <scope name="SpecialHash" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
        </scope>
        <scope name="Stream" ilk="class" classrefs="Object" >
          <scope name="add" ilk="function" />
          <scope name="documents" ilk="function" />
          <scope name="documents=" ilk="function" />
          <scope name="edit" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
        </scope>
        <scope name="TypeError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="UNESCAPES" attributes="__const__" citdl="Hash" />
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <variable name="WORD_CHAR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Psych" ilk="namespace" >
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
      </scope>
      <scope name="StringIO" ilk="class" classrefs="Data" >
        <import symbol="Enumerable" />
        <scope name="binmode" ilk="function" signature="binmode()" doc="Returns *strio* itself.  Just for compatibility to IO." />
        <scope name="bytes" ilk="function" signature="bytes()" doc="See IO#each_byte." />
        <scope name="chars" ilk="function" signature="chars()" doc="See IO#each_char." />
        <scope name="close" ilk="function" signature="close()" doc="Closes strio.  The *strio* is unavailable for any further data operations; an +IOError+ is raised if such an attempt is made." />
        <scope name="close_read" ilk="function" signature="close_read()" doc="Closes the read end of a StringIO.  Will raise an +IOError+ if the *strio* is not readable." />
        <scope name="close_write" ilk="function" signature="close_write()" doc="Closes the write end of a StringIO.  Will raise an  +IOError+ if the *strio* is not writeable." />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns +true+ if *strio* is completely closed, +false+ otherwise." />
        <scope name="closed_read?" ilk="function" signature="closed_read?()" doc="Returns +true+ if *strio* is not readable, +false+ otherwise." />
        <scope name="closed_write?" ilk="function" signature="closed_write?()" doc="Returns +true+ if *strio* is not writable, +false+ otherwise." />
        <scope name="codepoints" ilk="function" signature="codepoints()" doc="See IO#each_codepoint." />
        <scope name="each" ilk="function" signature="each(*args)" doc="See IO#each." />
        <scope name="each_byte" ilk="function" signature="each_byte()" doc="See IO#each_byte." />
        <scope name="each_char" ilk="function" signature="each_char()" doc="See IO#each_char." />
        <scope name="each_codepoint" ilk="function" signature="each_codepoint()" doc="See IO#each_codepoint." />
        <scope name="each_line" ilk="function" signature="each_line(*args)" doc="See IO#each." />
        <scope name="eof" ilk="function" signature="eof()" doc="Returns true if *strio* is at end of file. The stringio must be opened for reading or an +IOError+ will be raised." />
        <scope name="eof?" ilk="function" signature="eof?()" doc="Returns true if *strio* is at end of file. The stringio must be opened for reading or an +IOError+ will be raised." />
        <scope name="external_encoding" ilk="function" signature="external_encoding()" doc="Returns the Encoding object that represents the encoding of the file. If strio is write mode and no encoding is specified, returns nil." />
        <scope name="fcntl" ilk="function" signature="fcntl(*args)" doc="Raises NotImplementedError." />
        <scope name="fileno" ilk="function" signature="fileno()" doc="Returns +nil+.  Just for compatibility to IO." />
        <scope name="flush" ilk="function" signature="flush()" doc="Returns *strio* itself.  Just for compatibility to IO." />
        <scope name="fsync" ilk="function" signature="fsync()" doc="Returns 0.  Just for compatibility to IO." />
        <scope name="getbyte" ilk="function" signature="getbyte()" doc="See IO#getbyte." />
        <scope name="getc" ilk="function" signature="getc()" doc="See IO#getc." />
        <scope name="gets" ilk="function" signature="gets(*args)" doc="See IO#gets." />
        <scope name="internal_encoding" ilk="function" signature="internal_encoding()" doc="Returns the Encoding of the internal string if conversion is specified.  Otherwise returns nil." />
        <scope name="isatty" ilk="function" signature="isatty()" doc="Returns +false+.  Just for compatibility to IO." />
        <scope name="length" ilk="function" signature="length()" doc="Returns the size of the buffer string." />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Returns the current line number in *strio*. The stringio must be opened for reading. +lineno+ counts the number of times  +gets+ is called, rather than the number of newlines  encountered. The two values will differ if +gets+ is  called with a separator other than newline.  See also the  $. variable." />
        <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="Manually sets the current line number to the given value. $. is updated only on the next read." />
        <scope name="lines" ilk="function" signature="lines(*args)" doc="See IO#each." />
        <scope name="pid" ilk="function" signature="pid()" doc="Returns +nil+.  Just for compatibility to IO." />
        <scope name="pos" ilk="function" signature="pos()" doc="Returns the current offset (in bytes) of *strio*." />
        <scope name="pos=" ilk="function" signature="pos=(p1)" doc="Seeks to the given position (in bytes) in *strio*." />
        <scope name="print" ilk="function" signature="print(*args)" doc="See IO#print." />
        <scope name="printf" ilk="function" signature="printf(*args)" doc="See IO#printf." />
        <scope name="putc" ilk="function" signature="putc(p1)" doc="See IO#putc." />
        <scope name="puts" ilk="function" signature="puts(*args)" doc="See IO#puts." />
        <scope name="read" ilk="function" signature="read(*args)" doc="See IO#read." />
        <scope name="read_nonblock" ilk="function" signature="read_nonblock(*args)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="readbyte" ilk="function" signature="readbyte()" doc="See IO#readbyte." />
        <scope name="readchar" ilk="function" signature="readchar()" doc="See IO#readchar." />
        <scope name="readline" ilk="function" signature="readline(*args)" doc="See IO#readline." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" doc="See IO#readlines." />
        <scope name="readpartial" ilk="function" signature="readpartial(*args)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="reopen" ilk="function" signature="reopen(*args)" doc="Reinitializes *strio* with the given other_StrIO or _string_ and _mode_ (see StringIO#new)." />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Positions *strio* to the beginning of input, resetting +lineno+ to zero." />
        <scope name="seek" ilk="function" signature="seek(p1, p2 = v2)" doc="Seeks to a given offset _amount_ in the stream according to the value of _whence_ (see IO#seek)." />
        <scope name="set_encoding" ilk="function" signature="set_encoding(p1, p2 = v2, p3 = {})" doc="Specify the encoding of the StringIO as ext_enc. Use the default external encoding if ext_enc is nil. 2nd argument int_enc and optional hash opt argument are ignored; they are for API compatibility to IO." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of the buffer string." />
        <scope name="string" ilk="function" signature="string()" doc="Returns underlying String object, the subject of IO." />
        <scope name="string=" ilk="function" signature="string=(p1)" doc="Changes underlying String object, the subject of IO." />
        <scope name="sync" ilk="function" signature="sync()" doc="Returns +true+ always." />
        <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Returns the argument unchanged.  Just for compatibility to IO." />
        <scope name="sysread" ilk="function" signature="sysread(*args)" doc="Similar to #read, but raises +EOFError+ at end of string instead of returning +nil+, as well as IO#sysread does." />
        <scope name="syswrite" ilk="function" signature="syswrite(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="tell" ilk="function" signature="tell()" doc="Returns the current offset (in bytes) of *strio*." />
        <scope name="truncate" ilk="function" signature="truncate(p1)" doc="Truncates the buffer string to at most _integer_ bytes. The *strio* must be opened for writing." />
        <scope name="tty?" ilk="function" signature="tty?()" doc="Returns +false+.  Just for compatibility to IO." />
        <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="See IO#ungetbyte" />
        <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="Pushes back one character (passed as a parameter) onto *strio* such that a subsequent buffered read will return it.  There is no limitation for multiple pushbacks including pushing back behind the beginning of the buffer string." />
        <scope name="write" ilk="function" signature="write(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="write_nonblock" ilk="function" signature="write_nonblock(p1)" doc="Appends the given string to the underlying buffer string of *strio*. The stream must be opened for writing.  If the argument is not a string, it will be converted to a string using to_s. Returns the number of bytes written.  See IO#write." />
        <scope name="open" ilk="function" attributes="__classmethod__" signature="open(*args)" doc="Equivalent to StringIO.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block." />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(*args)" doc="Creates new StringIO instance from with _string_ and _mode_." />
      </scope>
      <scope name="DateTime" ilk="class" classrefs="Date" >
        <scope name="hour" ilk="function" />
        <scope name="min" ilk="function" />
        <scope name="minute" ilk="function" />
        <scope name="new_offset" ilk="function" />
        <scope name="offset" ilk="function" />
        <scope name="sec" ilk="function" />
        <scope name="sec_fraction" ilk="function" />
        <scope name="second" ilk="function" />
        <scope name="second_fraction" ilk="function" />
        <scope name="zone" ilk="function" />
        <scope name="now" ilk="function" attributes="__classmethod__" signature="now(p1 = v1)" doc="Creates a date-time object denoting the present time. &#xA; For example: &#xA; DateTime.now              =&gt; #&lt;DateTime: 2011-06-11T21:20:44+09:00 ...&gt;" />
        <scope name="new" ilk="function" attributes="__classmethod__" signature="new(p1 = v1, p2 = v2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 = v7, p8 = v8)" doc="Creates a date-time object denoting the given calendar date. &#xA; For example: &#xA; DateTime.new(2001,2,3)    =&gt; #&lt;DateTime: 2001-02-03T00:00:00+00:00 ...&gt;&#xA;DateTime.new(2001,2,3,4,5,6,&apos;+7&apos;)&#xA;                          =&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;&#xA;DateTime.new(2001,-11,-26,-20,-55,-54,&apos;+7&apos;)&#xA;                          =&gt; #&lt;DateTime: 2001-02-03T04:05:06+07:00 ...&gt;" />
        <variable name="ABBR_DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ABBR_MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="DAYNAMES" attributes="__const__" citdl="Array" />
        <variable name="ENGLAND" attributes="__const__" citdl="Fixnum" />
        <scope name="Format" ilk="namespace" >
          <variable name="ABBR_DAYS" attributes="__const__" citdl="Hash" />
          <variable name="ABBR_MONTHS" attributes="__const__" citdl="Hash" />
          <scope name="Bag" ilk="class" classrefs="Object" >
            <scope name="method_missing" ilk="function" />
            <scope name="to_hash" ilk="function" />
          </scope>
          <variable name="DAYS" attributes="__const__" citdl="Hash" />
          <variable name="MONTHS" attributes="__const__" citdl="Hash" />
          <variable name="ZONES" attributes="__const__" citdl="Hash" />
        </scope>
        <variable name="GREGORIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="HALF_DAYS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="HOURS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="ITALY" attributes="__const__" citdl="Fixnum" />
        <scope name="Infinity" ilk="class" classrefs="Numeric" >
          <import symbol="Comparable" />
          <scope name="d" ilk="function" />
          <scope name="finite?" ilk="function" />
          <scope name="infinite?" ilk="function" />
          <scope name="nan?" ilk="function" />
        </scope>
        <variable name="JULIAN" attributes="__const__" citdl="Date::Infinity" />
        <variable name="LD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MILLISECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MILLISECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="MINUTES_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="MJD_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
        <variable name="MONTHNAMES" attributes="__const__" citdl="Array" />
        <variable name="NANOSECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="NANOSECONDS_IN_SECOND" attributes="__const__" citdl="Rational" />
        <variable name="SECONDS_IN_DAY" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_AJD" attributes="__const__" citdl="Rational" />
        <variable name="UNIX_EPOCH_IN_CJD" attributes="__const__" citdl="Fixnum" />
      </scope>
      <scope name="YAML" ilk="namespace" >
        <scope name="add_builtin_type" ilk="function" />
        <scope name="add_domain_type" ilk="function" />
        <scope name="add_private_type" ilk="function" />
        <scope name="add_ruby_type" ilk="function" />
        <scope name="compile" ilk="function" />
        <scope name="detect_implicit" ilk="function" />
        <scope name="dump" ilk="function" />
        <scope name="dump_stream" ilk="function" />
        <scope name="each_document" ilk="function" />
        <scope name="each_node" ilk="function" />
        <scope name="emitter" ilk="function" />
        <scope name="generic_parser" ilk="function" />
        <scope name="load" ilk="function" />
        <scope name="load_documents" ilk="function" />
        <scope name="load_file" ilk="function" />
        <scope name="load_stream" ilk="function" />
        <scope name="object_maker" ilk="function" />
        <scope name="parse" ilk="function" />
        <scope name="parse_documents" ilk="function" />
        <scope name="parse_file" ilk="function" />
        <scope name="parser" ilk="function" />
        <scope name="quick_emit" ilk="function" />
        <scope name="read_type_class" ilk="function" />
        <scope name="resolver" ilk="function" />
        <scope name="tag_class" ilk="function" />
        <scope name="tagged_classes" ilk="function" />
        <scope name="tagurize" ilk="function" />
        <scope name="transfer" ilk="function" />
        <scope name="try_implicit" ilk="function" />
        <scope name="BadAlias" ilk="class" classrefs="Object" >
          <import symbol="Comparable" />
          <scope name="name" ilk="function" />
          <scope name="name=" ilk="function" />
        </scope>
        <scope name="BaseNode" ilk="namespace" >
          <scope name="at" ilk="function" />
          <scope name="children" ilk="function" />
          <scope name="children_with_index" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="match_path" ilk="function" />
          <scope name="match_segment" ilk="function" />
          <scope name="search" ilk="function" />
          <scope name="select" ilk="function" />
          <scope name="select!" ilk="function" />
        </scope>
        <variable name="DEFAULTS" attributes="__const__" citdl="Hash" />
        <variable name="DNS_COMP_RE" attributes="__const__" citdl="String" />
        <variable name="DNS_NAME_RE" attributes="__const__" citdl="String" />
        <scope name="DefaultKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="DefaultResolver" attributes="__const__" citdl="Syck::Resolver" />
        <scope name="DomainType" ilk="class" classrefs="Object" >
          <scope name="domain" ilk="function" />
          <scope name="domain=" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="ENGINE" attributes="__const__" citdl="YAML::EngineManager" />
        <variable name="ERROR_ANCHOR_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_BAD_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ALIAS" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_EXPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_MANY_IMPLICIT" attributes="__const__" citdl="String" />
        <variable name="ERROR_NEED_HEADER" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_ANCHOR" attributes="__const__" citdl="String" />
        <variable name="ERROR_NO_HEADER_NODE" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_ENCODING" attributes="__const__" citdl="String" />
        <variable name="ERROR_UNSUPPORTED_VERSION" attributes="__const__" citdl="String" />
        <variable name="ERROR_ZERO_INDENT" attributes="__const__" citdl="String" />
        <variable name="ESCAPES" attributes="__const__" citdl="Array" />
        <variable name="ESCAPE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Emitter" ilk="class" classrefs="Object" >
          <scope name="emit" ilk="function" />
          <scope name="level" ilk="function" />
          <scope name="level=" ilk="function" />
          <scope name="node_export" ilk="function" />
          <scope name="reset" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="GenericResolver" attributes="__const__" citdl="Syck::Resolver" />
        <variable name="INDICATOR_CHAR" attributes="__const__" citdl="String" />
        <scope name="Map" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="MergeKey" ilk="class" classrefs="Object" >
        </scope>
        <variable name="NOT_PLAIN_CHAR" attributes="__const__" citdl="String" />
        <scope name="Node" ilk="class" classrefs="Object" >
          <import symbol="Syck::BaseNode" />
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="kind" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="transform" ilk="function" />
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
        </scope>
        <scope name="Object" ilk="class" >
          <scope name="class=" ilk="function" />
          <scope name="ivars" ilk="function" />
          <scope name="ivars=" ilk="function" />
          <scope name="yaml_initialize" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <scope name="Omap" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="Out" ilk="class" classrefs="Object" >
          <scope name="emitter" ilk="function" />
          <scope name="emitter=" ilk="function" />
          <scope name="map" ilk="function" />
          <scope name="scalar" ilk="function" />
          <scope name="seq" ilk="function" />
        </scope>
        <variable name="PRINTABLE_CHAR" attributes="__const__" citdl="String" />
        <scope name="Pairs" ilk="class" classrefs="Array" >
          <import symbol="Enumerable" />
          <scope name="has_key?" ilk="function" />
          <scope name="is_complex_yaml?" ilk="function" />
        </scope>
        <scope name="ParseError" ilk="class" classrefs="Syck::Error" >
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object" >
          <scope name="bufsize" ilk="function" />
          <scope name="bufsize=" ilk="function" />
          <scope name="input" ilk="function" />
          <scope name="input=" ilk="function" />
          <scope name="load" ilk="function" />
          <scope name="load_documents" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
          <scope name="resolver" ilk="function" />
          <scope name="resolver=" ilk="function" />
          <scope name="set_resolver" ilk="function" />
        </scope>
        <scope name="PrivateType" ilk="class" classrefs="Object" >
          <scope name="type_id" ilk="function" />
          <scope name="type_id=" ilk="function" />
          <scope name="value" ilk="function" />
          <scope name="value=" ilk="function" />
          <scope name="tag_subclasses?" ilk="function" attributes="__classmethod__" />
        </scope>
        <variable name="RESTRICTED_INDICATORS" attributes="__const__" citdl="String" />
        <scope name="Resolver" ilk="class" classrefs="Object" >
          <scope name="add_type" ilk="function" />
          <scope name="detect_implicit" ilk="function" />
          <scope name="node_import" ilk="function" />
          <scope name="tags" ilk="function" />
          <scope name="tags=" ilk="function" />
          <scope name="tagurize" ilk="function" />
          <scope name="transfer" ilk="function" />
          <scope name="use_types_at" ilk="function" />
        </scope>
        <variable name="SPACE_INDICATORS" attributes="__const__" citdl="String" />
        <variable name="SUPPORTED_YAML_VERSIONS" attributes="__const__" citdl="Array" />
        <scope name="Scalar" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Seq" ilk="class" classrefs="Syck::Node" >
          <import symbol="Syck::BaseNode" />
          <scope name="add" ilk="function" />
          <scope name="style=" ilk="function" />
          <scope name="value=" ilk="function" />
        </scope>
        <scope name="Set" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new(enum = nil)" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        </scope>
        <scope name="SpecialHash" ilk="class" classrefs="Hash" >
          <import symbol="Enumerable" />
        </scope>
        <scope name="Stream" ilk="class" classrefs="Object" >
          <scope name="add" ilk="function" />
          <scope name="documents" ilk="function" />
          <scope name="documents=" ilk="function" />
          <scope name="edit" ilk="function" />
          <scope name="emit" ilk="function" />
          <scope name="options" ilk="function" />
          <scope name="options=" ilk="function" />
        </scope>
        <scope name="TypeError" ilk="class" classrefs="StandardError" >
        </scope>
        <variable name="UNESCAPES" attributes="__const__" citdl="Hash" />
        <variable name="VERSION" attributes="__const__" citdl="String" />
        <variable name="WORD_CHAR" attributes="__const__" citdl="String" />
      </scope>
      <scope name="Monitor" ilk="class" classrefs="Object" >
        <import symbol="MonitorMixin" />
        <scope name="enter" ilk="function" />
        <scope name="exit" ilk="function" />
        <scope name="try_enter" ilk="function" />
        <scope name="ConditionVariable" ilk="class" classrefs="Object" >
          <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
          <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
          <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
          <scope name="wait_until" ilk="function" />
          <scope name="wait_while" ilk="function" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
          <scope name="Timeout" ilk="class" classrefs="Exception" >
          </scope>
        </scope>
      </scope>
      <scope name="MonitorMixin" ilk="namespace" >
        <scope name="extend_object" ilk="function" />
        <scope name="mon_enter" ilk="function" signature="mon_enter()" doc="Enters exclusive section." />
        <scope name="mon_exit" ilk="function" signature="mon_exit()" doc="Leaves exclusive section." />
        <scope name="mon_synchronize" ilk="function" signature="mon_synchronize()" doc="Enters exclusive section and executes the block.  Leaves the exclusive section automatically when the block exits.  See example under +MonitorMixin+." />
        <scope name="mon_try_enter" ilk="function" signature="mon_try_enter()" doc="Attempts to enter exclusive section.  Returns +false+ if lock fails." />
        <scope name="new_cond" ilk="function" signature="new_cond()" doc="Creates a new MonitorMixin::ConditionVariable associated with the receiver." />
        <scope name="synchronize" ilk="function" signature="synchronize()" />
        <scope name="try_mon_enter" ilk="function" signature="try_mon_enter()" doc="For backward compatibility" />
        <scope name="ConditionVariable" ilk="class" classrefs="Object" >
          <scope name="broadcast" ilk="function" signature="broadcast()" doc="Wakes up all threads waiting for this lock." />
          <scope name="signal" ilk="function" signature="signal()" doc="Wakes up the first thread in line waiting for this lock." />
          <scope name="wait" ilk="function" signature="wait(mutex, timeout=nil)" doc="Releases the lock held in +mutex+ and waits; reacquires the lock on wakeup. &#xA; If +timeout+ is given, this method returns after +timeout+ seconds passed, even if no other thread doesn&apos;t signal." />
          <scope name="wait_until" ilk="function" />
          <scope name="wait_while" ilk="function" />
          <scope name="new" ilk="function" attributes="__classmethod__" signature="new()" doc="Creates a new ConditionVariable" />
          <scope name="Timeout" ilk="class" classrefs="Exception" >
          </scope>
        </scope>
      </scope>
      <scope name="Array" ilk="function" signature="Array(p1)" doc="Returns arg as an Array. First tries to call arg.to_ary, then arg.to_a. &#xA; Array(1..5)   =&gt; [1, 2, 3, 4, 5]" />
      <scope name="Complex" ilk="function" signature="Complex(*args)" doc="Returns x+i*y;" />
      <scope name="Float" ilk="function" signature="Float(p1)" doc="Returns arg converted to a float. Numeric types are converted directly, the rest are converted using arg.to_f. As of Ruby 1.8, converting nil generates a TypeError. &#xA; Float(1)           =&gt; 1.0&#xA;Float(&quot;123.456&quot;)   =&gt; 123.456" />
      <scope name="Integer" ilk="function" signature="Integer(p1, p2 = v2)" doc="Converts arg to a Fixnum or Bignum. Numeric types are converted directly (with floating point numbers being truncated).    base (0, or between 2 and 36) is a base for integer string representation.  If arg is a String, when base is omitted or equals to zero, radix indicators (0, 0b, and 0x) are honored. In any case, strings should be strictly conformed to numeric representation. This behavior is different from that of String#to_i.  Non string values will be converted using to_int, and to_i. &#xA; Integer(123.999)    =&gt; 123&#xA;Integer(&quot;0x1a&quot;)     =&gt; 26&#xA;Integer(Time.new)   =&gt; 1204973019&#xA;Integer(&quot;0930&quot;, 10) =&gt; 930&#xA;Integer(&quot;111&quot;, 2)   =&gt; 7" />
      <scope name="Rational" ilk="function" signature="Rational(*args)" doc="Returns x/y;" />
      <scope name="String" ilk="function" signature="String(p1)" doc="Converts arg to a String by calling its to_s method. &#xA; String(self)        =&gt; &quot;main&quot;&#xA;String(self.class)  =&gt; &quot;Object&quot;&#xA;String(123456)      =&gt; &quot;123456&quot;" />
      <scope name="URI" ilk="function" signature="URI(uri)" doc="Returns +uri+ converted to a URI object." />
      <scope name="__callee__" ilk="function" signature="__callee__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
      <scope name="__method__" ilk="function" signature="__method__()" doc="Returns the name of the current method as a Symbol. If called outside of a method, it returns nil." />
      <scope name="`" ilk="function" signature="`(p1)" doc="Returns the standard output of running _cmd_ in a subshell. The built-in syntax %x{...} uses this method. Sets $? to the process status. &#xA; `date`                   =&gt; &quot;Wed Apr  9 08:56:30 CDT 2003\n&quot;&#xA;`ls testdir`.split[1]    =&gt; &quot;main.rb&quot;&#xA;`echo oops &amp;&amp; exit 99`   =&gt; &quot;oops\n&quot;&#xA;$?.exitstatus            =&gt; 99" />
      <scope name="abort" ilk="function" signature="abort(p1)" doc="Terminate execution immediately, effectively by calling Kernel.exit(false). If _msg_ is given, it is written to STDERR prior to terminating." />
      <scope name="at_exit" ilk="function" signature="at_exit()" doc="Converts _block_ to a +Proc+ object (and therefore binds it at the point of call) and registers it for execution when the program exits. If multiple handlers are registered, they are executed in reverse order of registration. &#xA; def do_at_exit(str1)&#xA;  at_exit { print str1 }&#xA;end&#xA;at_exit { puts &quot;cruel world&quot; }&#xA;do_at_exit(&quot;goodbye &quot;)&#xA;exit&#xA; produces: &#xA; goodbye cruel world" />
      <scope name="binding" ilk="function" signature="binding()" doc="Returns a +Binding+ object, describing the variable and method bindings at the point of call. This object can be used when calling +eval+ to execute the evaluated command in this environment. See also the description of class +Binding+. &#xA; def get_binding(param)&#xA;  return binding&#xA;end&#xA;b = get_binding(&quot;hello&quot;)&#xA;eval(&quot;param&quot;, b)   =&gt; &quot;hello&quot;" />
      <scope name="block_given?" ilk="function" signature="block_given?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA; def try&#xA;  if block_given?&#xA;    yield&#xA;  else&#xA;    &quot;no block&quot;&#xA;  end&#xA;end&#xA;try                  =&gt; &quot;no block&quot;&#xA;try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
      <scope name="caller" ilk="function" signature="caller(p1 = v1)" doc="Returns the current execution stack---an array containing strings in the form ``file:line&apos;&apos; or ``file:line: in `method&apos;&apos;&apos;. The optional _start_ parameter determines the number of initial stack entries to omit from the result. &#xA; Returns +nil+ if _start_ is greater than the size of current execution stack. &#xA; def a(skip)&#xA;  caller(skip)&#xA;end&#xA;def b(skip)&#xA;  a(skip)&#xA;end&#xA;def c(skip)&#xA;  b(skip)&#xA;end&#xA;c(0)   =&gt; [&quot;prog:2:in `a&apos;&quot;, &quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:10:in `&lt;main&gt;&apos;&quot;]&#xA;c(1)   =&gt; [&quot;prog:5:in `b&apos;&quot;, &quot;prog:8:in `c&apos;&quot;, &quot;prog:11:in `&lt;main&gt;&apos;&quot;]" />
      <scope name="catch" ilk="function" signature="catch(p1 = v1)" doc="+catch+ executes its block. If a +throw+ is executed, Ruby searches up its stack for a +catch+ block with a tag corresponding to the +throw+&apos;s _tag_. If found, that block is terminated, and +catch+ returns the value given to +throw+. If +throw+ is not called, the block terminates normally, and the value of +catch+ is the value of the last expression evaluated. +catch+ expressions may be nested, and the +throw+ call need not be in lexical scope. &#xA; def routine(n)&#xA;  puts n&#xA;  throw :done if n &lt;= 0&#xA;  routine(n-1)&#xA;end&#xA;catch(:done) { routine(3) }&#xA; produces: &#xA; 3&#xA;2&#xA;1&#xA;0&#xA; when _arg_ is given, +catch+ yields it as is, or when no _arg_ is given, +catch+ assigns a new unique object to +throw+.  this is useful for nested +catch+.  _arg_ can be an arbitrary object, not only Symbol." />
      <scope name="eval" ilk="function" signature="eval(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Evaluates the Ruby expression(s) in string. If binding is given, which must be a Binding object, the evaluation is performed in its context. If the optional filename and lineno parameters are present, they will be used when reporting syntax errors. &#xA; def get_binding(str)&#xA;  return binding&#xA;end&#xA;str = &quot;hello&quot;&#xA;eval &quot;str + &apos; Fred&apos;&quot;                      =&gt; &quot;hello Fred&quot;&#xA;eval &quot;str + &apos; Fred&apos;&quot;, get_binding(&quot;bye&quot;)  =&gt; &quot;bye Fred&quot;" />
      <scope name="exec" ilk="function" signature="exec(*args)" doc="Replaces the current process by running the given external _command_. _command..._ is one of following forms. &#xA; commandline                 : command line string which is passed to the standard shell&#xA;cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; If single string is given as the command, it is taken as a command line that is subject to shell expansion before being executed. &#xA; The standard shell means always &quot;/bin/sh&quot; on Unix-like systems, ENV[&quot;RUBYSHELL&quot;] or ENV[&quot;COMSPEC&quot;] on Windows NT series, and similar. &#xA; If two or more +string+ given, the first is taken as a command name and the rest are passed as parameters to command with no shell expansion. &#xA; If a two-element array at the beginning of the command, the first element is the command to be executed, and the second argument is used as the argv[0] value, which may show up in process listings. &#xA; In order to execute the command, one of the exec(2) system calls is used, so the running command may inherit some of the environment of the original program (including open file descriptors). This behavior is modified by env and options. See spawn for details. &#xA; Raises SystemCallError if the command couldn&apos;t execute (typically Errno::ENOENT when it was not found). &#xA; exec &quot;echo *&quot;       # echoes list of files in current directory&#xA;# never get here&#xA;exec &quot;echo&quot;, &quot;*&quot;    # echoes an asterisk" />
      <scope name="exit" ilk="function" signature="exit(p1 = v1)" doc="Initiates the termination of the Ruby script by raising the SystemExit exception. This exception may be caught. The optional parameter is used to return a status code to the invoking environment. +true+ and +FALSE+ of _status_ means success and failure respectively.  The interpretation of other integer values are system dependent. &#xA; begin&#xA;  exit&#xA;  puts &quot;never get here&quot;&#xA;rescue SystemExit&#xA;  puts &quot;rescued a SystemExit exception&quot;&#xA;end&#xA;puts &quot;after begin block&quot;&#xA; produces: &#xA; rescued a SystemExit exception&#xA;after begin block&#xA; Just prior to termination, Ruby executes any at_exit functions (see Kernel::at_exit) and runs any object finalizers (see ObjectSpace::define_finalizer). &#xA; at_exit { puts &quot;at_exit function&quot; }" />
      <scope name="exit!" ilk="function" signature="exit!(p1 = v1)" doc="Exits the process immediately. No exit handlers are run. status is returned to the underlying system as the exit status. &#xA; Process.exit!(true)" />
      <scope name="fail" ilk="function" signature="fail(*args)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA; raise &quot;Failed to create socket&quot;&#xA;raise ArgumentError, &quot;No parameters&quot;, caller" />
      <scope name="fork" ilk="function" signature="fork()" doc="Creates a subprocess. If a block is specified, that block is run in the subprocess, and the subprocess terminates with a status of zero. Otherwise, the +fork+ call returns twice, once in the parent, returning the process ID of the child, and once in the child, returning _nil_. The child process can exit using Kernel.exit! to avoid running any at_exit functions. The parent process should use Process.wait to collect the termination statuses of its children or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; The thread calling fork is the only thread in the created child process. fork doesn&apos;t copy other threads. &#xA; If fork is not usable, Process.respond_to?(:fork) returns false." />
      <scope name="format" ilk="function" signature="format(*args)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA; %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA; Field |  Integer Format&#xA;------+--------------------------------------------------------------&#xA;  b   | Convert argument as a binary number.&#xA;      | Negative numbers will be displayed as a two&apos;s complement&#xA;      | prefixed with `..1&apos;.&#xA;  B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;      | in the alternative format by #.&#xA;  d   | Convert argument as a decimal number." />
      <scope name="gets" ilk="function" signature="gets(*args)" doc="Returns (and assigns to $_) the next line from the list of files in +ARGV+ (or $*), or from standard input if no files are present on the command line. Returns +nil+ at end of file. The optional argument specifies the record separator. The separator is included with the contents of each record. A separator of +nil+ reads the entire contents, and a zero-length separator reads the input one paragraph at a time, where paragraphs are divided by two consecutive newlines.  If the first argument is an integer, or optional second argument is given, the returning string would not be longer than the given value in bytes.  If multiple filenames are present in +ARGV+, +gets(nil)+ will read the contents one file at a time. &#xA; ARGV &lt;&lt; &quot;testfile&quot;&#xA;print while gets&#xA; produces: &#xA; This is line one&#xA;This is line two&#xA;This is line three&#xA;And so on...&#xA; The style of programming using $_ as an implicit parameter is gradually losing favor in the Ruby community." />
      <scope name="global_variables" ilk="function" signature="global_variables()" doc="Returns an array of the names of global variables. &#xA; global_variables.grep /std/   =&gt; [:$stdin, :$stdout, :$stderr]" />
      <scope name="iterator?" ilk="function" signature="iterator?()" doc="Returns true if yield would execute a block in the current context. The iterator? form is mildly deprecated. &#xA; def try&#xA;  if block_given?&#xA;    yield&#xA;  else&#xA;    &quot;no block&quot;&#xA;  end&#xA;end&#xA;try                  =&gt; &quot;no block&quot;&#xA;try { &quot;hello&quot; }      =&gt; &quot;hello&quot;&#xA;try do &quot;hello&quot; end   =&gt; &quot;hello&quot;" />
      <scope name="lambda" ilk="function" signature="lambda()" doc="Equivalent to Proc.new, except the resulting Proc objects check the number of parameters passed when called." />
      <scope name="load" ilk="function" signature="load(p1, p2 = v2)" doc="Loads and executes the Ruby program in the file _filename_. If the filename does not resolve to an absolute path, the file is searched for in the library directories listed in $:. If the optional _wrap_ parameter is +true+, the loaded script will be executed under an anonymous module, protecting the calling program&apos;s global namespace. In no circumstance will any local variables in the loaded file be propagated to the loading environment." />
      <scope name="local_variables" ilk="function" signature="local_variables()" doc="Returns the names of the current local variables. &#xA; fred = 1&#xA;for i in 1..10&#xA;   # ...&#xA;end&#xA;local_variables   =&gt; [:fred, :i]" />
      <scope name="loop" ilk="function" signature="loop()" doc="Repeatedly executes the block. &#xA; If no block is given, an enumerator is returned instead. &#xA; loop do&#xA;  print &quot;Input: &quot;&#xA;  line = gets&#xA;  break if !line or line =~ /^qQ/&#xA;  # ...&#xA;end&#xA; StopIteration raised in the block breaks the loop." />
      <scope name="open" ilk="function" signature="open(*args)" doc="Creates an IO object connected to the given stream, file, or subprocess. &#xA; If path does not start with a pipe character (``|&apos;&apos;), treat it as the name of a file to open using the specified mode (defaulting to ``r&apos;&apos;). &#xA; The mode_enc is either a string or an integer.  If it is an integer, it must be bitwise-or of open(2) flags, such as File::RDWR or File::EXCL. If it is a string, it is either &quot;mode&quot;, &quot;mode:ext_enc&quot;, or &quot;mode:ext_enc:int_enc&quot;. The mode is one of the following: &#xA; r: read (default)&#xA;w: write&#xA;a: append&#xA; The mode can be followed by &quot;b&quot; (means binary-mode), or &quot;+&quot; (means both reading and writing allowed) or both. If ext_enc (external encoding) is specified, read string will be tagged by the encoding in reading, and output string will be converted to the specified encoding in writing. If ext_enc starts with &apos;BOM|&apos;, check whether the input has a BOM. If there is a BOM, strip it and set external encoding as what the BOM tells. If there is no BOM, use ext_enc without &apos;BOM|&apos;. If two encoding names, ext_enc and int_enc (external encoding and internal encoding), are specified, the read string is converted from ext_enc to int_enc then tagged with the int_enc in read mode, and in write mode, the output string will be converted from int_enc to ext_enc before writing. &#xA; If a file is being created, its initial permissions may be set using the integer third parameter. &#xA; If a block is specified, it will be invoked with the File object as a parameter, and the file will be automatically closed when the block terminates. The call returns the value of the block. &#xA; If path starts with a pipe character, a subprocess is created, connected to the caller by a pair of pipes. The returned IO object may be used to write to the standard input and read from the standard output of this subprocess. If the command following the ``|&apos;&apos; is a single minus sign, Ruby forks, and this subprocess is connected to the parent. In the subprocess, the open call returns nil. If the command is not ``-&apos;&apos;, the subprocess runs the command. If a block is associated with an open(&quot;|-&quot;) call, that block will be run twice---once in the parent and once in the child. The block parameter will be an IO object in the parent and nil in the child. The parent&apos;s IO object will be connected to the child&apos;s $stdin and $stdout. The subprocess will be terminated at the end of the block. &#xA; open(&quot;testfile&quot;) do |f|&#xA;  print f.gets&#xA;end" />
      <scope name="p" ilk="function" signature="p(*args)" doc="For each object, directly writes _obj_.+inspect+ followed by a newline to the program&apos;s standard output. &#xA; S = Struct.new(:name, :state)&#xA;s = S[&apos;dave&apos;, &apos;TX&apos;]&#xA;p s&#xA; produces: &#xA; #&lt;S name=&quot;dave&quot;, state=&quot;TX&quot;&gt;" />
      <scope name="print" ilk="function" signature="print(*args)" doc="Prints each object in turn to $stdout. If the output field separator ($,) is not +nil+, its contents will appear between each field. If the output record separator ($\\) is not +nil+, it will be appended to the output. If no arguments are given, prints $_. Objects that aren&apos;t strings will be converted by calling their to_s method. &#xA; print &quot;cat&quot;, [1,2,3], 99, &quot;\n&quot;&#xA;$, = &quot;, &quot;&#xA;$\ = &quot;\n&quot;&#xA;print &quot;cat&quot;, [1,2,3], 99&#xA; produces: &#xA; cat12399&#xA;cat, 1, 2, 3, 99" />
      <scope name="printf" ilk="function" signature="printf(*args)" doc="Equivalent to: io.write(sprintf(string, obj, ...)&#xA; or $stdout.write(sprintf(string, obj, ...)" />
      <scope name="proc" ilk="function" signature="proc()" doc="Equivalent to Proc.new." />
      <scope name="putc" ilk="function" signature="putc(p1)" doc="Equivalent to:&#xA;&#xA;  $stdout.putc(int)&#xA; Refer to the documentation for IO#putc for important information regarding multi-byte characters." />
      <scope name="puts" ilk="function" signature="puts(*args)" doc="Equivalent to &#xA; $stdout.puts(obj, ...)" />
      <scope name="raise" ilk="function" signature="raise(*args)" doc="With no arguments, raises the exception in $! or raises a RuntimeError if $! is +nil+. With a single +String+ argument, raises a +RuntimeError+ with the string as a message. Otherwise, the first parameter should be the name of an +Exception+ class (or an object that returns an +Exception+ object when sent an +exception+ message). The optional second parameter sets the message associated with the exception, and the third parameter is an array of callback information. Exceptions are caught by the +rescue+ clause of begin...end blocks. &#xA; raise &quot;Failed to create socket&quot;&#xA;raise ArgumentError, &quot;No parameters&quot;, caller" />
      <scope name="rand" ilk="function" signature="rand(p1 = v1)" doc="If max is +Range+, returns a pseudorandom number where range.member(number) == true. &#xA; Or else converts _max_ to an integer using max1 = max.to_i.abs. &#xA; Then if _max_ is +nil+ the result is zero, returns a pseudorandom floating point number greater than or equal to 0.0 and less than 1.0. &#xA; Otherwise, returns a pseudorandom integer greater than or equal to zero and less than max1. &#xA; Kernel::srand may be used to ensure repeatable sequences of random numbers between different runs of the program. Ruby currently uses a modified Mersenne Twister with a period of 2**19937-1. &#xA; srand 1234                 =&gt; 0&#xA;[ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]&#xA;[ rand(10), rand(1000) ]   =&gt; [6, 817]&#xA;srand 1234                 =&gt; 1234&#xA;[ rand,  rand ]            =&gt; [0.191519450163469, 0.49766366626136]" />
      <scope name="readline" ilk="function" signature="readline(*args)" doc="Equivalent to Kernel::gets, except +readline+ raises +EOFError+ at end of file." />
      <scope name="readlines" ilk="function" signature="readlines(*args)" doc="Returns an array containing the lines returned by calling Kernel.gets(sep) until the end of file." />
      <scope name="require" ilk="function" signature="require(p1)" doc="Loads the given +name+, returning +true+ if successful and +false+ if the feature is already loaded. &#xA; If the filename does not resolve to an absolute path, it will be searched for in the directories listed in $LOAD_PATH ($:). &#xA; If the filename has the extension &quot;.rb&quot;, it is loaded as a source file; if the extension is &quot;.so&quot;, &quot;.o&quot;, or &quot;.dll&quot;, or the default shared library extension on the current platform, Ruby loads the shared library as a Ruby extension.  Otherwise, Ruby tries adding &quot;.rb&quot;, &quot;.so&quot;, and so on to the name until found.  If the file named cannot be found, a LoadError will be raised. &#xA; For Ruby extensions the filename given may use any shared library extension.  For example, on Linux the socket extension is &quot;socket.so&quot; and require &apos;socket.dll&apos; will load the socket extension. &#xA; The absolute path of the loaded file is added to $LOADED_FEATURES ($&quot;).  A file will not be loaded again if its path already appears in $&quot;.  For example, require &apos;a&apos;; require &apos;./a&apos; will not load a.rb again. &#xA; require &quot;my-library.rb&quot;&#xA;require &quot;db-driver&quot;" />
      <scope name="require_relative" ilk="function" signature="require_relative(p1)" doc="Ruby tries to load the library named _string_ relative to the requiring file&apos;s path.  If the file&apos;s path cannot be determined a LoadError is raised. If a file is loaded +true+ is returned and false otherwise." />
      <scope name="select" ilk="function" signature="select(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Calls select(2) system call. It monitors given arrays of IO objects, waits one or more of IO objects ready for reading, are ready for writing, and have pending exceptions respectably, and returns an array that contains arrays of those IO objects.  It will return nil if optional timeout value is given and no IO object is ready in timeout seconds. &#xA; Parameters an array of IO objects that wait until ready for read&#xA;an array of IO objects that wait until ready for write&#xA;an array of IO objects that wait for exceptions&#xA;a numeric value in second &#xA; Example &#xA; rp, wp = IO.pipe&#xA;mesg = &quot;ping &quot;&#xA;100.times {&#xA;  rs, ws, = IO.select([rp], [wp])&#xA;  if r = rs[0]&#xA;    ret = r.read(5)&#xA;    print ret" />
      <scope name="set_trace_func" ilk="function" signature="set_trace_func(p1)" doc="Establishes _proc_ as the handler for tracing, or disables tracing if the parameter is +nil+. _proc_ takes up to six parameters: an event name, a filename, a line number, an object id, a binding, and the name of a class. _proc_ is invoked whenever an event occurs. Events are: c-call (call a C-language routine), c-return (return from a C-language routine), call (call a Ruby method), class (start a class or module definition), end (finish a class or module definition), line (execute code on a new line), raise (raise an exception), and return (return from a Ruby method). Tracing is disabled within the context of _proc_. &#xA;   class Test&#xA;  def test&#xA;    a = 1&#xA;    b = 2&#xA;  end&#xA;  end&#xA;  set_trace_func proc { |event, file, line, id, binding, classname|&#xA;     printf &quot;%8s %s:%-2d %10s %8s\n&quot;, event, file, line, id, classname&#xA;  }&#xA;  t = Test.new&#xA;  t.test&#xA;    line prog.rb:11               false" />
      <scope name="sleep" ilk="function" signature="sleep(*args)" doc="Suspends the current thread for _duration_ seconds (which may be any number, including a +Float+ with fractional seconds). Returns the actual number of seconds slept (rounded), which may be less than that asked for if another thread calls Thread#run. Called without an argument, sleep() will sleep forever. &#xA; Time.new    =&gt; 2008-03-08 19:56:19 +0900&#xA;sleep 1.2   =&gt; 1&#xA;Time.new    =&gt; 2008-03-08 19:56:20 +0900&#xA;sleep 1.9   =&gt; 2&#xA;Time.new    =&gt; 2008-03-08 19:56:22 +0900" />
      <scope name="spawn" ilk="function" signature="spawn(*args)" doc="spawn executes specified command and return its pid. &#xA; This method doesn&apos;t wait for end of the command. The parent process should use Process.wait to collect the termination status of its child or use Process.detach to register disinterest in their status; otherwise, the operating system may accumulate zombie processes. &#xA; spawn has bunch of options to specify process attributes: &#xA; env: hash&#xA;  name =&gt; val : set the environment variable&#xA;  name =&gt; nil : unset the environment variable&#xA;command...:&#xA;  commandline                 : command line string which is passed to the standard shell&#xA;  cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;  [cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA;options: hash&#xA;  clearing environment variables:&#xA;    :unsetenv_others =&gt; true   : clear environment variables except specified by env" />
      <scope name="sprintf" ilk="function" signature="sprintf(*args)" doc="Returns the string resulting from applying format_string to any additional arguments.  Within the format string, any characters other than format sequences are copied to the result. &#xA; The syntax of a format sequence is follows. &#xA; %[flags][width][.precision]type&#xA; A format sequence consists of a percent sign, followed by optional flags, width, and precision indicators, then terminated with a field type character.  The field type controls how the corresponding sprintf argument is to be interpreted, while the flags modify that interpretation. &#xA; The field type characters are: &#xA; Field |  Integer Format&#xA;------+--------------------------------------------------------------&#xA;  b   | Convert argument as a binary number.&#xA;      | Negative numbers will be displayed as a two&apos;s complement&#xA;      | prefixed with `..1&apos;.&#xA;  B   | Equivalent to `b&apos;, but uses an uppercase 0B for prefix&#xA;      | in the alternative format by #.&#xA;  d   | Convert argument as a decimal number." />
      <scope name="srand" ilk="function" signature="srand(p1 = v1)" doc="Seeds the pseudorandom number generator to the value of number. If number is omitted, seeds the generator using a combination of the time, the process id, and a sequence number. (This is also the behavior if Kernel::rand is called without previously calling srand, but without the sequence.) By setting the seed to a known value, scripts can be made deterministic during testing. The previous seed value is returned. Also see Kernel::rand." />
      <scope name="syscall" ilk="function" signature="syscall(*args)" doc="Calls the operating system function identified by _num_ and&#xA;returns the result of the function or raises SystemCallError if&#xA;it failed.&#xA;Arguments for the function can follow _num_. They must be either&#xA;+String+ objects or +Integer+ objects. A +String+ object is passed&#xA;as a pointer to the byte sequence. An +Integer+ object is passed&#xA;as an integer whose bit size is same as a pointer.&#xA;Up to nine parameters may be passed (14 on the Atari-ST).&#xA;The function identified by _num_ is system&#xA;dependent. On some Unix systems, the numbers may be obtained from a&#xA;header file called syscall.h.&#xA;   syscall 4, 1, &quot;hello\n&quot;, 6   # &apos;4&apos; is write(2) on our box&#xA;produces:" />
      <scope name="system" ilk="function" signature="system(*args)" doc="Executes _command..._ in a subshell. _command..._ is one of following forms. &#xA; commandline                 : command line string which is passed to the standard shell&#xA;cmdname, arg1, ...          : command name and one or more arguments (no shell)&#xA;[cmdname, argv0], arg1, ... : command name, argv[0] and zero or more arguments (no shell)&#xA; system returns +true+ if the command gives zero exit status, +false+ for non zero exit status. Returns +nil+ if command execution fails. An error status is available in $?. The arguments are processed in the same way as for Kernel.spawn. &#xA; The hash arguments, env and options, are same as exec and spawn. See Kernel.spawn for details. &#xA; system(&quot;echo *&quot;)&#xA;system(&quot;echo&quot;, &quot;*&quot;)&#xA; produces: &#xA; config.h main.rb&#xA;*&#xA; See Kernel.exec for the standard shell." />
      <scope name="test" ilk="function" signature="test(*args)" doc="Uses the integer aCmd to perform various tests on&#xA;file1 (first table below) or on file1 and&#xA;file2 (second table).&#xA;File tests on a single file:&#xA;  Test   Returns   Meaning&#xA;  &quot;A&quot;  | Time    | Last access time for file1&#xA;  &quot;b&quot;  | boolean | True if file1 is a block device&#xA;  &quot;c&quot;  | boolean | True if file1 is a character device&#xA;  &quot;C&quot;  | Time    | Last change time for file1&#xA;  &quot;d&quot;  | boolean | True if file1 exists and is a directory&#xA;  &quot;e&quot;  | boolean | True if file1 exists&#xA;  &quot;f&quot;  | boolean | True if file1 exists and is a regular file&#xA;  &quot;g&quot;  | boolean | True if file1 has the \CF{setgid} bit" />
      <scope name="throw" ilk="function" signature="throw(p1, p2 = v2)" doc="Transfers control to the end of the active +catch+ block waiting for _tag_. Raises +ArgumentError+ if there is no +catch+ block for the _tag_. The optional second parameter supplies a return value for the +catch+ block, which otherwise defaults to +nil+. For examples, see Kernel::catch." />
      <scope name="trace_var" ilk="function" signature="trace_var(p1, p2 = v2)" doc="Controls tracing of assignments to global variables. The parameter +symbol_ identifies the variable (as either a string name or a symbol identifier). _cmd_ (which may be a string or a +Proc+ object) or block is executed whenever the variable is assigned. The block or +Proc+ object receives the variable&apos;s new value as a parameter. Also see Kernel::untrace_var. &#xA; trace_var :$_, proc {|v| puts &quot;$_ is now &apos;#{v}&apos;&quot; }&#xA;$_ = &quot;hello&quot;&#xA;$_ = &apos; there&apos;&#xA; produces: &#xA; $_ is now &apos;hello&apos;&#xA;$_ is now &apos; there&apos;" />
      <scope name="trap" ilk="function" signature="trap(*args)" doc="Specifies the handling of signals. The first parameter is a signal name (a string such as ``SIGALRM&apos;&apos;, ``SIGUSR1&apos;&apos;, and so on) or a signal number. The characters ``SIG&apos;&apos; may be omitted from the signal name. The command or block specifies code to be run when the signal is raised. If the command is the string ``IGNORE&apos;&apos; or ``SIG_IGN&apos;&apos;, the signal will be ignored. If the command is ``DEFAULT&apos;&apos; or ``SIG_DFL&apos;&apos;, the Ruby&apos;s default handler will be invoked. If the command is ``EXIT&apos;&apos;, the script will be terminated by the signal. If the command is ``SYSTEM_DEFAULT&apos;&apos;, the operating system&apos;s default handler will be invoked. Otherwise, the given command or block will be run. The special signal name ``EXIT&apos;&apos; or signal number zero will be invoked just prior to program termination. trap returns the previous handler for the given signal. &#xA; Signal.trap(0, proc { puts &quot;Terminating: #{$$}&quot; })&#xA;Signal.trap(&quot;CLD&quot;)  { puts &quot;Child died&quot; }&#xA;fork &amp;&amp; Process.wait&#xA; produces: Terminating: 27461&#xA;Child died&#xA;Terminating: 27460" />
      <scope name="untrace_var" ilk="function" signature="untrace_var(p1, p2 = v2)" doc="Removes tracing for the specified command on the given global variable and returns +nil+. If no command is specified, removes all tracing for that variable and returns an array containing the commands actually removed." />
      <scope name="warn" ilk="function" signature="warn(p1)" doc="Display the given message (followed by a newline) on STDERR unless warnings are disabled (for example with the -W0 flag)." />
    </scope>
    <scope name="abbrev" ilk="blob" lang="Ruby">
      <scope name="Abbrev" ilk="namespace">
        <scope name="abbrev" ilk="function" signature="abbrev(words, pattern = nil)" attributes="__classmethod__" doc="Given a set of strings, calculate the set of unambiguous abbreviations for those strings, and return a hash where the keys are all the possible abbreviations and the values are the full strings. Thus, given input of &quot;car&quot; and &quot;cone&quot;, the keys pointing to &quot;car&quot; would be &quot;ca&quot; and &quot;car&quot;, while those pointing to &quot;cone&quot; would be &quot;co&quot;, &quot;con&quot;, and &quot;cone&quot;. &#xA; The optional +pattern+ parameter is a pattern or a string. Only those input strings matching the pattern, or begging the string, are considered for inclusion in the output hash" />
      </scope>
    </scope>
    <scope name="base64" ilk="blob" lang="Ruby">
      <scope name="Base64" ilk="namespace">
        <scope name="decode64" ilk="function" signature="decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with RFC 2045. Characters outside the base alphabet are ignored. &#xA; require &apos;base64&apos;&#xA;str = &apos;VGhpcyBpcyBsaW5lIG9uZQpUaGlzIG&apos; +&#xA;      &apos;lzIGxpbmUgdHdvClRoaXMgaXMgbGlu&apos; +&#xA;      &apos;ZSB0aHJlZQpBbmQgc28gb24uLi4K&apos;&#xA;puts Base64.decode64(str)&#xA; Generates: &#xA; This is line one&#xA;This is line two&#xA;This is line three&#xA;And so on..." />
        <scope name="encode64" ilk="function" signature="encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with RFC 2045. Line feeds are added to every 60 encoded charactors. &#xA; require &apos;base64&apos;&#xA;Base64.encode64(&quot;Now is the time for all good coders\nto learn Ruby&quot;)&#xA; Generates: &#xA; Tm93IGlzIHRoZSB0aW1lIGZvciBhbGwgZ29vZCBjb2RlcnMKdG8gbGVhcm4g&#xA;UnVieQ==" />
        <scope name="strict_decode64" ilk="function" signature="strict_decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with RFC 4648. ArgumentError is raised if +str+ is incorrectly padded or contains non-alphabet characters.  Note that CR or LF are also rejected." />
        <scope name="strict_encode64" ilk="function" signature="strict_encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with RFC 4648. No line feeds are added." />
        <scope name="urlsafe_decode64" ilk="function" signature="urlsafe_decode64(str)" doc="Returns the Base64-decoded version of +str+. This method complies with ``Base 64 Encoding with URL and Filename Safe Alphabet&apos;&apos; in RFC 4648. The alphabet uses &apos;-&apos; instead of &apos;+&apos; and &apos;_&apos; instead of &apos;/&apos;." />
        <scope name="urlsafe_encode64" ilk="function" signature="urlsafe_encode64(bin)" doc="Returns the Base64-encoded version of +bin+. This method complies with ``Base 64 Encoding with URL and Filename Safe Alphabet&apos;&apos; in RFC 4648. The alphabet uses &apos;-&apos; instead of &apos;+&apos; and &apos;_&apos; instead of &apos;/&apos;." />
      </scope>
    </scope>
    <scope name="benchmark" ilk="blob" lang="Ruby">
      <scope name="Benchmark" ilk="namespace">
        <scope name="benchmark" ilk="function" signature="benchmark(caption = &quot;&quot;, label_width = nil, format = nil, *labels)" attributes="__classmethod__" doc="Invokes the block with a Benchmark::Report object, which may be used to collect and report on the results of individual benchmark tests. Reserves label_width leading spaces for labels on each line. Prints _caption_ at the top of the report, and uses _format_ to format each line. Returns an array of Benchmark::Tms objects. &#xA; If the block returns an array of Benchmark::Tms objects, these will be used to format additional lines of output. If _label_ parameters are given, these are used to label these extra lines. &#xA; _Note_: Other methods provide a simpler interface to this one, and are suitable for nearly all benchmarking requirements.  See the examples in Benchmark, and the #bm and #bmbm methods. &#xA; Example: &#xA; require &apos;benchmark&apos;&#xA;include Benchmark          # we need the CAPTION and FORMAT constants&#xA;n = 50000&#xA;Benchmark.benchmark(CAPTION, 7, FORMAT, &quot;&gt;total:&quot;, &quot;&gt;avg:&quot;) do |x|&#xA;  tf = x.report(&quot;for:&quot;)   { for i in 1..n; a = &quot;1&quot;; end }&#xA;  tt = x.report(&quot;times:&quot;) { n.times do   ; a = &quot;1&quot;; end }&#xA;  tu = x.report(&quot;upto:&quot;)  { 1.upto(n) do ; a = &quot;1&quot;; end }&#xA;  [tf+tt+tu, (tf+tt+tu)/3]&#xA;end" />
        <scope name="bm" ilk="function" signature="bm(label_width = 0, *labels)" attributes="__classmethod__" doc="A simple interface to the #benchmark method, #bm is generates sequential reports with labels.  The parameters have the same meaning as for #benchmark. &#xA; require &apos;benchmark&apos;&#xA;n = 50000&#xA;Benchmark.bm(7) do |x|&#xA;  x.report(&quot;for:&quot;)   { for i in 1..n; a = &quot;1&quot;; end }&#xA;  x.report(&quot;times:&quot;) { n.times do   ; a = &quot;1&quot;; end }&#xA;  x.report(&quot;upto:&quot;)  { 1.upto(n) do ; a = &quot;1&quot;; end }&#xA;end&#xA; Generates: &#xA;              user     system      total        real&#xA;for:     1.050000   0.000000   1.050000 (  0.503462)&#xA;times:   1.533333   0.016667   1.550000 (  0.735473)&#xA;upto:    1.500000   0.016667   1.516667 (  0.711239)" />
        <scope name="bmbm" ilk="function" signature="bmbm(width = 0)" attributes="__classmethod__" doc="Sometimes benchmark results are skewed because code executed earlier encounters different garbage collection overheads than that run later. #bmbm attempts to minimize this effect by running the tests twice, the first time as a rehearsal in order to get the runtime environment stable, the second time for real. GC.start is executed before the start of each of the real timings; the cost of this is not included in the timings. In reality, though, there&apos;s only so much that #bmbm can do, and the results are not guaranteed to be isolated from garbage collection and other effects. &#xA; Because #bmbm takes two passes through the tests, it can calculate the required label width. &#xA; require &apos;benchmark&apos;&#xA;array = (1..1000000).map { rand }&#xA;Benchmark.bmbm do |x|&#xA;  x.report(&quot;sort!&quot;) { array.dup.sort! }&#xA;  x.report(&quot;sort&quot;)  { array.dup.sort  }&#xA;end&#xA; Generates: &#xA; Rehearsal -----------------------------------------&#xA;sort!  11.928000   0.010000  11.938000 ( 12.756000)&#xA;sort   13.048000   0.020000  13.068000 ( 13.857000)&#xA;------------------------------- total: 25.006000sec" />
        <scope name="measure" ilk="function" signature="measure(label = &quot;&quot;)" attributes="__classmethod__" doc="Returns the time used to execute the given block as a Benchmark::Tms object." />
        <scope name="realtime" ilk="function" signature="realtime()" attributes="__classmethod__" doc="Returns the elapsed real time used to execute the given block." />
        <variable name="BENCHMARK_VERSION" attributes="__const__" citdl="Object" />
        <variable name="CAPTION" attributes="__const__" citdl="Object" />
        <variable name="FORMAT" attributes="__const__" citdl="Object" />
        <scope name="Tms" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(utime = 0.0, stime = 0.0, cutime = 0.0, cstime = 0.0, real = 0.0, label = nil)" attributes="__classmethod__ __ctor__" doc="Returns an initialized Tms object which has _utime_ as the user CPU time, _stime_ as the system CPU time, _cutime_ as the children&apos;s user CPU time, _cstime_ as the children&apos;s system CPU time, _real_ as the elapsed real time and _label_ as the label." />
          <scope name="add" ilk="function" signature="add()" doc="Returns a new Tms object whose times are the sum of the times for this Tms object, plus the time required to execute the code block (_blk_)." />
          <scope name="add!" ilk="function" signature="add!(&amp;blk)" doc="An in-place version of #add." />
          <scope name="format" ilk="function" signature="format(format = nil, *args)" doc="Returns the contents of this Tms object as a formatted string, according to a format string like that passed to Kernel.format. In addition, #format accepts the following extensions: &#xA; Replaced by the user CPU time, as reported by Tms#utime.&#xA;Replaced by the system CPU time, as reported by #stime (Mnemonic: y of &quot;s*y*stem&quot;)&#xA;Replaced by the children&apos;s user CPU time, as reported by Tms#cutime&#xA;Replaced by the children&apos;s system CPU time, as reported by Tms#cstime&#xA;Replaced by the total CPU time, as reported by Tms#total&#xA;Replaced by the elapsed real time, as reported by Tms#real&#xA;Replaced by the label string, as reported by Tms#label (Mnemonic: n of &quot;*n*ame&quot;) &#xA; If _format_ is not given, FORMAT is used as default value, detailing the user, system and real elapsed time." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Returns a new 6-element array, consisting of the label, user CPU time, system CPU time, children&apos;s user CPU time, children&apos;s system CPU time and elapsed real time." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Same as #format." />
          <scope ilk="function" name="cstime" />
          <scope ilk="function" name="cutime" />
          <scope ilk="function" name="label" />
          <scope ilk="function" name="real" />
          <scope ilk="function" name="stime" />
          <scope ilk="function" name="total" />
          <scope ilk="function" name="utime" />
          <variable name="CAPTION" attributes="__const__" citdl="Object" />
          <variable name="FORMAT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="bigdecimal" ilk="blob" lang="Ruby">
      <scope name="BigDecimal" ilk="class" classrefs="Numeric">
        <scope name="_load" ilk="function" signature="_load(p1)" attributes="__classmethod__" doc="Internal method used to provide marshalling support. See the Marshal module." />
        <scope name="double_fig" ilk="function" signature="double_fig()" attributes="__classmethod__" doc="The BigDecimal.double_fig class method returns the number of digits a Float number is allowed to have. The result depends upon the CPU and OS in use." />
        <scope name="limit" ilk="function" signature="limit(p1 = v1)" attributes="__classmethod__" doc="Limit the number of significant digits in newly created BigDecimal numbers to the specified value. Rounding is performed as necessary, as specified by BigDecimal.mode. &#xA; A limit of 0, the default, means no upper limit. &#xA; The limit specified by this method takes less priority over any limit specified to instance methods such as ceil, floor, truncate, or round." />
        <scope name="mode" ilk="function" signature="mode(p1, p2 = v2)" attributes="__classmethod__" doc="Controls handling of arithmetic exceptions and rounding. If no value is supplied, the current value is returned. &#xA; Six values of the mode parameter control the handling of arithmetic exceptions: &#xA; BigDecimal::EXCEPTION_NaN BigDecimal::EXCEPTION_INFINITY BigDecimal::EXCEPTION_UNDERFLOW BigDecimal::EXCEPTION_OVERFLOW BigDecimal::EXCEPTION_ZERODIVIDE BigDecimal::EXCEPTION_ALL &#xA; For each mode parameter above, if the value set is false, computation continues after an arithmetic exception of the appropriate type. When computation continues, results are as follows: &#xA; NaN&#xA;+infinity or -infinity&#xA;0&#xA;+infinity or -infinity&#xA;+infinity or -infinity &#xA; One value of the mode parameter controls the rounding of numeric values: BigDecimal::ROUND_MODE. The values it can take are: &#xA; round away from zero&#xA;round towards zero (truncate)&#xA;round towards the nearest neighbor, unless both neighbors are equidistant, in which case round away from zero. (default)" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Create a new BigDecimal object. &#xA; The initial value, as an Integer, a Float, a Rational, a BigDecimal, or a String. If it is a String, spaces are ignored and unrecognized characters terminate the value. &#xA;&#xA;The number of significant digits, as a Fixnum. If omitted or 0, the number of significant digits is determined from the initial value. &#xA; The actual number of significant digits used in computation is usually larger than the specified number." />
        <scope name="save_exception_mode" ilk="function" signature="save_exception_mode()" attributes="__classmethod__" />
        <scope name="save_limit" ilk="function" signature="save_limit()" attributes="__classmethod__" />
        <scope name="save_rounding_mode" ilk="function" signature="save_rounding_mode()" attributes="__classmethod__" />
        <scope name="ver" ilk="function" signature="ver()" attributes="__classmethod__" doc="Returns the BigDecimal version number. &#xA; Ruby 1.8.0 returns 1.0.0. Ruby 1.8.1 thru 1.8.3 return 1.0.1." />
        <scope name="_dump" ilk="function" signature="_dump(p1 = v1)" />
        <scope name="abs" ilk="function" signature="abs()" doc="Returns the absolute value. &#xA; BigDecimal(&apos;5&apos;).abs -&gt; 5 &#xA; BigDecimal(&apos;-3&apos;).abs -&gt; 3" />
        <scope name="add" ilk="function" signature="add(p1, p2)" />
        <scope name="ceil" ilk="function" signature="ceil(p1 = v1)" doc="Return the smallest integer greater than or equal to the value, as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).ceil -&gt; 4 &#xA; BigDecimal(&apos;-9.1&apos;).ceil -&gt; -9 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).ceil(3) -&gt; 3.142 &#xA; BigDecimal(&apos;13345.234&apos;).ceil(-2) -&gt; 13400.0" />
        <scope name="coerce" ilk="function" signature="coerce(p1)" doc="The coerce method provides support for Ruby type coercion. It is not enabled by default. &#xA; This means that binary operations like + * / or - can often be performed on a BigDecimal and an object of another type, if the other object can be coerced into a BigDecimal value. &#xA; e.g. a = BigDecimal.new(&quot;1.0&quot;) b = a / 2.0  -&gt; 0.5 &#xA; Note that coercing a String to a BigDecimal is not supported by default; it requires a special compile-time option when building Ruby." />
        <scope name="div" ilk="function" signature="div(p1, p2 = v2)" />
        <scope name="divmod" ilk="function" signature="divmod(p1)" doc="Divides by the specified value, and returns the quotient and modulus as BigDecimal numbers. The quotient is rounded towards negative infinity. &#xA; For example: &#xA; require &apos;bigdecimal&apos; &#xA; a = BigDecimal.new(&quot;42&quot;) b = BigDecimal.new(&quot;9&quot;) &#xA; q,m = a.divmod(b) &#xA; c = q * b + m &#xA; a == c  -&gt; true &#xA; The quotient q is (a/b).floor, and the modulus is the amount that must be added to q * b to get a." />
        <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Tests for value equality; returns true if the values are equal. &#xA; The == and === operators and the eql? method have the same implementation for BigDecimal. &#xA; Values may be coerced to perform the comparison: &#xA; BigDecimal.new(&apos;1.0&apos;) == 1.0  -&gt; true" />
        <scope name="exponent" ilk="function" signature="exponent()" doc="Returns the exponent of the BigDecimal number, as an Integer. &#xA; If the number can be represented as 0.xxxxxx*10**n where xxxxxx is a string of digits with no leading zeros, then n is the exponent." />
        <scope name="finite?" ilk="function" signature="finite?()" doc="Returns True if the value is finite (not NaN or infinite)   " />
        <scope name="fix" ilk="function" signature="fix()" doc="Return the integer part of the number." />
        <scope name="floor" ilk="function" signature="floor(p1 = v1)" doc="Return the largest integer less than or equal to the value, as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).floor -&gt; 3 &#xA; BigDecimal(&apos;-9.1&apos;).floor -&gt; -10 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).floor(3) -&gt; 3.141 &#xA; BigDecimal(&apos;13345.234&apos;).floor(-2) -&gt; 13300.0" />
        <scope name="frac" ilk="function" signature="frac()" doc="Return the fractional part of the number." />
        <scope name="hash" ilk="function" signature="hash()" />
        <scope name="infinite?" ilk="function" signature="infinite?()" doc="Returns nil, -1, or +1 depending on whether the value is finite, -infinity, or +infinity." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns debugging information about the value as a string of comma-separated values in angle brackets with a leading #: &#xA; BigDecimal.new(&quot;1234.5678&quot;).inspect -&gt; &quot;#&lt;BigDecimal:b7ea1130,&apos;0.12345678E4&apos;,8(12)&gt;&quot; &#xA; The first part is the address, the second is the value as a string, and the final part ss(mm) is the current number of significant digits and the maximum number of significant digits, respectively." />
        <scope name="modulo" ilk="function" signature="modulo(p1)" doc="Returns the modulus from dividing by b. See divmod." />
        <scope name="mult" ilk="function" signature="mult(p1, p2)" />
        <scope name="nan?" ilk="function" signature="nan?()" doc="Returns True if the value is Not a Number   " />
        <scope name="nonzero?" ilk="function" signature="nonzero?()" doc="Returns self if the value is non-zero, nil otherwise.   " />
        <scope name="power" ilk="function" signature="power(p1, p2 = v2)" doc="Returns the value raised to the power of n. Note that n must be an Integer. &#xA; Also available as the operator **" />
        <scope name="precs" ilk="function" signature="precs()" doc="Returns an Array of two Integer values. &#xA; The first value is the current number of significant digits in the BigDecimal. The second value is the maximum number of significant digits for the BigDecimal." />
        <scope name="quo" ilk="function" signature="quo(p1)" doc="Divide by the specified value. &#xA; e.g. c = a.div(b,n)&#xA; If specified and less than the number of significant digits of the result, the result is rounded to that number of digits, according to BigDecimal.mode. &#xA; If digits is 0, the result is the same as the / operator. If not, the result is an integer BigDecimal, by analogy with Float#div. &#xA; The alias quo is provided since div(value, 0) is the same as computing the quotient; see divmod." />
        <scope name="remainder" ilk="function" signature="remainder(p1)" doc="Returns the remainder from dividing by the value. &#xA; x.remainder(y) means x-y*(x/y).truncate" />
        <scope name="round" ilk="function" signature="round(p1 = v1, p2 = v2)" doc="Round to the nearest 1 (by default), returning the result as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).round -&gt; 3 &#xA; BigDecimal(&apos;8.7&apos;).round -&gt; 9 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).round(3) -&gt; 3.142 &#xA; BigDecimal(&apos;13345.234&apos;).round(-2) -&gt; 13300.0 &#xA; The value of the optional mode argument can be used to determine how rounding is performed; see BigDecimal.mode." />
        <scope name="sign" ilk="function" signature="sign()" doc="Returns the sign of the value. &#xA; Returns a positive value if &gt; 0, a negative value if &lt; 0, and a zero if == 0. &#xA; The specific value returned indicates the type and sign of the BigDecimal, as follows: &#xA; value is Not a Number&#xA;value is +0&#xA;value is -0&#xA;value is +infinity&#xA;value is -infinity&#xA;value is positive&#xA;value is negative" />
        <scope name="split" ilk="function" signature="split()" doc="Splits a BigDecimal number into four parts, returned as an array of values. &#xA; The first value represents the sign of the BigDecimal, and is -1 or 1, or 0 if the BigDecimal is Not a Number. &#xA; The second value is a string representing the significant digits of the BigDecimal, with no leading zeros. &#xA; The third value is the base used for arithmetic (currently always 10) as an Integer. &#xA; The fourth value is an Integer exponent. &#xA; If the BigDecimal can be represented as 0.xxxxxx*10**n, then xxxxxx is the string of significant digits with no leading zeros, and n is the exponent. &#xA; From these values, you can translate a BigDecimal to a float as follows: &#xA; sign, significant_digits, base, exponent = a.split&#xA;f = sign * &quot;0.#{significant_digits}&quot;.to_f * (base ** exponent)&#xA; (Note that the to_f method is provided as a more convenient way to translate a BigDecimal to a Float.)" />
        <scope name="sqrt" ilk="function" signature="sqrt(p1)" doc="Returns the square root of the value. &#xA; If n is specified, returns at least that many significant digits." />
        <scope name="sub" ilk="function" signature="sub(p1, p2)" />
        <scope name="to_d" ilk="function" signature="to_d()" doc="Returns self." />
        <scope name="to_digits" ilk="function" signature="to_digits()" doc="Converts a BigDecimal to a String of the form &quot;nnnnnn.mmm&quot;. This method is deprecated; use BigDecimal#to_s(&quot;F&quot;) instead. &#xA; require &apos;bigdecimal&apos;&#xA;require &apos;bigdecimal/util&apos;&#xA;&#xA;d = BigDecimal.new(&quot;3.14&quot;)&#xA;d.to_digits&#xA;# =&gt; &quot;3.14&quot;" />
        <scope name="to_f" ilk="function" signature="to_f()" doc="Returns a new Float object having approximately the same value as the BigDecimal number. Normal accuracy limits and built-in errors of binary Float arithmetic apply." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the value as an integer (Fixnum or Bignum). &#xA; If the BigNumber is infinity or NaN, raises FloatDomainError." />
        <scope name="to_int" ilk="function" signature="to_int()" doc="Returns the value as an integer (Fixnum or Bignum). &#xA; If the BigNumber is infinity or NaN, raises FloatDomainError." />
        <scope name="to_r" ilk="function" signature="to_r()" doc="Converts a BigDecimal to a Rational." />
        <scope name="to_s" ilk="function" signature="to_s(p1 = v1)" doc="Converts the value to a string. &#xA; The default format looks like  0.xxxxEnn. &#xA; The optional parameter s consists of either an integer; or an optional &apos;+&apos; or &apos; &apos;, followed by an optional number, followed by an optional &apos;E&apos; or &apos;F&apos;. &#xA; If there is a &apos;+&apos; at the start of s, positive values are returned with a leading &apos;+&apos;. &#xA; A space at the start of s returns positive values with a leading space. &#xA; If s contains a number, a space is inserted after each group of that many fractional digits. &#xA; If s ends with an &apos;E&apos;, engineering notation (0.xxxxEnn) is used. &#xA; If s ends with an &apos;F&apos;, conventional floating point notation is used. &#xA; Examples: &#xA; BigDecimal.new(&apos;-123.45678901234567890&apos;).to_s(&apos;5F&apos;) -&gt; &apos;-123.45678 90123 45678 9&apos; &#xA; BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos;+8F&apos;) -&gt; &apos;+123.45678901 23456789&apos; &#xA; BigDecimal.new(&apos;123.45678901234567890&apos;).to_s(&apos; F&apos;) -&gt; &apos; 123.4567890123456789&apos;" />
        <scope name="truncate" ilk="function" signature="truncate(p1 = v1)" doc="Truncate to the nearest 1, returning the result as a BigDecimal. &#xA; BigDecimal(&apos;3.14159&apos;).truncate -&gt; 3 &#xA; BigDecimal(&apos;8.7&apos;).truncate -&gt; 8 &#xA; If n is specified and positive, the fractional part of the result has no more than that many digits. &#xA; If n is specified and negative, at least that many digits to the left of the decimal point will be 0 in the result. &#xA; BigDecimal(&apos;3.14159&apos;).truncate(3) -&gt; 3.141 &#xA; BigDecimal(&apos;13345.234&apos;).truncate(-2) -&gt; 13300.0" />
        <scope name="zero?" ilk="function" signature="zero?()" doc="Returns True if the value is zero.   " />
        <variable name="BASE" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_ALL" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_INFINITY" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_UNDERFLOW" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_OVERFLOW" attributes="__const__" citdl="Object" />
        <variable name="EXCEPTION_ZERODIVIDE" attributes="__const__" citdl="Object" />
        <variable name="ROUND_MODE" attributes="__const__" citdl="Object" />
        <variable name="ROUND_UP" attributes="__const__" citdl="Object" />
        <variable name="ROUND_DOWN" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_UP" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_DOWN" attributes="__const__" citdl="Object" />
        <variable name="ROUND_CEILING" attributes="__const__" citdl="Object" />
        <variable name="ROUND_FLOOR" attributes="__const__" citdl="Object" />
        <variable name="ROUND_HALF_EVEN" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_ZERO" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_ZERO" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_FINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_FINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_POSITIVE_INFINITE" attributes="__const__" citdl="Object" />
        <variable name="SIGN_NEGATIVE_INFINITE" attributes="__const__" citdl="Object" />
        <variable name="INFINITY" attributes="__const__" citdl="Object" />
        <variable name="NAN" attributes="__const__" citdl="Object" />
      </scope>
      <scope name="BigMath" ilk="namespace">
        <scope name="exp" ilk="function" signature="exp(p1, p2)" attributes="__classmethod__" doc="Computes the value of e (the base of natural logarithms) raised to the power of x, to the specified number of digits of precision. &#xA; If x is infinite, returns Infinity. &#xA; If x is NaN, returns NaN." />
        <scope name="log" ilk="function" signature="log(p1, p2)" attributes="__classmethod__" doc="Computes the natural logarithm of x to the specified number of digits of precision. &#xA; If x is zero or negative, raises Math::DomainError. &#xA; If x is positive infinite, returns Infinity. &#xA; If x is NaN, returns NaN." />
        <scope name="E" ilk="function" signature="E(prec)" doc="Computes e (the base of natural logarithms) to the specified number of digits of precision." />
        <scope name="PI" ilk="function" signature="PI(prec)" doc="Computes the value of pi to the specified number of digits of precision." />
        <scope name="atan" ilk="function" signature="atan(x, prec)" doc="Computes the arctangent of x to the specified number of digits of precision. &#xA; If x is NaN, returns NaN." />
        <scope name="cos" ilk="function" signature="cos(x, prec)" doc="Computes the cosine of x to the specified number of digits of precision. &#xA; If x is infinite or NaN, returns NaN." />
        <scope name="sin" ilk="function" signature="sin(x, prec)" doc="Computes the sine of x to the specified number of digits of precision. &#xA; If x is infinite or NaN, returns NaN." />
        <scope name="sqrt" ilk="function" signature="sqrt(x,prec)" doc="Computes the square root of x to the specified number of digits of precision. &#xA; BigDecimal.new(&apos;2&apos;).sqrt(16).to_s -&gt; &quot;0.14142135623730950488016887242096975E1&quot;" />
      </scope>
    </scope>
    <scope name="bigdecimal/jacobian" ilk="blob" lang="Ruby">
      <scope name="Jacobian" ilk="namespace">
        <scope name="dfdxi" ilk="function" signature="dfdxi(f,fx,x,i)" doc="Computes the derivative of f[i] at x[i]. fx is the value of f at x." />
        <scope name="isEqual" ilk="function" signature="isEqual(a,b,zero=0.0,e=1.0e-8)" doc="Determines the equality of two numbers by comparing to zero, or using the epsilon value" />
        <scope name="jacobian" ilk="function" signature="jacobian(f,fx,x)" doc="Computes the Jacobian of f at x. fx is the value of f at x." />
      </scope>
    </scope>
    <scope name="bigdecimal/ludcmp" ilk="blob" lang="Ruby">
      <scope name="LUSolve" ilk="namespace">
        <scope name="ludecomp" ilk="function" signature="ludecomp(a,n,zero=0,one=1)" doc="Performs LU decomposition of the n by n matrix a." />
        <scope name="lusolve" ilk="function" signature="lusolve(a,b,ps,zero=0.0)" doc="Solves a*x = b for x, using LU decomposition. &#xA; a is a matrix, b is a constant vector, x is the solution vector. &#xA; ps is the pivot, a vector which indicates the permutation of rows performed during LU decomposition." />
      </scope>
    </scope>
    <scope name="bigdecimal/newton" ilk="blob" lang="Ruby">
      <scope name="Newton" ilk="namespace">
        <import symbol="Jacobian" />
        <import symbol="LUSolve" />
        <scope name="nlsolve" ilk="function" signature="nlsolve(f,x)" />
        <scope name="norm" ilk="function" signature="norm(fv,zero=0.0)" />
      </scope>
    </scope>
    <scope name="cgi" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="class" classrefs="Object">
        <scope name="accept_charset" ilk="function" signature="accept_charset()" attributes="__classmethod__" doc="Return the accept character set for all new CGI instances." />
        <scope name="accept_charset=" ilk="function" signature="accept_charset=(accept_charset)" attributes="__classmethod__" doc="Set the accept character set for all new CGI instances." />
        <scope name="escape" ilk="function" signature="escape(string)" attributes="__classmethod__" doc="URL-encode a string. url_encoded_string = CGI::escape(&quot;&apos;Stop!&apos; said Fred&quot;)&#xA;   # =&gt; &quot;%27Stop%21%27+said+Fred&quot;" />
        <scope name="escapeElement" ilk="function" signature="escapeElement(string, *elements)" attributes="__classmethod__" doc="Escape only the tags of certain HTML elements in +string+. &#xA; Takes an element or elements or array of elements.  Each element is specified by the name of the element, without angle brackets. This matches both the start and the end tag of that element. The attribute list of the open tag will also be escaped (for instance, the double-quotes surrounding attribute values). &#xA; print CGI::escapeElement(&apos;&lt;BR&gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&apos;, &quot;A&quot;, &quot;IMG&quot;)&#xA;  # &quot;&lt;BR&gt;&amp;lt;A HREF=&amp;quot;url&amp;quot;&amp;gt;&amp;lt;/A&amp;gt&quot;&#xA;&#xA;print CGI::escapeElement(&apos;&lt;BR&gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&apos;, [&quot;A&quot;, &quot;IMG&quot;])&#xA;  # &quot;&lt;BR&gt;&amp;lt;A HREF=&amp;quot;url&amp;quot;&amp;gt;&amp;lt;/A&amp;gt&quot;" />
        <scope name="escapeHTML" ilk="function" signature="escapeHTML(string)" attributes="__classmethod__" doc="Escape special characters in HTML, namely &amp;\&quot;&lt;&gt; CGI::escapeHTML(&apos;Usage: foo &quot;bar&quot; &lt;baz&gt;&apos;)&#xA;   # =&gt; &quot;Usage: foo &amp;quot;bar&amp;quot; &amp;lt;baz&amp;gt;&quot;" />
        <scope name="escape_element" ilk="function" signature="escape_element(str)" attributes="__classmethod__" doc="Synonym for CGI::escapeElement(str)" />
        <scope name="escape_html" ilk="function" signature="escape_html(str)" attributes="__classmethod__" doc="Synonym for CGI::escapeHTML(str)" />
        <scope name="new" ilk="function" signature="new(options = {})" attributes="__classmethod__ __ctor__" doc="Create a new CGI instance. &#xA; This is the same as using the +options_hash+ form with the value { :tag_maker =&gt; tag_maker } Note that it is recommended to use the +options_hash+ form, since it also allows you specify the charset you will accept.&#xA;A Hash that recognizes two options: &#xA; specifies encoding of received query string.  If omitted, @@accept_charset is used.  If the encoding is not valid, a CGI::InvalidEncoding will be raised. &#xA; Example. Suppose @@accept_charset is &quot;UTF-8&quot; &#xA; when not specified: &#xA; cgi=CGI.new      # @accept_charset # =&gt; &quot;UTF-8&quot;&#xA; when specified as &quot;EUC-JP&quot;: &#xA; cgi=CGI.new(:accept_charset =&gt; &quot;EUC-JP&quot;) # =&gt; &quot;EUC-JP&quot;&#xA;String that specifies which version of the HTML generation methods to use.  If not specified, no HTML generation methods will be loaded. &#xA; The following values are supported: &#xA; HTML 3.x&#xA;HTML 4.0" />
        <scope name="parse" ilk="function" signature="parse(query)" attributes="__classmethod__" doc="Parse an HTTP query string into a hash of key=&gt;value pairs. &#xA; params = CGI::parse(&quot;query_string&quot;)&#xA;  # {&quot;name1&quot; =&gt; [&quot;value1&quot;, &quot;value2&quot;, ...],&#xA;  #  &quot;name2&quot; =&gt; [&quot;value1&quot;, &quot;value2&quot;, ...], ... }" />
        <scope name="pretty" ilk="function" signature="pretty(string, shift = &quot; &quot;)" attributes="__classmethod__" doc="Prettify (indent) an HTML string. &#xA; +string+ is the HTML string to indent.  +shift+ is the indentation unit to use; it defaults to two spaces. &#xA; print CGI::pretty(&quot;&lt;HTML&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;)&#xA;  # &lt;HTML&gt;&#xA;  #   &lt;BODY&gt;&#xA;  #   &lt;/BODY&gt;&#xA;  # &lt;/HTML&gt;&#xA;&#xA;print CGI::pretty(&quot;&lt;HTML&gt;&lt;BODY&gt;&lt;/BODY&gt;&lt;/HTML&gt;&quot;, &quot;\t&quot;)&#xA;  # &lt;HTML&gt;&#xA;  #         &lt;BODY&gt;&#xA;  #         &lt;/BODY&gt;&#xA;  # &lt;/HTML&gt;" />
        <scope name="rfc1123_date" ilk="function" signature="rfc1123_date(time)" attributes="__classmethod__" doc="Format a +Time+ object as a String using the format specified by RFC 1123. &#xA; CGI::rfc1123_date(Time.now)&#xA;  # Sat, 01 Jan 2000 00:00:00 GMT" />
        <scope name="unescape" ilk="function" signature="unescape(string,encoding=@@accept_charset)" attributes="__classmethod__" doc="URL-decode a string with encoding(optional). string = CGI::unescape(&quot;%27Stop%21%27+said+Fred&quot;)&#xA;   # =&gt; &quot;&apos;Stop!&apos; said Fred&quot;" />
        <scope name="unescapeElement" ilk="function" signature="unescapeElement(string, *elements)" attributes="__classmethod__" doc="Undo escaping such as that done by CGI::escapeElement() &#xA; print CGI::unescapeElement(&#xA;        CGI::escapeHTML(&apos;&lt;BR&gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&apos;), &quot;A&quot;, &quot;IMG&quot;)&#xA;  # &quot;&amp;lt;BR&amp;gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&quot;&#xA;&#xA;print CGI::unescapeElement(&#xA;        CGI::escapeHTML(&apos;&lt;BR&gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&apos;), [&quot;A&quot;, &quot;IMG&quot;])&#xA;  # &quot;&amp;lt;BR&amp;gt;&lt;A HREF=&quot;url&quot;&gt;&lt;/A&gt;&quot;" />
        <scope name="unescapeHTML" ilk="function" signature="unescapeHTML(string)" attributes="__classmethod__" doc="Unescape a string that has been HTML-escaped CGI::unescapeHTML(&quot;Usage: foo &amp;quot;bar&amp;quot; &amp;lt;baz&amp;gt;&quot;)&#xA;   # =&gt; &quot;Usage: foo \&quot;bar\&quot; &lt;baz&gt;&quot;" />
        <scope name="unescape_element" ilk="function" signature="unescape_element(str)" attributes="__classmethod__" doc="Synonym for CGI::unescapeElement(str)" />
        <scope name="unescape_html" ilk="function" signature="unescape_html(str)" attributes="__classmethod__" doc="Synonym for CGI::unescapeHTML(str)" />
        <scope name="header" ilk="function" signature="header(options=&apos;text/html&apos;)" doc="Create an HTTP header block as a string. &#xA; Includes the empty line that ends the header block. &#xA; If this form is used, this string is the Content-Type&#xA;A Hash of header values. The following header keys are recognized: &#xA; The Content-Type header.  Defaults to &quot;text/html&quot;&#xA;The charset of the body, appended to the Content-Type header.&#xA;A boolean value.  If true, prepend protocol string and status code, and date; and sets default values for &quot;server&quot; and &quot;connection&quot; if not explicitly set.&#xA;The HTTP status code as a String, returned as the Status header.  The values are: &#xA; 200 OK&#xA;206 Partial Content&#xA;300 Multiple Choices&#xA;301 Moved Permanently&#xA;302 Found" />
        <scope name="out" ilk="function" signature="out(options = &quot;text/html&quot;)" doc="Print an HTTP header and body to $DEFAULT_OUTPUT ($&gt;) &#xA; If a string is passed, it is assumed to be the content type.&#xA;This is a Hash of headers, similar to that used by #header.&#xA;A block is required and should evaluate to the body of the response. &#xA; Content-Length is automatically calculated from the size of the String returned by the content block. &#xA; If ENV[&apos;REQUEST_METHOD&apos;] == &quot;HEAD&quot;, then only the header is output (the content block is still required, but it is ignored). &#xA; If the charset is &quot;iso-2022-jp&quot; or &quot;euc-jp&quot; or &quot;shift_jis&quot; then the content is converted to this charset, and the language is set to &quot;ja&quot;. &#xA; Example: &#xA; cgi = CGI.new&#xA;cgi.out{ &quot;string&quot; }&#xA;  # Content-Type: text/html&#xA;  # Content-Length: 6&#xA;  #" />
        <scope name="print" ilk="function" signature="print(*options)" doc="Print an argument or list of arguments to the default output stream &#xA; cgi = CGI.new&#xA;cgi.print    # default:  cgi.print == $DEFAULT_OUTPUT.print" />
        <scope ilk="function" name="accept_charset" />
        <variable name="TABLE_FOR_ESCAPE_HTML__" attributes="__const__" citdl="Object" />
        <variable name="CR" attributes="__const__" citdl="Object" />
        <variable name="LF" attributes="__const__" citdl="Object" />
        <variable name="EOL" attributes="__const__" citdl="Object" />
        <variable name="REVISION" attributes="__const__" citdl="Object" />
        <variable name="NEEDS_BINMODE" attributes="__const__" citdl="Object" />
        <variable name="PATH_SEPARATOR" attributes="__const__" citdl="Object" />
        <variable name="HTTP_STATUS" attributes="__const__" citdl="Object" />
        <variable name="MAX_MULTIPART_LENGTH" attributes="__const__" citdl="Object" />
        <variable name="MAX_MULTIPART_COUNT" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="cgi/cookie" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="Cookie" ilk="class" classrefs="Array">
          <scope name="new" ilk="function" signature="new(name = &quot;&quot;, *value)" attributes="__classmethod__ __ctor__" doc="Create a new CGI::Cookie object. &#xA; The name of the cookie; in this form, there is no #domain or #expiration.  The #path is gleaned from the +SCRIPT_NAME+ environment variable, and #secure is false.&#xA;value or list of values of the cookie&#xA;A Hash of options to initialize this Cookie.  Possible options are: &#xA; the name of the cookie.  Required.&#xA;the cookie&apos;s value or list of values.&#xA;the path for which this cookie applies.  Defaults to the the value of the +SCRIPT_NAME+ environment variable.&#xA;the domain for which this cookie applies.&#xA;the time at which this cookie expires, as a +Time+ object.&#xA;whether this cookie is a secure cookie or not (default to false).  Secure cookies are only transmitted to HTTPS servers. &#xA; These keywords correspond to attributes of the cookie object." />
          <scope name="parse" ilk="function" signature="parse(raw_cookie)" attributes="__classmethod__" doc="Parse a raw cookie string into a hash of cookie-name=&gt;Cookie pairs. &#xA; cookies = CGI::Cookie::parse(&quot;raw_cookie_string&quot;)&#xA;  # { &quot;name1&quot; =&gt; cookie1, &quot;name2&quot; =&gt; cookie2, ... }" />
          <scope name="secure=" ilk="function" signature="secure=(val)" doc="Set whether the Cookie is a secure cookie or not. &#xA; +val+ must be a boolean." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Convert the Cookie to its string representation." />
          <scope name="value" ilk="function" signature="value()" doc="Returns the value or list of values for this cookie." />
          <scope name="value=" ilk="function" signature="value=(val)" doc="Replaces the value of this cookie with a new value or list of values." />
          <scope ilk="function" name="domain" />
          <scope ilk="function" name="domain=" />
          <scope ilk="function" name="expires" />
          <scope ilk="function" name="expires=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="path=" />
          <scope ilk="function" name="secure" />
        </scope>
      </scope>
    </scope>
    <scope name="cgi/core" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="InvalidEncoding" ilk="class" classrefs="Exception">
        </scope>
        <scope name="QueryExtension" ilk="namespace">
          <scope name="has_key?" ilk="function" signature="has_key?(*args)" doc="Returns true if a given query string parameter exists." />
          <scope name="include?" ilk="function" signature="include?(*args)" />
          <scope name="key?" ilk="function" signature="key?(*args)" />
          <scope name="keys" ilk="function" signature="keys(*args)" doc="Return all query parameter names as an array of String." />
          <scope name="multipart?" ilk="function" signature="multipart?()" doc="Returns whether the form contained multipart/form-data" />
          <scope name="params=" ilk="function" signature="params=(hash)" doc="Set all the parameters." />
          <scope name="raw_cookie" ilk="function" signature="raw_cookie()" doc="Get the raw cookies as a string." />
          <scope name="raw_cookie2" ilk="function" signature="raw_cookie2()" doc="Get the raw RFC2965 cookies as a string." />
          <scope ilk="function" name="cookies" />
          <scope ilk="function" name="cookies=" />
          <scope ilk="function" name="files" />
          <scope ilk="function" name="params" />
        </scope>
      </scope>
    </scope>
    <scope name="cgi/html" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="HtmlExtension" ilk="namespace">
          <scope name="a" ilk="function" signature="a(href = &quot;&quot;)" doc="Generate an Anchor element as a string. &#xA; +href+ can either be a string, giving the URL for the HREF attribute, or it can be a hash of the element&apos;s attributes. &#xA; The body of the element is the string returned by the no-argument block passed in. &#xA; a(&quot;http://www.example.com&quot;) { &quot;Example&quot; }&#xA;  # =&gt; &quot;&lt;A HREF=\&quot;http://www.example.com\&quot;&gt;Example&lt;/A&gt;&quot;&#xA;&#xA;a(&quot;HREF&quot; =&gt; &quot;http://www.example.com&quot;, &quot;TARGET&quot; =&gt; &quot;_top&quot;) { &quot;Example&quot; }&#xA;  # =&gt; &quot;&lt;A HREF=\&quot;http://www.example.com\&quot; TARGET=\&quot;_top\&quot;&gt;Example&lt;/A&gt;&quot;" />
          <scope name="base" ilk="function" signature="base(href = &quot;&quot;)" doc="Generate a Document Base URI element as a String. &#xA; +href+ can either by a string, giving the base URL for the HREF attribute, or it can be a has of the element&apos;s attributes. &#xA; The passed-in no-argument block is ignored. &#xA; base(&quot;http://www.example.com/cgi&quot;)&#xA;  # =&gt; &quot;&lt;BASE HREF=\&quot;http://www.example.com/cgi\&quot;&gt;&quot;" />
          <scope name="blockquote" ilk="function" signature="blockquote(cite = {})" doc="Generate a BlockQuote element as a string. &#xA; +cite+ can either be a string, give the URI for the source of the quoted text, or a hash, giving all attributes of the element, or it can be omitted, in which case the element has no attributes. &#xA; The body is provided by the passed-in no-argument block &#xA; blockquote(&quot;http://www.example.com/quotes/foo.html&quot;) { &quot;Foo!&quot; }&#xA;  =&gt; &quot;&lt;BLOCKQUOTE CITE=\&quot;http://www.example.com/quotes/foo.html\&quot;&gt;Foo!&lt;/BLOCKQUOTE&gt;" />
          <scope name="caption" ilk="function" signature="caption(align = {})" doc="Generate a Table Caption element as a string. &#xA; +align+ can be a string, giving the alignment of the caption (one of top, bottom, left, or right).  It can be a hash of all the attributes of the element.  Or it can be omitted. &#xA; The body of the element is provided by the passed-in no-argument block. &#xA; caption(&quot;left&quot;) { &quot;Capital Cities&quot; }&#xA;  # =&gt; &lt;CAPTION ALIGN=\&quot;left\&quot;&gt;Capital Cities&lt;/CAPTION&gt;" />
          <scope name="checkbox" ilk="function" signature="checkbox(name = &quot;&quot;, value = nil, checked = nil)" doc="Generate a Checkbox Input element as a string. &#xA; The attributes of the element can be specified as three arguments, +name+, +value+, and +checked+.  +checked+ is a boolean value; if true, the CHECKED attribute will be included in the element. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; checkbox(&quot;name&quot;)&#xA;  # = checkbox(&quot;NAME&quot; =&gt; &quot;name&quot;)&#xA;&#xA;checkbox(&quot;name&quot;, &quot;value&quot;)&#xA;  # = checkbox(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;value&quot;)&#xA;&#xA;checkbox(&quot;name&quot;, &quot;value&quot;, true)&#xA;  # = checkbox(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;value&quot;, &quot;CHECKED&quot; =&gt; true)" />
          <scope name="checkbox_group" ilk="function" signature="checkbox_group(name = &quot;&quot;, *values)" doc="Generate a sequence of checkbox elements, as a String. &#xA; The checkboxes will all have the same +name+ attribute. Each checkbox is followed by a label. There will be one checkbox for each value.  Each value can be specified as a String, which will be used both as the value of the VALUE attribute and as the label for that checkbox.  A single-element array has the same effect. &#xA; Each value can also be specified as a three-element array. The first element is the VALUE attribute; the second is the label; and the third is a boolean specifying whether this checkbox is CHECKED. &#xA; Each value can also be specified as a two-element array, by omitting either the value element (defaults to the same as the label), or the boolean checked element (defaults to false). &#xA; checkbox_group(&quot;name&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;name&quot; VALUE=&quot;foo&quot;&gt;foo&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;name&quot; VALUE=&quot;bar&quot;&gt;bar&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;name&quot; VALUE=&quot;baz&quot;&gt;baz&#xA;checkbox_group(&quot;name&quot;, [&quot;foo&quot;], [&quot;bar&quot;, true], &quot;baz&quot;)&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;name&quot; VALUE=&quot;foo&quot;&gt;foo&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; CHECKED NAME=&quot;name&quot; VALUE=&quot;bar&quot;&gt;bar&#xA;  # &lt;INPUT TYPE=&quot;checkbox&quot; NAME=&quot;name&quot; VALUE=&quot;baz&quot;&gt;baz&#xA;checkbox_group(&quot;name&quot;, [&quot;1&quot;, &quot;Foo&quot;], [&quot;2&quot;, &quot;Bar&quot;, true], &quot;Baz&quot;)" />
          <scope name="file_field" ilk="function" signature="file_field(name = &quot;&quot;, size = 20, maxlength = nil)" doc="Generate an File Upload Input element as a string. &#xA; The attributes of the element can be specified as three arguments, +name+, +size+, and +maxlength+.  +maxlength+ is the maximum length of the file&apos;s _name_, not of the file&apos;s _contents_. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; See #multipart_form() for forms that include file uploads. &#xA; file_field(&quot;name&quot;)&#xA;  # &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;name&quot; SIZE=&quot;20&quot;&gt;&#xA;&#xA;file_field(&quot;name&quot;, 40)&#xA;  # &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;name&quot; SIZE=&quot;40&quot;&gt;&#xA;&#xA;file_field(&quot;name&quot;, 40, 100)&#xA;  # &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;name&quot; SIZE=&quot;40&quot; MAXLENGTH=&quot;100&quot;&gt;&#xA;&#xA;file_field(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;SIZE&quot; =&gt; 40)&#xA;  # &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;name&quot; SIZE=&quot;40&quot;&gt;" />
          <scope name="form" ilk="function" signature="form(method = &quot;post&quot;, action = script_name, enctype = &quot;application/x-www-form-urlencoded&quot;)" doc="Generate a Form element as a string. &#xA; +method+ should be either &quot;get&quot; or &quot;post&quot;, and defaults to the latter. +action+ defaults to the current CGI script name.  +enctype+ defaults to &quot;application/x-www-form-urlencoded&quot;. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; See also #multipart_form() for forms that include file uploads. &#xA; form{ &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;post&quot; ENCTYPE=&quot;application/x-www-form-urlencoded&quot;&gt;string&lt;/FORM&gt;&#xA;&#xA;form(&quot;get&quot;) { &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;get&quot; ENCTYPE=&quot;application/x-www-form-urlencoded&quot;&gt;string&lt;/FORM&gt;&#xA;&#xA;form(&quot;get&quot;, &quot;url&quot;) { &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;get&quot; ACTION=&quot;url&quot; ENCTYPE=&quot;application/x-www-form-urlencoded&quot;&gt;string&lt;/FORM&gt;&#xA;&#xA;form(&quot;METHOD&quot; =&gt; &quot;post&quot;, &quot;ENCTYPE&quot; =&gt; &quot;enctype&quot;) { &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;post&quot; ENCTYPE=&quot;enctype&quot;&gt;string&lt;/FORM&gt;" />
          <scope name="hidden" ilk="function" signature="hidden(name = &quot;&quot;, value = nil)" doc="Generate a Hidden Input element as a string. &#xA; The attributes of the element can be specified as two arguments, +name+ and +value+. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; hidden(&quot;name&quot;)&#xA;  # &lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;name&quot;&gt;&#xA;&#xA;hidden(&quot;name&quot;, &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot;&gt;&#xA;&#xA;hidden(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;reset&quot;, &quot;ID&quot; =&gt; &quot;foo&quot;)&#xA;  # &lt;INPUT TYPE=&quot;hidden&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; ID=&quot;foo&quot;&gt;" />
          <scope name="html" ilk="function" signature="html(attributes = {})" doc="Generate a top-level HTML element as a string. &#xA; The attributes of the element are specified as a hash.  The pseudo-attribute &quot;PRETTY&quot; can be used to specify that the generated HTML string should be indented.  &quot;PRETTY&quot; can also be specified as a string as the sole argument to this method.  The pseudo-attribute &quot;DOCTYPE&quot;, if given, is used as the leading DOCTYPE SGML tag; it should include the entire text of this tag, including angle brackets. &#xA; The body of the html element is supplied as a block. &#xA; html{ &quot;string&quot; }&#xA;  # &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;&lt;HTML&gt;string&lt;/HTML&gt;&#xA;html(&quot;LANG&quot; =&gt; &quot;ja&quot;) { &quot;string&quot; }&#xA;  # &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;&lt;HTML LANG=&quot;ja&quot;&gt;string&lt;/HTML&gt;&#xA;html(&quot;DOCTYPE&quot; =&gt; false) { &quot;string&quot; }&#xA;  # &lt;HTML&gt;string&lt;/HTML&gt;&#xA;html(&quot;DOCTYPE&quot; =&gt; &apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML//EN&quot;&gt;&apos;) { &quot;string&quot; }&#xA;  # &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML//EN&quot;&gt;&lt;HTML&gt;string&lt;/HTML&gt;&#xA;html(&quot;PRETTY&quot; =&gt; &quot;  &quot;) { &quot;&lt;BODY&gt;&lt;/BODY&gt;&quot; }&#xA;  # &lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;" />
          <scope name="image_button" ilk="function" signature="image_button(src = &quot;&quot;, name = nil, alt = nil)" doc="Generate an Image Button Input element as a string. &#xA; +src+ is the URL of the image to use for the button.  +name+ is the input name.  +alt+ is the alternative text for the image. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; image_button(&quot;url&quot;)&#xA;  # &lt;INPUT TYPE=&quot;image&quot; SRC=&quot;url&quot;&gt;&#xA;&#xA;image_button(&quot;url&quot;, &quot;name&quot;, &quot;string&quot;)&#xA;  # &lt;INPUT TYPE=&quot;image&quot; SRC=&quot;url&quot; NAME=&quot;name&quot; ALT=&quot;string&quot;&gt;&#xA;&#xA;image_button(&quot;SRC&quot; =&gt; &quot;url&quot;, &quot;ALT&quot; =&gt; &quot;string&quot;)&#xA;  # &lt;INPUT TYPE=&quot;image&quot; SRC=&quot;url&quot; ALT=&quot;string&quot;&gt;" />
          <scope name="img" ilk="function" signature="img(src = &quot;&quot;, alt = &quot;&quot;, width = nil, height = nil)" doc="Generate an Image element as a string. &#xA; +src+ is the URL of the image.  +alt+ is the alternative text for the image.  +width+ is the width of the image, and +height+ is its height. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; img(&quot;src&quot;, &quot;alt&quot;, 100, 50)&#xA;  # &lt;IMG SRC=&quot;src&quot; ALT=&quot;alt&quot; WIDTH=&quot;100&quot; HEIGHT=&quot;50&quot;&gt;&#xA;&#xA;img(&quot;SRC&quot; =&gt; &quot;src&quot;, &quot;ALT&quot; =&gt; &quot;alt&quot;, &quot;WIDTH&quot; =&gt; 100, &quot;HEIGHT&quot; =&gt; 50)&#xA;  # &lt;IMG SRC=&quot;src&quot; ALT=&quot;alt&quot; WIDTH=&quot;100&quot; HEIGHT=&quot;50&quot;&gt;" />
          <scope name="multipart_form" ilk="function" signature="multipart_form(action = nil, enctype = &quot;multipart/form-data&quot;)" doc="Generate a Form element with multipart encoding as a String. &#xA; Multipart encoding is used for forms that include file uploads. &#xA; +action+ is the action to perform.  +enctype+ is the encoding type, which defaults to &quot;multipart/form-data&quot;. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; multipart_form{ &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;post&quot; ENCTYPE=&quot;multipart/form-data&quot;&gt;string&lt;/FORM&gt;&#xA;&#xA;multipart_form(&quot;url&quot;) { &quot;string&quot; }&#xA;  # &lt;FORM METHOD=&quot;post&quot; ACTION=&quot;url&quot; ENCTYPE=&quot;multipart/form-data&quot;&gt;string&lt;/FORM&gt;" />
          <scope name="password_field" ilk="function" signature="password_field(name = &quot;&quot;, value = nil, size = 40, maxlength = nil)" doc="Generate a Password Input element as a string. &#xA; +name+ is the name of the input field.  +value+ is its default value.  +size+ is the size of the input field display.  +maxlength+ is the maximum length of the inputted password. &#xA; Alternatively, attributes can be specified as a hash. &#xA; password_field(&quot;name&quot;)&#xA;  # &lt;INPUT TYPE=&quot;password&quot; NAME=&quot;name&quot; SIZE=&quot;40&quot;&gt;&#xA;&#xA;password_field(&quot;name&quot;, &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;password&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; SIZE=&quot;40&quot;&gt;&#xA;&#xA;password_field(&quot;password&quot;, &quot;value&quot;, 80, 200)&#xA;  # &lt;INPUT TYPE=&quot;password&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; SIZE=&quot;80&quot; MAXLENGTH=&quot;200&quot;&gt;&#xA;&#xA;password_field(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;password&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot;&gt;" />
          <scope name="popup_menu" ilk="function" signature="popup_menu(name = &quot;&quot;, *values)" doc="Generate a Select element as a string. &#xA; +name+ is the name of the element.  The +values+ are the options that can be selected from the Select menu.  Each value can be a String or a one, two, or three-element Array.  If a String or a one-element Array, this is both the value of that option and the text displayed for it.  If a three-element Array, the elements are the option value, displayed text, and a boolean value specifying whether this option starts as selected. The two-element version omits either the option value (defaults to the same as the display text) or the boolean selected specifier (defaults to false). &#xA; The attributes and options can also be specified as a hash.  In this case, options are specified as an array of values as described above, with the hash key of &quot;VALUES&quot;. &#xA; popup_menu(&quot;name&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)&#xA;  # &lt;SELECT NAME=&quot;name&quot;&gt;&#xA;  #   &lt;OPTION VALUE=&quot;foo&quot;&gt;foo&lt;/OPTION&gt;&#xA;  #   &lt;OPTION VALUE=&quot;bar&quot;&gt;bar&lt;/OPTION&gt;&#xA;  #   &lt;OPTION VALUE=&quot;baz&quot;&gt;baz&lt;/OPTION&gt;&#xA;  # &lt;/SELECT&gt;&#xA;popup_menu(&quot;name&quot;, [&quot;foo&quot;], [&quot;bar&quot;, true], &quot;baz&quot;)&#xA;  # &lt;SELECT NAME=&quot;name&quot;&gt;&#xA;  #   &lt;OPTION VALUE=&quot;foo&quot;&gt;foo&lt;/OPTION&gt;&#xA;  #   &lt;OPTION VALUE=&quot;bar&quot; SELECTED&gt;bar&lt;/OPTION&gt;" />
          <scope name="radio_button" ilk="function" signature="radio_button(name = &quot;&quot;, value = nil, checked = nil)" doc="Generates a radio-button Input element. &#xA; +name+ is the name of the input field.  +value+ is the value of the field if checked.  +checked+ specifies whether the field starts off checked. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; radio_button(&quot;name&quot;, &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot;&gt;&#xA;&#xA;radio_button(&quot;name&quot;, &quot;value&quot;, true)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; CHECKED&gt;&#xA;&#xA;radio_button(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;value&quot;, &quot;ID&quot; =&gt; &quot;foo&quot;)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; ID=&quot;foo&quot;&gt;" />
          <scope name="radio_group" ilk="function" signature="radio_group(name = &quot;&quot;, *values)" doc="Generate a sequence of radio button Input elements, as a String. &#xA; This works the same as #checkbox_group().  However, it is not valid to have more than one radiobutton in a group checked. &#xA; radio_group(&quot;name&quot;, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;foo&quot;&gt;foo&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;bar&quot;&gt;bar&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;baz&quot;&gt;baz&#xA;radio_group(&quot;name&quot;, [&quot;foo&quot;], [&quot;bar&quot;, true], &quot;baz&quot;)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;foo&quot;&gt;foo&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; CHECKED NAME=&quot;name&quot; VALUE=&quot;bar&quot;&gt;bar&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;baz&quot;&gt;baz&#xA;radio_group(&quot;name&quot;, [&quot;1&quot;, &quot;Foo&quot;], [&quot;2&quot;, &quot;Bar&quot;, true], &quot;Baz&quot;)&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; NAME=&quot;name&quot; VALUE=&quot;1&quot;&gt;Foo&#xA;  # &lt;INPUT TYPE=&quot;radio&quot; CHECKED NAME=&quot;name&quot; VALUE=&quot;2&quot;&gt;Bar" />
          <scope name="reset" ilk="function" signature="reset(value = nil, name = nil)" doc="Generate a reset button Input element, as a String. &#xA; This resets the values on a form to their initial values.  +value+ is the text displayed on the button. +name+ is the name of this button. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; reset&#xA;  # &lt;INPUT TYPE=&quot;reset&quot;&gt;&#xA;&#xA;reset(&quot;reset&quot;)&#xA;  # &lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;reset&quot;&gt;&#xA;&#xA;reset(&quot;VALUE&quot; =&gt; &quot;reset&quot;, &quot;ID&quot; =&gt; &quot;foo&quot;)&#xA;  # &lt;INPUT TYPE=&quot;reset&quot; VALUE=&quot;reset&quot; ID=&quot;foo&quot;&gt;" />
          <scope name="scrolling_list" ilk="function" signature="scrolling_list(name = &quot;&quot;, *values)" />
          <scope name="submit" ilk="function" signature="submit(value = nil, name = nil)" doc="Generate a submit button Input element, as a String. &#xA; +value+ is the text to display on the button.  +name+ is the name of the input. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; submit&#xA;  # &lt;INPUT TYPE=&quot;submit&quot;&gt;&#xA;&#xA;submit(&quot;ok&quot;)&#xA;  # &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;ok&quot;&gt;&#xA;&#xA;submit(&quot;ok&quot;, &quot;button1&quot;)&#xA;  # &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;ok&quot; NAME=&quot;button1&quot;&gt;&#xA;&#xA;submit(&quot;VALUE&quot; =&gt; &quot;ok&quot;, &quot;NAME&quot; =&gt; &quot;button1&quot;, &quot;ID&quot; =&gt; &quot;foo&quot;)&#xA;  # &lt;INPUT TYPE=&quot;submit&quot; VALUE=&quot;ok&quot; NAME=&quot;button1&quot; ID=&quot;foo&quot;&gt;" />
          <scope name="text_field" ilk="function" signature="text_field(name = &quot;&quot;, value = nil, size = 40, maxlength = nil)" doc="Generate a text field Input element, as a String. &#xA; +name+ is the name of the input field.  +value+ is its initial value.  +size+ is the size of the input area.  +maxlength+ is the maximum length of input accepted. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; text_field(&quot;name&quot;)&#xA;  # &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; SIZE=&quot;40&quot;&gt;&#xA;text_field(&quot;name&quot;, &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; SIZE=&quot;40&quot;&gt;&#xA;text_field(&quot;name&quot;, &quot;value&quot;, 80)&#xA;  # &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; SIZE=&quot;80&quot;&gt;&#xA;text_field(&quot;name&quot;, &quot;value&quot;, 80, 200)&#xA;  # &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot; SIZE=&quot;80&quot; MAXLENGTH=&quot;200&quot;&gt;&#xA;text_field(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;VALUE&quot; =&gt; &quot;value&quot;)&#xA;  # &lt;INPUT TYPE=&quot;text&quot; NAME=&quot;name&quot; VALUE=&quot;value&quot;&gt;" />
          <scope name="textarea" ilk="function" signature="textarea(name = &quot;&quot;, cols = 70, rows = 10)" doc="Generate a TextArea element, as a String. &#xA; +name+ is the name of the textarea.  +cols+ is the number of columns and +rows+ is the number of rows in the display. &#xA; Alternatively, the attributes can be specified as a hash. &#xA; The body is provided by the passed-in no-argument block &#xA; textarea(&quot;name&quot;)&#xA;   # = textarea(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;COLS&quot; =&gt; 70, &quot;ROWS&quot; =&gt; 10)&#xA;&#xA;textarea(&quot;name&quot;, 40, 5)&#xA;   # = textarea(&quot;NAME&quot; =&gt; &quot;name&quot;, &quot;COLS&quot; =&gt; 40, &quot;ROWS&quot; =&gt; 5)" />
        </scope>
      </scope>
    </scope>
    <scope name="cgi/session" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="Session" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(request, option={})" attributes="__classmethod__ __ctor__" doc="Create a new CGI::Session object for +request+. &#xA; +request+ is an instance of the +CGI+ class (see cgi.rb). +option+ is a hash of options for initialising this CGI::Session instance.  The following options are recognised: &#xA; the parameter name used for the session id. Defaults to &apos;_session_id&apos;.&#xA;the session id to use.  If not provided, then it is retrieved from the +session_key+ parameter of the request, or automatically generated for a new session.&#xA;if true, force creation of a new session.  If not set, a new session is only created if none currently exists.  If false, a new session is never created, and if none currently exists and the +session_id+ option is not set, an ArgumentError is raised.&#xA;the name of the class providing storage facilities for session state persistence.  Built-in support is provided for +FileStore+ (the default), +MemoryStore+, and +PStore+ (from cgi/session/pstore.rb).  See the documentation for these classes for more details. &#xA; The following options are also recognised, but only apply if the session id is stored in a cookie. &#xA; the time the current session expires, as a +Time+ object.  If not set, the session will terminate when the user&apos;s browser is closed.&#xA;the hostname domain for which this session is valid. If not set, defaults to the hostname of the server.&#xA;if +true+, this session will only work over HTTPS.&#xA;the path for which this session applies.  Defaults to the directory of the CGI script. &#xA; +option+ is also passed on to the session storage class initializer; see the documentation for each session storage class for the options they support. &#xA; The retrieved or created session is automatically added to +request+ as a cookie, and also to its +output_hidden+ table, which is used to add hidden input elements to forms. " />
          <scope name="close" ilk="function" signature="close()" doc="Store session data on the server and close the session storage. For some session storage types, this is a no-op." />
          <scope name="delete" ilk="function" signature="delete()" doc="Delete the session from storage.  Also closes the storage. &#xA; Note that the session&apos;s data is _not_ automatically deleted upon the session expiring." />
          <scope name="update" ilk="function" signature="update()" doc="Store session data on the server.  For some session storage types, this is a no-op." />
          <scope ilk="function" name="new_session" />
          <scope ilk="function" name="session_id" />
          <scope name="FileStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option={})" attributes="__classmethod__ __ctor__" doc="Create a new FileStore instance. &#xA; This constructor is used internally by CGI::Session.  The user does not generally need to call it directly. &#xA; +session+ is the session for which this instance is being created.  The session id must only contain alphanumeric characters; automatically generated session ids observe this requirement. &#xA; +option+ is a hash of options for the initializer.  The following options are recognised: &#xA; the directory to use for storing the FileStore file.  Defaults to Dir::tmpdir (generally &quot;/tmp&quot; on Unix systems).&#xA;the prefix to add to the session id when generating the filename for this session&apos;s FileStore file. Defaults to &quot;cgi_sid_&quot;.&#xA;the prefix to add to the session id when generating the filename for this session&apos;s FileStore file. Defaults to the empty string. &#xA; This session&apos;s FileStore file will be created if it does not exist, or opened if it does." />
            <scope name="close" ilk="function" signature="close()" doc="Update and close the session&apos;s FileStore file." />
            <scope name="delete" ilk="function" signature="delete()" doc="Close and delete the session&apos;s FileStore file." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore session state from the session&apos;s FileStore file. &#xA; Returns the session state as a hash." />
            <scope name="update" ilk="function" signature="update()" doc="Save session state to the session&apos;s FileStore file." />
          </scope>
          <scope name="MemoryStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option=nil)" attributes="__classmethod__ __ctor__" doc="Create a new MemoryStore instance. &#xA; +session+ is the session this instance is associated with. +option+ is a list of initialisation options.  None are currently recognised." />
            <scope name="close" ilk="function" signature="close()" doc="Close session storage. &#xA; A no-op." />
            <scope name="delete" ilk="function" signature="delete()" doc="Delete the session state." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore session state. &#xA; Returns session data as a hash." />
            <scope name="update" ilk="function" signature="update()" doc="Update session state. &#xA; A no-op." />
            <variable name="GLOBAL_HASH_TABLE" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="NullStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option=nil)" attributes="__classmethod__ __ctor__" doc="Create a new NullStore instance. &#xA; +session+ is the session this instance is associated with. +option+ is a list of initialisation options.  None are currently recognised." />
            <scope name="close" ilk="function" signature="close()" doc="Close session storage. &#xA; A no-op." />
            <scope name="delete" ilk="function" signature="delete()" doc="Delete the session state. &#xA; A no-op." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore (empty) session state." />
            <scope name="update" ilk="function" signature="update()" doc="Update session state. &#xA; A no-op." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="cgi/session/pstore" ilk="blob" lang="Ruby">
      <scope name="CGI" ilk="namespace">
        <scope name="Session" ilk="namespace">
          <scope name="PStore" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(session, option={})" attributes="__classmethod__ __ctor__" doc="Create a new CGI::Session::PStore instance &#xA; This constructor is used internally by CGI::Session.  The user does not generally need to call it directly. &#xA; +session+ is the session for which this instance is being created.  The session id must only contain alphanumeric characters; automatically generated session ids observe this requirement. &#xA; +option+ is a hash of options for the initializer.  The following options are recognised: &#xA; the directory to use for storing the PStore file.  Defaults to Dir::tmpdir (generally &quot;/tmp&quot; on Unix systems).&#xA;the prefix to add to the session id when generating the filename for this session&apos;s PStore file. Defaults to the empty string. &#xA; This session&apos;s PStore file will be created if it does not exist, or opened if it does." />
            <scope name="close" ilk="function" signature="close()" doc="Update and close the session&apos;s PStore file." />
            <scope name="delete" ilk="function" signature="delete()" doc="Close and delete the session&apos;s PStore file." />
            <scope name="restore" ilk="function" signature="restore()" doc="Restore session state from the session&apos;s PStore file. &#xA; Returns the session state as a hash." />
            <scope name="update" ilk="function" signature="update()" doc="Save session state to the session&apos;s PStore file." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="cmath" ilk="blob" lang="Ruby">
      <scope name="CMath" ilk="namespace">
        <import symbol="Math" />
        <scope name="acos" ilk="function" signature="acos(z)" attributes="__classmethod__" doc="returns the arc cosine of +z+" />
        <scope name="acos!" ilk="function" signature="acos!(z)" attributes="__classmethod__" />
        <scope name="acosh" ilk="function" signature="acosh(z)" attributes="__classmethod__" doc="returns the inverse hyperbolic cosine of +z+" />
        <scope name="acosh!" ilk="function" signature="acosh!(z)" attributes="__classmethod__" />
        <scope name="asin" ilk="function" signature="asin(z)" attributes="__classmethod__" doc="returns the arc sine of +z+" />
        <scope name="asin!" ilk="function" signature="asin!(z)" attributes="__classmethod__" />
        <scope name="asinh" ilk="function" signature="asinh(z)" attributes="__classmethod__" doc="returns the inverse hyperbolic sine of +z+" />
        <scope name="asinh!" ilk="function" signature="asinh!(z)" attributes="__classmethod__" />
        <scope name="atan" ilk="function" signature="atan(z)" attributes="__classmethod__" doc="returns the arc tangent of +z+" />
        <scope name="atan!" ilk="function" signature="atan!(z)" attributes="__classmethod__" />
        <scope name="atan2" ilk="function" signature="atan2(y,x)" attributes="__classmethod__" doc="returns the arc tangent of +y+ divided by +x+ using the signs of +y+ and +x+ to determine the quadrant" />
        <scope name="atan2!" ilk="function" signature="atan2!(y,x)" attributes="__classmethod__" />
        <scope name="atanh" ilk="function" signature="atanh(z)" attributes="__classmethod__" doc="returns the inverse hyperbolic tangent of +z+" />
        <scope name="atanh!" ilk="function" signature="atanh!(z)" attributes="__classmethod__" />
        <scope name="cbrt" ilk="function" signature="cbrt(z)" attributes="__classmethod__" doc="returns the principal value of the cube root of +z+" />
        <scope name="cbrt!" ilk="function" signature="cbrt!(z)" attributes="__classmethod__" />
        <scope name="cos" ilk="function" signature="cos(z)" attributes="__classmethod__" doc="returns the cosine of +z+, where +z+ is given in radians" />
        <scope name="cos!" ilk="function" signature="cos!(z)" attributes="__classmethod__" />
        <scope name="cosh" ilk="function" signature="cosh(z)" attributes="__classmethod__" doc="returns the hyperbolic cosine of +z+, where +z+ is given in radians" />
        <scope name="cosh!" ilk="function" signature="cosh!(z)" attributes="__classmethod__" />
        <scope name="exp" ilk="function" signature="exp(z)" attributes="__classmethod__" doc="Math::E raised to the +z+ power &#xA; exp(Complex(0,0))      =&gt; 1.0+0.0i&#xA;exp(Complex(0,PI))     =&gt; -1.0+1.2246467991473532e-16i&#xA;exp(Complex(0,PI/2.0)) =&gt; 6.123233995736766e-17+1.0i" />
        <scope name="exp!" ilk="function" signature="exp!(z)" attributes="__classmethod__" />
        <scope name="log" ilk="function" signature="log(*args)" attributes="__classmethod__" doc="Returns the natural logarithm of Complex.  If a second argument is given, it will be the base of logarithm. &#xA; log(Complex(0,0)) =&gt; -Infinity+0.0i" />
        <scope name="log!" ilk="function" signature="log!(*args)" attributes="__classmethod__" />
        <scope name="log10" ilk="function" signature="log10(z)" attributes="__classmethod__" doc="returns the base 10 logarithm of +z+" />
        <scope name="log10!" ilk="function" signature="log10!(z)" attributes="__classmethod__" />
        <scope name="log2" ilk="function" signature="log2(z)" attributes="__classmethod__" doc="returns the base 2 logarithm of +z+" />
        <scope name="log2!" ilk="function" signature="log2!(z)" attributes="__classmethod__" />
        <scope name="sin" ilk="function" signature="sin(z)" attributes="__classmethod__" doc="returns the sine of +z+, where +z+ is given in radians" />
        <scope name="sin!" ilk="function" signature="sin!(z)" attributes="__classmethod__" />
        <scope name="sinh" ilk="function" signature="sinh(z)" attributes="__classmethod__" doc="returns the hyperbolic sine of +z+, where +z+ is given in radians" />
        <scope name="sinh!" ilk="function" signature="sinh!(z)" attributes="__classmethod__" />
        <scope name="sqrt" ilk="function" signature="sqrt(z)" attributes="__classmethod__" doc="Returns the non-negative square root of Complex. sqrt(-1)            =&gt; 0+1.0i&#xA;sqrt(Complex(-1,0)) =&gt; 0.0+1.0i&#xA;sqrt(Complex(0,8))  =&gt; 2.0+2.0i" />
        <scope name="sqrt!" ilk="function" signature="sqrt!(z)" attributes="__classmethod__" />
        <scope name="tan" ilk="function" signature="tan(z)" attributes="__classmethod__" doc="returns the tangent of +z+, where +z+ is given in radians" />
        <scope name="tan!" ilk="function" signature="tan!(z)" attributes="__classmethod__" />
        <scope name="tanh" ilk="function" signature="tanh(z)" attributes="__classmethod__" doc="returns the hyperbolic tangent of +z+, where +z+ is given in radians" />
        <scope name="tanh!" ilk="function" signature="tanh!(z)" attributes="__classmethod__" />
      </scope>
    </scope>
    <scope name="coverage" ilk="blob" lang="Ruby">
      <scope name="Coverage" ilk="namespace">
        <scope name="result" ilk="function" signature="result()" attributes="__classmethod__" doc="Returns a hash that contains filename as key and coverage array as value and disables coverage measurement." />
        <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" doc="Enables coverage measurement." />
      </scope>
    </scope>
    <scope name="csv" ilk="blob" lang="Ruby">
      <scope name="CSV" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="dump" ilk="function" signature="dump(ary_of_objs, io = &quot;&quot;, options = Hash.new)" attributes="__classmethod__" doc="This method allows you to serialize an Array of Ruby objects to a String or File of CSV data.  This is not as powerful as Marshal or YAML, but perhaps useful for spreadsheet and database interaction. &#xA; Out of the box, this method is intended to work with simple data objects or Structs.  It will serialize a list of instance variables and/or Struct.members(). &#xA; If you need need more complicated serialization, you can control the process by adding methods to the class to be serialized. &#xA; A class method csv_meta() is responsible for returning the first row of the document (as an Array).  This row is considered to be a Hash of the form key_1,value_1,key_2,value_2,...  CSV::load() expects to find a class key with a value of the stringified class name and CSV::dump() will create this, if you do not define this method.  This method is only called on the first object of the Array. &#xA; The next method you can provide is an instance method called csv_headers(). This method is expected to return the second line of the document (again as an Array), which is to be used to give each column a header.  By default, CSV::load() will set an instance variable if the field header starts with an @ character or call send() passing the header as the method name and the field value as an argument.  This method is only called on the first object of the Array. &#xA; Finally, you can provide an instance method called csv_dump(), which will be passed the headers.  This should return an Array of fields that can be serialized for this object.  This method is called once for every object in the Array. &#xA; The +io+ parameter can be used to serialize to a File, and +options+ can be anything CSV::new() accepts." />
        <scope name="filter" ilk="function" signature="filter(*args)" attributes="__classmethod__" doc="This method is a convenience for building Unix-like filters for CSV data. Each row is yielded to the provided block which can alter it as needed. After the block returns, the row is appended to +output+ altered or not. &#xA; The +input+ and +output+ arguments can be anything CSV::new() accepts (generally String or IO objects).  If not given, they default to ARGF and $stdout. &#xA; The +options+ parameter is also filtered down to CSV::new() after some clever key parsing.  Any key beginning with :in_ or :input_ will have that leading identifier stripped and will only be used in the +options+ Hash for the +input+ object.  Keys starting with :out_ or :output_ affect only +output+.  All other keys are assigned to both objects. &#xA; The :output_row_sep +option+ defaults to $INPUT_RECORD_SEPARATOR ($/)." />
        <scope name="foreach" ilk="function" signature="foreach(path, options = Hash.new, &amp;block)" attributes="__classmethod__" doc="This method is intended as the primary interface for reading CSV files.  You pass a +path+ and any +options+ you wish to set for the read.  Each row of file will be passed to the provided +block+ in turn. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method also understands an additional :encoding parameter that you can use to specify the Encoding of the data in the file to be read. You must provide this unless your data is in Encoding::default_external().  CSV will use this to determine how to parse the data.  You may provide a second Encoding to have the data transcoded as it is read.  For example, encoding: &quot;UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it." />
        <scope name="generate" ilk="function" signature="generate(*args)" attributes="__classmethod__" doc="This method wraps a String you provide, or an empty default String, in a CSV object which is passed to the provided block.  You can use the block to append CSV rows to the String and when the block exits, the final String will be returned. &#xA; Note that a passed String *is* modfied by this method.  Call dup() before passing if you need a new String. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method understands an additional :encoding parameter when not passed a String to set the base Encoding for the output.  CSV needs this hint if you plan to output non-ASCII compatible data." />
        <scope name="generate_line" ilk="function" signature="generate_line(row, options = Hash.new)" attributes="__classmethod__" doc="This method is a shortcut for converting a single row (Array) into a CSV String. &#xA; The +options+ parameter can be anything CSV::new() understands.  This method understands an additional :encoding parameter to set the base Encoding for the output.  This method will try to guess your Encoding from the first non-+nil+ field in +row+, if possible, but you may need to use this parameter as a backup plan. &#xA; The :row_sep +option+ defaults to $INPUT_RECORD_SEPARATOR ($/) when calling this method." />
        <scope name="instance" ilk="function" signature="instance(data = $stdout, options = Hash.new)" attributes="__classmethod__" doc="This method will return a CSV instance, just like CSV::new(), but the instance will be cached and returned for all future calls to this method for the same +data+ object (tested by Object#object_id()) with the same +options+. &#xA; If a block is given, the instance is passed to the block and the return value becomes the return value of the block." />
        <scope name="load" ilk="function" signature="load(io_or_str, options = Hash.new)" attributes="__classmethod__" doc="This method is the reading counterpart to CSV::dump().  See that method for a detailed description of the process. &#xA; You can customize loading by adding a class method called csv_load() which will be passed a Hash of meta information, an Array of headers, and an Array of fields for the object the method is expected to return. &#xA; Remember that all fields will be Strings after this load.  If you need something else, use +options+ to setup converters or provide a custom csv_load() implementation." />
        <scope name="new" ilk="function" signature="new(data, options = Hash.new)" attributes="__classmethod__ __ctor__" doc="This constructor will wrap either a String or IO object passed in +data+ for reading and/or writing.  In addition to the CSV instance methods, several IO methods are delegated.  (See CSV::open() for a complete list.)  If you pass a String for +data+, you can later retrieve it (after writing to it, for example) with CSV.string(). &#xA; Note that a wrapped String will be positioned at at the beginning (for reading).  If you want it at the end (for writing), use CSV::generate(). If you want any other positioning, pass a preset StringIO object instead. &#xA; You may set any reading and/or writing preferences in the +options+ Hash. Available options are: &#xA; The String placed between each field. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;The String appended to the end of each row.  This can be set to the special :auto setting, which requests that CSV automatically discover this from the data.  Auto-discovery reads ahead in the data looking for the next &quot;\r\n&quot;, &quot;\n&quot;, or &quot;\r&quot; sequence.  A sequence will be selected even if it occurs in a quoted field, assuming that you would have the same line endings there.  If none of those sequences is found, +data+ is ARGF, STDIN, STDOUT, or STDERR, or the stream is only available for output, the default $INPUT_RECORD_SEPARATOR ($/) is used.  Obviously, discovery takes a little time.  Set manually if speed is important.  Also note that IO objects should be opened in binary mode on Windows if this feature will be used as the line-ending translation can cause problems with resetting the document position to where it was before the read ahead. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;The character used to quote fields. This has to be a single character String.  This is useful for application that incorrectly use &apos; as the quote character instead of the correct &quot;. CSV will always consider a double sequence this character to be an escaped quote. This String will be transcoded into the data&apos;s Encoding before parsing.&#xA;This is a maximum size CSV will read ahead looking for the closing quote for a field.  (In truth, it reads to the first line ending beyond this size.)  If a quote cannot be found within the limit CSV will raise a MalformedCSVError, assuming the data is faulty.  You can use this limit to prevent what are effectively DoS attacks on the parser.  However, this limit can cause a legitimate parse to fail and thus is set to +nil+, or off, by default.&#xA;An Array of names from the Converters Hash and/or lambdas that handle custom conversion.  A single converter doesn&apos;t have to be in an Array.  All built-in converters try to transcode fields to UTF-8 before converting. The conversion will fail if the data cannot be transcoded, leaving the field unchanged.&#xA;If set to +true+, an unconverted_fields() method will be added to all returned rows (Array or CSV::Row) that will return the fields as they were before conversion.  Note that :headers supplied by Array or String were not fields of the document and thus will have an empty Array attached.&#xA;If set to :first_row or +true+, the initial row of the CSV file will be treated as a row of headers.  If set to an Array, the contents will be used as the headers. If set to a String, the String is run through a call of CSV::parse_line() with the same :col_sep, :row_sep, and :quote_char as this instance to produce an Array of headers.  This setting causes CSV#shift() to return rows as CSV::Row objects instead of Arrays and CSV#read() to return CSV::Table objects instead of an Array of Arrays.&#xA;When +false+, header rows are silently swallowed.  If set to +true+, header rows are returned in a CSV::Row object with identical headers and fields (save that the fields do not go through the converters).&#xA;When +true+ and :headers is set, a header row will be added to the output.&#xA;Identical in functionality to :converters save that the conversions are only made to header rows.  All built-in converters try to transcode headers to UTF-8 before converting.  The conversion will fail if the data cannot be transcoded, leaving the header unchanged." />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="This method opens an IO object, and wraps that with CSV.  This is intended as the primary interface for writing a CSV file. &#xA; You must pass a +filename+ and may optionally add a +mode+ for Ruby&apos;s open().  You may also pass an optional Hash containing any +options+ CSV::new() understands as the final argument. &#xA; This method works like Ruby&apos;s open() call, in that it will pass a CSV object to a provided block and close it when the block terminates, or it will return the CSV object when no block is provided.  (*Note*: This is different from the Ruby 1.8 CSV library which passed rows to the block.  Use CSV::foreach() for that behavior.) &#xA; You must provide a +mode+ with an embedded Encoding designator unless your data is in Encoding::default_external().  CSV will check the Encoding of the underlying IO object (set by the +mode+ you pass) to determine how to parse the data.   You may provide a second Encoding to have the data transcoded as it is read just as you can with a normal call to IO::open().  For example, &quot;rb:UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it. &#xA; An opened CSV object will delegate to many IO methods for convenience.  You may call: &#xA; binmode()&#xA;binmode?()&#xA;close()&#xA;close_read()&#xA;close_write()&#xA;closed?()&#xA;eof()&#xA;eof?()" />
        <scope name="parse" ilk="function" signature="parse(*args, &amp;block)" attributes="__classmethod__" doc="This method can be used to easily parse CSV out of a String.  You may either provide a +block+ which will be called with each row of the String in turn, or just use the returned Array of Arrays (when no +block+ is given). &#xA; You pass your +str+ to read from, and an optional +options+ Hash containing anything CSV::new() understands." />
        <scope name="parse_line" ilk="function" signature="parse_line(line, options = Hash.new)" attributes="__classmethod__" doc="This method is a shortcut for converting a single line of a CSV String into a into an Array.  Note that if +line+ contains multiple rows, anything beyond the first row is ignored. &#xA; The +options+ parameter can be anything CSV::new() understands." />
        <scope name="read" ilk="function" signature="read(path, *options)" attributes="__classmethod__" doc="Use to slurp a CSV file into an Array of Arrays.  Pass the +path+ to the file and any +options+ CSV::new() understands.  This method also understands an additional :encoding parameter that you can use to specify the Encoding of the data in the file to be read. You must provide this unless your data is in Encoding::default_external().  CSV will use this to determine how to parse the data.  You may provide a second Encoding to have the data transcoded as it is read.  For example, encoding: &quot;UTF-32BE:UTF-8&quot; would read UTF-32BE data from the file but transcode it to UTF-8 before CSV parses it." />
        <scope name="readlines" ilk="function" signature="readlines(*args)" attributes="__classmethod__" doc="Alias for CSV::read()." />
        <scope name="table" ilk="function" signature="table(path, options = Hash.new)" attributes="__classmethod__" doc="A shortcut for: &#xA; CSV.read( path, { headers:           true,&#xA;                  converters:        :numeric,&#xA;                  header_converters: :symbol }.merge(options) )" />
        <scope name="add_row" ilk="function" signature="add_row(row)" />
        <scope name="convert" ilk="function" signature="convert(name = nil, &amp;converter)" doc="You can use this method to install a CSV::Converters built-in, or provide a block that handles a custom conversion. &#xA; If you provide a block that takes one argument, it will be passed the field and is expected to return the converted value or the field itself.  If your block takes two arguments, it will also be passed a CSV::FieldInfo Struct, containing details about the field.  Again, the block should return a converted field or the field itself." />
        <scope name="converters" ilk="function" signature="converters()" doc="Returns the current list of converters in effect.  See CSV::new for details. Built-in converters will be returned by name, while others will be returned as is." />
        <scope name="each" ilk="function" signature="each()" doc="Yields each row of the data source in turn. &#xA; Support for Enumerable. &#xA; The data source must be open for reading." />
        <scope name="force_quotes?" ilk="function" signature="force_quotes?()" doc="Returns +true+ if all output fields are quoted. See CSV::new for details." />
        <scope name="gets" ilk="function" signature="gets()" />
        <scope name="header_convert" ilk="function" signature="header_convert(name = nil, &amp;converter)" doc="Identical to CSV#convert(), but for header rows. &#xA; Note that this method must be called before header rows are read to have any effect." />
        <scope name="header_converters" ilk="function" signature="header_converters()" doc="Returns the current list of converters in effect for headers.  See CSV::new for details.  Built-in converters will be returned by name, while others will be returned as is." />
        <scope name="header_row?" ilk="function" signature="header_row?()" doc="Returns +true+ if the next row read will be a header row." />
        <scope name="headers" ilk="function" signature="headers()" doc="Returns +nil+ if headers will not be used, +true+ if they will but have not yet been read, or the actual headers after they have been read.  See CSV::new for details." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a simplified description of the key CSV attributes in an ASCII compatible String." />
        <scope name="puts" ilk="function" signature="puts(row)" />
        <scope name="read" ilk="function" signature="read()" doc="Slurps the remaining rows and returns an Array of Arrays. &#xA; The data source must be open for reading." />
        <scope name="readline" ilk="function" signature="readline()" />
        <scope name="readlines" ilk="function" signature="readlines()" />
        <scope name="return_headers?" ilk="function" signature="return_headers?()" doc="Returns +true+ if headers will be returned as a row of results. See CSV::new for details." />
        <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the underlying IO object and resets CSV&apos;s lineno() counter." />
        <scope name="shift" ilk="function" signature="shift()" doc="The primary read method for wrapped Strings and IOs, a single row is pulled from the data source, parsed and returned as an Array of fields (if header rows are not used) or a CSV::Row (when header rows are used). &#xA; The data source must be open for reading." />
        <scope name="skip_blanks?" ilk="function" signature="skip_blanks?()" doc="Returns +true+ blank lines are skipped by the parser. See CSV::new for details." />
        <scope name="unconverted_fields?" ilk="function" signature="unconverted_fields?()" doc="Returns +true+ if unconverted_fields() to parsed results.  See CSV::new for details." />
        <scope name="write_headers?" ilk="function" signature="write_headers?()" doc="Returns +true+ if headers are written in output. See CSV::new for details." />
        <scope ilk="function" name="col_sep" />
        <scope ilk="function" name="encoding" />
        <scope ilk="function" name="field_size_limit" />
        <scope ilk="function" name="lineno" />
        <scope ilk="function" name="quote_char" />
        <scope ilk="function" name="row_sep" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_OPTIONS" attributes="__const__" citdl="Object" />
        <scope name="MalformedCSVError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="Row" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(headers, fields, header_row = false)" attributes="__classmethod__ __ctor__" doc="Construct a new CSV::Row from +headers+ and +fields+, which are expected to be Arrays.  If one Array is shorter than the other, it will be padded with +nil+ objects. &#xA; The optional +header_row+ parameter can be set to +true+ to indicate, via CSV::Row.header_row?() and CSV::Row.field_row?(), that this is a header row.  Otherwise, the row is assumes to be a field row. &#xA; A CSV::Row object supports the following Array methods through delegation: &#xA; empty?()&#xA;length()&#xA;size()" />
          <scope name="delete" ilk="function" signature="delete(header_or_index, minimum_index = 0)" doc="Used to remove a pair from the row by +header+ or +index+.  The pair is located as described in CSV::Row.field().  The deleted pair is returned, or +nil+ if a pair could not be found." />
          <scope name="delete_if" ilk="function" signature="delete_if(&amp;block)" doc="The provided +block+ is passed a header and field for each pair in the row and expected to return +true+ or +false+, depending on whether the pair should be deleted. &#xA; This method returns the row for chaining." />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Yields each pair of the row as header and field tuples (much like iterating over a Hash). &#xA; Support for Enumerable. &#xA; This method returns the row for chaining." />
          <scope name="field" ilk="function" signature="field(header_or_index, minimum_index = 0)" doc="This method will fetch the field value by +header+ or +index+.  If a field is not found, +nil+ is returned. &#xA; When provided, +offset+ ensures that a header match occurrs on or later than the +offset+ index.  You can use this to find duplicate headers, without resorting to hard-coding exact indices." />
          <scope name="field?" ilk="function" signature="field?(data)" doc="Returns +true+ if +data+ matches a field in this row, and +false+ otherwise." />
          <scope name="field_row?" ilk="function" signature="field_row?()" doc="Returns +true+ if this is a field row." />
          <scope name="fields" ilk="function" signature="fields(*headers_and_or_indices)" doc="This method accepts any number of arguments which can be headers, indices, Ranges of either, or two-element Arrays containing a header and offset. Each argument will be replaced with a field lookup as described in CSV::Row.field(). &#xA; If called with no arguments, all fields are returned." />
          <scope name="header?" ilk="function" signature="header?(name)" doc="Returns +true+ if +name+ is a header for this row, and +false+ otherwise." />
          <scope name="header_row?" ilk="function" signature="header_row?()" doc="Returns +true+ if this is a header row." />
          <scope name="headers" ilk="function" signature="headers()" doc="Returns the headers of this row." />
          <scope name="include?" ilk="function" signature="include?(name)" />
          <scope name="index" ilk="function" signature="index(header, minimum_index = 0)" doc="This method will return the index of a field with the provided +header+. The +offset+ can be used to locate duplicate header names, as described in CSV::Row.field()." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="A summary of fields, by header, in an ASCII compatible String." />
          <scope name="push" ilk="function" signature="push(*args)" doc="A shortcut for appending multiple fields.  Equivalent to: &#xA; args.each { |arg| csv_row &lt;&lt; arg }&#xA; This method returns the row for chaining." />
          <scope name="to_csv" ilk="function" signature="to_csv(options = Hash.new)" doc="Returns the row as a CSV String.  Headers are not used.  Equivalent to: &#xA; csv_row.fields.to_csv( options )" />
          <scope name="to_hash" ilk="function" signature="to_hash()" doc="Collapses the row into a simple Hash.  Be warning that this discards field order and clobbers duplicate fields." />
          <scope name="to_s" ilk="function" signature="to_s(options = Hash.new)" />
          <scope name="values_at" ilk="function" signature="values_at(*headers_and_or_indices)" />
          <scope ilk="function" name="row" />
        </scope>
        <scope name="Table" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(array_of_rows)" attributes="__classmethod__ __ctor__" doc="Construct a new CSV::Table from +array_of_rows+, which are expected to be CSV::Row objects.  All rows are assumed to have the same headers. &#xA; A CSV::Table object supports the following Array methods through delegation: &#xA; empty?()&#xA;length()&#xA;size()" />
          <scope name="by_col" ilk="function" signature="by_col()" doc="Returns a duplicate table object, in column mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_col!" ilk="function" signature="by_col!()" doc="Switches the mode of this table to column mode.  All calls to indexing and iteration methods will work with columns until the mode is changed again. &#xA; This method returns the table and is safe to chain." />
          <scope name="by_col_or_row" ilk="function" signature="by_col_or_row()" doc="Returns a duplicate table object, in mixed mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_col_or_row!" ilk="function" signature="by_col_or_row!()" doc="Switches the mode of this table to mixed mode.  All calls to indexing and iteration methods will use the default intelligent indexing system until the mode is changed again.  In mixed mode an index is assumed to be a row reference while anything else is assumed to be column access by headers. &#xA; This method returns the table and is safe to chain." />
          <scope name="by_row" ilk="function" signature="by_row()" doc="Returns a duplicate table object, in row mode.  This is handy for chaining in a single call without changing the table mode, but be aware that this method can consume a fair amount of memory for bigger data sets. &#xA; This method returns the duplicate table for chaining.  Don&apos;t chain destructive methods (like []=()) this way though, since you are working with a duplicate." />
          <scope name="by_row!" ilk="function" signature="by_row!()" doc="Switches the mode of this table to row mode.  All calls to indexing and iteration methods will work with rows until the mode is changed again. &#xA; This method returns the table and is safe to chain." />
          <scope name="delete" ilk="function" signature="delete(index_or_header)" doc="Removes and returns the indicated column or row.  In the default mixed mode indices refer to rows and everything else is assumed to be a column header.  Use by_col!() or by_row!() to force the lookup." />
          <scope name="delete_if" ilk="function" signature="delete_if(&amp;block)" doc="Removes any column or row for which the block returns +true+.  In the default mixed mode or row mode, iteration is the standard row major walking of rows.  In column mode, interation will +yield+ two element tuples containing the column name and an Array of values for that column. &#xA; This method returns the table for chaining." />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="In the default mixed mode or row mode, iteration is the standard row major walking of rows.  In column mode, interation will +yield+ two element tuples containing the column name and an Array of values for that column. &#xA; This method returns the table for chaining." />
          <scope name="headers" ilk="function" signature="headers()" doc="Returns the headers for the first row of this table (assumed to match all other rows).  An empty Array is returned for empty tables." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Shows the mode and size of this table in a US-ASCII String." />
          <scope name="push" ilk="function" signature="push(*rows)" doc="A shortcut for appending multiple rows.  Equivalent to: &#xA; rows.each { |row| self &lt;&lt; row }&#xA; This method returns the table for chaining." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Returns the table as an Array of Arrays.  Headers will be the first row, then all of the field rows will follow." />
          <scope name="to_csv" ilk="function" signature="to_csv(options = Hash.new)" doc="Returns the table as a complete CSV String.  Headers will be listed first, then all of the field rows. &#xA; This method assumes you want the Table.headers(), unless you explicitly pass :write_headers =&gt; false." />
          <scope name="to_s" ilk="function" signature="to_s(options = Hash.new)" />
          <scope name="values_at" ilk="function" signature="values_at(*indices_or_headers)" doc="The mixed mode default is to treat a list of indices as row access, returning the rows indicated.  Anything else is considered columnar access.  For columnar access, the return set has an Array for each row with the values indicated by the headers in each Array.  You can force column or row mode using by_col!() or by_row!(). &#xA; You cannot mix column and row access." />
          <scope ilk="function" name="mode" />
          <scope ilk="function" name="table" />
        </scope>
      </scope>
    </scope>
    <scope name="curses" ilk="blob" lang="Ruby">
      <scope name="Curses" ilk="namespace">
        <scope name="ESCDELAY" ilk="function" signature="ESCDELAY()" attributes="__classmethod__" doc="Returns the total time, in milliseconds, for which curses will await a character sequence, e.g., a function key" />
        <scope name="ESCDELAY=" ilk="function" signature="ESCDELAY=(p1)" attributes="__classmethod__" doc="Sets the ESCDELAY to Integer +value+" />
        <scope name="TABSIZE" ilk="function" signature="TABSIZE()" attributes="__classmethod__" doc="Returns the number of positions in a tab." />
        <scope name="TABSIZE=" ilk="function" signature="TABSIZE=(p1)" attributes="__classmethod__" doc="Sets the TABSIZE to Integer +value+" />
        <scope name="addch" ilk="function" signature="addch(p1)" attributes="__classmethod__" doc="Add a character +ch+, with attributes, then advance the cursor. &#xA; see also the system manual for curs_addch(3)" />
        <scope name="addstr" ilk="function" signature="addstr(p1)" attributes="__classmethod__" doc="add a string of characters +str+, to the window and advance cursor" />
        <scope name="attroff" ilk="function" signature="attroff(p1)" attributes="__classmethod__" doc="Turns on the named attributes +attrs+ without affecting any others. &#xA; See also Curses::Window.attrset for additional information." />
        <scope name="attron" ilk="function" signature="attron(p1)" attributes="__classmethod__" doc="Turns off the named attributes +attrs+ without turning any other attributes on or off. &#xA; See also Curses::Window.attrset for additional information." />
        <scope name="attrset" ilk="function" signature="attrset(p1)" attributes="__classmethod__" doc="Sets the current attributes of the given window to +attrs+. &#xA; see also Curses::Window.attrset" />
        <scope name="beep" ilk="function" signature="beep()" attributes="__classmethod__" doc="Sounds an audible alarm on the terminal, if possible; otherwise it flashes the screen (visual bell). &#xA; see also Curses.flash" />
        <scope name="bkgd" ilk="function" signature="bkgd(p1)" attributes="__classmethod__" doc="Window background manipulation routines. &#xA; Set the background property of the current and then apply the character Integer +ch+ setting to every character position in that window. &#xA; see also the system manual for curs_bkgd(3)" />
        <scope name="bkgdset" ilk="function" signature="bkgdset(p1)" attributes="__classmethod__" doc="Manipulate the background of the named window with character Integer +ch+ &#xA; The background becomes a property of the character and moves with the character through any scrolling and insert/delete line/character operations. &#xA; see also the system manual for curs_bkgd(3)" />
        <scope name="can_change_color?" ilk="function" signature="can_change_color?()" attributes="__classmethod__" doc="Returns +true+ or +false+ depending on whether the terminal can change color attributes" />
        <scope name="cbreak" ilk="function" signature="cbreak()" attributes="__classmethod__" doc="Put the terminal into cbreak mode. &#xA; Normally, the tty driver buffers typed characters until a newline or carriage return is typed. The Curses.cbreak routine disables line buffering and erase/kill character-processing (interrupt and flow control characters are unaffected), making characters typed by the user immediately available to the program. &#xA; The Curses.nocbreak routine returns the terminal to normal (cooked) mode. &#xA; Initially the terminal may or may not be in cbreak mode, as the mode is inherited; therefore, a program should call Curses.cbreak or Curses.nocbreak explicitly. Most interactive programs using curses set the cbreak mode. Note that Curses.cbreak overrides Curses.raw. &#xA; see also Curses.raw" />
        <scope name="clear" ilk="function" signature="clear()" attributes="__classmethod__" doc="Clears every position on the screen completely, so that a subsequent call by Curses.refresh for the screen/window will be repainted from scratch." />
        <scope name="close_screen" ilk="function" signature="close_screen()" attributes="__classmethod__" doc="A program should always call Curses.close_screen before exiting or escaping from curses mode temporarily. This routine restores tty modes, moves the cursor to the lower left-hand corner of the screen and resets the terminal into the proper non-visual mode. &#xA; Calling Curses.refresh or Curses.doupdate after a temporary escape causes the program to resume visual mode." />
        <scope name="closed?" ilk="function" signature="closed?()" attributes="__classmethod__" doc="Returns +true+ if the window/screen has been closed, without any subsequent Curses.refresh calls, returns +false+ otherwise." />
        <scope name="clrtoeol" ilk="function" signature="clrtoeol()" attributes="__classmethod__" doc="Clears to the end of line, that the cursor is currently on." />
        <scope name="color_content" ilk="function" signature="color_content(p1)" attributes="__classmethod__" doc="Returns an 3 item Array of the RGB values in +color+" />
        <scope name="color_pair" ilk="function" signature="color_pair(p1)" attributes="__classmethod__" doc="Sets the color pair attributes to +attrs+. &#xA; This should be equivalent to Curses.attrset(COLOR_PAIR(+attrs+)) &#xA; TODO: validate that equivalency" />
        <scope name="color_pairs" ilk="function" signature="color_pairs()" attributes="__classmethod__" doc="Returns the COLOR_PAIRS available, if the curses library supports it." />
        <scope name="colors" ilk="function" signature="colors()" attributes="__classmethod__" doc="returns COLORS" />
        <scope name="cols" ilk="function" signature="cols()" attributes="__classmethod__" doc="Returns the number of columns on the screen" />
        <scope name="crmode" ilk="function" signature="crmode()" attributes="__classmethod__" doc="Put the terminal into normal mode (out of cbreak mode). &#xA; See Curses.cbreak for more detail." />
        <scope name="curs_set" ilk="function" signature="curs_set(p1)" attributes="__classmethod__" doc="Sets Cursor Visibility. 0: invisible 1: visible 2: very visible" />
        <scope name="def_prog_mode" ilk="function" signature="def_prog_mode()" attributes="__classmethod__" doc="Save the current terminal modes as the &quot;program&quot; state for use by the Curses.reset_prog_mode &#xA; This is done automatically by Curses.init_screen" />
        <scope name="delch" ilk="function" signature="delch()" attributes="__classmethod__" doc="Delete the character under the cursor" />
        <scope name="deleteln" ilk="function" signature="deleteln()" attributes="__classmethod__" doc="Delete the line under the cursor." />
        <scope name="doupdate" ilk="function" signature="doupdate()" attributes="__classmethod__" doc="Refreshes the windows and lines. &#xA; Curses.doupdate allows multiple updates with more efficiency than Curses.refresh alone." />
        <scope name="echo" ilk="function" signature="echo()" attributes="__classmethod__" doc="Enables characters typed by the user to be echoed by Curses.getch as they are typed." />
        <scope name="flash" ilk="function" signature="flash()" attributes="__classmethod__" doc="Flashs the screen, for visual alarm on the terminal, if possible; otherwise it sounds the alert. &#xA; see also Curses.beep" />
        <scope name="getch" ilk="function" signature="getch()" attributes="__classmethod__" doc="Read and returns a character from the window. &#xA; See Curses::Key to all the function KEY_* available" />
        <scope name="getmouse" ilk="function" signature="getmouse()" attributes="__classmethod__" doc="Returns coordinates of the mouse. &#xA; This will read and pop the mouse event data off the queue &#xA; See the BUTTON*, ALL_MOUSE_EVENTS and REPORT_MOUSE_POSITION constants, to examine the mask of the event" />
        <scope name="getstr" ilk="function" signature="getstr()" attributes="__classmethod__" doc="This is equivalent to a series f Curses::Window.getch calls" />
        <scope name="has_colors?" ilk="function" signature="has_colors?()" attributes="__classmethod__" doc="Returns +true+ or +false+ depending on whether the terminal has color capbilities." />
        <scope name="inch" ilk="function" signature="inch()" attributes="__classmethod__" doc="Returns the character at the current position." />
        <scope name="init_color" ilk="function" signature="init_color(p1, p2, p3, p4)" attributes="__classmethod__" doc="Changes the definition of a color. It takes four arguments: the number of the color to be changed, +color+&#xA;the amount of red, +r+&#xA;the amount of green, +g+&#xA;the amount of blue, +b+ &#xA; The value of the first argument must be between 0 and  COLORS. (See the section Colors for the default color index.)  Each of the last three arguments must be a value between 0 and 1000. When Curses.init_color is used, all occurrences of that color on the screen immediately change to the new definition." />
        <scope name="init_pair" ilk="function" signature="init_pair(p1, p2, p3)" attributes="__classmethod__" doc="Changes the definition of a color-pair. &#xA; It takes three arguments: the number of the color-pair to be changed +pair+, the foreground color number +f+, and the background color number +b+. &#xA; If the color-pair was previously initialized, the screen is refreshed and all occurrences of that color-pair are changed to the new definition." />
        <scope name="init_screen" ilk="function" signature="init_screen()" attributes="__classmethod__" doc="Initialize a standard screen &#xA; see also Curses.stdscr" />
        <scope name="insch" ilk="function" signature="insch(p1)" attributes="__classmethod__" doc="Insert a character +ch+, before the cursor." />
        <scope name="insertln" ilk="function" signature="insertln()" attributes="__classmethod__" doc="Inserts a line above the cursor, and the bottom line is lost" />
        <scope name="keyname" ilk="function" signature="keyname(p1)" attributes="__classmethod__" doc="Returns the character string corresponding to key +c+" />
        <scope name="lines" ilk="function" signature="lines()" attributes="__classmethod__" doc="Returns the number of lines on the screen" />
        <scope name="mouseinterval" ilk="function" signature="mouseinterval(p1)" attributes="__classmethod__" doc="The Curses.mouseinterval function sets the maximum time (in thousands of a second) that can elapse between press and release events for them to be recognized as a click. &#xA; Use Curses.mouseinterval(0) to disable click resolution. This function returns the previous interval value. &#xA; Use Curses.mouseinterval(-1) to obtain the interval without altering it. &#xA; The default is one sixth of a second." />
        <scope name="mousemask" ilk="function" signature="mousemask(p1)" attributes="__classmethod__" doc="Returns the +mask+ of the reportable events" />
        <scope name="nl" ilk="function" signature="nl()" attributes="__classmethod__" doc="Enable the underlying display device to translate the return key into newline on input, and whether it translates newline into return and line-feed on output (in either case, the call Curses.addch(&apos;\n&apos;) does the equivalent of return and line feed on the virtual screen). &#xA; Initially, these translations do occur. If you disable them using Curses.nonl, curses will be able to make better use of the line-feed capability, resulting in faster cursor motion. Also, curses will then be able to detect the return key." />
        <scope name="nocbreak" ilk="function" signature="nocbreak()" attributes="__classmethod__" doc="Put the terminal into normal mode (out of cbreak mode). &#xA; See Curses.cbreak for more detail." />
        <scope name="nocrmode" ilk="function" signature="nocrmode()" attributes="__classmethod__" doc="Put the terminal into normal mode (out of cbreak mode). &#xA; See Curses.cbreak for more detail." />
        <scope name="noecho" ilk="function" signature="noecho()" attributes="__classmethod__" doc="Disables characters typed by the user to be echoed by Curses.getch as they are typed." />
        <scope name="nonl" ilk="function" signature="nonl()" attributes="__classmethod__" doc="Disable the underlying display device to translate the return key into newline on input &#xA; See Curses.nl for more detail" />
        <scope name="noraw" ilk="function" signature="noraw()" attributes="__classmethod__" doc="Put the terminal out of raw mode. &#xA; see Curses.raw for more detail" />
        <scope name="pair_content" ilk="function" signature="pair_content(p1)" attributes="__classmethod__" doc="Returns a 2 item Array, with the foreground and background color, in +pair+" />
        <scope name="pair_number" ilk="function" signature="pair_number(p1)" attributes="__classmethod__" doc="Returns the Fixnum color pair number of attributes +attrs+." />
        <scope name="raw" ilk="function" signature="raw()" attributes="__classmethod__" doc="Put the terminal into raw mode. &#xA; Raw mode is similar to Curses.cbreak mode, in that characters typed are immediately passed through to the user program. &#xA; The differences are that in raw mode, the interrupt, quit, suspend, and flow control characters are all passed through uninterpreted, instead of generating a signal. The behavior of the BREAK key depends on other bits in the tty driver that are not set by curses." />
        <scope name="refresh" ilk="function" signature="refresh()" attributes="__classmethod__" doc="Refreshes the windows and lines." />
        <scope name="reset_prog_mode" ilk="function" signature="reset_prog_mode()" attributes="__classmethod__" doc="Reset the current terminal modes to the saved state by the Curses.def_prog_mode &#xA; This is done automatically by Curses.close_screen" />
        <scope name="resize" ilk="function" signature="resize(p1, p2)" attributes="__classmethod__" doc="Resize the current term to Fixnum +lines+ and Fixnum +cols+" />
        <scope name="resizeterm" ilk="function" signature="resizeterm(p1, p2)" attributes="__classmethod__" doc="Resize the current term to Fixnum +lines+ and Fixnum +cols+" />
        <scope name="scrl" ilk="function" signature="scrl(p1)" attributes="__classmethod__" doc="Scrolls the current window Fixnum +num+ lines. The current cursor position is not changed. &#xA; For positive +num+, it scrolls up. &#xA; For negative +num+, it scrolls down." />
        <scope name="setpos" ilk="function" signature="setpos(p1, p2)" attributes="__classmethod__" doc="A setter for the position of the cursor, using coordinates +x+ and +y+" />
        <scope name="setscrreg" ilk="function" signature="setscrreg(p1, p2)" attributes="__classmethod__" doc="Set a software scrolling region in a window. +top+ and +bottom+ are lines numbers of the margin. &#xA; If this option and Curses.scrollok are enabled, an attempt to move off the bottom margin line causes all lines in the scrolling region to scroll one line in the direction of the first line. Only the text of the window is scrolled." />
        <scope name="standend" ilk="function" signature="standend()" attributes="__classmethod__" doc="Enables the Normal display (no highlight) &#xA; This is equivalent to Curses.attron(A_NORMAL) &#xA; see also Curses::Window.attrset for additional information." />
        <scope name="standout" ilk="function" signature="standout()" attributes="__classmethod__" doc="Enables the best highlighting mode of the terminal. &#xA; This is equivalent to Curses:Window.attron(A_STANDOUT) &#xA; see also Curses::Window.attrset additional information" />
        <scope name="start_color" ilk="function" signature="start_color()" attributes="__classmethod__" doc="Initializes the color attributes, for terminals that support it. &#xA; This must be called, in order to use color attributes. It is good practice to call it just after Curses.init_screen" />
        <scope name="stdscr" ilk="function" signature="stdscr()" attributes="__classmethod__" doc="The Standard Screen.&#xA;&#xA;Upon initializing curses, a default window called stdscr,&#xA;which is the size of the terminal screen, is created.&#xA;&#xA;Many curses functions use this window.&#xA; Initialize a standard screen &#xA; see also Curses.stdscr" />
        <scope name="timeout=" ilk="function" signature="timeout=(p1)" attributes="__classmethod__" doc="Sets block and non-blocking reads for the window. If delay is negative, blocking read is used (i.e., waits indefinitely for input).&#xA;If delay is zero, then non-blocking read is used (i.e., read returns ERR if no input is waiting).&#xA;If delay is positive, then read blocks for delay milliseconds, and returns ERR if there is still no input." />
        <scope name="ungetch" ilk="function" signature="ungetch(p1)" attributes="__classmethod__" doc="Places +ch+ back onto the input queue to be returned by the next call to Curses.getch. &#xA; There is just one input queue for all windows." />
        <scope name="ungetmouse" ilk="function" signature="ungetmouse(p1)" attributes="__classmethod__" doc="It pushes a KEY_MOUSE event onto the input queue, and associates with that event the given state data and screen-relative character-cell coordinates. &#xA; The Curses.ungetmouse function behaves analogously to Curses.ungetch." />
        <scope name="use_default_colors" ilk="function" signature="use_default_colors()" attributes="__classmethod__" doc="tells the curses library to use terminal&apos;s default colors. &#xA; see also the system manual for default_colors(3)" />
        <variable name="A_ATTRIBUTES" attributes="__const__" citdl="Object" />
        <variable name="A_NORMAL" attributes="__const__" citdl="Object" />
        <variable name="A_STANDOUT" attributes="__const__" citdl="Object" />
        <variable name="A_UNDERLINE" attributes="__const__" citdl="Object" />
        <variable name="A_REVERSE" attributes="__const__" citdl="Object" />
        <variable name="A_BLINK" attributes="__const__" citdl="Object" />
        <variable name="A_DIM" attributes="__const__" citdl="Object" />
        <variable name="A_BOLD" attributes="__const__" citdl="Object" />
        <variable name="A_PROTECT" attributes="__const__" citdl="Object" />
        <variable name="A_INVIS" attributes="__const__" citdl="Object" />
        <variable name="A_ALTCHARSET" attributes="__const__" citdl="Object" />
        <variable name="A_CHARTEXT" attributes="__const__" citdl="Object" />
        <variable name="A_HORIZONTAL" attributes="__const__" citdl="Object" />
        <variable name="A_LEFT" attributes="__const__" citdl="Object" />
        <variable name="A_LOW" attributes="__const__" citdl="Object" />
        <variable name="A_RIGHT" attributes="__const__" citdl="Object" />
        <variable name="A_TOP" attributes="__const__" citdl="Object" />
        <variable name="A_VERTICAL" attributes="__const__" citdl="Object" />
        <variable name="A_COLOR" attributes="__const__" citdl="Object" />
        <variable name="COLORS" attributes="__const__" citdl="Object" />
        <variable name="COLOR_BLACK" attributes="__const__" citdl="Object" />
        <variable name="COLOR_RED" attributes="__const__" citdl="Object" />
        <variable name="COLOR_GREEN" attributes="__const__" citdl="Object" />
        <variable name="COLOR_YELLOW" attributes="__const__" citdl="Object" />
        <variable name="COLOR_BLUE" attributes="__const__" citdl="Object" />
        <variable name="COLOR_MAGENTA" attributes="__const__" citdl="Object" />
        <variable name="COLOR_CYAN" attributes="__const__" citdl="Object" />
        <variable name="COLOR_WHITE" attributes="__const__" citdl="Object" />
        <variable name="BUTTON_SHIFT" attributes="__const__" citdl="Object" />
        <variable name="BUTTON_CTRL" attributes="__const__" citdl="Object" />
        <variable name="BUTTON_ALT" attributes="__const__" citdl="Object" />
        <variable name="ALL_MOUSE_EVENTS" attributes="__const__" citdl="Object" />
        <variable name="REPORT_MOUSE_POSITION" attributes="__const__" citdl="Object" />
        <variable name="KEY_MOUSE" attributes="__const__" citdl="Object" />
        <variable name="KEY_MIN" attributes="__const__" citdl="Object" />
        <variable name="KEY_BREAK" attributes="__const__" citdl="Object" />
        <variable name="KEY_DOWN" attributes="__const__" citdl="Object" />
        <variable name="KEY_UP" attributes="__const__" citdl="Object" />
        <variable name="KEY_LEFT" attributes="__const__" citdl="Object" />
        <variable name="KEY_RIGHT" attributes="__const__" citdl="Object" />
        <variable name="KEY_HOME" attributes="__const__" citdl="Object" />
        <variable name="KEY_BACKSPACE" attributes="__const__" citdl="Object" />
        <variable name="KEY_DL" attributes="__const__" citdl="Object" />
        <variable name="KEY_IL" attributes="__const__" citdl="Object" />
        <variable name="KEY_DC" attributes="__const__" citdl="Object" />
        <variable name="KEY_IC" attributes="__const__" citdl="Object" />
        <variable name="KEY_EIC" attributes="__const__" citdl="Object" />
        <variable name="KEY_CLEAR" attributes="__const__" citdl="Object" />
        <variable name="KEY_EOS" attributes="__const__" citdl="Object" />
        <variable name="KEY_EOL" attributes="__const__" citdl="Object" />
        <variable name="KEY_SF" attributes="__const__" citdl="Object" />
        <variable name="KEY_SR" attributes="__const__" citdl="Object" />
        <variable name="KEY_NPAGE" attributes="__const__" citdl="Object" />
        <variable name="KEY_PPAGE" attributes="__const__" citdl="Object" />
        <variable name="KEY_STAB" attributes="__const__" citdl="Object" />
        <variable name="KEY_CTAB" attributes="__const__" citdl="Object" />
        <variable name="KEY_CATAB" attributes="__const__" citdl="Object" />
        <variable name="KEY_ENTER" attributes="__const__" citdl="Object" />
        <variable name="KEY_SRESET" attributes="__const__" citdl="Object" />
        <variable name="KEY_RESET" attributes="__const__" citdl="Object" />
        <variable name="KEY_PRINT" attributes="__const__" citdl="Object" />
        <variable name="KEY_LL" attributes="__const__" citdl="Object" />
        <variable name="KEY_BTAB" attributes="__const__" citdl="Object" />
        <variable name="KEY_BEG" attributes="__const__" citdl="Object" />
        <variable name="KEY_CANCEL" attributes="__const__" citdl="Object" />
        <variable name="KEY_CLOSE" attributes="__const__" citdl="Object" />
        <variable name="KEY_COMMAND" attributes="__const__" citdl="Object" />
        <variable name="KEY_COPY" attributes="__const__" citdl="Object" />
        <variable name="KEY_CREATE" attributes="__const__" citdl="Object" />
        <variable name="KEY_END" attributes="__const__" citdl="Object" />
        <variable name="KEY_EXIT" attributes="__const__" citdl="Object" />
        <variable name="KEY_FIND" attributes="__const__" citdl="Object" />
        <variable name="KEY_HELP" attributes="__const__" citdl="Object" />
        <variable name="KEY_MARK" attributes="__const__" citdl="Object" />
        <variable name="KEY_MESSAGE" attributes="__const__" citdl="Object" />
        <variable name="KEY_MOVE" attributes="__const__" citdl="Object" />
        <variable name="KEY_NEXT" attributes="__const__" citdl="Object" />
        <variable name="KEY_OPEN" attributes="__const__" citdl="Object" />
        <variable name="KEY_OPTIONS" attributes="__const__" citdl="Object" />
        <variable name="KEY_PREVIOUS" attributes="__const__" citdl="Object" />
        <variable name="KEY_REDO" attributes="__const__" citdl="Object" />
        <variable name="KEY_REFERENCE" attributes="__const__" citdl="Object" />
        <variable name="KEY_REFRESH" attributes="__const__" citdl="Object" />
        <variable name="KEY_REPLACE" attributes="__const__" citdl="Object" />
        <variable name="KEY_RESTART" attributes="__const__" citdl="Object" />
        <variable name="KEY_RESUME" attributes="__const__" citdl="Object" />
        <variable name="KEY_SAVE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SBEG" attributes="__const__" citdl="Object" />
        <variable name="KEY_SCANCEL" attributes="__const__" citdl="Object" />
        <variable name="KEY_SCOMMAND" attributes="__const__" citdl="Object" />
        <variable name="KEY_SCOPY" attributes="__const__" citdl="Object" />
        <variable name="KEY_SCREATE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SDC" attributes="__const__" citdl="Object" />
        <variable name="KEY_SDL" attributes="__const__" citdl="Object" />
        <variable name="KEY_SELECT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SEND" attributes="__const__" citdl="Object" />
        <variable name="KEY_SEOL" attributes="__const__" citdl="Object" />
        <variable name="KEY_SEXIT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SFIND" attributes="__const__" citdl="Object" />
        <variable name="KEY_SHELP" attributes="__const__" citdl="Object" />
        <variable name="KEY_SHOME" attributes="__const__" citdl="Object" />
        <variable name="KEY_SIC" attributes="__const__" citdl="Object" />
        <variable name="KEY_SLEFT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SMESSAGE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SMOVE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SNEXT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SOPTIONS" attributes="__const__" citdl="Object" />
        <variable name="KEY_SPREVIOUS" attributes="__const__" citdl="Object" />
        <variable name="KEY_SPRINT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SREDO" attributes="__const__" citdl="Object" />
        <variable name="KEY_SREPLACE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SRIGHT" attributes="__const__" citdl="Object" />
        <variable name="KEY_SRSUME" attributes="__const__" citdl="Object" />
        <variable name="KEY_SSAVE" attributes="__const__" citdl="Object" />
        <variable name="KEY_SSUSPEND" attributes="__const__" citdl="Object" />
        <variable name="KEY_SUNDO" attributes="__const__" citdl="Object" />
        <variable name="KEY_SUSPEND" attributes="__const__" citdl="Object" />
        <variable name="KEY_UNDO" attributes="__const__" citdl="Object" />
        <variable name="KEY_RESIZE" attributes="__const__" citdl="Object" />
        <variable name="KEY_MAX" attributes="__const__" citdl="Object" />
        <scope name="Key" ilk="namespace">
          <variable name="MOUSE" attributes="__const__" citdl="Object" />
          <variable name="MIN" attributes="__const__" citdl="Object" />
          <variable name="BREAK" attributes="__const__" citdl="Object" />
          <variable name="DOWN" attributes="__const__" citdl="Object" />
          <variable name="UP" attributes="__const__" citdl="Object" />
          <variable name="LEFT" attributes="__const__" citdl="Object" />
          <variable name="RIGHT" attributes="__const__" citdl="Object" />
          <variable name="HOME" attributes="__const__" citdl="Object" />
          <variable name="BACKSPACE" attributes="__const__" citdl="Object" />
          <variable name="DL" attributes="__const__" citdl="Object" />
          <variable name="IL" attributes="__const__" citdl="Object" />
          <variable name="DC" attributes="__const__" citdl="Object" />
          <variable name="IC" attributes="__const__" citdl="Object" />
          <variable name="EIC" attributes="__const__" citdl="Object" />
          <variable name="CLEAR" attributes="__const__" citdl="Object" />
          <variable name="EOS" attributes="__const__" citdl="Object" />
          <variable name="EOL" attributes="__const__" citdl="Object" />
          <variable name="SF" attributes="__const__" citdl="Object" />
          <variable name="SR" attributes="__const__" citdl="Object" />
          <variable name="NPAGE" attributes="__const__" citdl="Object" />
          <variable name="PPAGE" attributes="__const__" citdl="Object" />
          <variable name="STAB" attributes="__const__" citdl="Object" />
          <variable name="CTAB" attributes="__const__" citdl="Object" />
          <variable name="CATAB" attributes="__const__" citdl="Object" />
          <variable name="ENTER" attributes="__const__" citdl="Object" />
          <variable name="SRESET" attributes="__const__" citdl="Object" />
          <variable name="RESET" attributes="__const__" citdl="Object" />
          <variable name="PRINT" attributes="__const__" citdl="Object" />
          <variable name="LL" attributes="__const__" citdl="Object" />
          <variable name="BTAB" attributes="__const__" citdl="Object" />
          <variable name="BEG" attributes="__const__" citdl="Object" />
          <variable name="CANCEL" attributes="__const__" citdl="Object" />
          <variable name="CLOSE" attributes="__const__" citdl="Object" />
          <variable name="COMMAND" attributes="__const__" citdl="Object" />
          <variable name="COPY" attributes="__const__" citdl="Object" />
          <variable name="CREATE" attributes="__const__" citdl="Object" />
          <variable name="END" attributes="__const__" citdl="Object" />
          <variable name="EXIT" attributes="__const__" citdl="Object" />
          <variable name="FIND" attributes="__const__" citdl="Object" />
          <variable name="HELP" attributes="__const__" citdl="Object" />
          <variable name="MARK" attributes="__const__" citdl="Object" />
          <variable name="MESSAGE" attributes="__const__" citdl="Object" />
          <variable name="MOVE" attributes="__const__" citdl="Object" />
          <variable name="NEXT" attributes="__const__" citdl="Object" />
          <variable name="OPEN" attributes="__const__" citdl="Object" />
          <variable name="OPTIONS" attributes="__const__" citdl="Object" />
          <variable name="PREVIOUS" attributes="__const__" citdl="Object" />
          <variable name="REDO" attributes="__const__" citdl="Object" />
          <variable name="REFERENCE" attributes="__const__" citdl="Object" />
          <variable name="REFRESH" attributes="__const__" citdl="Object" />
          <variable name="REPLACE" attributes="__const__" citdl="Object" />
          <variable name="RESTART" attributes="__const__" citdl="Object" />
          <variable name="RESUME" attributes="__const__" citdl="Object" />
          <variable name="SAVE" attributes="__const__" citdl="Object" />
          <variable name="SBEG" attributes="__const__" citdl="Object" />
          <variable name="SCANCEL" attributes="__const__" citdl="Object" />
          <variable name="SCOMMAND" attributes="__const__" citdl="Object" />
          <variable name="SCOPY" attributes="__const__" citdl="Object" />
          <variable name="SCREATE" attributes="__const__" citdl="Object" />
          <variable name="SDC" attributes="__const__" citdl="Object" />
          <variable name="SDL" attributes="__const__" citdl="Object" />
          <variable name="SELECT" attributes="__const__" citdl="Object" />
          <variable name="SEND" attributes="__const__" citdl="Object" />
          <variable name="SEOL" attributes="__const__" citdl="Object" />
          <variable name="SEXIT" attributes="__const__" citdl="Object" />
          <variable name="SFIND" attributes="__const__" citdl="Object" />
          <variable name="SHELP" attributes="__const__" citdl="Object" />
          <variable name="SHOME" attributes="__const__" citdl="Object" />
          <variable name="SIC" attributes="__const__" citdl="Object" />
          <variable name="SLEFT" attributes="__const__" citdl="Object" />
          <variable name="SMESSAGE" attributes="__const__" citdl="Object" />
          <variable name="SMOVE" attributes="__const__" citdl="Object" />
          <variable name="SNEXT" attributes="__const__" citdl="Object" />
          <variable name="SOPTIONS" attributes="__const__" citdl="Object" />
          <variable name="SPREVIOUS" attributes="__const__" citdl="Object" />
          <variable name="SPRINT" attributes="__const__" citdl="Object" />
          <variable name="SREDO" attributes="__const__" citdl="Object" />
          <variable name="SREPLACE" attributes="__const__" citdl="Object" />
          <variable name="SRIGHT" attributes="__const__" citdl="Object" />
          <variable name="SRSUME" attributes="__const__" citdl="Object" />
          <variable name="SSAVE" attributes="__const__" citdl="Object" />
          <variable name="SSUSPEND" attributes="__const__" citdl="Object" />
          <variable name="SUNDO" attributes="__const__" citdl="Object" />
          <variable name="SUSPEND" attributes="__const__" citdl="Object" />
          <variable name="UNDO" attributes="__const__" citdl="Object" />
          <variable name="RESIZE" attributes="__const__" citdl="Object" />
          <variable name="MAX" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="MouseEvent" ilk="class" classrefs="Object">
        </scope>
        <scope name="Window" ilk="class" classrefs="Data">
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4)" attributes="__classmethod__ __ctor__" doc="Contruct a new Curses::Window with constraints of +height+ lines, +width+ columns, begin at +top+ line, and begin +left+ most column. &#xA; A new window using full screen is called as Curses::Window.new(0,0,0,0)" />
          <scope name="addch" ilk="function" signature="addch(p1)" doc="Add a character +ch+, with attributes, to the window, then advance the cursor. &#xA; see also the system manual for curs_addch(3)" />
          <scope name="addstr" ilk="function" signature="addstr(p1)" doc="add a string of characters +str+, to the window and advance cursor" />
          <scope name="attroff" ilk="function" signature="attroff(p1)" doc="Turns on the named attributes +attrs+ without affecting any others. &#xA; See also Curses::Window.attrset" />
          <scope name="attron" ilk="function" signature="attron(p1)" doc="Turns off the named attributes +attrs+ without turning any other attributes on or off. &#xA; See also Curses::Window.attrset" />
          <scope name="attrset" ilk="function" signature="attrset(p1)" doc="Sets the current attributes of the given window to +attrs+. &#xA; The following video attributes, defined in &lt;curses.h&gt;, can be passed to the routines Curses::Window.attron, Curses::Window.attroff, and Curses::Window.attrset, or OR&apos;d with the characters passed to addch. A_NORMAL        Normal display (no highlight)&#xA;A_STANDOUT      Best highlighting mode of the terminal.&#xA;A_UNDERLINE     Underlining&#xA;A_REVERSE       Reverse video&#xA;A_BLINK         Blinking&#xA;A_DIM           Half bright&#xA;A_BOLD          Extra bright or bold&#xA;A_PROTECT       Protected mode&#xA;A_INVIS         Invisible or blank mode&#xA;A_ALTCHARSET    Alternate character set&#xA;A_CHARTEXT      Bit-mask to extract a character&#xA;COLOR_PAIR(n)   Color-pair number n" />
          <scope name="begx" ilk="function" signature="begx()" doc="A getter for the beginning column (X coord) of the window" />
          <scope name="begy" ilk="function" signature="begy()" doc="A getter for the beginning line (Y coord) of the window" />
          <scope name="bkgd" ilk="function" signature="bkgd(p1)" doc="Set the background of the current window and apply character Integer +ch+ to every character. &#xA; see also Curses.bkgd" />
          <scope name="bkgdset" ilk="function" signature="bkgdset(p1)" doc="Manipulate the background of the current window with character Integer +ch+ &#xA; see also Curses.bkgdset" />
          <scope name="box" ilk="function" signature="box(p1, p2, p3 = v3)" doc="set the characters to frame the window in. The vertical +vert+ and horizontal +hor+ character. &#xA; win = Curses::Window.new(5,5,5,5)&#xA;win.box(?|, ?-)" />
          <scope name="clear" ilk="function" signature="clear()" doc="Clear the window." />
          <scope name="close" ilk="function" signature="close()" doc="Deletes the window, and frees the memory" />
          <scope name="clrtoeol" ilk="function" signature="clrtoeol()" doc="Clear the window to the end of line, that the cursor is currently on." />
          <scope name="color_set" ilk="function" signature="color_set(p1)" doc="Sets the current color of the given window to the foreground/background combination described by the Fixnum +col+." />
          <scope name="curx" ilk="function" signature="curx()" doc="A getter for the current column (X coord) of the window" />
          <scope name="cury" ilk="function" signature="cury()" doc="A getter for the current line (Y coord) of the window" />
          <scope name="delch" ilk="function" signature="delch()" doc="Delete the character under the cursor" />
          <scope name="deleteln" ilk="function" signature="deleteln()" doc="Delete the line under the cursor." />
          <scope name="getbkgd" ilk="function" signature="getbkgd()" doc="Returns an Interer (+ch+) for the character property in the current window." />
          <scope name="getch" ilk="function" signature="getch()" doc="Read and returns a character from the window. &#xA; See Curses::Key to all the function KEY_* available" />
          <scope name="getstr" ilk="function" signature="getstr()" doc="This is equivalent to a series f Curses::Window.getch calls" />
          <scope name="idlok" ilk="function" signature="idlok(p1)" doc="If +bool+ is +true+ curses considers using the hardware insert/delete line feature of terminals so equipped. &#xA; If +bool+ is +false+, disables use of line insertion and deletion. This option should be enabled only if the application needs insert/delete line, for example, for a screen editor. &#xA; It is disabled by default because insert/delete line tends to be visually annoying when used in applications where it is not really needed. If insert/delete line cannot be used, curses redraws the changed portions of all lines." />
          <scope name="inch" ilk="function" signature="inch()" doc="Returns the character at the current position of the window." />
          <scope name="insch" ilk="function" signature="insch(p1)" doc="Insert a character +ch+, before the cursor, in the current window" />
          <scope name="insertln" ilk="function" signature="insertln()" doc="Inserts a line above the cursor, and the bottom line is lost" />
          <scope name="keypad" ilk="function" signature="keypad(p1)" doc="Enables the keypad of the user&apos;s terminal. &#xA; If enabled (+bool+ is +true+), the user can press a function key (such as an arrow key) and wgetch returns a single value representing the function key, as in KEY_LEFT.  If disabled (+bool+ is +false+), curses does not treat function keys specially and the program has to interpret the escape sequences itself.  If the keypad in the terminal can be turned on (made to transmit) and off (made to work locally), turning on this option causes the terminal keypad to be turned on when Curses::Window.getch is called. &#xA; The default value for keypad is false." />
          <scope name="keypad=" ilk="function" signature="keypad=(p1)" doc="Enables the keypad of the user&apos;s terminal. &#xA; If enabled (+bool+ is +true+), the user can press a function key (such as an arrow key) and wgetch returns a single value representing the function key, as in KEY_LEFT.  If disabled (+bool+ is +false+), curses does not treat function keys specially and the program has to interpret the escape sequences itself.  If the keypad in the terminal can be turned on (made to transmit) and off (made to work locally), turning on this option causes the terminal keypad to be turned on when Curses::Window.getch is called. &#xA; The default value for keypad is false." />
          <scope name="maxx" ilk="function" signature="maxx()" doc="A getter for the maximum columns for the window" />
          <scope name="maxy" ilk="function" signature="maxy()" doc="A getter for the maximum lines for the window" />
          <scope name="move" ilk="function" signature="move(p1, p2)" doc="Moves the window so that the upper left-hand corner is at position (+y+, +x+)" />
          <scope name="nodelay=" ilk="function" signature="nodelay=(p1)" doc="Causes Curses::Window.getch to be a non-blocking call.  If no input is ready, getch returns ERR. &#xA; If disabled (+bool+ is +false+), Curses::Window.getch waits until a key is pressed." />
          <scope name="noutrefresh" ilk="function" signature="noutrefresh()" doc="Refreshes the windows and lines. &#xA; Curses::Window.noutrefresh allows multiple updates with more efficiency than Curses::Window.refresh alone." />
          <scope name="refresh" ilk="function" signature="refresh()" doc="Refreshes the windows and lines." />
          <scope name="resize" ilk="function" signature="resize(p1, p2)" doc="Resize the current window to Fixnum +lines+ and Fixnum +cols+" />
          <scope name="scrl" ilk="function" signature="scrl(p1)" doc="Scrolls the current window Fixnum +num+ lines. The current cursor position is not changed. &#xA; For positive +num+, it scrolls up. &#xA; For negative +num+, it scrolls down." />
          <scope name="scroll" ilk="function" signature="scroll()" doc="Scrolls the current window up one line." />
          <scope name="scrollok" ilk="function" signature="scrollok(p1)" doc="Controls what happens when the cursor of a window is moved off the edge of the window or scrolling region, either as a result of a newline action on the bottom line, or typing the last character of the last line. &#xA; If disabled, (+bool+ is false), the cursor is left on the bottom line. &#xA; If enabled, (+bool+ is true), the window is scrolled up one line (Note that to get the physical scrolling effect on the terminal, it is also necessary to call Curses::Window.idlok)" />
          <scope name="setpos" ilk="function" signature="setpos(p1, p2)" doc="A setter for the position of the cursor in the current window, using coordinates +x+ and +y+" />
          <scope name="setscrreg" ilk="function" signature="setscrreg(p1, p2)" doc="Set a software scrolling region in a window. +top+ and +bottom+ are lines numbers of the margin. &#xA; If this option and Curses::Window.scrollok are enabled, an attempt to move off the bottom margin line causes all lines in the scrolling region to scroll one line in the direction of the first line.  Only the text of the window is scrolled." />
          <scope name="standend" ilk="function" signature="standend()" doc="Enables the Normal display (no highlight) &#xA; This is equivalent to Curses::Window.attron(A_NORMAL) &#xA; see also Curses::Window.attrset" />
          <scope name="standout" ilk="function" signature="standout()" doc="Enables the best highlighting mode of the terminal. &#xA; This is equivalent to Curses::Window.attron(A_STANDOUT) &#xA; see also Curses::Window.attrset" />
          <scope name="subwin" ilk="function" signature="subwin(p1, p2, p3, p4)" doc="Contruct a new subwindow with constraints of +height+ lines, +width+ columns, begin at +top+ line, and begin +left+ most column." />
          <scope name="timeout=" ilk="function" signature="timeout=(p1)" doc="Sets block and non-blocking reads for the window. If delay is negative, blocking read is used (i.e., waits indefinitely for input).&#xA;If delay is zero, then non-blocking read is used (i.e., read returns ERR if no input is waiting).&#xA;If delay is positive, then read blocks for delay milliseconds, and returns ERR if there is still no input." />
        </scope>
      </scope>
    </scope>
    <scope name="dbm" ilk="blob" lang="Ruby">
      <scope name="DBM" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Open a dbm database with the specified name, which can include a directory path. Any file extensions needed will be supplied automatically by the dbm library. For example, Berkeley DB appends &apos;.db&apos;, and GNU gdbm uses two physical files with extensions &apos;.dir&apos; and &apos;.pag&apos;. &#xA; The mode should be an integer, as for Unix chmod. &#xA; Flags should be one of READER, WRITER, WRCREAT or NEWDB." />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Open a dbm database and yields it if a block is given. See also DBM.new." />
        <scope name="clear" ilk="function" signature="clear()" doc="Deletes all data from the database." />
        <scope name="close" ilk="function" signature="close()" doc="Closes the database." />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if the database is closed, false otherwise." />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Deletes an entry from the database." />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes all entries for which the code block returns true. Returns self." />
        <scope name="each" ilk="function" signature="each()" doc="Calls the block once for each [key, value] pair in the database. Returns self." />
        <scope name="each_key" ilk="function" signature="each_key()" doc="Calls the block once for each key string in the database. Returns self." />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Calls the block once for each [key, value] pair in the database. Returns self." />
        <scope name="each_value" ilk="function" signature="each_value()" doc="Calls the block once for each value string in the database. Returns self." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if the database is empty, false otherwise." />
        <scope name="fetch" ilk="function" signature="fetch(p1, p2 = v2)" doc="Return a value from the database by locating the key string provided.  If the key is not found, returns +ifnone+. If +ifnone+ is not given, raises IndexError." />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" doc="Returns true if the database contains the specified key, false otherwise." />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" doc="Returns true if the database contains the specified string value, false otherwise." />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if the database contains the specified key, false otherwise." />
        <scope name="invert" ilk="function" signature="invert()" doc="Returns a Hash (not a DBM database) created by using each value in the database as a key, with the corresponding key as its value." />
        <scope name="key" ilk="function" signature="key(p1)" doc="Returns the key for the specified value." />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the database contains the specified key, false otherwise." />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns an array of all the string keys in the database." />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of entries in the database." />
        <scope name="member?" ilk="function" signature="member?(p1)" doc="Returns true if the database contains the specified key, false otherwise." />
        <scope name="reject" ilk="function" signature="reject()" doc="Converts the contents of the database to an in-memory Hash, then calls Hash#reject with the specified code block, returning a new Hash." />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Deletes all entries for which the code block returns true. Returns self." />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the contents of the database with the contents of the specified object. Takes any object which implements the each_pair method, including Hash and DBM objects." />
        <scope name="select" ilk="function" signature="select()" doc="Returns a new array consisting of the [key, value] pairs for which the code block returns true." />
        <scope name="shift" ilk="function" signature="shift()" doc="Removes a [key, value] pair from the database, and returns it. If the database is empty, returns nil. The order in which values are removed/returned is not guaranteed." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of entries in the database." />
        <scope name="store" ilk="function" signature="store(p1, p2)" doc="Stores the specified string value in the database, indexed via the string key provided." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Converts the contents of the database to an array of [key, value] arrays, and returns it." />
        <scope name="to_hash" ilk="function" signature="to_hash()" doc="Converts the contents of the database to an in-memory Hash object, and returns it." />
        <scope name="update" ilk="function" signature="update(p1)" doc="Updates the database with multiple values from the specified object. Takes any object which implements the each_pair method, including Hash and DBM objects." />
        <scope name="value?" ilk="function" signature="value?(p1)" doc="Returns true if the database contains the specified string value, false otherwise." />
        <scope name="values" ilk="function" signature="values()" doc="Returns an array of all the string values in the database." />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Returns an array containing the values associated with the given keys." />
        <variable name="READER" attributes="__const__" citdl="Object" />
        <variable name="WRITER" attributes="__const__" citdl="Object" />
        <variable name="WRCREAT" attributes="__const__" citdl="Object" />
        <variable name="NEWDB" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
      </scope>
      <scope name="DBMError" ilk="class" classrefs="StandardError">
      </scope>
    </scope>
    <scope name="delegate" ilk="blob" lang="Ruby">
      <scope name="Delegator" ilk="class" classrefs="BasicObject">
        <scope name="delegating_block" ilk="function" signature="delegating_block(mid)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(obj)" attributes="__classmethod__ __ctor__" doc="Pass in the _obj_ to delegate method calls to.  All methods supported by _obj_ will be delegated to." />
        <scope name="__getobj__" ilk="function" signature="__getobj__()" doc="This method must be overridden by subclasses and should return the object method calls are being delegated to." />
        <scope name="__setobj__" ilk="function" signature="__setobj__(obj)" doc="This method must be overridden by subclasses and change the object delegate to _obj_." />
        <scope name="freeze" ilk="function" signature="freeze" doc="Freeze both the object returned by \_\_getobj\_\_ and self." />
        <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Serialization support for the object returned by \_\_getobj\_\_." />
        <scope name="marshal_load" ilk="function" signature="marshal_load(data)" doc="Reinitializes delegation from a serialized object." />
        <scope name="method_missing" ilk="function" signature="method_missing(m, *args, &amp;block)" doc="Handles the magic of delegation through \_\_getobj\_\_." />
        <scope name="methods" ilk="function" signature="methods()" doc="Returns the methods available to this delegate object as the union of this object&apos;s and \_\_getobj\_\_ methods." />
        <scope name="protected_methods" ilk="function" signature="protected_methods(all=true)" doc="Returns the methods available to this delegate object as the union of this object&apos;s and \_\_getobj\_\_ protected methods." />
        <scope name="public_methods" ilk="function" signature="public_methods(all=true)" doc="Returns the methods available to this delegate object as the union of this object&apos;s and \_\_getobj\_\_ public methods." />
        <scope name="respond_to_missing?" ilk="function" signature="respond_to_missing?(m, include_private)" doc="Checks for a method provided by this the delegate object by forwarding the call through \_\_getobj\_\_." />
        <scope name="taint" ilk="function" signature="taint" doc="Taint both the object returned by \_\_getobj\_\_ and self." />
        <scope name="trust" ilk="function" signature="trust" doc="Trust both the object returned by \_\_getobj\_\_ and self." />
        <scope name="untaint" ilk="function" signature="untaint" doc="Untaint both the object returned by \_\_getobj\_\_ and self." />
        <scope name="untrust" ilk="function" signature="untrust" doc="Untrust both the object returned by \_\_getobj\_\_ and self." />
      </scope>
      <scope name="SimpleDelegator" ilk="class" classrefs="Delegator">
        <scope name="__getobj__" ilk="function" signature="__getobj__()" doc="Returns the current object method calls are being delegated to." />
        <scope name="__setobj__" ilk="function" signature="__setobj__(obj)" doc="Changes the delegate object to _obj_. &#xA; It&apos;s important to note that this does *not* cause SimpleDelegator&apos;s methods to change.  Because of this, you probably only want to change delegation to objects of the same type as the original delegate. &#xA; Here&apos;s an example of changing the delegation object. &#xA; names = SimpleDelegator.new(%w{James Edward Gray II})&#xA;puts names[1]    # =&gt; Edward&#xA;names.__setobj__(%w{Gavin Sinclair})&#xA;puts names[1]    # =&gt; Sinclair" />
      </scope>
    </scope>
    <scope name="digest" ilk="blob" lang="Ruby">
      <scope name="Digest" ilk="namespace">
        <scope name="hexencode" ilk="function" signature="hexencode(p1)" attributes="__classmethod__" doc="Generates a hex-encoded version of a given _string_." />
        <scope name="Base" ilk="class" classrefs="Digest::Class">
        </scope>
        <scope name="Class" ilk="class" classrefs="Object">
          <import symbol="Digest::Instance" />
          <scope name="base64digest" ilk="function" signature="base64digest(str, *args)" attributes="__classmethod__" doc="Returns the base64 encoded hash value of a given _string_.  The return value is properly padded with &apos;=&apos; and contains no line feeds." />
          <scope name="digest" ilk="function" signature="digest(*args)" attributes="__classmethod__" doc="Returns the hash value of a given _string_.  This is equivalent to Digest::Class.new(*parameters).digest(string), where extra _parameters_, if any, are passed through to the constructor and the _string_ is passed to #digest()." />
          <scope name="file" ilk="function" signature="file(name)" attributes="__classmethod__" doc="creates a digest object and reads a given file, _name_. &#xA; p Digest::SHA256.file(&quot;X11R6.8.2-src.tar.bz2&quot;).hexdigest&#xA;# =&gt; &quot;f02e3c85572dc9ad7cb77c2a638e3be24cc1b5bea9fdbb0b0299c9668475c534&quot;" />
          <scope name="hexdigest" ilk="function" signature="hexdigest(*args)" attributes="__classmethod__" doc="Returns the hex-encoded hash value of a given _string_.  This is almost equivalent to Digest.hexencode(Digest::Class.new(*parameters).digest(string))." />
        </scope>
        <scope name="Instance" ilk="namespace">
          <scope name="base64digest" ilk="function" signature="base64digest(str = nil)" doc="If none is given, returns the resulting hash value of the digest in a base64 encoded form, keeping the digest&apos;s state. &#xA; If a +string+ is given, returns the hash value for the given +string+ in a base64 encoded form, resetting the digest to the initial state before and after the process. &#xA; In either case, the return value is properly padded with &apos;=&apos; and contains no line feeds." />
          <scope name="base64digest!" ilk="function" signature="base64digest!()" doc="Returns the resulting hash value and resets the digest to the initial state." />
          <scope name="block_length" ilk="function" signature="block_length()" doc="Returns the block length of the digest. &#xA; This method is overridden by each implementation subclass." />
          <scope name="digest" ilk="function" signature="digest(p1 = v1)" doc="If none is given, returns the resulting hash value of the digest, keeping the digest&apos;s state. &#xA; If a _string_ is given, returns the hash value for the given _string_, resetting the digest to the initial state before and after the process." />
          <scope name="digest!" ilk="function" signature="digest!()" doc="Returns the resulting hash value and resets the digest to the initial state." />
          <scope name="digest_length" ilk="function" signature="digest_length()" doc="Returns the length of the hash value of the digest. &#xA; This method should be overridden by each implementation subclass. If not, digest_obj.digest().length() is returned." />
          <scope name="file" ilk="function" signature="file(name)" doc="updates the digest with the contents of a given file _name_ and returns self." />
          <scope name="hexdigest" ilk="function" signature="hexdigest(p1 = v1)" doc="If none is given, returns the resulting hash value of the digest in a hex-encoded form, keeping the digest&apos;s state. &#xA; If a _string_ is given, returns the hash value for the given _string_ in a hex-encoded form, resetting the digest to the initial state before and after the process." />
          <scope name="hexdigest!" ilk="function" signature="hexdigest!()" doc="Returns the resulting hash value in a hex-encoded form and resets the digest to the initial state." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Creates a printable version of the digest object." />
          <scope name="length" ilk="function" signature="length()" doc="Returns digest_obj.digest_length()." />
          <scope name="new" ilk="function" signature="new()" doc="Returns a new, initialized copy of the digest object.  Equivalent to digest_obj.clone().reset()." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the digest to the initial state and returns self. &#xA; This method is overridden by each implementation subclass." />
          <scope name="size" ilk="function" signature="size()" doc="Returns digest_obj.digest_length()." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns digest_obj.hexdigest()." />
          <scope name="update" ilk="function" signature="update(p1)" doc="Updates the digest using a given _string_ and returns self. &#xA; The update() method and the left-shift operator are overridden by each implementation subclass. (One should be an alias for the other)" />
        </scope>
      </scope>
    </scope>
    <scope name="digest/hmac" ilk="blob" lang="Ruby">
      <scope name="Digest" ilk="namespace">
        <scope name="HMAC" ilk="class" classrefs="Digest::Class">
          <scope name="new" ilk="function" signature="new(key, digester)" attributes="__classmethod__ __ctor__" doc="Creates a Digest::HMAC instance." />
          <scope name="block_length" ilk="function" signature="block_length()" doc="Returns the block length in bytes of the hmac." />
          <scope name="digest_length" ilk="function" signature="digest_length()" doc="Returns the length in bytes of the hash value of the digest." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Creates a printable version of the hmac object." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the hmac to the initial state and returns self." />
          <scope name="update" ilk="function" signature="update(text)" doc="Updates the hmac using a given +string+ and returns self." />
        </scope>
      </scope>
    </scope>
    <scope name="dl" ilk="blob" lang="Ruby">
      <scope name="DL" ilk="namespace">
        <scope name="dlopen" ilk="function" signature="dlopen(*args)" attributes="__classmethod__" />
        <scope name="dlunwrap" ilk="function" signature="dlunwrap(p1)" attributes="__classmethod__" />
        <scope name="dlwrap" ilk="function" signature="dlwrap(p1)" attributes="__classmethod__" />
        <scope name="fiddle?" ilk="function" signature="fiddle?()" attributes="__classmethod__" />
        <scope name="free" ilk="function" signature="free(p1)" attributes="__classmethod__" doc="Free the memory at address +addr+" />
        <scope name="malloc" ilk="function" signature="malloc(p1)" attributes="__classmethod__" doc="Allocate +size+ bytes of memory and return the integer memory address for the allocated memory." />
        <scope name="realloc" ilk="function" signature="realloc(p1, p2)" attributes="__classmethod__" doc="Change the size of the memory allocated at the memory location +addr+ to +size+ bytes.  Returns the memory address of the reallocated memory, which may be different than the address passed in." />
        <scope name="remove_callback" ilk="function" signature="remove_callback(addr, ctype = nil)" />
        <scope name="remove_callback_internal" ilk="function" signature="remove_callback_internal(proc_entry, addr_entry, addr, ctype = nil)" />
        <scope name="remove_cdecl_callback" ilk="function" signature="remove_cdecl_callback(addr, ctype = nil)" />
        <scope name="remove_stdcall_callback" ilk="function" signature="remove_stdcall_callback(addr, ctype = nil)" />
        <scope name="set_callback" ilk="function" signature="set_callback(ty, argc, &amp;cbp)" />
        <scope name="set_callback_internal" ilk="function" signature="set_callback_internal(proc_entry, addr_entry, argc, ty, abi = nil, &amp;cbp)" />
        <scope name="set_cdecl_callback" ilk="function" signature="set_cdecl_callback(ty, argc, &amp;cbp)" />
        <scope name="set_stdcall_callback" ilk="function" signature="set_stdcall_callback(ty, argc, &amp;cbp)" />
        <variable name="NULL" attributes="__const__" citdl="Object" />
        <variable name="MAX_CALLBACK" attributes="__const__" citdl="Object" />
        <variable name="DLSTACK_SIZE" attributes="__const__" citdl="Object" />
        <variable name="RTLD_GLOBAL" attributes="__const__" citdl="Object" />
        <variable name="RTLD_LAZY" attributes="__const__" citdl="Object" />
        <variable name="RTLD_NOW" attributes="__const__" citdl="Object" />
        <variable name="TYPE_VOID" attributes="__const__" citdl="Object" />
        <variable name="TYPE_VOIDP" attributes="__const__" citdl="Object" />
        <variable name="TYPE_CHAR" attributes="__const__" citdl="Object" />
        <variable name="TYPE_SHORT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_INT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_LONG" attributes="__const__" citdl="Object" />
        <variable name="TYPE_LONG_LONG" attributes="__const__" citdl="Object" />
        <variable name="TYPE_FLOAT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_DOUBLE" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_VOIDP" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_CHAR" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_SHORT" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_INT" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_LONG" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_LONG_LONG" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_FLOAT" attributes="__const__" citdl="Object" />
        <variable name="ALIGN_DOUBLE" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_VOIDP" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_CHAR" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_SHORT" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_INT" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_LONG" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_LONG_LONG" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_FLOAT" attributes="__const__" citdl="Object" />
        <variable name="SIZEOF_DOUBLE" attributes="__const__" citdl="Object" />
        <variable name="RUBY_FREE" attributes="__const__" citdl="Object" />
        <variable name="BUILD_RUBY_PLATFORM" attributes="__const__" citdl="Object" />
        <variable name="BUILD_RUBY_VERSION" attributes="__const__" citdl="Object" />
        <variable name="SEM" attributes="__const__" citdl="Object" />
        <scope name="CParser" ilk="namespace">
          <scope name="parse_ctype" ilk="function" signature="parse_ctype(ty, tymap=nil)" />
          <scope name="parse_signature" ilk="function" signature="parse_signature(signature, tymap=nil)" />
          <scope name="parse_struct_signature" ilk="function" signature="parse_struct_signature(signature, tymap=nil)" />
        </scope>
        <scope name="CStruct" ilk="class" classrefs="Object">
          <scope name="entity_class" ilk="function" signature="entity_class()" attributes="__classmethod__" />
        </scope>
        <scope name="CStructBuilder" ilk="namespace">
          <scope name="create" ilk="function" signature="create(klass, types, members)" attributes="__classmethod__" />
        </scope>
        <scope name="CStructEntity" ilk="class" classrefs="DL::CPtr">
          <import symbol="PackInfo" />
          <import symbol="ValueUtil" />
          <scope name="malloc" ilk="function" signature="malloc(types, func = nil)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(addr, types, func = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="size" ilk="function" signature="size(types)" attributes="__classmethod__" />
          <scope name="assign_names" ilk="function" signature="assign_names(members)" />
          <scope name="set_ctypes" ilk="function" signature="set_ctypes(types)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
        </scope>
        <scope name="CUnion" ilk="class" classrefs="Object">
          <scope name="entity_class" ilk="function" signature="entity_class()" attributes="__classmethod__" />
        </scope>
        <scope name="CUnionEntity" ilk="class" classrefs="DL::CStructEntity">
          <import symbol="PackInfo" />
          <scope name="malloc" ilk="function" signature="malloc(types, func=nil)" attributes="__classmethod__" />
          <scope name="size" ilk="function" signature="size(types)" attributes="__classmethod__" />
          <scope name="set_ctypes" ilk="function" signature="set_ctypes(types)" />
        </scope>
        <scope name="CarriedFunction" ilk="class" classrefs="DL::Function">
          <scope name="new" ilk="function" signature="new(cfunc, argtypes, n)" attributes="__classmethod__ __ctor__" />
          <scope name="bind_at_call" ilk="function" signature="bind_at_call(&amp;block)" />
          <scope name="create_carrier" ilk="function" signature="create_carrier(data)" />
        </scope>
        <scope name="CompositeHandler" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(handlers)" attributes="__classmethod__ __ctor__" />
          <scope name="handlers" ilk="function" signature="handlers()" />
          <scope name="sym" ilk="function" signature="sym(symbol)" />
        </scope>
        <scope name="DLError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="DLTypeError" ilk="class" classrefs="DL::DLError">
        </scope>
        <scope name="Function" ilk="class" classrefs="parent">
          <import symbol="DL" />
          <import symbol="ValueUtil" />
          <scope name="new" ilk="function" signature="new(cfunc, argtypes, abi = nil, &amp;block)" attributes="__classmethod__ __ctor__" />
          <scope name="bind" ilk="function" signature="bind(&amp;block)" />
          <scope name="bind_at_call" ilk="function" signature="bind_at_call(&amp;block)" />
          <scope name="bound?" ilk="function" signature="bound?()" />
          <scope name="call" ilk="function" signature="call(*args, &amp;block)" />
          <scope name="name" ilk="function" signature="name()" />
          <scope name="to_i" ilk="function" signature="to_i()" />
          <scope name="unbind" ilk="function" signature="unbind()" />
          <scope name="unbind_at_call" ilk="function" signature="unbind_at_call()" />
          <scope name="wrap_result" ilk="function" signature="wrap_result(r)" />
        </scope>
        <scope name="PackInfo" ilk="namespace">
          <scope name="align" ilk="function" signature="align(addr, align)" attributes="__classmethod__" />
          <variable name="ALIGN_MAP" attributes="__const__" citdl="Object" />
          <variable name="PACK_MAP" attributes="__const__" citdl="Object" />
          <variable name="SIZE_MAP" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Packer" ilk="class" classrefs="Object">
          <import symbol="PackInfo" />
          <scope name="new" ilk="function" signature="new(types)" attributes="__classmethod__ __ctor__" />
          <scope name="pack" ilk="function" signature="pack(ary)" />
          <scope name="size" ilk="function" signature="size()" />
          <scope name="unpack" ilk="function" signature="unpack(ary)" />
        </scope>
        <scope name="Stack" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(types)" attributes="__classmethod__ __ctor__" />
          <scope name="pack" ilk="function" signature="pack(ary)" />
          <scope name="size" ilk="function" signature="size()" />
          <scope name="types" ilk="function" signature="types()" />
          <scope name="unpack" ilk="function" signature="unpack(ary)" />
          <variable name="ALIGN_MAP" attributes="__const__" citdl="Object" />
          <variable name="PACK_MAP" attributes="__const__" citdl="Object" />
          <variable name="SIZE_MAP" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="TempFunction" ilk="class" classrefs="DL::Function">
          <scope name="bind_at_call" ilk="function" signature="bind_at_call(&amp;block)" />
          <scope name="unbind_at_call" ilk="function" signature="unbind_at_call()" />
        </scope>
        <scope name="ValueUtil" ilk="namespace">
          <scope name="signed_value" ilk="function" signature="signed_value(val, ty)" />
          <scope name="unsigned_value" ilk="function" signature="unsigned_value(val, ty)" />
          <scope name="wrap_arg" ilk="function" signature="wrap_arg(arg, ty, funcs = [], &amp;block)" />
          <scope name="wrap_args" ilk="function" signature="wrap_args(args, tys, funcs, &amp;block)" />
        </scope>
        <scope name="CFunc" ilk="class" classrefs="Object">
          <scope name="last_error" ilk="function" signature="last_error()" attributes="__classmethod__" doc="Returns the last error for the current executing thread" />
          <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="Create a new function that points to +address+ with an optional return type of +type+, a name of +name+ and a calltype of +calltype+." />
          <scope name="win32_last_error" ilk="function" signature="win32_last_error()" attributes="__classmethod__" doc="Returns the last win32 error for the current executing thread" />
          <scope name="call" ilk="function" signature="call(p1)" doc="Calls the function pointer passing in +ary+ as values to the underlying C function.  The return value depends on the ctype." />
          <scope name="calltype" ilk="function" signature="calltype()" doc="Get the call type of this function." />
          <scope name="calltype=" ilk="function" signature="calltype=(p1)" doc="Set the call type for this function." />
          <scope name="ctype" ilk="function" signature="ctype()" doc="Get the C function return value type.  See DL for a list of constants corresponding to this method&apos;s return value." />
          <scope name="ctype=" ilk="function" signature="ctype=(p1)" doc="Set the C function return value type to +type+." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string formatted with an easily readable representation of the internal state of the DL::CFunc" />
          <scope name="name" ilk="function" signature="name()" doc="Get the name of this function" />
          <scope name="ptr" ilk="function" signature="ptr()" doc="Get the underlying function pointer as a DL::CPtr object." />
          <scope name="ptr=" ilk="function" signature="ptr=(p1)" doc="Set the underlying function pointer to a DL::CPtr named +pointer+." />
          <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the memory location of this function pointer as an integer." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns a string formatted with an easily readable representation of the internal state of the DL::CFunc" />
        </scope>
        <scope name="CPtr" ilk="class" classrefs="Object">
          <scope name="malloc" ilk="function" signature="malloc(p1, p2 = v2)" attributes="__classmethod__" doc="Allocate +size+ bytes of memory and associate it with an optional +freefunc+ that will be called when the pointer is garbage collected. +freefunc+ must be an address pointing to a function or an instance of DL::CFunc" />
          <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Create a new pointer to +address+ with an optional +size+ and +freefunc+. +freefunc+ will be called when the instance is garbage collected." />
          <scope name="to_ptr" ilk="function" signature="to_ptr(p1)" attributes="__classmethod__" doc="Get the underlying pointer for ruby object +val+ and return it as a DL::CPtr object." />
          <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Returns true if +other+ wraps the same pointer, otherwise returns false." />
          <scope name="free" ilk="function" signature="free()" doc="Get the free function for this pointer.  Returns  DL::CFunc or nil." />
          <scope name="free=" ilk="function" signature="free=(p1)" doc="Set the free function for this pointer to the DL::CFunc in +function+." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string formatted with an easily readable representation of the internal state of the DL::CPtr" />
          <scope name="null?" ilk="function" signature="null?()" doc="Returns true if this is a null pointer." />
          <scope name="ptr" ilk="function" signature="ptr()" doc="Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr. Analogous to the star operator in C." />
          <scope name="ref" ilk="function" signature="ref()" doc="Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous to the ampersand operator in C." />
          <scope name="size" ilk="function" signature="size()" doc="Get the size of this pointer." />
          <scope name="size=" ilk="function" signature="size=(p1)" doc="Set the size of this pointer to +size+" />
          <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the integer memory location of this DL::CPtr." />
          <scope name="to_int" ilk="function" signature="to_int()" doc="Returns the integer memory location of this DL::CPtr." />
          <scope name="to_s" ilk="function" signature="to_s(p1 = v1)" doc="Returns the pointer contents as a string.  When called with no arguments, this method will return the contents until the first NULL byte.  When called with +len+, a string of +len+ bytes will be returned." />
          <scope name="to_str" ilk="function" signature="to_str(p1 = v1)" doc="Returns the pointer contents as a string.  When called with no arguments, this method will return the contents with the length of this pointer&apos;s +size+. When called with +len+, a string of +len+ bytes will be returned." />
          <scope name="to_value" ilk="function" signature="to_value()" doc="Cast this CPtr to a ruby object." />
        </scope>
        <scope name="Handle" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Create a new handler that opens library named +lib+ with +flags+.  If no library is specified, RTLD_DEFAULT is used." />
          <scope name="sym" ilk="function" signature="sym(p1)" attributes="__classmethod__" doc="Document-method: [] &#xA; Get the address as an Integer for the function named +name+." />
          <scope name="close" ilk="function" signature="close()" doc="Close this DL::Handle.  Calling close more than once will raise a DL::DLError exception." />
          <scope name="close_enabled?" ilk="function" signature="close_enabled?()" doc="Returns +true+ if dlclose() will be called when this DL::Handle is garbage collected." />
          <scope name="disable_close" ilk="function" signature="disable_close()" doc="Disable a call to dlclose() when this DL::Handle is garbage collected." />
          <scope name="enable_close" ilk="function" signature="enable_close()" doc="Enable a call to dlclose() when this DL::Handle is garbage collected." />
          <scope name="sym" ilk="function" signature="sym(p1)" doc="Document-method: [] &#xA; Get the address as an Integer for the function named +name+." />
          <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the memory address for this handle." />
          <variable name="NEXT" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
      <scope name="Fiddle" ilk="namespace">
        <scope name="Pointer" ilk="class" classrefs="Object">
          <scope name="malloc" ilk="function" signature="malloc(p1, p2 = v2)" attributes="__classmethod__" doc="Allocate +size+ bytes of memory and associate it with an optional +freefunc+ that will be called when the pointer is garbage collected. +freefunc+ must be an address pointing to a function or an instance of DL::CFunc" />
          <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Create a new pointer to +address+ with an optional +size+ and +freefunc+. +freefunc+ will be called when the instance is garbage collected." />
          <scope name="to_ptr" ilk="function" signature="to_ptr(p1)" attributes="__classmethod__" doc="Get the underlying pointer for ruby object +val+ and return it as a DL::CPtr object." />
          <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Returns true if +other+ wraps the same pointer, otherwise returns false." />
          <scope name="free" ilk="function" signature="free()" doc="Get the free function for this pointer.  Returns  DL::CFunc or nil." />
          <scope name="free=" ilk="function" signature="free=(p1)" doc="Set the free function for this pointer to the DL::CFunc in +function+." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string formatted with an easily readable representation of the internal state of the DL::CPtr" />
          <scope name="null?" ilk="function" signature="null?()" doc="Returns true if this is a null pointer." />
          <scope name="ptr" ilk="function" signature="ptr()" doc="Returns a DL::CPtr that is a dereferenced pointer for this DL::CPtr. Analogous to the star operator in C." />
          <scope name="ref" ilk="function" signature="ref()" doc="Returns a DL::CPtr that is a reference pointer for this DL::CPtr. Analogous to the ampersand operator in C." />
          <scope name="size" ilk="function" signature="size()" doc="Get the size of this pointer." />
          <scope name="size=" ilk="function" signature="size=(p1)" doc="Set the size of this pointer to +size+" />
          <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the integer memory location of this DL::CPtr." />
          <scope name="to_int" ilk="function" signature="to_int()" doc="Returns the integer memory location of this DL::CPtr." />
          <scope name="to_s" ilk="function" signature="to_s(p1 = v1)" doc="Returns the pointer contents as a string.  When called with no arguments, this method will return the contents until the first NULL byte.  When called with +len+, a string of +len+ bytes will be returned." />
          <scope name="to_str" ilk="function" signature="to_str(p1 = v1)" doc="Returns the pointer contents as a string.  When called with no arguments, this method will return the contents with the length of this pointer&apos;s +size+. When called with +len+, a string of +len+ bytes will be returned." />
          <scope name="to_value" ilk="function" signature="to_value()" doc="Cast this CPtr to a ruby object." />
        </scope>
      </scope>
    </scope>
    <scope name="dl/import" ilk="blob" lang="Ruby">
      <scope name="DL" ilk="namespace">
        <scope name="Importer" ilk="namespace">
          <import symbol="CParser" />
          <import symbol="DL" />
          <scope name="bind" ilk="function" signature="bind(signature, *opts, &amp;blk)" />
          <scope name="bind_function" ilk="function" signature="bind_function(name, ctype, argtype, call_type = nil, &amp;block)" />
          <scope name="create_carried_function" ilk="function" signature="create_carried_function(name, ctype, argtype, call_type = nil, n = 0)" />
          <scope name="create_temp_function" ilk="function" signature="create_temp_function(name, ctype, argtype, call_type = nil)" />
          <scope name="create_value" ilk="function" signature="create_value(ty, val=nil)" />
          <scope name="dlload" ilk="function" signature="dlload(*libs)" />
          <scope name="extern" ilk="function" signature="extern(signature, *opts)" />
          <scope name="handler" ilk="function" signature="handler()" />
          <scope name="import_function" ilk="function" signature="import_function(name, ctype, argtype, call_type = nil)" />
          <scope name="import_symbol" ilk="function" signature="import_symbol(name)" />
          <scope name="import_value" ilk="function" signature="import_value(ty, addr)" />
          <scope name="sizeof" ilk="function" signature="sizeof(ty)" />
          <scope name="struct" ilk="function" signature="struct(signature)" />
          <scope name="typealias" ilk="function" signature="typealias(alias_type, orig_type)" />
          <scope name="union" ilk="function" signature="union(signature)" />
          <scope name="value" ilk="function" signature="value(ty, val=nil)" />
        </scope>
      </scope>
    </scope>
    <scope name="dl/types" ilk="blob" lang="Ruby">
      <scope name="DL" ilk="namespace">
        <scope name="BasicTypes" ilk="namespace">
        </scope>
        <scope name="Win32Types" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="drb/acl" ilk="blob" lang="Ruby">
      <scope name="ACL" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(list=nil, order = DENY_ALLOW)" attributes="__classmethod__ __ctor__" doc="Creates a new ACL from +list+ with an evaluation +order+ of DENY_ALLOW or ALLOW_DENY. &#xA; An ACL +list+ is an Array of &quot;allow&quot; or &quot;deny&quot; and an address or address mask or &quot;all&quot; or &quot;*&quot; to match any address: &#xA; %w[&#xA;  deny all&#xA;  allow 192.0.2.2&#xA;  allow 192.0.2.128/26&#xA;]" />
        <scope name="allow_addr?" ilk="function" signature="allow_addr?(addr)" doc="Allow connections from addrinfo +addr+?  It must be formatted like Socket#peeraddr: &#xA; [&quot;AF_INET&quot;, 10, &quot;lc630&quot;, &quot;192.0.2.1&quot;]" />
        <scope name="allow_socket?" ilk="function" signature="allow_socket?(soc)" doc="Allow connections from Socket +soc+?" />
        <scope name="install_list" ilk="function" signature="install_list(list)" doc="Adds +list+ of ACL entries to this ACL." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="DENY_ALLOW" attributes="__const__" citdl="Object" />
        <variable name="ALLOW_DENY" attributes="__const__" citdl="Object" />
        <scope name="ACLEntry" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(str)" attributes="__classmethod__ __ctor__" doc="Creates a new entry using +str+. &#xA; +str+ may be &quot;*&quot; or &quot;all&quot; to match any address, an IP address string to match a specific address, an IP address mask per IPAddr, or one containing &quot;*&quot; to match part of an IPv4 address." />
          <scope name="match" ilk="function" signature="match(addr)" doc="Matches +addr+ against this entry." />
        </scope>
        <scope name="ACLList" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates an empty ACLList" />
          <scope name="add" ilk="function" signature="add(str)" doc="Adds +str+ as an ACLEntry in this list" />
          <scope name="match" ilk="function" signature="match(addr)" doc="Matches +addr+ against each ACLEntry in this list." />
        </scope>
      </scope>
    </scope>
    <scope name="drb/drb" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbArray" ilk="class" classrefs="Object">
          <scope name="_load" ilk="function" signature="_load(s)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(ary)" attributes="__classmethod__ __ctor__" />
          <scope name="_dump" ilk="function" signature="_dump(lv)" />
        </scope>
        <scope name="DRbBadScheme" ilk="class" classrefs="DRb::DRbError">
        </scope>
        <scope name="DRbBadURI" ilk="class" classrefs="DRb::DRbError">
        </scope>
        <scope name="DRbConn" ilk="class" classrefs="Object">
          <variable name="POOL_SIZE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="DRbConnError" ilk="class" classrefs="DRb::DRbError">
        </scope>
        <scope name="DRbError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="DRbIdConv" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbMessage" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbObject" ilk="class" classrefs="Object">
        </scope>
        <scope name="DRbProtocol" ilk="namespace">
          <scope name="add_protocol" ilk="function" signature="add_protocol(prot)" attributes="__classmethod__" doc="Add a new protocol to the DRbProtocol module." />
          <scope name="open" ilk="function" signature="open(uri, config, first=true)" attributes="__classmethod__" doc="Open a client connection to +uri+ with the configuration +config+. &#xA; The DRbProtocol module asks each registered protocol in turn to try to open the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised.  If a protocol accepts the URI, but an error occurs in opening it, a DRbConnError is raised." />
          <scope name="open_server" ilk="function" signature="open_server(uri, config, first=true)" attributes="__classmethod__" doc="Open a server listening for connections at +uri+ with configuration +config+. &#xA; The DRbProtocol module asks each registered protocol in turn to try to open a server at the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised.  If a protocol accepts the URI, but an error occurs in opening it, the underlying error is passed on to the caller." />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config, first=true)" attributes="__classmethod__" doc="Parse +uri+ into a [uri, option] pair. &#xA; The DRbProtocol module asks each registered protocol in turn to try to parse the URI.  Each protocol signals that it does not handle that URI by raising a DRbBadScheme error.  If no protocol recognises the URI, then a DRbBadURI error is raised." />
        </scope>
        <scope name="DRbRemoteError" ilk="class" classrefs="DRb::DRbError">
          <scope name="new" ilk="function" signature="new(error)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="reason" />
        </scope>
        <scope name="DRbServer" ilk="class" classrefs="Object">
          <scope name="default_acl" ilk="function" signature="default_acl(acl)" attributes="__classmethod__" doc="Set the default value for the :acl option. &#xA; See #new().  The initial default value is nil." />
          <scope name="default_argc_limit" ilk="function" signature="default_argc_limit(argc)" attributes="__classmethod__" doc="Set the default value for the :argc_limit option. &#xA; See #new().  The initial default value is 256." />
          <scope name="default_id_conv" ilk="function" signature="default_id_conv(idconv)" attributes="__classmethod__" doc="Set the default value for the :id_conv option. &#xA; See #new().  The initial default value is a DRbIdConv instance." />
          <scope name="default_load_limit" ilk="function" signature="default_load_limit(sz)" attributes="__classmethod__" doc="Set the default value for the :load_limit option. &#xA; See #new().  The initial default value is 25 MB." />
          <scope name="default_safe_level" ilk="function" signature="default_safe_level(level)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(uri=nil, front=nil, config_or_acl=nil)" attributes="__classmethod__ __ctor__" doc="Create a new DRbServer instance. &#xA; +uri+ is the URI to bind to.  This is normally of the form &apos;druby://&lt;hostname&gt;:&lt;port&gt;&apos; where &lt;hostname&gt; is a hostname of the local machine.  If nil, then the system&apos;s default hostname will be bound to, on a port selected by the system; these value can be retrieved from the +uri+ attribute.  &apos;druby:&apos; specifies the default dRuby transport protocol: another protocol, such as &apos;drbunix:&apos;, can be specified instead. &#xA; +front+ is the front object for the server, that is, the object to which remote method calls on the server will be passed.  If nil, then the server will not accept remote method calls. &#xA; If +config_or_acl+ is a hash, it is the configuration to use for this server.  The following options are recognised: &#xA; an id-to-object conversion object.  This defaults to an instance of the class DRb::DRbIdConv.&#xA;if true, all unsuccessful remote calls on objects in the server will be logged to $stdout. false by default.&#xA;the access control list for this server.  See the ACL class from the main dRuby distribution.&#xA;the maximum message size in bytes accepted by the server.  Defaults to 25 MB (26214400).&#xA;the maximum number of arguments to a remote method accepted by the server.  Defaults to 256. &#xA; The default values of these options can be modified on a class-wide basis by the class methods #default_argc_limit, #default_load_limit, #default_acl, #default_id_conv, and #verbose= &#xA; If +config_or_acl+ is not a hash, but is not nil, it is assumed to be the access control list for this server. See the :tcp_acl option for more details. &#xA; If no other server is currently set as the primary server, this will become the primary server. &#xA; The server will immediately start running in its own thread." />
          <scope name="verbose" ilk="function" signature="verbose()" attributes="__classmethod__" doc="Get the default value of the :verbose option." />
          <scope name="verbose=" ilk="function" signature="verbose=(on)" attributes="__classmethod__" doc="Set the default value of the :verbose option. &#xA; See #new().  The initial default value is false." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="Is this server alive?" />
          <scope name="check_insecure_method" ilk="function" signature="check_insecure_method(obj, msg_id)" doc="Check that a method is callable via dRuby. &#xA; +obj+ is the object we want to invoke the method on. +msg_id+ is the method name, as a Symbol. &#xA; If the method is an insecure method (see #insecure_method?) a SecurityError is thrown.  If the method is private or undefined, a NameError is thrown." />
          <scope name="here?" ilk="function" signature="here?(uri)" />
          <scope name="stop_service" ilk="function" signature="stop_service()" doc="Stop this server." />
          <scope name="to_id" ilk="function" signature="to_id(obj)" doc="Convert a local object to a dRuby reference." />
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" doc="Convert a dRuby reference to the local object it refers to." />
          <scope name="verbose" ilk="function" signature="verbose()" doc="Get whether the server is in verbose mode. &#xA; In verbose mode, failed calls are logged to stdout." />
          <scope name="verbose=" ilk="function" signature="verbose=(v)" doc="Set whether to operate in verbose mode. &#xA; In verbose mode, failed calls are logged to stdout." />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="front" />
          <scope ilk="function" name="safe_level" />
          <scope ilk="function" name="thread" />
          <scope ilk="function" name="uri" />
          <variable name="INSECURE_METHOD" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="DRbServerNotFound" ilk="class" classrefs="DRb::DRbError">
        </scope>
        <scope name="DRbTCPSocket" ilk="class" classrefs="Object">
          <scope name="getservername" ilk="function" signature="getservername()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(uri, soc, config={})" attributes="__classmethod__ __ctor__" doc="Create a new DRbTCPSocket instance. &#xA; +uri+ is the URI we are connected to. +soc+ is the tcp socket we are bound to.  +config+ is our configuration." />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" doc="Open a client connection to +uri+ using configuration +config+." />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" doc="Open a server listening for connections at +uri+ using configuration +config+." />
          <scope name="open_server_inaddr_any" ilk="function" signature="open_server_inaddr_any(host, port)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" doc="Parse +uri+ into a [uri, option] pair." />
          <scope name="accept" ilk="function" signature="accept()" doc="On the server side, for an instance returned by #open_server, accept a client connection and return a new instance to handle the server&apos;s side of this client-server session." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="Check to see if this connection is alive." />
          <scope name="close" ilk="function" signature="close()" doc="Close the connection. &#xA; If this is an instance returned by #open_server, then this stops listening for new connections altogether.  If this is an instance returned by #open or by #accept, then it closes this particular client-server session." />
          <scope name="peeraddr" ilk="function" signature="peeraddr()" doc="Get the address of our TCP peer (the other end of the socket we are bound to." />
          <scope name="recv_reply" ilk="function" signature="recv_reply()" doc="On the client side, receive a reply from the server." />
          <scope name="recv_request" ilk="function" signature="recv_request()" doc="On the server side, receive a request from the client." />
          <scope name="send_reply" ilk="function" signature="send_reply(succ, result)" doc="On the server side, send a reply to the client." />
          <scope name="send_request" ilk="function" signature="send_request(ref, msg_id, arg, b)" doc="On the client side, send a request to the server." />
          <scope name="stream" ilk="function" signature="stream()" doc="Get the socket." />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="DRbUndumped" ilk="namespace">
        </scope>
        <scope name="DRbUnknown" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(err, buf)" attributes="__classmethod__ __ctor__" doc="Create a new DRbUnknown object. &#xA; +buf+ is a string containing a marshalled object that could not be unmarshalled.  +err+ is the error message that was raised when the unmarshalling failed.  It is used to determine the name of the unmarshalled object." />
          <scope name="exception" ilk="function" signature="exception()" doc="Create a DRbUnknownError exception containing this object." />
          <scope name="reload" ilk="function" signature="reload()" doc="Attempt to load the wrapped marshalled object again. &#xA; If the class of the object is now known locally, the object will be unmarshalled and returned.  Otherwise, a new but identical DRbUnknown object will be returned." />
          <scope ilk="function" name="buf" />
          <scope ilk="function" name="name" />
        </scope>
        <scope name="DRbUnknownError" ilk="class" classrefs="DRb::DRbError">
          <scope name="new" ilk="function" signature="new(unknown)" attributes="__classmethod__ __ctor__" doc="Create a new DRbUnknownError for the DRb::DRbUnknown object +unknown+" />
          <scope ilk="function" name="unknown" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/extserv" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="ExtServ" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(there, name, server=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="alive?" ilk="function" signature="alive?()" />
          <scope name="front" ilk="function" signature="front()" />
          <scope name="stop_service" ilk="function" signature="stop_service()" />
          <scope ilk="function" name="server" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/extservm" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="ExtServManager" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="command" ilk="function" signature="command()" attributes="__classmethod__" />
          <scope name="command=" ilk="function" signature="command=(cmd)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="regist" ilk="function" signature="regist(name, ro)" />
          <scope name="service" ilk="function" signature="service(name)" />
          <scope name="unregist" ilk="function" signature="unregist(name)" />
          <scope ilk="function" name="uri" />
          <scope ilk="function" name="uri=" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/gw" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="GW" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="GWIdConv" ilk="class" classrefs="DRbIdConv">
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/invokemethod" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="config" ilk="function" signature="config()" attributes="__classmethod__" doc="Get the configuration of the current server. &#xA; If there is no current server, this returns the default configuration. See #current_server and DRbServer::make_config." />
        <scope name="current_server" ilk="function" signature="current_server()" attributes="__classmethod__" doc="Get the &apos;current&apos; server. &#xA; In the context of execution taking place within the main thread of a dRuby server (typically, as a result of a remote call on the server or one of its objects), the current server is that server.  Otherwise, the current server is the primary server. &#xA; If the above rule fails to find a server, a DRbServerNotFound error is raised." />
        <scope name="fetch_server" ilk="function" signature="fetch_server(uri)" attributes="__classmethod__" />
        <scope name="front" ilk="function" signature="front()" attributes="__classmethod__" doc="Get the front object of the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="here?" ilk="function" signature="here?(uri)" attributes="__classmethod__" doc="Is +uri+ the URI for the current local server?" />
        <scope name="install_acl" ilk="function" signature="install_acl(acl)" attributes="__classmethod__" doc="Set the default acl. &#xA; See DRb::DRbServer.default_acl." />
        <scope name="install_id_conv" ilk="function" signature="install_id_conv(idconv)" attributes="__classmethod__" doc="Set the default id conv object. &#xA; See DRbServer#default_id_conv." />
        <scope name="mutex" ilk="function" signature="mutex()" attributes="__classmethod__" />
        <scope name="regist_server" ilk="function" signature="regist_server(server)" attributes="__classmethod__" />
        <scope name="remove_server" ilk="function" signature="remove_server(server)" attributes="__classmethod__" />
        <scope name="start_service" ilk="function" signature="start_service(uri=nil, front=nil, config=nil)" attributes="__classmethod__" doc="Start a dRuby server locally. &#xA; The new dRuby server will become the primary server, even if another server is currently the primary server. &#xA; +uri+ is the URI for the server to bind to.  If nil, the server will bind to random port on the default local host name and use the default dRuby protocol. &#xA; +front+ is the server&apos;s front object.  This may be nil. &#xA; +config+ is the configuration for the new server.  This may be nil. &#xA; See DRbServer::new." />
        <scope name="stop_service" ilk="function" signature="stop_service()" attributes="__classmethod__" doc="Stop the local dRuby server. &#xA; This operates on the primary server.  If there is no primary server currently running, it is a noop." />
        <scope name="thread" ilk="function" signature="thread()" attributes="__classmethod__" doc="Get the thread of the primary server. &#xA; This returns nil if there is no primary server.  See #primary_server." />
        <scope name="to_id" ilk="function" signature="to_id(obj)" attributes="__classmethod__" doc="Get a reference id for an object using the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="to_obj" ilk="function" signature="to_obj(ref)" attributes="__classmethod__" doc="Convert a reference into an object using the current server. &#xA; This raises a DRbServerNotFound error if there is no current server. See #current_server." />
        <scope name="uri" ilk="function" signature="uri()" attributes="__classmethod__" doc="Get the URI defining the local dRuby space. &#xA; This is the URI of the current server.  See #current_server." />
        <scope ilk="function" name="primary_server" />
        <scope ilk="function" name="primary_server=" />
        <scope ilk="function" name="primary_server" />
        <scope ilk="function" name="primary_server=" />
        <scope name="DRbServer" ilk="namespace">
          <scope name="InvokeMethod18Mixin" ilk="namespace">
            <scope name="block_yield" ilk="function" signature="block_yield(x)" />
            <scope name="perform_with_block" ilk="function" signature="perform_with_block()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/observer" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbObservable" ilk="namespace">
          <import symbol="Observable" />
          <scope name="notify_observers" ilk="function" signature="notify_observers(*arg)" />
        </scope>
      </scope>
    </scope>
    <scope name="drb/ssl" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbSSLSocket" ilk="class" classrefs="DRbTCPSocket">
          <scope name="new" ilk="function" signature="new(uri, soc, config, is_established)" attributes="__classmethod__ __ctor__" />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" />
          <scope name="parse_uri" ilk="function" signature="parse_uri(uri)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" />
          <scope name="accept" ilk="function" signature="accept()" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="stream" ilk="function" signature="stream()" />
          <scope name="SSLConfig" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" />
            <scope name="accept" ilk="function" signature="accept(tcp)" />
            <scope name="connect" ilk="function" signature="connect(tcp)" />
            <scope name="setup_certificate" ilk="function" signature="setup_certificate()" />
            <scope name="setup_ssl_context" ilk="function" signature="setup_ssl_context()" />
            <variable name="DEFAULT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/timeridconv" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="TimerIdConv" ilk="class" classrefs="DRbIdConv">
          <scope name="new" ilk="function" signature="new(timeout=600)" attributes="__classmethod__ __ctor__" />
          <scope name="to_id" ilk="function" signature="to_id(obj)" />
          <scope name="to_obj" ilk="function" signature="to_obj(ref)" />
          <scope name="TimerHolder2" ilk="class" classrefs="Object">
            <import symbol="MonitorMixin" />
            <scope name="new" ilk="function" signature="new(timeout=600)" attributes="__classmethod__ __ctor__" />
            <scope name="add" ilk="function" signature="add(obj)" />
            <scope name="fetch" ilk="function" signature="fetch(key, dv=@sentinel)" />
            <scope name="include?" ilk="function" signature="include?(key)" />
            <scope name="peek" ilk="function" signature="peek(key)" />
            <scope name="InvalidIndexError" ilk="class" classrefs="RuntimeError">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="drb/unix" ilk="blob" lang="Ruby">
      <scope name="DRb" ilk="namespace">
        <scope name="DRbUNIXSocket" ilk="class" classrefs="DRbTCPSocket">
          <scope name="new" ilk="function" signature="new(uri, soc, config={}, server_mode = false)" attributes="__classmethod__ __ctor__" />
          <scope name="open" ilk="function" signature="open(uri, config)" attributes="__classmethod__" />
          <scope name="open_server" ilk="function" signature="open_server(uri, config)" attributes="__classmethod__" />
          <scope name="parse_uri" ilk="function" signature="parse_uri(uri)" attributes="__classmethod__" />
          <scope name="uri_option" ilk="function" signature="uri_option(uri, config)" attributes="__classmethod__" />
          <scope name="accept" ilk="function" signature="accept()" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="set_sockopt" ilk="function" signature="set_sockopt(soc)" />
        </scope>
      </scope>
    </scope>
    <scope name="e2mmap" ilk="blob" lang="Ruby">
      <scope name="Exception2MessageMapper" ilk="namespace">
        <scope name="Fail" ilk="function" signature="Fail(klass = E2MM, err = nil, *rest)" attributes="__classmethod__" />
        <scope name="Raise" ilk="function" signature="Raise(klass = E2MM, err = nil, *rest)" attributes="__classmethod__" doc="Fail(klass, err, *rest) klass:  class to define exception under.&#xA;err:    exception&#xA;rest:   message arguments" />
        <scope name="def_e2message" ilk="function" signature="def_e2message(k, c, m)" attributes="__classmethod__" doc="E2MM.def_e2message(k, e, m)     k:  class to define exception under.&#xA;    e:  exception&#xA;    m:  message_form&#xA;define exception c with message m." />
        <scope name="def_exception" ilk="function" signature="def_exception(k, n, m, s = StandardError)" attributes="__classmethod__" doc="E2MM.def_exception(k, n, m, s)     k:  class to define exception under.&#xA;    n:  exception_name&#xA;    m:  message_form&#xA;    s:  superclass(default: StandardError)&#xA;define exception named ``c&apos;&apos; with message m." />
        <scope name="e2mm_message" ilk="function" signature="e2mm_message(klass, exp)" attributes="__classmethod__" />
        <scope name="extend_object" ilk="function" signature="extend_object(cl)" attributes="__classmethod__" />
        <scope name="message" ilk="function" signature="message(klass, exp)" attributes="__classmethod__" />
        <scope name="Fail" ilk="function" signature="Fail(err = nil, *rest)" />
        <scope name="Raise" ilk="function" signature="Raise(err = nil, *rest)" doc="Fail(err, *rest) err:    exception&#xA;rest:   message arguments" />
        <scope name="bind" ilk="function" signature="bind(cl)" />
        <scope name="def_e2message" ilk="function" signature="def_e2message(c, m)" doc="def_e2message(c, m)     c:  exception&#xA;    m:  message_form&#xA;define exception c with message m." />
        <scope name="def_exception" ilk="function" signature="def_exception(n, m, s = StandardError)" doc="def_exception(n, m, s)     n:  exception_name&#xA;    m:  message_form&#xA;    s:  superclass(default: StandardError)&#xA;define exception named ``c&apos;&apos; with message m." />
        <scope name="fail" ilk="function" signature="fail(err = nil, *rest)" />
        <scope name="E2MM" ilk="namespace">
          <scope name="Fail" ilk="function" signature="Fail(klass = E2MM, err = nil, *rest)" attributes="__classmethod__" />
          <scope name="Raise" ilk="function" signature="Raise(klass = E2MM, err = nil, *rest)" attributes="__classmethod__" doc="Fail(klass, err, *rest) klass:  class to define exception under.&#xA;err:    exception&#xA;rest:   message arguments" />
          <scope name="def_e2message" ilk="function" signature="def_e2message(k, c, m)" attributes="__classmethod__" doc="E2MM.def_e2message(k, e, m)     k:  class to define exception under.&#xA;    e:  exception&#xA;    m:  message_form&#xA;define exception c with message m." />
          <scope name="def_exception" ilk="function" signature="def_exception(k, n, m, s = StandardError)" attributes="__classmethod__" doc="E2MM.def_exception(k, n, m, s)     k:  class to define exception under.&#xA;    n:  exception_name&#xA;    m:  message_form&#xA;    s:  superclass(default: StandardError)&#xA;define exception named ``c&apos;&apos; with message m." />
          <scope name="e2mm_message" ilk="function" signature="e2mm_message(klass, exp)" attributes="__classmethod__" />
          <scope name="extend_object" ilk="function" signature="extend_object(cl)" attributes="__classmethod__" />
          <scope name="message" ilk="function" signature="message(klass, exp)" attributes="__classmethod__" />
          <scope name="Fail" ilk="function" signature="Fail(err = nil, *rest)" />
          <scope name="Raise" ilk="function" signature="Raise(err = nil, *rest)" doc="Fail(err, *rest) err:    exception&#xA;rest:   message arguments" />
          <scope name="bind" ilk="function" signature="bind(cl)" />
          <scope name="def_e2message" ilk="function" signature="def_e2message(c, m)" doc="def_e2message(c, m)     c:  exception&#xA;    m:  message_form&#xA;define exception c with message m." />
          <scope name="def_exception" ilk="function" signature="def_exception(n, m, s = StandardError)" doc="def_exception(n, m, s)     n:  exception_name&#xA;    m:  message_form&#xA;    s:  superclass(default: StandardError)&#xA;define exception named ``c&apos;&apos; with message m." />
          <scope name="fail" ilk="function" signature="fail(err = nil, *rest)" />
        </scope>
      </scope>
    </scope>
    <scope name="erb" ilk="blob" lang="Ruby">
      <scope name="ERB" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(str, safe_level=nil, trim_mode=nil, eoutvar=&apos;_erbout&apos;)" attributes="__classmethod__ __ctor__" doc="Constructs a new ERB object with the template specified in _str_. &#xA; An ERB object works by building a chunk of Ruby code that will output the completed template when run. If _safe_level_ is set to a non-nil value, ERB code will be run in a separate thread with &lt;b&gt;$SAFE&lt;/b&gt; set to the provided level. &#xA; If _trim_mode_ is passed a String containing one or more of the following modifiers, ERB will adjust its code generation as listed: &#xA; %  enables Ruby code processing for lines beginning with %&#xA;&lt;&gt; omit newline for lines starting with &lt;% and ending in %&gt;&#xA;&gt;  omit newline for lines ending in %&gt;&#xA; _eoutvar_ can be used to set the name of the variable ERB will build up its output in.  This is useful when you need to run multiple ERB templates through the same binding and/or when you want to control where output ends up.  Pass the name of the variable to be used inside a String. &#xA; Example &#xA; require &quot;erb&quot;&#xA;# build data class&#xA;class Listings&#xA;  PRODUCT = { :name =&gt; &quot;Chicken Fried Steak&quot;,&#xA;              :desc =&gt; &quot;A well messages pattie, breaded and fried.&quot;," />
        <scope name="version" ilk="function" signature="version()" attributes="__classmethod__" doc="Returns revision information for the erb.rb module." />
        <scope name="def_class" ilk="function" signature="def_class(superklass=Object, methodname=&apos;result&apos;)" doc="Define unnamed class which has _methodname_ as instance method, and return it. &#xA; example: class MyClass_&#xA;  def initialize(arg1, arg2)&#xA;    @arg1 = arg1;  @arg2 = arg2&#xA;  end&#xA;end&#xA;filename = &apos;example.rhtml&apos;  # @arg1 and @arg2 are used in example.rhtml&#xA;erb = ERB.new(File.read(filename))&#xA;erb.filename = filename&#xA;MyClass = erb.def_class(MyClass_, &apos;render()&apos;)&#xA;print MyClass.new(&apos;foo&apos;, 123).render()" />
        <scope name="def_method" ilk="function" signature="def_method(mod, methodname, fname=&apos;(ERB)&apos;)" doc="Define _methodname_ as instance method of _mod_ from compiled ruby source. &#xA; example: filename = &apos;example.rhtml&apos;   # &apos;arg1&apos; and &apos;arg2&apos; are used in example.rhtml&#xA;erb = ERB.new(File.read(filename))&#xA;erb.def_method(MyClass, &apos;render(arg1, arg2)&apos;, filename)&#xA;print MyClass.new.render(&apos;foo&apos;, 123)" />
        <scope name="def_module" ilk="function" signature="def_module(methodname=&apos;erb&apos;)" doc="Create unnamed module, define _methodname_ as instance method of it, and return it. &#xA; example: filename = &apos;example.rhtml&apos;   # &apos;arg1&apos; and &apos;arg2&apos; are used in example.rhtml&#xA;erb = ERB.new(File.read(filename))&#xA;erb.filename = filename&#xA;MyModule = erb.def_module(&apos;render(arg1, arg2)&apos;)&#xA;class MyClass&#xA;  include MyModule&#xA;end" />
        <scope name="result" ilk="function" signature="result(b=TOPLEVEL_BINDING)" doc="Executes the generated ERB code to produce a completed template, returning the results of that code.  (See ERB#new for details on how this process can be affected by _safe_level_.) &#xA; _b_ accepts a Binding or Proc object which is used to set the context of code evaluation." />
        <scope name="run" ilk="function" signature="run(b=TOPLEVEL_BINDING)" doc="Generate results and print them. (see ERB#result)" />
        <scope name="set_eoutvar" ilk="function" signature="set_eoutvar(compiler, eoutvar = &apos;_erbout&apos;)" doc="Can be used to set _eoutvar_ as described in ERB#new.  It&apos;s probably easier to just use the constructor though, since calling this method requires the setup of an ERB _compiler_ object." />
        <scope ilk="function" name="filename" />
        <scope ilk="function" name="filename=" />
        <scope ilk="function" name="src" />
        <scope name="DefMethod" ilk="namespace">
          <scope name="def_erb_method" ilk="function" signature="def_erb_method(methodname, erb_or_fname)" attributes="__classmethod__" doc="define _methodname_ as instance method of current module, using ERB object or eRuby file" />
        </scope>
        <scope name="Util" ilk="namespace">
          <scope name="h" ilk="function" signature="h(s)" attributes="__classmethod__" />
          <scope name="html_escape" ilk="function" signature="html_escape(s)" attributes="__classmethod__" doc="A utility method for escaping HTML tag characters in _s_. &#xA; require &quot;erb&quot;&#xA;include ERB::Util&#xA;&#xA;puts html_escape(&quot;is a &gt; 0 &amp; a &lt; 10?&quot;)&#xA; _Generates_ &#xA; is a &amp;gt; 0 &amp;amp; a &amp;lt; 10?" />
          <scope name="u" ilk="function" signature="u(s)" attributes="__classmethod__" />
          <scope name="url_encode" ilk="function" signature="url_encode(s)" attributes="__classmethod__" doc="A utility method for encoding the String _s_ as a URL. &#xA; require &quot;erb&quot;&#xA;include ERB::Util&#xA;&#xA;puts url_encode(&quot;Programming Ruby:  The Pragmatic Programmer&apos;s Guide&quot;)&#xA; _Generates_ &#xA; Programming%20Ruby%3A%20%20The%20Pragmatic%20Programmer%27s%20Guide" />
        </scope>
      </scope>
    </scope>
    <scope name="etc" ilk="blob" lang="Ruby">
      <scope name="Etc" ilk="namespace">
        <scope name="endgrent" ilk="function" signature="endgrent()" attributes="__classmethod__" doc="Ends the process of scanning through the /etc/group file begun by getgrent, and closes the file." />
        <scope name="endpwent" ilk="function" signature="endpwent()" attributes="__classmethod__" doc="Ends the process of scanning through the /etc/passwd file begun with getpwent, and closes the file." />
        <scope name="getgrent" ilk="function" signature="getgrent()" attributes="__classmethod__" doc="Returns an entry from the /etc/group file. The first time it is called it opens the file and returns the first entry; each successive call returns the next entry, or nil if the end of the file has been reached. &#xA; To close the file when processing is complete, call endgrent. &#xA; Each entry is returned as a Struct::Group: &#xA; Group#name contains the name of the group as a String. &#xA;&#xA;Group#passwd contains the encrypted password as a String. An &apos;x&apos; is returned if password access to the group is not available; an empty string is returned if no password is needed to obtain membership of the group. &#xA;&#xA;Group#gid contains the group&apos;s numeric ID as an integer. &#xA;&#xA;Group#mem is an Array of Strings containing the short login names of the members of the group." />
        <scope name="getgrgid" ilk="function" signature="getgrgid(p1 = v1)" attributes="__classmethod__" doc="Returns information about the group with specified integer group id (gid), as found in /etc/group. &#xA; The information is returned as a Struct::Group; see getgrent above for details. &#xA; e.g.  Etc.getgrgid(100) -&gt; #&lt;struct Struct::Group name=&quot;users&quot;, passwd=&quot;x&quot;, gid=100, mem=[&quot;meta&quot;, &quot;root&quot;]&gt;" />
        <scope name="getgrnam" ilk="function" signature="getgrnam(p1)" attributes="__classmethod__" doc="Returns information about the group with specified String name, as found in /etc/group. &#xA; The information is returned as a Struct::Group; see getgrent above for details. &#xA; e.g.  Etc.getgrnam(&apos;users&apos;) -&gt; #&lt;struct Struct::Group name=&quot;users&quot;, passwd=&quot;x&quot;, gid=100, mem=[&quot;meta&quot;, &quot;root&quot;]&gt;" />
        <scope name="getlogin" ilk="function" signature="getlogin()" attributes="__classmethod__" doc="Returns the short user name of the currently logged in user. Unfortunately, it is often rather easy to fool getlogin(). Avoid getlogin() for security-related purposes. &#xA; e.g. Etc.getlogin -&gt; &apos;guest&apos;" />
        <scope name="getpwent" ilk="function" signature="getpwent()" attributes="__classmethod__" doc="Returns an entry from the /etc/passwd file. The first time it is called it opens the file and returns the first entry; each successive call returns the next entry, or nil if the end of the file has been reached. &#xA; To close the file when processing is complete, call endpwent. &#xA; Each entry is returned as a Struct::Passwd: &#xA; Passwd#name contains the short login name of the user as a String. &#xA;&#xA;Passwd#passwd contains the encrypted password of the user as a String. an &apos;x&apos; is returned if shadow passwords are in use. An &apos;*&apos; is returned if the user cannot log in using a password. &#xA;&#xA;Passwd#uid contains the integer user ID (uid) of the user. &#xA;&#xA;Passwd#gid contains the integer group ID (gid) of the user&apos;s primary group. &#xA;&#xA;Passwd#gecos contains a longer String description of the user, such as a full name. Some Unix systems provide structured information in the gecos field, but this is system-dependent. &#xA;&#xA;Passwd#dir contains the path to the home directory of the user as a String. &#xA;&#xA;Passwd#shell contains the path to the login shell of the user as a String." />
        <scope name="getpwnam" ilk="function" signature="getpwnam(p1)" attributes="__classmethod__" doc="Returns the /etc/passwd information for the user with specified login name. &#xA; The information is returned as a Struct::Passwd; see getpwent above for details. &#xA; e.g.  * Etc.getpwnam(&apos;root&apos;) -&gt; #&lt;struct Struct::Passwd name=&quot;root&quot;, passwd=&quot;x&quot;, uid=0, gid=0, gecos=&quot;root&quot;,dir=&quot;/root&quot;, shell=&quot;/bin/bash&quot;&gt;" />
        <scope name="getpwuid" ilk="function" signature="getpwuid(p1 = v1)" attributes="__classmethod__" doc="Returns the /etc/passwd information for the user with specified integer user id (uid). &#xA; The information is returned as a Struct::Passwd; see getpwent above for details. &#xA; e.g.  * Etc.getpwuid(0) -&gt; #&lt;struct Struct::Passwd name=&quot;root&quot;, passwd=&quot;x&quot;, uid=0, gid=0, gecos=&quot;root&quot;,dir=&quot;/root&quot;, shell=&quot;/bin/bash&quot;&gt;" />
        <scope name="group" ilk="function" signature="group()" attributes="__classmethod__" doc="Provides a convenient Ruby iterator which executes a block for each entry in the /etc/group file. &#xA; The code block is passed an Struct::Group struct; see getgrent above for details. &#xA; Example: &#xA; require &apos;etc&apos;&#xA;&#xA;Etc.group {|g|&#xA;  puts g.name + &quot;: &quot; + g.mem.join(&apos;, &apos;)&#xA;}" />
        <scope name="passwd" ilk="function" signature="passwd()" attributes="__classmethod__" doc="Provides a convenient Ruby iterator which executes a block for each entry in the /etc/passwd file. &#xA; The code block is passed an Struct::Passwd struct; see getpwent above for details. &#xA; Example: &#xA; require &apos;etc&apos;&#xA;&#xA;Etc.passwd {|u|&#xA;  puts u.name + &quot; = &quot; + u.gecos&#xA;}" />
        <scope name="setgrent" ilk="function" signature="setgrent()" attributes="__classmethod__" doc="Resets the process of reading the /etc/group file, so that the next call to getgrent will return the first entry again." />
        <scope name="setpwent" ilk="function" signature="setpwent()" attributes="__classmethod__" doc="Resets the process of reading the /etc/passwd file, so that the next call to getpwent will return the first entry again." />
        <scope name="sysconfdir" ilk="function" signature="sysconfdir()" attributes="__classmethod__" doc="Returns system configuration directory." />
        <scope name="systmpdir" ilk="function" signature="systmpdir()" attributes="__classmethod__" doc="Returns system temporary directory." />
      </scope>
    </scope>
    <scope name="fcntl" ilk="blob" lang="Ruby">
      <scope name="Fcntl" ilk="namespace">
        <variable name="F_DUPFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETLK" attributes="__const__" citdl="Object" />
        <variable name="F_SETFD" attributes="__const__" citdl="Object" />
        <variable name="F_GETFL" attributes="__const__" citdl="Object" />
        <variable name="F_SETFL" attributes="__const__" citdl="Object" />
        <variable name="F_SETLK" attributes="__const__" citdl="Object" />
        <variable name="F_SETLKW" attributes="__const__" citdl="Object" />
        <variable name="FD_CLOEXEC" attributes="__const__" citdl="Object" />
        <variable name="F_RDLCK" attributes="__const__" citdl="Object" />
        <variable name="F_UNLCK" attributes="__const__" citdl="Object" />
        <variable name="F_WRLCK" attributes="__const__" citdl="Object" />
        <variable name="O_CREAT" attributes="__const__" citdl="Object" />
        <variable name="O_EXCL" attributes="__const__" citdl="Object" />
        <variable name="O_NOCTTY" attributes="__const__" citdl="Object" />
        <variable name="O_TRUNC" attributes="__const__" citdl="Object" />
        <variable name="O_APPEND" attributes="__const__" citdl="Object" />
        <variable name="O_NONBLOCK" attributes="__const__" citdl="Object" />
        <variable name="O_NDELAY" attributes="__const__" citdl="Object" />
        <variable name="O_RDONLY" attributes="__const__" citdl="Object" />
        <variable name="O_RDWR" attributes="__const__" citdl="Object" />
        <variable name="O_WRONLY" attributes="__const__" citdl="Object" />
        <variable name="O_ACCMODE" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="fiddle" ilk="blob" lang="Ruby">
      <scope name="Fiddle" ilk="namespace">
        <scope name="last_error" ilk="function" signature="last_error()" attributes="__classmethod__" doc="Returns the last +Error+ of the current executing +Thread+ or nil if none" />
        <scope name="last_error=" ilk="function" signature="last_error=(error)" attributes="__classmethod__" doc="Sets the last +Error+ of the current executing +Thread+ to +error+" />
        <scope name="win32_last_error" ilk="function" signature="win32_last_error()" attributes="__classmethod__" doc="Returns the last win32 +Error+ of the current executing +Thread+ or nil if none" />
        <scope name="win32_last_error=" ilk="function" signature="win32_last_error=(error)" attributes="__classmethod__" doc="Sets the last win32 +Error+ of the current executing +Thread+ to +error+" />
        <variable name="TYPE_VOID" attributes="__const__" citdl="Object" />
        <variable name="TYPE_VOIDP" attributes="__const__" citdl="Object" />
        <variable name="TYPE_CHAR" attributes="__const__" citdl="Object" />
        <variable name="TYPE_SHORT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_INT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_LONG" attributes="__const__" citdl="Object" />
        <variable name="TYPE_LONG_LONG" attributes="__const__" citdl="Object" />
        <variable name="TYPE_FLOAT" attributes="__const__" citdl="Object" />
        <variable name="TYPE_DOUBLE" attributes="__const__" citdl="Object" />
        <variable name="WINDOWS" attributes="__const__" citdl="Object" />
        <scope name="Closure" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Construct a new Closure object. &#xA; +ret+ is the C type to be returned&#xA;+args+ are passed the callback&#xA;+abi+ is the abi of the closure &#xA; If there is an error in preparing the ffi_cif or ffi_prep_closure, then a RuntimeError will be raised." />
          <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the memory address for this closure" />
          <scope ilk="function" name="args" />
          <scope ilk="function" name="ctype" />
        </scope>
        <scope name="Function" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="Constructs a Function object. +ptr+ is a referenced function, of a DL::Handle&#xA;+args+ is an Array of arguments, passed to the +ptr+ function&#xA;+ret_type+ is the return type of the function&#xA;+abi+ is the ABI of the function" />
          <scope name="call" ilk="function" signature="call(*args)" doc="Calls the constructed Function, with +args+ &#xA; For an example see Fiddle::Function" />
          <scope ilk="function" name="abi" />
          <variable name="DEFAULT" attributes="__const__" citdl="Object" />
          <variable name="STDCALL" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="fiddle/closure" ilk="blob" lang="Ruby">
      <scope name="Fiddle" ilk="namespace">
        <scope name="Closure" ilk="namespace">
          <scope name="BlockCaller" ilk="class" classrefs="Fiddle::Closure">
            <scope name="new" ilk="function" signature="new(ctype, args, abi = Fiddle::Function::DEFAULT, &amp;block)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Construct a new BlockCaller object. &#xA; +ctype+ is the C type to be returned&#xA;+args+ are passed the callback&#xA;+abi+ is the abi of the closure &#xA; If there is an error in preparing the +ffi_cif+ or +ffi_prep_closure+, then a RuntimeError will be raised. &#xA; Example &#xA; include Fiddle&#xA;&#xA;cb = Closure::BlockCaller.new(TYPE_INT, [TYPE_INT]) do |one|&#xA;  one&#xA;end&#xA;&#xA;func = Function.new(cb, [TYPE_INT], TYPE_INT)" />
            <scope name="call" ilk="function" signature="call(*args)" doc="Calls the constructed BlockCaller, with +args+ &#xA; For an example see Fiddle::Closure::BlockCaller.new" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="fileutils" ilk="blob" lang="Ruby">
      <scope name="FileUtils" ilk="namespace">
        <import symbol="StreamUtils_" />
        <scope name="cd" ilk="function" signature="cd(dir, options = {})" attributes="__classmethod__" doc="Options: verbose &#xA; Changes the current directory to the directory +dir+. &#xA; If this method is called with block, resumes to the old working directory after the block execution finished. &#xA; FileUtils.cd(&apos;/&apos;, :verbose =&gt; true)   # chdir and report it&#xA;&#xA;FileUtils.cd(&apos;/&apos;) do  # chdir&#xA;  [...]               # do something&#xA;end                   # return to original directory" />
        <scope name="chdir" ilk="function" signature="chdir(dir, options = {})" attributes="__classmethod__" />
        <scope name="chmod" ilk="function" signature="chmod(mode, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Changes permission bits on the named files (in +list+) to the bit pattern represented by +mode+. &#xA; +mode+ is the symbolic and absolute mode can be used. &#xA; Absolute mode is FileUtils.chmod 0755, &apos;somecommand&apos;&#xA;FileUtils.chmod 0644, %w(my.rb your.rb his.rb her.rb)&#xA;FileUtils.chmod 0755, &apos;/usr/bin/ruby&apos;, :verbose =&gt; true&#xA; Symbolic mode is FileUtils.chmod &quot;u=wrx,go=rx&quot;, &apos;somecommand&apos;&#xA;FileUtils.chmod &quot;u=wr,go=rr&quot;, %w(my.rb your.rb his.rb her.rb)&#xA;FileUtils.chmod &quot;u=wrx,go=rx&quot;, &apos;/usr/bin/ruby&apos;, :verbose =&gt; true&#xA;&quot;a&quot; is user, group, other mask.&#xA;&quot;u&quot; is user&apos;s mask.&#xA;&quot;g&quot; is group&apos;s mask.&#xA;&quot;o&quot; is other&apos;s mask." />
        <scope name="chmod_R" ilk="function" signature="chmod_R(mode, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose force &#xA; Changes permission bits on the named files (in +list+) to the bit pattern represented by +mode+. &#xA; FileUtils.chmod_R 0700, &quot;/tmp/app.#{$$}&quot;&#xA;FileUtils.chmod_R &quot;u=wrx&quot;, &quot;/tmp/app.#{$$}&quot;" />
        <scope name="chown" ilk="function" signature="chown(user, group, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Changes owner and group on the named files (in +list+) to the user +user+ and the group +group+.  +user+ and +group+ may be an ID (Integer/String) or a name (String). If +user+ or +group+ is nil, this method does not change the attribute. &#xA; FileUtils.chown &apos;root&apos;, &apos;staff&apos;, &apos;/usr/local/bin/ruby&apos;&#xA;FileUtils.chown nil, &apos;bin&apos;, Dir.glob(&apos;/usr/bin/*&apos;), :verbose =&gt; true" />
        <scope name="chown_R" ilk="function" signature="chown_R(user, group, list, options = {})" attributes="__classmethod__" doc="Options: noop verbose force &#xA; Changes owner and group on the named files (in +list+) to the user +user+ and the group +group+ recursively. +user+ and +group+ may be an ID (Integer/String) or a name (String).  If +user+ or +group+ is nil, this method does not change the attribute. &#xA; FileUtils.chown_R &apos;www&apos;, &apos;www&apos;, &apos;/var/www/htdocs&apos;&#xA;FileUtils.chown_R &apos;cvs&apos;, &apos;cvs&apos;, &apos;/var/cvs&apos;, :verbose =&gt; true" />
        <scope name="cmp" ilk="function" signature="cmp(a, b)" attributes="__classmethod__" />
        <scope name="compare_file" ilk="function" signature="compare_file(a, b)" attributes="__classmethod__" doc="Returns true if the contents of a file A and a file B are identical. &#xA; FileUtils.compare_file(&apos;somefile&apos;, &apos;somefile&apos;)  =&gt; true&#xA;FileUtils.compare_file(&apos;/bin/cp&apos;, &apos;/bin/mv&apos;)    =&gt; maybe false" />
        <scope name="compare_stream" ilk="function" signature="compare_stream(a, b)" attributes="__classmethod__" doc="Returns true if the contents of a stream +a+ and +b+ are identical." />
        <scope name="copy" ilk="function" signature="copy(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="copy_entry" ilk="function" signature="copy_entry(src, dest, preserve = false, dereference_root = false, remove_destination = false)" attributes="__classmethod__" doc="Copies a file system entry +src+ to +dest+. If +src+ is a directory, this method copies its contents recursively. This method preserves file types, c.f. symlink, directory... (FIFO, device files and etc. are not supported yet) &#xA; Both of +src+ and +dest+ must be a path name. +src+ must exist, +dest+ must not exist. &#xA; If +preserve+ is true, this method preserves owner, group, permissions and modified time. &#xA; If +dereference_root+ is true, this method dereference tree root. &#xA; If +remove_destination+ is true, this method removes each destination file before copy." />
        <scope name="copy_file" ilk="function" signature="copy_file(src, dest, preserve = false, dereference = true)" attributes="__classmethod__" doc="Copies file contents of +src+ to +dest+. Both of +src+ and +dest+ must be a path name." />
        <scope name="copy_stream" ilk="function" signature="copy_stream(src, dest)" attributes="__classmethod__" doc="Copies stream +src+ to +dest+. +src+ must respond to #read(n) and +dest+ must respond to #write(str)." />
        <scope name="cp" ilk="function" signature="cp(src, dest, options = {})" attributes="__classmethod__" doc="Options: preserve noop verbose &#xA; Copies a file content +src+ to +dest+.  If +dest+ is a directory, copies +src+ to +dest/src+. &#xA; If +src+ is a list of files, then +dest+ must be a directory. &#xA; FileUtils.cp &apos;eval.c&apos;, &apos;eval.c.org&apos;&#xA;FileUtils.cp %w(cgi.rb complex.rb date.rb), &apos;/usr/lib/ruby/1.6&apos;&#xA;FileUtils.cp %w(cgi.rb complex.rb date.rb), &apos;/usr/lib/ruby/1.6&apos;, :verbose =&gt; true&#xA;FileUtils.cp &apos;symlink&apos;, &apos;dest&apos;   # copy content, &quot;dest&quot; is not a symlink" />
        <scope name="cp_r" ilk="function" signature="cp_r(src, dest, options = {})" attributes="__classmethod__" doc="Options: preserve noop verbose dereference_root remove_destination &#xA; Copies +src+ to +dest+. If +src+ is a directory, this method copies all its contents recursively. If +dest+ is a directory, copies +src+ to +dest/src+. &#xA; +src+ can be a list of files. &#xA; # Installing ruby library &quot;mylib&quot; under the site_ruby&#xA;FileUtils.rm_r site_ruby + &apos;/mylib&apos;, :force&#xA;FileUtils.cp_r &apos;lib/&apos;, site_ruby + &apos;/mylib&apos;&#xA;# Examples of copying several files to target directory.&#xA;FileUtils.cp_r %w(mail.rb field.rb debug/), site_ruby + &apos;/tmail&apos;&#xA;FileUtils.cp_r Dir.glob(&apos;*.rb&apos;), &apos;/home/aamine/lib/ruby&apos;, :noop =&gt; true, :verbose =&gt; true&#xA;# If you want to copy all contents of a directory instead of the&#xA;# directory itself, c.f. src/x -&gt; dest/x, src/y -&gt; dest/y,&#xA;# use following code.&#xA;FileUtils.cp_r &apos;src/.&apos;, &apos;dest&apos;     # cp_r(&apos;src&apos;, &apos;dest&apos;) makes src/dest," />
        <scope name="getwd" ilk="function" signature="getwd()" attributes="__classmethod__" />
        <scope name="identical?" ilk="function" signature="identical?(a, b)" attributes="__classmethod__" />
        <scope name="install" ilk="function" signature="install(src, dest, options = {})" attributes="__classmethod__" doc="Options: mode preserve noop verbose &#xA; If +src+ is not same as +dest+, copies it and changes the permission mode to +mode+.  If +dest+ is a directory, destination is +dest+/+src+. This method removes destination before copy. &#xA; FileUtils.install &apos;ruby&apos;, &apos;/usr/local/bin/ruby&apos;, :mode =&gt; 0755, :verbose =&gt; true&#xA;FileUtils.install &apos;lib.rb&apos;, &apos;/usr/local/lib/ruby/site_ruby&apos;, :verbose =&gt; true" />
        <scope name="link" ilk="function" signature="link(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="ln" ilk="function" signature="ln(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; &lt;b&gt;ln(old, new, options = {})&lt;/b&gt; &#xA; Creates a hard link +new+ which points to +old+. If +new+ already exists and it is a directory, creates a link +new/old+. If +new+ already exists and it is not a directory, raises Errno::EEXIST. But if :force option is set, overwrite +new+. &#xA; FileUtils.ln &apos;gcc&apos;, &apos;cc&apos;, :verbose =&gt; true&#xA;FileUtils.ln &apos;/usr/bin/emacs21&apos;, &apos;/usr/bin/emacs&apos;&#xA; &lt;b&gt;ln(list, destdir, options = {})&lt;/b&gt; &#xA; Creates several hard links in a directory, with each one pointing to the item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA; include FileUtils&#xA;cd &apos;/sbin&apos;&#xA;FileUtils.ln %w(cp mv mkdir), &apos;/bin&apos;   # Now /sbin/cp and /bin/cp are linked." />
        <scope name="ln_s" ilk="function" signature="ln_s(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; &lt;b&gt;ln_s(old, new, options = {})&lt;/b&gt; &#xA; Creates a symbolic link +new+ which points to +old+.  If +new+ already exists and it is a directory, creates a symbolic link +new/old+.  If +new+ already exists and it is not a directory, raises Errno::EEXIST.  But if :force option is set, overwrite +new+. &#xA; FileUtils.ln_s &apos;/usr/bin/ruby&apos;, &apos;/usr/local/bin/ruby&apos;&#xA;FileUtils.ln_s &apos;verylongsourcefilename.c&apos;, &apos;c&apos;, :force =&gt; true&#xA; &lt;b&gt;ln_s(list, destdir, options = {})&lt;/b&gt; &#xA; Creates several symbolic links in a directory, with each one pointing to the item in +list+.  If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA; If +destdir+ is not a directory, raises Errno::ENOTDIR. &#xA; FileUtils.ln_s Dir.glob(&apos;bin/*.rb&apos;), &apos;/home/aamine/bin&apos;" />
        <scope name="ln_sf" ilk="function" signature="ln_sf(src, dest, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Same as #ln_s(src, dest, :force)" />
        <scope name="makedirs" ilk="function" signature="makedirs(list, options = {})" attributes="__classmethod__" />
        <scope name="mkdir" ilk="function" signature="mkdir(list, options = {})" attributes="__classmethod__" doc="Options: mode noop verbose &#xA; Creates one or more directories. &#xA; FileUtils.mkdir &apos;test&apos;&#xA;FileUtils.mkdir %w( tmp data )&#xA;FileUtils.mkdir &apos;notexist&apos;, :noop =&gt; true  # Does not really create.&#xA;FileUtils.mkdir &apos;tmp&apos;, :mode =&gt; 0700" />
        <scope name="mkdir_p" ilk="function" signature="mkdir_p(list, options = {})" attributes="__classmethod__" doc="Options: mode noop verbose &#xA; Creates a directory and all its parent directories. For example, &#xA; FileUtils.mkdir_p &apos;/usr/local/lib/ruby&apos;&#xA; causes to make following directories, if it does not exist. * /usr&#xA;* /usr/local&#xA;* /usr/local/lib&#xA;* /usr/local/lib/ruby&#xA; You can pass several directories at a time in a list." />
        <scope name="mkpath" ilk="function" signature="mkpath(list, options = {})" attributes="__classmethod__" />
        <scope name="move" ilk="function" signature="move(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="mv" ilk="function" signature="mv(src, dest, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; Moves file(s) +src+ to +dest+.  If +file+ and +dest+ exist on the different disk partition, the file is copied then the original file is removed. &#xA; FileUtils.mv &apos;badname.rb&apos;, &apos;goodname.rb&apos;&#xA;FileUtils.mv &apos;stuff.rb&apos;, &apos;/notexist/lib/ruby&apos;, :force =&gt; true  # no error&#xA;&#xA;FileUtils.mv %w(junk.txt dust.txt), &apos;/home/aamine/.trash/&apos;&#xA;FileUtils.mv Dir.glob(&apos;test*.rb&apos;), &apos;test&apos;, :noop =&gt; true, :verbose =&gt; true" />
        <scope name="pwd" ilk="function" signature="pwd()" attributes="__classmethod__" doc="Options: (none) &#xA; Returns the name of the current directory." />
        <scope name="remove" ilk="function" signature="remove(list, options = {})" attributes="__classmethod__" />
        <scope name="remove_dir" ilk="function" signature="remove_dir(path, force = false)" attributes="__classmethod__" doc="Removes a directory +dir+ and its contents recursively. This method ignores StandardError if +force+ is true." />
        <scope name="remove_entry" ilk="function" signature="remove_entry(path, force = false)" attributes="__classmethod__" doc="This method removes a file system entry +path+. +path+ might be a regular file, a directory, or something. If +path+ is a directory, remove it recursively. &#xA; See also #remove_entry_secure." />
        <scope name="remove_entry_secure" ilk="function" signature="remove_entry_secure(path, force = false)" attributes="__classmethod__" doc="This method removes a file system entry +path+.  +path+ shall be a regular file, a directory, or something.  If +path+ is a directory, remove it recursively.  This method is required to avoid TOCTTOU (time-of-check-to-time-of-use) local security vulnerability of #rm_r. #rm_r causes security hole when: &#xA; * Parent directory is world writable (including /tmp).&#xA;* Removing directory tree includes world writable directory.&#xA;* The system has symbolic link.&#xA; To avoid this security hole, this method applies special preprocess. If +path+ is a directory, this method chown(2) and chmod(2) all removing directories.  This requires the current process is the owner of the removing whole directory tree, or is the super user (root). &#xA; WARNING: You must ensure that *ALL* parent directories cannot be moved by other untrusted users.  For example, parent directories should not be owned by untrusted users, and should not be world writable except when the sticky bit set. &#xA; WARNING: Only the owner of the removing directory tree, or Unix super user (root) should invoke this method.  Otherwise this method does not work. &#xA; For details of this security vulnerability, see Perl&apos;s case: &#xA; http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2005-0448&#xA;http://www.cve.mitre.org/cgi-bin/cvename.cgi?name=CAN-2004-0452&#xA; For fileutils.rb, this vulnerability is reported in [ruby-dev:26100]." />
        <scope name="remove_file" ilk="function" signature="remove_file(path, force = false)" attributes="__classmethod__" doc="Removes a file +path+. This method ignores StandardError if +force+ is true." />
        <scope name="rm" ilk="function" signature="rm(list, options = {})" attributes="__classmethod__" doc="Options: force noop verbose &#xA; Remove file(s) specified in +list+.  This method cannot remove directories. All StandardErrors are ignored when the :force option is set. &#xA; FileUtils.rm %w( junk.txt dust.txt )&#xA;FileUtils.rm Dir.glob(&apos;*.so&apos;)&#xA;FileUtils.rm &apos;NotExistFile&apos;, :force =&gt; true   # never raises exception" />
        <scope name="rm_f" ilk="function" signature="rm_f(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Equivalent to &#xA; #rm(list, :force =&gt; true)" />
        <scope name="rm_r" ilk="function" signature="rm_r(list, options = {})" attributes="__classmethod__" doc="Options: force noop verbose secure &#xA; remove files +list+[0] +list+[1]... If +list+[n] is a directory, removes its all contents recursively. This method ignores StandardError when :force option is set. &#xA; FileUtils.rm_r Dir.glob(&apos;/tmp/*&apos;)&#xA;FileUtils.rm_r &apos;/&apos;, :force =&gt; true          #  :-)&#xA; WARNING: This method causes local vulnerability if one of parent directories or removing directory tree are world writable (including /tmp, whose permission is 1777), and the current process has strong privilege such as Unix super user (root), and the system has symbolic link.  For secure removing, read the documentation of #remove_entry_secure carefully, and set :secure option to true. Default is :secure=&gt;false. &#xA; NOTE: This method calls #remove_entry_secure if :secure option is set. See also #remove_entry_secure." />
        <scope name="rm_rf" ilk="function" signature="rm_rf(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose secure &#xA; Equivalent to &#xA; #rm_r(list, :force =&gt; true)&#xA; WARNING: This method causes local vulnerability. Read the documentation of #rm_r first." />
        <scope name="rmdir" ilk="function" signature="rmdir(list, options = {})" attributes="__classmethod__" doc="Options: noop, verbose &#xA; Removes one or more directories. &#xA; FileUtils.rmdir &apos;somedir&apos;&#xA;FileUtils.rmdir %w(somedir anydir otherdir)&#xA;# Does not really remove directory; outputs message.&#xA;FileUtils.rmdir &apos;somedir&apos;, :verbose =&gt; true, :noop =&gt; true" />
        <scope name="rmtree" ilk="function" signature="rmtree(list, options = {})" attributes="__classmethod__" />
        <scope name="safe_unlink" ilk="function" signature="safe_unlink(list, options = {})" attributes="__classmethod__" />
        <scope name="symlink" ilk="function" signature="symlink(src, dest, options = {})" attributes="__classmethod__" />
        <scope name="touch" ilk="function" signature="touch(list, options = {})" attributes="__classmethod__" doc="Options: noop verbose &#xA; Updates modification time (mtime) and access time (atime) of file(s) in +list+.  Files are created if they don&apos;t exist. &#xA; FileUtils.touch &apos;timestamp&apos;&#xA;FileUtils.touch Dir.glob(&apos;*.c&apos;);  system &apos;make&apos;" />
        <scope name="uptodate?" ilk="function" signature="uptodate?(new, old_list, options = nil)" attributes="__classmethod__" doc="Options: (none) &#xA; Returns true if +newer+ is newer than all +old_list+. Non-existent files are older than any file. &#xA; FileUtils.uptodate?(&apos;hello.o&apos;, %w(hello.c hello.h)) or \&#xA;    system &apos;make hello.o&apos;" />
        <scope name="ruby" ilk="function" signature="ruby(*args,&amp;block)" doc="Run a Ruby interpreter with the given arguments. &#xA; Example: ruby %{-pe &apos;$_.upcase!&apos; &lt;README}" />
        <scope name="safe_ln" ilk="function" signature="safe_ln(*args)" doc="Attempt to do a normal file link, but fall back to a copy if the link fails." />
        <scope name="sh" ilk="function" signature="sh(*cmd, &amp;block)" doc="Run the system command +cmd+. If multiple arguments are given the command is not run with the shell (same semantics as Kernel::exec and Kernel::system). &#xA; Example: sh %{ls -ltr}&#xA;&#xA;sh &apos;ls&apos;, &apos;file with spaces&apos;&#xA;&#xA;# check exit status after command runs&#xA;sh %{grep pattern file} do |ok, res|&#xA;  if ! ok&#xA;    puts &quot;pattern not found (status = #{res.exitstatus})&quot;&#xA;  end&#xA;end" />
        <scope name="split_all" ilk="function" signature="split_all(path)" doc="Split a file path into individual directory names. &#xA; Example: split_all(&quot;a/b/c&quot;) =&gt;  [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]" />
        <variable name="OPT_TABLE" attributes="__const__" citdl="Object" />
        <variable name="LOW_METHODS" attributes="__const__" citdl="Object" />
        <variable name="METHODS" attributes="__const__" citdl="Object" />
        <variable name="RUBY" attributes="__const__" citdl="Object" />
        <variable name="LN_SUPPORTED" attributes="__const__" citdl="Object" />
        <scope name="DryRun" ilk="namespace">
          <import symbol="FileUtils" />
          <import symbol="LowMethods" />
        </scope>
        <scope name="LowMethods" ilk="namespace">
        </scope>
        <scope name="NoWrite" ilk="namespace">
          <import symbol="FileUtils" />
          <import symbol="LowMethods" />
        </scope>
        <scope name="StreamUtils_" ilk="namespace">
        </scope>
        <scope name="Verbose" ilk="namespace">
          <import symbol="FileUtils" />
        </scope>
      </scope>
    </scope>
    <scope name="find" ilk="blob" lang="Ruby">
      <scope name="Find" ilk="namespace">
        <scope name="find" ilk="function" signature="find(*paths)" attributes="__classmethod__" doc="Calls the associated block with the name of every file and directory listed as arguments, then recursively on their subdirectories, and so on. &#xA; See the +Find+ module documentation for an example." />
        <scope name="prune" ilk="function" signature="prune()" attributes="__classmethod__" doc="Skips the current file or directory, restarting the loop with the next entry. If the current file is a directory, that directory will not be recursively entered. Meaningful only within the block associated with Find::find. &#xA; See the +Find+ module documentation for an example." />
      </scope>
    </scope>
    <scope name="forwardable" ilk="blob" lang="Ruby">
      <scope name="Forwardable" ilk="namespace">
        <scope name="def_delegator" ilk="function" signature="def_delegator(accessor, method, ali = method)" />
        <scope name="def_delegators" ilk="function" signature="def_delegators(accessor, *methods)" />
        <scope name="def_instance_delegator" ilk="function" signature="def_instance_delegator(accessor, method, ali = method)" doc="Define +method+ as delegator instance method with an optional alias name +ali+. Method calls to +ali+ will be delegated to +accessor.method+.  &#xA; class MyQueue&#xA;  extend Forwardable&#xA;  attr_reader :queue&#xA;  def initialize&#xA;    @queue = []&#xA;  end&#xA;  def_delegator :@queue, :push, :mypush&#xA;end&#xA;q = MyQueue.new&#xA;q.mypush 42&#xA;q.queue    =&gt; [42]&#xA;q.push 23  =&gt; NoMethodError" />
        <scope name="def_instance_delegators" ilk="function" signature="def_instance_delegators(accessor, *methods)" doc="Shortcut for defining multiple delegator methods, but with no provision for using a different name.  The following two code samples have the same effect: &#xA; def_delegators :@records, :size, :&lt;&lt;, :map&#xA;&#xA;def_delegator :@records, :size&#xA;def_delegator :@records, :&lt;&lt;&#xA;def_delegator :@records, :map" />
        <scope name="delegate" ilk="function" signature="delegate(hash)" />
        <scope name="instance_delegate" ilk="function" signature="instance_delegate(hash)" doc="Takes a hash as its argument.  The key is a symbol or an array of symbols.  These symbols correspond to method names.  The value is the accessor to which the methods will be delegated." />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <variable name="FORWARDABLE_VERSION" attributes="__const__" citdl="Object" />
      </scope>
      <scope name="SingleForwardable" ilk="namespace">
        <scope name="def_delegator" ilk="function" signature="def_delegator(accessor, method, ali = method)" />
        <scope name="def_delegators" ilk="function" signature="def_delegators(accessor, *methods)" />
        <scope name="def_single_delegator" ilk="function" signature="def_single_delegator(accessor, method, ali = method)" doc="Defines a method _method_ which delegates to _obj_ (i.e. it calls the method of the same name in _obj_).  If _new_name_ is provided, it is used as the name for the delegate method." />
        <scope name="def_single_delegators" ilk="function" signature="def_single_delegators(accessor, *methods)" doc="Shortcut for defining multiple delegator methods, but with no provision for using a different name.  The following two code samples have the same effect: &#xA; def_delegators :@records, :size, :&lt;&lt;, :map&#xA;&#xA;def_delegator :@records, :size&#xA;def_delegator :@records, :&lt;&lt;&#xA;def_delegator :@records, :map" />
        <scope name="delegate" ilk="function" signature="delegate(hash)" />
        <scope name="single_delegate" ilk="function" signature="single_delegate(hash)" doc="Takes a hash as its argument.  The key is a symbol or an array of symbols.  These symbols correspond to method names.  The value is the accessor to which the methods will be delegated." />
      </scope>
    </scope>
    <scope name="gdbm" ilk="blob" lang="Ruby">
      <scope name="GDBM" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Creates a new GDBM instance by opening a gdbm file named _filename_. If the file does not exist, a new file with file mode _mode_ will be created. _flags_ may be one of the following: *READER*  - open as a reader&#xA;*WRITER*  - open as a writer&#xA;*WRCREAT* - open as a writer; if the database does not exist, create a new one&#xA;*NEWDB*   - open as a writer; overwrite any existing databases &#xA; The values *WRITER*, *WRCREAT* and *NEWDB* may be combined with the following values by bitwise or: *SYNC*    - cause all database operations to be synchronized to the disk&#xA;*NOLOCK*  - do not lock the database file &#xA; If no _flags_ are specified, the GDBM object will try to open the database file as a writer and will create it if it does not already exist (cf. flag WRCREAT). If this fails (for instance, if another process has already opened the database as a reader), it will try to open the database file as a reader (cf. flag READER)." />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="If called without a block, this is synonymous to GDBM::new. If a block is given, the new GDBM instance will be passed to the block as a parameter, and the corresponding database file will be closed after the execution of the block code has been finished. &#xA; Example for an open call with a block: &#xA; require &apos;gdbm&apos;&#xA;GDBM.open(&quot;fruitstore.db&quot;) do |gdbm|&#xA;  gdbm.each_pair do |key, value|&#xA;    print &quot;#{key}: #{value}\n&quot;&#xA;  end&#xA;end" />
        <scope name="cachesize=" ilk="function" signature="cachesize=(p1)" doc="Sets the size of the internal bucket cache to _size_." />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all the key-value pairs within _gdbm_." />
        <scope name="close" ilk="function" signature="close()" doc="Closes the associated database file." />
        <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if the associated database file has been closed." />
        <scope name="delete" ilk="function" signature="delete(p1)" doc="Removes the key-value-pair with the specified _key_ from this database and returns the corresponding _value_. Returns nil if the database is empty." />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every key-value pair from _gdbm_ for which _block_ evaluates to true." />
        <scope name="each" ilk="function" signature="each()" doc="Executes _block_ for each key in the database, passing the _key_ and the correspoding _value_ as a parameter." />
        <scope name="each_key" ilk="function" signature="each_key()" doc="Executes _block_ for each key in the database, passing the _key_ as a parameter." />
        <scope name="each_pair" ilk="function" signature="each_pair()" doc="Executes _block_ for each key in the database, passing the _key_ and the correspoding _value_ as a parameter." />
        <scope name="each_value" ilk="function" signature="each_value()" doc="Executes _block_ for each key in the database, passing the corresponding _value_ as a parameter." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if the database is empty." />
        <scope name="fastmode=" ilk="function" signature="fastmode=(p1)" doc="Turns the database&apos;s fast mode on or off. If fast mode is turned on, gdbm does not wait for writes to be flushed to the disk before continuing. &#xA; This option is obsolete for gdbm &gt;= 1.8 since fast mode is turned on by default. See also: #syncmode=" />
        <scope name="fetch" ilk="function" signature="fetch(p1, p2 = v2)" doc="Retrieves the _value_ corresponding to _key_. If there is no value associated with _key_, _default_ will be returned instead." />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" doc="Returns true if the given value _v_ exists within the database. Returns false otherwise." />
        <scope name="include?" ilk="function" signature="include?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="invert" ilk="function" signature="invert()" doc="Returns a hash created by using _gdbm_&apos;s values as keys, and the keys as values." />
        <scope name="key" ilk="function" signature="key(p1)" doc="Returns the _key_ for a given _value_. If several keys may map to the same value, the key that is found first will be returned." />
        <scope name="key?" ilk="function" signature="key?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="keys" ilk="function" signature="keys()" doc="Returns an array of all keys of this database." />
        <scope name="length" ilk="function" signature="length()" doc="Returns the number of key-value pairs in this database." />
        <scope name="member?" ilk="function" signature="member?(p1)" doc="Returns true if the given key _k_ exists within the database. Returns false otherwise." />
        <scope name="reject" ilk="function" signature="reject()" doc="Returns a hash copy of _gdbm_ where all key-value pairs from _gdbm_ for which _block_ evaluates to true are removed. See also: #delete_if" />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Deletes every key-value pair from _gdbm_ for which _block_ evaluates to true." />
        <scope name="reorganize" ilk="function" signature="reorganize()" doc="Reorganizes the database file. This operation removes reserved space of elements that have already been deleted. It is only useful after a lot of deletions in the database." />
        <scope name="replace" ilk="function" signature="replace(p1)" doc="Replaces the content of _gdbm_ with the key-value pairs of _other_. _other_ must have an each_pair method." />
        <scope name="select" ilk="function" signature="select()" doc="Returns a new array of all key-value pairs of the database for which _block_ evaluates to true." />
        <scope name="shift" ilk="function" signature="shift()" doc="Removes a key-value-pair from this database and returns it as a two-item array [ _key_, _value_ ]. Returns nil if the database is empty." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of key-value pairs in this database." />
        <scope name="store" ilk="function" signature="store(p1, p2)" doc="Associates the value _value_ with the specified _key_." />
        <scope name="sync" ilk="function" signature="sync()" doc="Unless the _gdbm_ object has been opened with the *SYNC* flag, it is not guarenteed that database modification operations are immediately applied to the database file. This method ensures that all recent modifications to the database are written to the file. Blocks until all writing operations to the disk have been finished." />
        <scope name="syncmode=" ilk="function" signature="syncmode=(p1)" doc="Turns the database&apos;s synchronization mode on or off. If the synchronization mode is turned on, the database&apos;s in-memory state will be synchronized to disk after every database modification operation. If the synchronization mode is turned off, GDBM does not wait for writes to be flushed to the disk before continuing. &#xA; This option is only available for gdbm &gt;= 1.8 where syncmode is turned off by default. See also: #fastmode=" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns an array of all key-value pairs contained in the database." />
        <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns a hash of all key-value pairs contained in the database." />
        <scope name="update" ilk="function" signature="update(p1)" doc="Adds the key-value pairs of _other_ to _gdbm_, overwriting entries with duplicate keys with those from _other_. _other_ must have an each_pair method." />
        <scope name="value?" ilk="function" signature="value?(p1)" doc="Returns true if the given value _v_ exists within the database. Returns false otherwise." />
        <scope name="values" ilk="function" signature="values()" doc="Returns an array of all values of this database." />
        <scope name="values_at" ilk="function" signature="values_at(*args)" doc="Returns an array of the values associated with each specified _key_." />
        <variable name="READER" attributes="__const__" citdl="Object" />
        <variable name="WRITER" attributes="__const__" citdl="Object" />
        <variable name="WRCREAT" attributes="__const__" citdl="Object" />
        <variable name="NEWDB" attributes="__const__" citdl="Object" />
        <variable name="FAST" attributes="__const__" citdl="Object" />
        <variable name="SYNC" attributes="__const__" citdl="Object" />
        <variable name="NOLOCK" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="getoptlong" ilk="blob" lang="Ruby">
      <scope name="GetoptLong" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(*arguments)" attributes="__classmethod__ __ctor__" doc="Set up option processing. &#xA; The options to support are passed to new() as an array of arrays. Each sub-array contains any number of String option names which carry the same meaning, and one of the following flags: &#xA; Option does not take an argument. &#xA;&#xA;Option always takes an argument. &#xA;&#xA;Option may or may not take an argument. &#xA; The first option name is considered to be the preferred (canonical) name. Other than that, the elements of each sub-array can be in any order." />
        <scope name="each" ilk="function" signature="each()" doc="Iterator version of `get&apos;. &#xA; The block is called repeatedly with two arguments: The first is the option name. The second is the argument which followed it (if any). Example: (&apos;--opt&apos;, &apos;value&apos;) &#xA; The option name is always converted to the first (preferred) name given in the original options to GetoptLong.new." />
        <scope name="each_option" ilk="function" signature="each_option()" doc="`each_option&apos; is an alias of `each&apos;." />
        <scope name="error_message" ilk="function" signature="error_message()" doc="Return the appropriate error message in POSIX-defined format. If no error has occurred, returns nil." />
        <scope name="get" ilk="function" signature="get()" doc="Get next option name and its argument, as an Array of two elements. &#xA; The option name is always converted to the first (preferred) name given in the original options to GetoptLong.new. &#xA; Example: [&apos;--option&apos;, &apos;value&apos;] &#xA; Returns nil if the processing is complete (as determined by STATUS_TERMINATED)." />
        <scope name="get_option" ilk="function" signature="get_option()" doc="`get_option&apos; is an alias of `get&apos;." />
        <scope name="ordering=" ilk="function" signature="ordering=(ordering)" doc="Set the handling of the ordering of options and arguments. A RuntimeError is raised if option processing has already started. &#xA; The supplied value must be a member of GetoptLong::ORDERINGS. It alters the processing of options as follows: &#xA; &lt;b&gt;REQUIRE_ORDER&lt;/b&gt; : &#xA; Options are required to occur before non-options. &#xA; Processing of options ends as soon as a word is encountered that has not been preceded by an appropriate option flag. &#xA; For example, if -a and -b are options which do not take arguments, parsing command line arguments of &apos;-a one -b two&apos; would result in &apos;one&apos;, &apos;-b&apos;, &apos;two&apos; being left in ARGV, and only (&apos;-a&apos;, &apos;&apos;) being processed as an option/arg pair. &#xA; This is the default ordering, if the environment variable POSIXLY_CORRECT is set. (This is for compatibility with GNU getopt_long.) &#xA; &lt;b&gt;PERMUTE&lt;/b&gt; : &#xA; Options can occur anywhere in the command line parsed. This is the default behavior. &#xA; Every sequence of words which can be interpreted as an option (with or without argument) is treated as an option; non-option words are skipped. &#xA; For example, if -a does not require an argument and -b optionally takes an argument, parsing &apos;-a one -b two three&apos; would result in (&apos;-a&apos;,&apos;&apos;) and (&apos;-b&apos;, &apos;two&apos;) being processed as option/arg pairs, and &apos;one&apos;,&apos;three&apos; being left in ARGV. &#xA; If the ordering is set to PERMUTE but the environment variable POSIXLY_CORRECT is set, REQUIRE_ORDER is used instead. This is for compatibility with GNU getopt_long. &#xA; &lt;b&gt;RETURN_IN_ORDER&lt;/b&gt; : " />
        <scope name="set_options" ilk="function" signature="set_options(*arguments)" doc="Set options. Takes the same argument as GetoptLong.new. &#xA; Raises a RuntimeError if option processing has already started." />
        <scope name="terminate" ilk="function" signature="terminate()" doc="Explicitly terminate option processing." />
        <scope name="terminated?" ilk="function" signature="terminated?()" doc="Returns true if option processing has terminated, false otherwise." />
        <scope ilk="function" name="error" />
        <scope ilk="function" name="error?" />
        <scope ilk="function" name="ordering" />
        <scope ilk="function" name="quiet" />
        <scope ilk="function" name="quiet=" />
        <scope ilk="function" name="quiet?" />
        <scope ilk="function" name="quiet?=" />
        <variable name="ORDERINGS" attributes="__const__" citdl="Object" />
        <variable name="ARGUMENT_FLAGS" attributes="__const__" citdl="Object" />
        <variable name="STATUS_TERMINATED" attributes="__const__" citdl="Object" />
        <scope name="AmbiguousOption" ilk="class" classrefs="GetoptLong::Error">
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="InvalidOption" ilk="class" classrefs="GetoptLong::Error">
        </scope>
        <scope name="MissingArgument" ilk="class" classrefs="GetoptLong::Error">
        </scope>
        <scope name="NeedlessArgument" ilk="class" classrefs="GetoptLong::Error">
        </scope>
      </scope>
    </scope>
    <scope name="gserver" ilk="blob" lang="Ruby">
      <scope name="GServer" ilk="class" classrefs="Object">
        <scope name="in_service?" ilk="function" signature="in_service?(port, host = DEFAULT_HOST)" attributes="__classmethod__" doc="Check if a server is running on the given port and host &#xA; port, as a FixNum, of the server to check&#xA;host on which to find the server to check &#xA; Returns true if a server is running on that port and host." />
        <scope name="new" ilk="function" signature="new(port, host = DEFAULT_HOST, maxConnections = 4, stdlog = $stderr, audit = false, debug = false)" attributes="__classmethod__ __ctor__" doc="Create a new server &#xA; the port, as a FixNum, on which to listen.&#xA;the host to bind to&#xA;The maximum number of simultaneous connections to accept&#xA;IO device on which to log messages&#xA;if true, lifecycle callbacks will be called.  See #audit&#xA;if true, error messages are logged.  See #debug" />
        <scope name="stop" ilk="function" signature="stop(port, host = DEFAULT_HOST)" attributes="__classmethod__" doc="Stop the server running on the given port, bound to the given host &#xA; port, as a FixNum, of the server to stop&#xA;host on which to find the server to stop" />
        <scope name="connections" ilk="function" signature="connections()" doc="Return the current number of connected clients" />
        <scope name="join" ilk="function" signature="join()" doc="Join with the server thread" />
        <scope name="serve" ilk="function" signature="serve(io)" />
        <scope name="shutdown" ilk="function" signature="shutdown()" doc="Schedule a shutdown for the server" />
        <scope name="start" ilk="function" signature="start(maxConnections = -1)" doc="Start the server if it isn&apos;t already running &#xA; override +maxConnections+ given to the constructor.  A negative value indicates that the value from the constructor should be used." />
        <scope name="stop" ilk="function" signature="stop()" doc="Stop the server" />
        <scope name="stopped?" ilk="function" signature="stopped?()" doc="Returns true if the server has stopped." />
        <scope ilk="function" name="audit" />
        <scope ilk="function" name="audit=" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="host" />
        <scope ilk="function" name="maxConnections" />
        <scope ilk="function" name="port" />
        <scope ilk="function" name="stdlog" />
        <scope ilk="function" name="stdlog=" />
        <variable name="DEFAULT_HOST" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="iconv" ilk="blob" lang="Ruby">
      <scope name="Iconv" ilk="class" classrefs="Data">
        <scope name="charset_map" ilk="function" signature="charset_map()" attributes="__classmethod__" doc="Returns the map from canonical name to system dependent name." />
        <scope name="conv" ilk="function" signature="conv(p1, p2, p3)" attributes="__classmethod__" doc="Shorthand for Iconv.iconv(to, from, str).join&#xA; See Iconv.iconv." />
        <scope name="ctlmethods" ilk="function" signature="ctlmethods()" attributes="__classmethod__" doc="Returns available iconvctl() method list." />
        <scope name="iconv" ilk="function" signature="iconv(*args)" attributes="__classmethod__" doc="Shorthand for Iconv.open(to, from) { |cd|&#xA;  (strs + [nil]).collect { |s| cd.iconv(s) }&#xA;}&#xA; Parameters &#xA; see Iconv.new&#xA;strings to be converted &#xA; Exceptions &#xA; Exceptions thrown by Iconv.new, Iconv.open and Iconv#iconv." />
        <scope name="list" ilk="function" signature="list()" attributes="__classmethod__" doc="Iterates each alias sets." />
        <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Creates new code converter from a coding-system designated with +from+ to another one designated with +to+. &#xA; Parameters &#xA; encoding name for destination&#xA;encoding name for source&#xA;options for converter &#xA; Exceptions &#xA; if +to+ or +from+ aren&apos;t String&#xA;if designated converter couldn&apos;t find out&#xA;if iconv_open(3) fails" />
        <scope name="open" ilk="function" signature="open(p1, p2, p3 = v3)" attributes="__classmethod__" doc="Equivalent to Iconv.new except that when it is called with a block, it yields with the new instance and closes it, and returns the result which returned from the block." />
        <scope name="close" ilk="function" signature="close()" doc="Finishes conversion. &#xA; After calling this, calling Iconv#iconv will cause an exception, but multiple calls of #close are guaranteed to end successfully. &#xA; Returns a string containing the byte sequence to change the output buffer to its initial shift state." />
        <scope name="conv" ilk="function" signature="conv(*args)" doc="Equivalent to &#xA; iconv(nil, str..., nil).join" />
        <scope name="discard_ilseq=" ilk="function" signature="discard_ilseq=(p1)" doc="Sets discard_ilseq flag." />
        <scope name="discard_ilseq?" ilk="function" signature="discard_ilseq?()" doc="Returns discard_ilseq flag." />
        <scope name="iconv" ilk="function" signature="iconv(p1, p2 = v2, p3 = v3)" doc="Converts string and returns the result. If +str+ is a String, converts str[start, length] and returns the converted string.&#xA;If +str+ is +nil+, places converter itself into initial shift state and just returns a string containing the byte sequence to change the output buffer to its initial shift state.&#xA;Otherwise, raises an exception. &#xA; Parameters &#xA; string to be converted, or nil&#xA;starting offset&#xA;conversion length; nil or -1 means whole the string from start &#xA; Exceptions &#xA; IconvIllegalSequence&#xA;IconvInvalidCharacter&#xA;IconvOutOfRange &#xA; Examples &#xA; See the Iconv documentation." />
        <scope name="transliterate=" ilk="function" signature="transliterate=(p1)" doc="Sets transliterate flag." />
        <scope name="transliterate?" ilk="function" signature="transliterate?()" doc="Returns transliterate flag." />
        <scope name="trivial?" ilk="function" signature="trivial?()" doc="Returns trivial flag." />
        <scope name="BrokenLibrary" ilk="class" classrefs="RuntimeError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="Failure" ilk="namespace">
          <scope name="new" ilk="function" signature="new(p1, p2, p3)" attributes="__classmethod__ __ctor__" doc="Creates new code converter from a coding-system designated with +from+ to another one designated with +to+. &#xA; Parameters &#xA; encoding name for destination&#xA;encoding name for source&#xA;options for converter &#xA; Exceptions &#xA; if +to+ or +from+ aren&apos;t String&#xA;if designated converter couldn&apos;t find out&#xA;if iconv_open(3) fails" />
          <scope name="failed" ilk="function" signature="failed()" doc="Returns substring of the original string passed to Iconv that starts at the character caused the exception." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns inspected string like as: #&lt;_class_: _success_, _failed_&gt;" />
          <scope name="success" ilk="function" signature="success()" doc="Returns string(s) translated successfully until the exception occurred. In the case of failure occurred within Iconv.iconv, returned value is an array of strings translated successfully preceding failure and the last element is string on the way." />
        </scope>
        <scope name="IllegalSequence" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="InvalidCharacter" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="InvalidEncoding" ilk="class" classrefs="ArgError">
          <import symbol="Iconv::Failure" />
        </scope>
        <scope name="OutOfRange" ilk="class" classrefs="RuntimeError">
          <import symbol="Iconv::Failure" />
        </scope>
      </scope>
    </scope>
    <scope name="ipaddr" ilk="blob" lang="Ruby">
      <scope name="IPAddr" ilk="class" classrefs="Object">
        <import symbol="Comparable" />
        <scope name="new" ilk="function" signature="new(addr = &apos;::&apos;, family = Socket::AF_UNSPEC)" attributes="__classmethod__ __ctor__" doc="Creates a new ipaddr object either from a human readable IP address representation in string, or from a packed in_addr value followed by an address family. &#xA; In the former case, the following are the valid formats that will be recognized: &quot;address&quot;, &quot;address/prefixlen&quot; and &quot;address/mask&quot;, where IPv6 address may be enclosed in square brackets (`[&apos; and `]&apos;).  If a prefixlen or a mask is specified, it returns a masked IP address.  Although the address family is determined automatically from a specified string, you can specify one explicitly by the optional second argument. &#xA; Otherwise an IP address is generated from a packed in_addr value and an address family. &#xA; The IPAddr class defines many methods and operators, and some of those, such as &amp;, |, include? and ==, accept a string, or a packed in_addr value instead of an IPAddr object." />
        <scope name="new_ntoh" ilk="function" signature="new_ntoh(addr)" attributes="__classmethod__" doc="Creates a new ipaddr containing the given network byte ordered string form of an IP address." />
        <scope name="ntop" ilk="function" signature="ntop(addr)" attributes="__classmethod__" doc="Convert a network byte ordered string form of an IP address into human readable form." />
        <scope name="eql?" ilk="function" signature="eql?(other)" doc="Checks equality used by Hash." />
        <scope name="hash" ilk="function" signature="hash()" doc="Returns a hash value used by Hash, Set, and Array classes" />
        <scope name="hton" ilk="function" signature="hton()" doc="Returns a network byte ordered string form of the IP address." />
        <scope name="include?" ilk="function" signature="include?(other)" doc="Returns true if the given ipaddr is in the range. &#xA; e.g.: require &apos;ipaddr&apos;&#xA;net1 = IPAddr.new(&quot;192.168.2.0/24&quot;)&#xA;net2 = IPAddr.new(&quot;192.168.2.100&quot;)&#xA;net3 = IPAddr.new(&quot;192.168.3.0&quot;)&#xA;p net1.include?(net2)     =&gt; true&#xA;p net1.include?(net3)     =&gt; false" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a human-readable representation of the ipaddr. (&quot;#&lt;IPAddr: family:address/mask&gt;&quot;)" />
        <scope name="ip6_arpa" ilk="function" signature="ip6_arpa()" doc="Returns a string for DNS reverse lookup compatible with RFC3172." />
        <scope name="ip6_int" ilk="function" signature="ip6_int()" doc="Returns a string for DNS reverse lookup compatible with RFC1886." />
        <scope name="ipv4?" ilk="function" signature="ipv4?()" doc="Returns true if the ipaddr is an IPv4 address." />
        <scope name="ipv4_compat" ilk="function" signature="ipv4_compat()" doc="Returns a new ipaddr built by converting the native IPv4 address into an IPv4-compatible IPv6 address." />
        <scope name="ipv4_compat?" ilk="function" signature="ipv4_compat?()" doc="Returns true if the ipaddr is an IPv4-compatible IPv6 address." />
        <scope name="ipv4_mapped" ilk="function" signature="ipv4_mapped()" doc="Returns a new ipaddr built by converting the native IPv4 address into an IPv4-mapped IPv6 address." />
        <scope name="ipv4_mapped?" ilk="function" signature="ipv4_mapped?()" doc="Returns true if the ipaddr is an IPv4-mapped IPv6 address." />
        <scope name="ipv6?" ilk="function" signature="ipv6?()" doc="Returns true if the ipaddr is an IPv6 address." />
        <scope name="mask" ilk="function" signature="mask(prefixlen)" doc="Returns a new ipaddr built by masking IP address with the given prefixlen/netmask. (e.g. 8, 64, &quot;255.255.255.0&quot;, etc.)" />
        <scope name="native" ilk="function" signature="native()" doc="Returns a new ipaddr built by converting the IPv6 address into a native IPv4 address.  If the IP address is not an IPv4-mapped or IPv4-compatible IPv6 address, returns self." />
        <scope name="reverse" ilk="function" signature="reverse()" doc="Returns a string for DNS reverse lookup.  It returns a string in RFC3172 form for an IPv6 address." />
        <scope name="succ" ilk="function" signature="succ()" doc="Returns the successor to the ipaddr." />
        <scope name="to_i" ilk="function" signature="to_i()" doc="Returns the integer representation of the ipaddr." />
        <scope name="to_range" ilk="function" signature="to_range()" doc="Creates a Range object for the network address." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Returns a string containing the IP address representation." />
        <scope name="to_string" ilk="function" signature="to_string()" doc="Returns a string containing the IP address representation in canonical form." />
        <scope ilk="function" name="family" />
      </scope>
    </scope>
    <scope name="irb" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Irb" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(workspace = nil, input_method = nil, output_method = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="eval_input" ilk="function" signature="eval_input()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="output_value" ilk="function" signature="output_value()" />
          <scope name="prompt" ilk="function" signature="prompt(prompt, ltype, indent, line_no)" />
          <scope name="signal_handle" ilk="function" signature="signal_handle()" />
          <scope name="signal_status" ilk="function" signature="signal_status(status)" />
          <scope name="suspend_context" ilk="function" signature="suspend_context(context)" />
          <scope name="suspend_input_method" ilk="function" signature="suspend_input_method(input_method)" />
          <scope name="suspend_name" ilk="function" signature="suspend_name(path = nil, name = nil)" />
          <scope name="suspend_workspace" ilk="function" signature="suspend_workspace(workspace)" />
          <scope ilk="function" name="context" />
          <scope ilk="function" name="scanner" />
          <scope ilk="function" name="scanner=" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/completion" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="InputCompletor" ilk="namespace">
          <scope name="select_message" ilk="function" signature="select_message(receiver, message, candidates, sep = &quot;.&quot;)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/context" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Context" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(irb, workspace = nil, input_method = nil, output_method = nil)" attributes="__classmethod__ __ctor__" doc="Arguments: input_method: nil -- stdin or readline&#xA;              String -- File&#xA;              other -- using this as InputMethod" />
          <scope name="__exit__" ilk="function" signature="__exit__(ret = 0)" />
          <scope name="__inspect__" ilk="function" signature="__inspect__()" />
          <scope name="__to_s__" ilk="function" signature="__to_s__()" />
          <scope name="_set_last_value" ilk="function" signature="_set_last_value(value)" />
          <scope name="change_workspace" ilk="function" signature="change_workspace(*_main)" />
          <scope name="debug?" ilk="function" signature="debug?()" />
          <scope name="debug_level=" ilk="function" signature="debug_level=(value)" />
          <scope name="eval_history=" ilk="function" signature="eval_history=(no)" />
          <scope name="evaluate" ilk="function" signature="evaluate(line, line_no)" />
          <scope name="exit" ilk="function" signature="exit(ret = 0)" />
          <scope name="file_input?" ilk="function" signature="file_input?()" />
          <scope name="history_file" ilk="function" signature="history_file()" />
          <scope name="history_file=" ilk="function" signature="history_file=(hist)" />
          <scope name="home_workspace" ilk="function" signature="home_workspace()" />
          <scope name="init_save_history" ilk="function" signature="init_save_history()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="inspect?" ilk="function" signature="inspect?()" />
          <scope name="inspect_last_value" ilk="function" signature="inspect_last_value()" />
          <scope name="inspect_mode=" ilk="function" signature="inspect_mode=(opt)" />
          <scope name="irb_level" ilk="function" signature="irb_level()" />
          <scope name="main" ilk="function" signature="main()" />
          <scope name="math_mode=" ilk="function" signature="math_mode=(opt)" />
          <scope name="pop_workspace" ilk="function" signature="pop_workspace()" />
          <scope name="prompt_mode=" ilk="function" signature="prompt_mode=(mode)" />
          <scope name="prompting?" ilk="function" signature="prompting?()" />
          <scope name="push_workspace" ilk="function" signature="push_workspace(*_main)" />
          <scope name="save_history" ilk="function" signature="save_history()" />
          <scope name="save_history=" ilk="function" signature="save_history=(val)" />
          <scope name="set_last_value" ilk="function" signature="set_last_value(value)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="use_loader" ilk="function" signature="use_loader()" />
          <scope name="use_loader=" ilk="function" signature="use_loader=(opt)" />
          <scope name="use_loader?" ilk="function" signature="use_loader?()" />
          <scope name="use_readline=" ilk="function" signature="use_readline=(opt)" />
          <scope name="use_tracer=" ilk="function" signature="use_tracer=(opt)" />
          <scope name="verbose?" ilk="function" signature="verbose?()" />
          <scope name="workspaces" ilk="function" signature="workspaces()" />
          <scope ilk="function" name="ap_name" />
          <scope ilk="function" name="ap_name=" />
          <scope ilk="function" name="auto_indent_mode" />
          <scope ilk="function" name="auto_indent_mode=" />
          <scope ilk="function" name="back_trace_limit" />
          <scope ilk="function" name="back_trace_limit=" />
          <scope ilk="function" name="debug_level" />
          <scope ilk="function" name="echo" />
          <scope ilk="function" name="echo=" />
          <scope ilk="function" name="echo?" />
          <scope ilk="function" name="echo?=" />
          <scope ilk="function" name="eval_history" />
          <scope ilk="function" name="ignore_eof" />
          <scope ilk="function" name="ignore_eof=" />
          <scope ilk="function" name="ignore_eof?" />
          <scope ilk="function" name="ignore_eof?=" />
          <scope ilk="function" name="ignore_sigint" />
          <scope ilk="function" name="ignore_sigint=" />
          <scope ilk="function" name="ignore_sigint?" />
          <scope ilk="function" name="ignore_sigint?=" />
          <scope ilk="function" name="inspect_mode" />
          <scope ilk="function" name="io" />
          <scope ilk="function" name="io=" />
          <scope ilk="function" name="irb" />
          <scope ilk="function" name="irb=" />
          <scope ilk="function" name="irb_name" />
          <scope ilk="function" name="irb_name=" />
          <scope ilk="function" name="irb_path" />
          <scope ilk="function" name="irb_path=" />
          <scope ilk="function" name="last_value" />
          <scope ilk="function" name="load_modules" />
          <scope ilk="function" name="load_modules=" />
          <scope ilk="function" name="math?" />
          <scope ilk="function" name="math_mode" />
          <scope ilk="function" name="prompt_c" />
          <scope ilk="function" name="prompt_c=" />
          <scope ilk="function" name="prompt_i" />
          <scope ilk="function" name="prompt_i=" />
          <scope ilk="function" name="prompt_mode" />
          <scope ilk="function" name="prompt_n" />
          <scope ilk="function" name="prompt_n=" />
          <scope ilk="function" name="prompt_s" />
          <scope ilk="function" name="prompt_s=" />
          <scope ilk="function" name="rc" />
          <scope ilk="function" name="rc=" />
          <scope ilk="function" name="rc?" />
          <scope ilk="function" name="rc?=" />
          <scope ilk="function" name="return_format" />
          <scope ilk="function" name="return_format=" />
          <scope ilk="function" name="thread" />
          <scope ilk="function" name="use_readline" />
          <scope ilk="function" name="use_readline?" />
          <scope ilk="function" name="use_tracer" />
          <scope ilk="function" name="use_tracer?" />
          <scope ilk="function" name="verbose" />
          <scope ilk="function" name="verbose=" />
          <scope ilk="function" name="workspace" />
          <scope ilk="function" name="workspace=" />
          <scope ilk="function" name="workspace_home" />
          <variable name="NOPRINTING_IVARS" attributes="__const__" citdl="Object" />
          <variable name="NO_INSPECTING_IVARS" attributes="__const__" citdl="Object" />
          <variable name="IDNAME_IVARS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/ext/multi-irb" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="JobManager" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="delete" ilk="function" signature="delete(key)" />
          <scope name="insert" ilk="function" signature="insert(irb)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="irb" ilk="function" signature="irb(key)" />
          <scope name="kill" ilk="function" signature="kill(*keys)" />
          <scope name="main_irb" ilk="function" signature="main_irb()" />
          <scope name="main_thread" ilk="function" signature="main_thread()" />
          <scope name="n_jobs" ilk="function" signature="n_jobs()" />
          <scope name="search" ilk="function" signature="search(key)" />
          <scope name="switch" ilk="function" signature="switch(key)" />
          <scope name="thread" ilk="function" signature="thread(key)" />
          <scope ilk="function" name="current_job" />
          <scope ilk="function" name="current_job=" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/extend-command" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="ContextExtender" ilk="namespace">
          <scope name="def_extend_command" ilk="function" signature="def_extend_command(cmd_name, load_file, *aliases)" attributes="__classmethod__" />
          <scope name="install_extend_commands" ilk="function" signature="install_extend_commands()" attributes="__classmethod__" />
          <variable name="CE" attributes="__const__" citdl="Object" />
          <scope name="CE" ilk="namespace">
            <scope name="def_extend_command" ilk="function" signature="def_extend_command(cmd_name, load_file, *aliases)" attributes="__classmethod__" />
            <scope name="install_extend_commands" ilk="function" signature="install_extend_commands()" attributes="__classmethod__" />
            <variable name="CE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="ExtendCommand" ilk="namespace">
          <scope name="ChangeWorkspace" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="CurrentWorkingWorkspace" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Foreground" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(key)" />
          </scope>
          <scope name="Fork" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <scope name="execute" ilk="function" signature="execute(&amp;block)" />
          </scope>
          <scope name="Help" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <scope name="execute" ilk="function" signature="execute(*names)" />
          </scope>
          <scope name="IrbCommand" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Jobs" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute()" />
          </scope>
          <scope name="Kill" ilk="class" classrefs="Nop">
            <scope name="execute" ilk="function" signature="execute(*keys)" />
          </scope>
          <scope name="Load" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name, priv = nil)" />
          </scope>
          <scope name="Nop" ilk="class" classrefs="Object">
            <scope name="execute" ilk="function" signature="execute(conf, *opts)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(conf)" attributes="__classmethod__ __ctor__" />
            <scope name="execute" ilk="function" signature="execute(*opts)" />
            <scope name="irb" ilk="function" signature="irb()" />
            <scope ilk="function" name="irb_context" />
          </scope>
          <scope name="PopWorkspace" ilk="class" classrefs="IRB::ExtendCommand::Workspaces">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="PushWorkspace" ilk="class" classrefs="IRB::ExtendCommand::Workspaces">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
          <scope name="Require" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name)" />
          </scope>
          <scope name="Source" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <import symbol="IrbLoader" />
            <scope name="execute" ilk="function" signature="execute(file_name)" />
          </scope>
          <scope name="Workspaces" ilk="class" classrefs="IRB::ExtendCommand::Nop">
            <scope name="execute" ilk="function" signature="execute(*obj)" />
          </scope>
        </scope>
        <scope name="ExtendCommandBundle" ilk="namespace">
          <scope name="def_extend_command" ilk="function" signature="def_extend_command(cmd_name, cmd_class, load_file = nil, *aliases)" attributes="__classmethod__" doc="aliases = [commands_alias, flag], ..." />
          <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" />
          <scope name="install_extend_commands" ilk="function" signature="install_extend_commands()" attributes="__classmethod__" />
          <scope name="irb_original_method_name" ilk="function" signature="irb_original_method_name(method_name)" attributes="__classmethod__" />
          <scope name="install_alias_method" ilk="function" signature="install_alias_method(to, from, override = NO_OVERRIDE)" doc="override = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}" />
          <scope name="irb_context" ilk="function" signature="irb_context()" />
          <scope name="irb_exit" ilk="function" signature="irb_exit(ret = 0)" />
          <scope name="irb_load" ilk="function" signature="irb_load(*opts, &amp;b)" />
          <scope name="irb_require" ilk="function" signature="irb_require(*opts, &amp;b)" />
          <variable name="EXCB" attributes="__const__" citdl="Object" />
          <variable name="NO_OVERRIDE" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_PRIVATE_ONLY" attributes="__const__" citdl="Object" />
          <variable name="OVERRIDE_ALL" attributes="__const__" citdl="Object" />
          <scope name="EXCB" ilk="namespace">
            <scope name="def_extend_command" ilk="function" signature="def_extend_command(cmd_name, cmd_class, load_file = nil, *aliases)" attributes="__classmethod__" doc="aliases = [commands_alias, flag], ..." />
            <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" />
            <scope name="install_extend_commands" ilk="function" signature="install_extend_commands()" attributes="__classmethod__" />
            <scope name="irb_original_method_name" ilk="function" signature="irb_original_method_name(method_name)" attributes="__classmethod__" />
            <scope name="install_alias_method" ilk="function" signature="install_alias_method(to, from, override = NO_OVERRIDE)" doc="override = {NO_OVERRIDE, OVERRIDE_PRIVATE_ONLY, OVERRIDE_ALL}" />
            <scope name="irb_context" ilk="function" signature="irb_context()" />
            <scope name="irb_exit" ilk="function" signature="irb_exit(ret = 0)" />
            <scope name="irb_load" ilk="function" signature="irb_load(*opts, &amp;b)" />
            <scope name="irb_require" ilk="function" signature="irb_require(*opts, &amp;b)" />
            <variable name="EXCB" attributes="__const__" citdl="Object" />
            <variable name="NO_OVERRIDE" attributes="__const__" citdl="Object" />
            <variable name="OVERRIDE_PRIVATE_ONLY" attributes="__const__" citdl="Object" />
            <variable name="OVERRIDE_ALL" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="MethodExtender" ilk="namespace">
          <scope name="def_post_proc" ilk="function" signature="def_post_proc(base_method, extend_method)" />
          <scope name="def_pre_proc" ilk="function" signature="def_pre_proc(base_method, extend_method)" />
          <scope name="new_alias_name" ilk="function" signature="new_alias_name(name, prefix = &quot;__alias_of__&quot;, postfix = &quot;__&quot;)" doc="return #{prefix}#{name}#{postfix}&lt;num&gt;" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/frame" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Frame" ilk="class" classrefs="Object">
          <scope name="bottom" ilk="function" signature="bottom(n = 0)" attributes="__classmethod__" doc="singleton functions" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="sender" ilk="function" signature="sender()" attributes="__classmethod__" />
          <scope name="top" ilk="function" signature="top(n = 0)" attributes="__classmethod__" />
          <scope name="bottom" ilk="function" signature="bottom(n = 0)" />
          <scope name="top" ilk="function" signature="top(n = 0)" />
          <scope name="trace_func" ilk="function" signature="trace_func(event, file, line, id, binding)" />
          <variable name="INIT_STACK_TIMES" attributes="__const__" citdl="Object" />
          <variable name="CALL_STACK_OFFSET" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/init" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="CurrentContext" ilk="function" signature="CurrentContext()" attributes="__classmethod__" />
        <scope name="Inspector" ilk="function" signature="Inspector(inspect, init = nil)" attributes="__classmethod__" />
        <scope name="JobManager" ilk="function" signature="JobManager()" attributes="__classmethod__" />
        <scope name="conf" ilk="function" signature="conf()" attributes="__classmethod__" />
        <scope name="delete_caller" ilk="function" signature="delete_caller()" attributes="__classmethod__" />
        <scope name="init_config" ilk="function" signature="init_config(ap_path)" attributes="__classmethod__" doc="@CONF default setting" />
        <scope name="init_error" ilk="function" signature="init_error()" attributes="__classmethod__" />
        <scope name="initialize_tracer" ilk="function" signature="initialize_tracer()" attributes="__classmethod__" doc="initialize tracing function" />
        <scope name="irb" ilk="function" signature="irb(file = nil, *main)" attributes="__classmethod__" doc="invoke multi-irb" />
        <scope name="irb_abort" ilk="function" signature="irb_abort(irb, exception = Abort)" attributes="__classmethod__" />
        <scope name="irb_at_exit" ilk="function" signature="irb_at_exit()" attributes="__classmethod__" />
        <scope name="irb_exit" ilk="function" signature="irb_exit(irb, ret)" attributes="__classmethod__" />
        <scope name="load_modules" ilk="function" signature="load_modules()" attributes="__classmethod__" doc="loading modules" />
        <scope name="parse_opts" ilk="function" signature="parse_opts()" attributes="__classmethod__" doc="option analyzing" />
        <scope name="print_usage" ilk="function" signature="print_usage()" attributes="__classmethod__" />
        <scope name="rc_file" ilk="function" signature="rc_file(ext = IRBRC_EXT)" attributes="__classmethod__" />
        <scope name="rc_file_generators" ilk="function" signature="rc_file_generators()" attributes="__classmethod__" doc="enumerate possible rc-file base name generators" />
        <scope name="run_config" ilk="function" signature="run_config()" attributes="__classmethod__" doc="running config" />
        <scope name="setup" ilk="function" signature="setup(ap_path)" attributes="__classmethod__" doc="initialize config" />
        <scope name="start" ilk="function" signature="start(ap_path = nil)" attributes="__classmethod__" doc="initialize IRB and start TOP_LEVEL irb" />
        <scope name="version" ilk="function" signature="version()" attributes="__classmethod__" doc="IRB version method" />
        <variable name="FEATURE_IOPT_CHANGE_VERSION" attributes="__const__" citdl="Object" />
        <variable name="IRBRC_EXT" attributes="__const__" citdl="Object" />
        <variable name="STDIN_FILE_NAME" attributes="__const__" citdl="Object" />
        <variable name="INSPECTORS" attributes="__const__" citdl="Object" />
        <scope name="Abort" ilk="class" classrefs="Exception">
        </scope>
        <scope name="History" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(size = 16)" attributes="__classmethod__ __ctor__" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="push" ilk="function" signature="push(no, val)" />
          <scope name="real_inspect" ilk="function" signature="real_inspect()" />
          <scope name="size" ilk="function" signature="size(size)" />
        </scope>
        <scope name="HistorySavingAbility" ilk="namespace">
          <import symbol="Readline" />
          <scope name="extended" ilk="function" signature="extended(obj)" attributes="__classmethod__" doc="def HistorySavingAbility.create_finalizer proc do&#xA;if num = IRB.conf[:SAVE_HISTORY] and (num = num.to_i) &gt; 0&#xA;  if hf = IRB.conf[:HISTORY_FILE]&#xA;    file = File.expand_path(hf)&#xA;  end&#xA;  file = IRB.rc_file(&quot;_history&quot;) unless file&#xA;  open(file, &apos;w&apos; ) do |f|&#xA;    hist = HISTORY.to_a&#xA;    f.puts(hist[-num..-1] || hist)&#xA;  end&#xA;end&#xA;end&#xA; end" />
          <scope name="load_history" ilk="function" signature="load_history()" />
          <scope name="save_history" ilk="function" signature="save_history()" />
        </scope>
        <scope name="INSPECTORS" ilk="namespace">
          <scope name="def_inspector" ilk="function" signature="def_inspector(key, arg=nil, &amp;block)" attributes="__classmethod__" doc="ex) INSPECTORS.def_inspector(key, init_p=nil){|v| v.inspect} INSPECTORS.def_inspector([key1,..], init_p=nil){|v| v.inspect} INSPECTORS.def_inspector(key, inspector) INSPECTORS.def_inspector([key1,...], inspector)" />
          <scope name="keys_with_inspector" ilk="function" signature="keys_with_inspector(inspector)" attributes="__classmethod__" />
        </scope>
        <scope name="IrbLoader" ilk="namespace">
          <scope name="irb_load" ilk="function" signature="irb_load(fn, priv = nil)" />
          <scope name="load_file" ilk="function" signature="load_file(path, priv = nil)" />
          <scope name="old" ilk="function" signature="old()" />
          <scope name="search_file_from_ruby_path" ilk="function" signature="search_file_from_ruby_path(fn)" />
          <scope name="source_file" ilk="function" signature="source_file(path)" />
        </scope>
        <scope name="LoadAbort" ilk="class" classrefs="Exception">
        </scope>
      </scope>
    </scope>
    <scope name="irb/input-method" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="FileInputMethod" ilk="class" classrefs="IRB::InputMethod">
          <scope name="new" ilk="function" signature="new(file)" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope ilk="function" name="file_name" />
        </scope>
        <scope name="InputMethod" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(file = STDIN_FILE_NAME)" attributes="__classmethod__ __ctor__" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
          <scope ilk="function" name="file_name" />
          <scope ilk="function" name="prompt" />
          <scope ilk="function" name="prompt=" />
        </scope>
        <scope name="ReadlineInputMethod" ilk="class" classrefs="IRB::InputMethod">
          <import symbol="Readline" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="line" ilk="function" signature="line(line_no)" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
        </scope>
        <scope name="StdioInputMethod" ilk="class" classrefs="IRB::InputMethod">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="encoding" ilk="function" signature="encoding()" />
          <scope name="eof?" ilk="function" signature="eof?()" />
          <scope name="gets" ilk="function" signature="gets()" />
          <scope name="line" ilk="function" signature="line(line_no)" />
          <scope name="readable_atfer_eof?" ilk="function" signature="readable_atfer_eof?()" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/inspector" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Inspector" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(inspect_proc, init_proc = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="init" ilk="function" signature="init()" />
          <scope name="inspect_value" ilk="function" signature="inspect_value(v)" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/locale" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Locale" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(locale = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="String" ilk="function" signature="String(mes)" />
          <scope name="find" ilk="function" signature="find(file , paths = $:)" />
          <scope name="format" ilk="function" signature="format(*opts)" />
          <scope name="gets" ilk="function" signature="gets(*rs)" />
          <scope name="load" ilk="function" signature="load(file, priv=nil)" />
          <scope name="print" ilk="function" signature="print(*opts)" />
          <scope name="printf" ilk="function" signature="printf(*opts)" />
          <scope name="puts" ilk="function" signature="puts(*opts)" />
          <scope name="readline" ilk="function" signature="readline(*rs)" />
          <scope name="require" ilk="function" signature="require(file, priv = nil)" />
          <scope name="toplevel_load" ilk="function" signature="toplevel_load(file, priv=nil)" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="lang" />
          <scope ilk="function" name="modifieer" />
          <scope ilk="function" name="territory" />
          <variable name="LOCALE_NAME_RE" attributes="__const__" citdl="Object" />
          <variable name="LOCALE_DIR" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/notifier" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="Notifier" ilk="namespace">
          <scope name="def_notifier" ilk="function" signature="def_notifier(prefix = &quot;&quot;, output_method = StdioOutputMethod.new)" attributes="__classmethod__" />
          <variable name="D_NOMSG" attributes="__const__" citdl="Object" />
          <scope name="AbstractNotifier" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(prefix, base_notifier)" attributes="__classmethod__ __ctor__" />
            <scope name="exec_if" ilk="function" signature="exec_if()" />
            <scope name="notify?" ilk="function" signature="notify?()" />
            <scope name="pp" ilk="function" signature="pp(*objs)" />
            <scope name="ppx" ilk="function" signature="ppx(prefix, *objs)" />
            <scope name="print" ilk="function" signature="print(*opts)" />
            <scope name="printf" ilk="function" signature="printf(format, *opts)" />
            <scope name="printn" ilk="function" signature="printn(*opts)" />
            <scope name="puts" ilk="function" signature="puts(*objs)" />
            <scope ilk="function" name="prefix" />
          </scope>
          <scope name="CompositeNotifier" ilk="class" classrefs="IRB::Notifier::AbstractNotifier">
            <scope name="new" ilk="function" signature="new(prefix, base_notifier)" attributes="__classmethod__ __ctor__" />
            <scope name="def_notifier" ilk="function" signature="def_notifier(level, prefix = &quot;&quot;)" />
            <scope name="level=" ilk="function" signature="level=(value)" />
            <scope name="level_notifier=" ilk="function" signature="level_notifier=(value)" />
            <scope ilk="function" name="level" />
            <scope ilk="function" name="level_notifier" />
            <scope ilk="function" name="notifiers" />
          </scope>
          <scope name="LeveledNotifier" ilk="class" classrefs="IRB::Notifier::AbstractNotifier">
            <import symbol="Comparable" />
            <scope name="new" ilk="function" signature="new(base, level, prefix)" attributes="__classmethod__ __ctor__" />
            <scope name="notify?" ilk="function" signature="notify?()" />
            <scope ilk="function" name="level" />
          </scope>
          <scope name="NoMsgNotifier" ilk="class" classrefs="IRB::Notifier::LeveledNotifier">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="notify?" ilk="function" signature="notify?()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="irb/output-method" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="OutputMethod" ilk="class" classrefs="Object">
          <scope name="parse_printf_format" ilk="function" signature="parse_printf_format(format, opts)" doc="% &lt;flag&gt;  [#0- +] &lt;minimum field width&gt; (\*|\*[1-9][0-9]*\$|[1-9][0-9]*) &lt;precision&gt;.(\*|\*[1-9][0-9]*\$|[1-9][0-9]*|)? #&lt;length modifier&gt;(hh|h|l|ll|L|q|j|z|t) &lt;conversion specifier&gt;[diouxXeEfgGcsb%]" />
          <scope name="pp" ilk="function" signature="pp(*objs)" />
          <scope name="ppx" ilk="function" signature="ppx(prefix, *objs)" />
          <scope name="print" ilk="function" signature="print(*opts)" />
          <scope name="printf" ilk="function" signature="printf(format, *opts)" doc="extend printf" />
          <scope name="printn" ilk="function" signature="printn(*opts)" />
          <scope name="puts" ilk="function" signature="puts(*objs)" />
        </scope>
        <scope name="StdioOutputMethod" ilk="class" classrefs="IRB::OutputMethod">
          <scope name="print" ilk="function" signature="print(*opts)" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/ruby-token" ilk="blob" lang="Ruby">
      <scope name="RubyToken" ilk="namespace">
        <scope name="def_token" ilk="function" signature="def_token(token_n, super_token = Token, reading = nil, *opts)" attributes="__classmethod__" />
        <scope name="Token" ilk="function" signature="Token(token, value = nil)" />
        <variable name="EXPR_BEG" attributes="__const__" citdl="Object" />
        <variable name="EXPR_MID" attributes="__const__" citdl="Object" />
        <variable name="EXPR_END" attributes="__const__" citdl="Object" />
        <variable name="EXPR_ARG" attributes="__const__" citdl="Object" />
        <variable name="EXPR_FNAME" attributes="__const__" citdl="Object" />
        <variable name="EXPR_DOT" attributes="__const__" citdl="Object" />
        <variable name="EXPR_CLASS" attributes="__const__" citdl="Object" />
        <scope name="TkError" ilk="class" classrefs="RubyToken::Token">
        </scope>
        <scope name="TkId" ilk="class" classrefs="RubyToken::Token">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no, name)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="name" />
        </scope>
        <scope name="TkNode" ilk="class" classrefs="RubyToken::Token">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="node" />
        </scope>
        <scope name="TkOPASGN" ilk="class" classrefs="RubyToken::TkOp">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no, op)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="op" />
        </scope>
        <scope name="TkOp" ilk="class" classrefs="RubyToken::Token">
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
        </scope>
        <scope name="TkUnknownChar" ilk="class" classrefs="RubyToken::Token">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no, id)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="name" />
        </scope>
        <scope name="TkVal" ilk="class" classrefs="RubyToken::Token">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no, value = nil)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="value" />
        </scope>
        <scope name="Token" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(seek, line_no, char_no)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="seek" />
          <scope ilk="function" name="seek=" />
        </scope>
      </scope>
    </scope>
    <scope name="irb/slex" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="SLex" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="create" ilk="function" signature="create(token, preproc = nil, postproc = nil)" />
          <scope name="def_rule" ilk="function" signature="def_rule(token, preproc = nil, postproc = nil, &amp;block)" />
          <scope name="def_rules" ilk="function" signature="def_rules(*tokens, &amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="match" ilk="function" signature="match(token)" />
          <scope name="postproc" ilk="function" signature="postproc(token)" doc="$BMW%A%&apos;%C%/(B?" />
          <scope name="preproc" ilk="function" signature="preproc(token, proc)" />
          <scope name="search" ilk="function" signature="search(token)" />
          <variable name="DOUT" attributes="__const__" citdl="Object" />
          <variable name="D_WARN" attributes="__const__" citdl="Object" />
          <variable name="D_DEBUG" attributes="__const__" citdl="Object" />
          <variable name="D_DETAIL" attributes="__const__" citdl="Object" />
          <scope name="Node" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(preproc = nil, postproc = nil)" attributes="__classmethod__ __ctor__" doc="if postproc is nil, this node is an abstract node. if postproc is non-nil, this node is a real node." />
            <scope name="create_subnode" ilk="function" signature="create_subnode(chrs, preproc = nil, postproc = nil)" />
            <scope name="match" ilk="function" signature="match(chrs, op = &quot;&quot;)" doc="chrs: String character array&#xA;io must have getc()/ungetc(); and ungetc() must be&#xA;able to be called arbitrary number of times." />
            <scope name="match_io" ilk="function" signature="match_io(io, op = &quot;&quot;)" />
            <scope name="search" ilk="function" signature="search(chrs, opt = nil)" />
            <scope ilk="function" name="postproc" />
            <scope ilk="function" name="postproc=" />
            <scope ilk="function" name="preproc" />
            <scope ilk="function" name="preproc=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="irb/workspace" ilk="blob" lang="Ruby">
      <scope name="IRB" ilk="namespace">
        <scope name="WorkSpace" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*main)" attributes="__classmethod__ __ctor__" doc="create new workspace. set self to main if specified, otherwise inherit main from TOPLEVEL_BINDING." />
          <scope name="__evaluate__" ilk="function" signature="__evaluate__(context, statements, file = __FILE__, line = __LINE__)" />
          <scope name="evaluate" ilk="function" signature="evaluate(context, statements, file = __FILE__, line = __LINE__)" />
          <scope name="filter_backtrace" ilk="function" signature="filter_backtrace(bt)" doc="error message manipulator" />
          <scope ilk="function" name="binding" />
          <scope ilk="function" name="main" />
        </scope>
      </scope>
    </scope>
    <scope name="json" ilk="blob" lang="Ruby">
      <scope name="JSON" ilk="namespace">
        <scope name="const_defined_in?" ilk="function" signature="const_defined_in?(modul, constant)" attributes="__classmethod__" />
        <scope name="iconv" ilk="function" signature="iconv(to, from, string)" attributes="__classmethod__" doc="Encodes string using Ruby&apos;s _String.encode_" />
        <scope name="restore" ilk="function" signature="restore(source, proc = nil)" attributes="__classmethod__" />
        <scope name="dump" ilk="function" signature="dump(obj, anIO = nil, limit = nil)" doc="Dumps _obj_ as a JSON string, i.e. calls generate on the object and returns the result. &#xA; If anIO (an IO-like object or an object that responds to the write method) was given, the resulting JSON is written to it. &#xA; If the number of nested arrays or objects exceeds _limit_, an ArgumentError exception is raised. This argument is similar (but not exactly the same!) to the _limit_ argument in Marshal.dump. &#xA; This method is part of the implementation of the load/dump interface of Marshal and YAML." />
        <scope name="fast_generate" ilk="function" signature="fast_generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. This method disables the checks for circles in Ruby objects. &#xA; *WARNING*: Be careful not to pass any Ruby data structures with circles as _obj_ argument because this will cause JSON to go into an infinite loop." />
        <scope name="generate" ilk="function" signature="generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. _state_ is * a JSON::State object, or a Hash like object (responding to to_hash),&#xA;an object convertible into a hash by a to_h method, that is used as or to configure a State object. &#xA; It defaults to a state object, that creates the shortest possible JSON text in one line, checks for circular data structures and doesn&apos;t allow NaN, Infinity, and -Infinity. &#xA; A _state_ hash can have the following keys: *indent*: a string used to indent levels (default: &apos;&apos;),&#xA;*space*: a string that is put after, a : or , delimiter (default: &apos;&apos;),&#xA;*space_before*: a string that is put before a : pair delimiter (default: &apos;&apos;),&#xA;*object_nl*: a string that is put at the end of a JSON object (default: &apos;&apos;),&#xA;*array_nl*: a string that is put at the end of a JSON array (default: &apos;&apos;),&#xA;*allow_nan*: true if NaN, Infinity, and -Infinity should be generated, otherwise an exception is thrown if these values are encountered. This options defaults to false.&#xA;*max_nesting*: The maximum depth of nesting allowed in the data structures from which JSON is to be generated. Disable depth checking with :max_nesting =&gt; false, it defaults to 19. &#xA; See also the fast_generate for the fastest creation method with the least amount of sanity checks, and the pretty_generate method for some defaults for pretty output." />
        <scope name="load" ilk="function" signature="load(source, proc = nil)" doc="Load a ruby data structure from a JSON _source_ and return it. A source can either be a string-like object, an IO-like object, or an object responding to the read method. If _proc_ was given, it will be called with any nested Ruby object as an argument recursively in depth first order. &#xA; This method is part of the implementation of the load/dump interface of Marshal and YAML." />
        <scope name="parse" ilk="function" signature="parse(source, opts = {})" doc="Parse the JSON document _source_ into a Ruby data structure and return it. &#xA; _opts_ can have the following keys: *max_nesting*: The maximum depth of nesting allowed in the parsed data structures. Disable depth checking with :max_nesting =&gt; false. It defaults to 19.&#xA;*allow_nan*: If set to true, allow NaN, Infinity and -Infinity in defiance of RFC 4627 to be parsed by the Parser. This option defaults to false.&#xA;*symbolize_names*: If set to true, returns symbols for the names (keys) in a JSON object. Otherwise strings are returned. Strings are the default.&#xA;*create_additions*: If set to false, the Parser doesn&apos;t create additions even if a matching class and create_id was found. This option defaults to true.&#xA;*object_class*: Defaults to Hash&#xA;*array_class*: Defaults to Array" />
        <scope name="parse!" ilk="function" signature="parse!(source, opts = {})" doc="Parse the JSON document _source_ into a Ruby data structure and return it. The bang version of the parse method defaults to the more dangerous values for the _opts_ hash, so be sure only to parse trusted _source_ documents. &#xA; _opts_ can have the following keys: *max_nesting*: The maximum depth of nesting allowed in the parsed data structures. Enable depth checking with :max_nesting =&gt; anInteger. The parse! methods defaults to not doing max depth checking: This can be dangerous if someone wants to fill up your stack.&#xA;*allow_nan*: If set to true, allow NaN, Infinity, and -Infinity in defiance of RFC 4627 to be parsed by the Parser. This option defaults to true.&#xA;*create_additions*: If set to false, the Parser doesn&apos;t create additions even if a matching class and create_id was found. This option defaults to true." />
        <scope name="pretty_generate" ilk="function" signature="pretty_generate(obj, opts = nil)" doc="Generate a JSON document from the Ruby data structure _obj_ and return it. The returned document is a prettier form of the document returned by #unparse. &#xA; The _opts_ argument can be used to configure the generator. See the generate method for a more detailed explanation." />
        <scope name="recurse_proc" ilk="function" signature="recurse_proc(result, &amp;proc)" doc="Recursively calls passed _Proc_ if the parsed data structure is an _Array_ or _Hash_" />
        <scope ilk="function" name="create_id" />
        <scope ilk="function" name="create_id=" />
        <scope ilk="function" name="generator" />
        <scope ilk="function" name="parser" />
        <scope ilk="function" name="state" />
        <scope ilk="function" name="state=" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="VERSION_ARRAY" attributes="__const__" citdl="Object" />
        <variable name="VERSION_MAJOR" attributes="__const__" citdl="Object" />
        <variable name="VERSION_MINOR" attributes="__const__" citdl="Object" />
        <variable name="VERSION_BUILD" attributes="__const__" citdl="Object" />
        <variable name="JSON_LOADED" attributes="__const__" citdl="Object" />
        <scope name="CircularDatastructure" ilk="class" classrefs="JSON::NestingError">
        </scope>
      </scope>
    </scope>
    <scope name="json/common" ilk="blob" lang="Ruby">
      <scope name="JSON" ilk="namespace">
        <scope name="GeneratorError" ilk="class" classrefs="JSON::JSONError">
        </scope>
        <scope name="JSONError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="MissingUnicodeSupport" ilk="class" classrefs="JSON::JSONError">
        </scope>
        <scope name="NestingError" ilk="class" classrefs="JSON::ParserError">
        </scope>
        <scope name="ParserError" ilk="class" classrefs="JSON::JSONError">
        </scope>
        <scope name="UnparserError" ilk="class" classrefs="JSON::JSONError">
        </scope>
      </scope>
    </scope>
    <scope name="json/ext" ilk="blob" lang="Ruby">
      <scope name="JSON" ilk="namespace">
        <scope name="Ext" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="kconv" ilk="blob" lang="Ruby">
      <scope name="Kconv" ilk="namespace">
        <scope name="guess" ilk="function" signature="guess(str)" attributes="__classmethod__" doc="Guess input encoding by NKF.guess" />
        <scope name="iseuc" ilk="function" signature="iseuc(str)" attributes="__classmethod__" doc="Returns whether input encoding is EUC-JP or not. &#xA; *Note* don&apos;t expect this return value is MatchData." />
        <scope name="isjis" ilk="function" signature="isjis(str)" attributes="__classmethod__" doc="Returns whether input encoding is ISO-2022-JP or not." />
        <scope name="issjis" ilk="function" signature="issjis(str)" attributes="__classmethod__" doc="Returns whether input encoding is Shift_JIS or not." />
        <scope name="isutf8" ilk="function" signature="isutf8(str)" attributes="__classmethod__" doc="Returns whether input encoding is UTF-8 or not." />
        <scope name="kconv" ilk="function" signature="kconv(str, to_enc, from_enc=nil)" attributes="__classmethod__" doc="Convert str to to_enc. to_enc and from_enc are given as constants of Kconv or Encoding objects." />
        <scope name="toeuc" ilk="function" signature="toeuc(str)" attributes="__classmethod__" doc="Convert str to EUC-JP" />
        <scope name="tojis" ilk="function" signature="tojis(str)" attributes="__classmethod__" doc="Convert str to ISO-2022-JP" />
        <scope name="tolocale" ilk="function" signature="tolocale(str)" attributes="__classmethod__" doc="Convert self to locale encoding" />
        <scope name="tosjis" ilk="function" signature="tosjis(str)" attributes="__classmethod__" doc="Convert str to Shift_JIS" />
        <scope name="toutf16" ilk="function" signature="toutf16(str)" attributes="__classmethod__" doc="Convert str to UTF-16" />
        <scope name="toutf32" ilk="function" signature="toutf32(str)" attributes="__classmethod__" doc="Convert str to UTF-32" />
        <scope name="toutf8" ilk="function" signature="toutf8(str)" attributes="__classmethod__" doc="Convert str to UTF-8" />
        <variable name="AUTO" attributes="__const__" citdl="Object" />
        <variable name="JIS" attributes="__const__" citdl="Object" />
        <variable name="EUC" attributes="__const__" citdl="Object" />
        <variable name="SJIS" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="NOCONV" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="logger" ilk="blob" lang="Ruby">
      <scope name="Logger" ilk="class" classrefs="Object">
        <import symbol="Severity" />
        <scope name="new" ilk="function" signature="new(logdev, shift_age = 0, shift_size = 1048576)" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA; Logger.new(name, shift_age = 7, shift_size = 1048576)&#xA;Logger.new(name, shift_age = &apos;weekly&apos;)&#xA; Args &#xA; The log device.  This is a filename (String) or IO object (typically +STDOUT+, +STDERR+, or an open file).&#xA;Number of old log files to keep, *or* frequency of rotation (+daily+, +weekly+ or +monthly+).&#xA;Maximum logfile size (only applies when +shift_age+ is a number). &#xA; Description &#xA; Create an instance." />
        <scope name="add" ilk="function" signature="add(severity, message = nil, progname = nil, &amp;block)" doc="Synopsis &#xA; Logger#add(severity, message = nil, progname = nil) { ... }&#xA; Args &#xA; Severity.  Constants are defined in Logger namespace: +DEBUG+, +INFO+, +WARN+, +ERROR+, +FATAL+, or +UNKNOWN+.&#xA;The log message.  A String or Exception.&#xA;Program name string.  Can be omitted.  Treated as a message if no +message+ and +block+ are given.&#xA;Can be omitted.  Called to get a message string if +message+ is nil. &#xA; Return &#xA; +true+ if successful, +false+ otherwise. &#xA; When the given severity is not high enough (for this particular logger), log no message, and return +true+. &#xA; Description &#xA; Log a message if the given severity is high enough.  This is the generic logging method.  Users will be more inclined to use #debug, #info, #warn, #error, and #fatal. &#xA; &lt;b&gt;Message format&lt;/b&gt;: +message+ can be any object, but it has to be converted to a String in order to log it.  Generally, +inspect+ is used if the given object is not a String. A special case is an +Exception+ object, which will be printed in detail, including message, class, and backtrace.  See #msg2str for the implementation if required. " />
        <scope name="close" ilk="function" signature="close()" doc="Close the logging device." />
        <scope name="datetime_format" ilk="function" signature="datetime_format()" doc="Returns the date format being used.  See #datetime_format=" />
        <scope name="datetime_format=" ilk="function" signature="datetime_format=(datetime_format)" doc="Set date-time format. &#xA; A string suitable for passing to +strftime+." />
        <scope name="debug" ilk="function" signature="debug(progname = nil, &amp;block)" doc="Log a +DEBUG+ message. &#xA; See #info for more information." />
        <scope name="debug?" ilk="function" signature="debug?()" doc="Returns +true+ iff the current severity level allows for the printing of +DEBUG+ messages." />
        <scope name="error" ilk="function" signature="error(progname = nil, &amp;block)" doc="Log an +ERROR+ message. &#xA; See #info for more information." />
        <scope name="error?" ilk="function" signature="error?()" doc="Returns +true+ iff the current severity level allows for the printing of +ERROR+ messages." />
        <scope name="fatal" ilk="function" signature="fatal(progname = nil, &amp;block)" doc="Log a +FATAL+ message. &#xA; See #info for more information." />
        <scope name="fatal?" ilk="function" signature="fatal?()" doc="Returns +true+ iff the current severity level allows for the printing of +FATAL+ messages." />
        <scope name="info" ilk="function" signature="info(progname = nil, &amp;block)" doc="Log an +INFO+ message. &#xA; the message to log; does not need to be a String&#xA;in the block form, this is the #progname to use in the the log message.  The default can be set with #progname=&#xA;evaluates to the message to log.  This is not evaluated unless the logger&apos;s level is sufficient to log the message.  This allows you to create potentially expensive logging messages that are only called when the logger is configured to show them. &#xA; Examples &#xA; logger.info(&quot;MainApp&quot;) { &quot;Received connection from #{ip}&quot; }&#xA;# ...&#xA;logger.info &quot;Waiting for input from user&quot;&#xA;# ...&#xA;logger.info { &quot;User typed #{input}&quot; }&#xA; You&apos;ll probably stick to the second form above, unless you want to provide a program name (which you can do with #progname= as well). &#xA; Return &#xA; See #add." />
        <scope name="info?" ilk="function" signature="info?()" doc="Returns +true+ iff the current severity level allows for the printing of +INFO+ messages." />
        <scope name="log" ilk="function" signature="log(severity, message = nil, progname = nil, &amp;block)" />
        <scope name="unknown" ilk="function" signature="unknown(progname = nil, &amp;block)" doc="Log an +UNKNOWN+ message.  This will be printed no matter what the logger&apos;s level. &#xA; See #info for more information." />
        <scope name="warn" ilk="function" signature="warn(progname = nil, &amp;block)" doc="Log a +WARN+ message. &#xA; See #info for more information." />
        <scope name="warn?" ilk="function" signature="warn?()" doc="Returns +true+ iff the current severity level allows for the printing of +WARN+ messages." />
        <scope ilk="function" name="formatter" />
        <scope ilk="function" name="formatter=" />
        <scope ilk="function" name="level" />
        <scope ilk="function" name="level=" />
        <scope ilk="function" name="progname" />
        <scope ilk="function" name="progname=" />
        <scope ilk="function" name="sev_threshold" />
        <scope ilk="function" name="sev_threshold=" />
        <scope ilk="function" name="sev_threshold=" />
        <scope ilk="function" name="sev_threshold==" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="SEV_LABEL" attributes="__const__" citdl="Object" />
        <scope name="Application" ilk="class" classrefs="Object">
          <import symbol="Logger::Severity" />
          <scope name="new" ilk="function" signature="new(appname = nil)" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA; Application.new(appname = &apos;&apos;)&#xA; Args &#xA; Name of the application. &#xA; Description &#xA; Create an instance.  Log device is +STDERR+ by default.  This can be changed with #set_log." />
          <scope name="level=" ilk="function" signature="level=(level)" doc="Set the logging threshold, just like Logger#level=." />
          <scope name="log" ilk="function" signature="log(severity, message = nil, &amp;block)" doc="See Logger#add.  This application&apos;s +appname+ is used." />
          <scope name="log=" ilk="function" signature="log=(logdev)" />
          <scope name="logger" ilk="function" signature="logger()" doc="Logger for this application.  See the class Logger for an explanation." />
          <scope name="logger=" ilk="function" signature="logger=(logger)" doc="Sets the logger for this application.  See the class Logger for an explanation." />
          <scope name="set_log" ilk="function" signature="set_log(logdev, shift_age = 0, shift_size = 1024000)" doc="Sets the log device for this application.  See Logger.new for an explanation of the arguments." />
          <scope name="start" ilk="function" signature="start()" doc="Start the application.  Return the status code." />
          <scope ilk="function" name="appname" />
        </scope>
        <scope name="Formatter" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="call" ilk="function" signature="call(severity, time, progname, msg)" />
          <scope ilk="function" name="datetime_format" />
          <scope ilk="function" name="datetime_format=" />
        </scope>
        <scope name="LogDevice" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(log = nil, opt = {})" attributes="__classmethod__ __ctor__" />
          <scope name="close" ilk="function" signature="close()" />
          <scope name="write" ilk="function" signature="write(message)" />
          <scope ilk="function" name="dev" />
          <scope ilk="function" name="filename" />
          <scope name="LogDeviceMutex" ilk="class" classrefs="Object">
            <import symbol="MonitorMixin" />
          </scope>
        </scope>
        <scope name="Severity" ilk="namespace">
          <variable name="DEBUG" attributes="__const__" citdl="Object" />
          <variable name="INFO" attributes="__const__" citdl="Object" />
          <variable name="WARN" attributes="__const__" citdl="Object" />
          <variable name="ERROR" attributes="__const__" citdl="Object" />
          <variable name="FATAL" attributes="__const__" citdl="Object" />
          <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="matrix" ilk="blob" lang="Ruby">
      <scope name="Matrix" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="I" ilk="function" signature="I(n)" attributes="__classmethod__" />
        <scope name="build" ilk="function" signature="build(row_size, column_size = row_size)" attributes="__classmethod__" doc="Creates a matrix of size +row_size+ x +column_size+. It fills the values by calling the given block, passing the current row and column. Returns an enumerator if no block is given. &#xA; m = Matrix.build(2, 4) {|row, col| col - row }&#xA;  =&gt; Matrix[[0, 1, 2, 3], [-1, 0, 1, 2]]&#xA;m = Matrix.build(3) { rand }&#xA;  =&gt; a 3x3 matrix with random elements" />
        <scope name="column_vector" ilk="function" signature="column_vector(column)" attributes="__classmethod__" doc="Creates a single-column matrix where the values of that column are as given in +column+. Matrix.column_vector([4,5,6])&#xA;  =&gt; 4&#xA;     5&#xA;     6" />
        <scope name="columns" ilk="function" signature="columns(columns)" attributes="__classmethod__" doc="Creates a matrix using +columns+ as an array of column vectors. Matrix.columns([[25, 93], [-1, 66]])&#xA;   =&gt;  25 -1&#xA;       93 66" />
        <scope name="diagonal" ilk="function" signature="diagonal(*values)" attributes="__classmethod__" doc="Creates a matrix where the diagonal elements are composed of +values+. Matrix.diagonal(9, 5, -3)&#xA;  =&gt;  9  0  0&#xA;      0  5  0&#xA;      0  0 -3" />
        <scope name="empty" ilk="function" signature="empty(row_size = 0, column_size = 0)" attributes="__classmethod__" doc="Creates a empty matrix of +row_size+ x +column_size+. At least one of +row_size+ or +column_size+ must be 0. &#xA; m = Matrix.empty(2, 0)&#xA;m == Matrix[ [], [] ]&#xA;  =&gt; true&#xA;n = Matrix.empty(0, 3)&#xA;n == Matrix.columns([ [], [], [] ])&#xA;  =&gt; true&#xA;m * n&#xA;  =&gt; Matrix[[0, 0, 0], [0, 0, 0]]" />
        <scope name="identity" ilk="function" signature="identity(n)" attributes="__classmethod__" doc="Creates an +n+ by +n+ identity matrix. Matrix.identity(2)&#xA;  =&gt; 1 0&#xA;     0 1" />
        <scope name="new" ilk="function" signature="new(rows, column_size = rows[0].size)" attributes="__classmethod__ __ctor__" doc="Matrix.new is private; use Matrix.rows, columns, [], etc... to create." />
        <scope name="row_vector" ilk="function" signature="row_vector(row)" attributes="__classmethod__" doc="Creates a single-row matrix where the values of that row are as given in +row+. Matrix.row_vector([4,5,6])&#xA;  =&gt; 4 5 6" />
        <scope name="rows" ilk="function" signature="rows(rows, copy = true)" attributes="__classmethod__" doc="Creates a matrix where +rows+ is an array of arrays, each of which is a row of the matrix.  If the optional argument +copy+ is false, use the given arrays as the internal structure of the matrix without copying. Matrix.rows([[25, 93], [-1, 66]])&#xA;   =&gt;  25 93&#xA;       -1 66" />
        <scope name="scalar" ilk="function" signature="scalar(n, value)" attributes="__classmethod__" doc="Creates an +n+ by +n+ diagonal matrix where each diagonal element is +value+. Matrix.scalar(2, 5)&#xA;  =&gt; 5 0&#xA;     0 5" />
        <scope name="unit" ilk="function" signature="unit(n)" attributes="__classmethod__" />
        <scope name="zero" ilk="function" signature="zero(row_size, column_size = row_size)" attributes="__classmethod__" doc="Creates a zero matrix. Matrix.zero(2)&#xA;  =&gt; 0 0&#xA;     0 0" />
        <scope name="clone" ilk="function" signature="clone()" doc="Returns a clone of the matrix, so that the contents of each do not reference identical objects. There should be no good reason to do this since Matrices are immutable." />
        <scope name="coerce" ilk="function" signature="coerce(other)" doc="The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. See also Numeric#coerce." />
        <scope name="collect" ilk="function" signature="collect()" doc="Returns a matrix that is the result of iteration of the given block over all elements of the matrix. Matrix[ [1,2], [3,4] ].collect { |e| e**2 }&#xA;  =&gt; 1  4&#xA;     9 16" />
        <scope name="column" ilk="function" signature="column(j)" doc="Returns column vector number +j+ of the matrix as a Vector (starting at 0 like an array).  When a block is given, the elements of that vector are iterated." />
        <scope name="column_vectors" ilk="function" signature="column_vectors()" doc="Returns an array of the column vectors of the matrix.  See Vector." />
        <scope name="component" ilk="function" signature="component(i, j)" />
        <scope name="conj" ilk="function" signature="conj()" />
        <scope name="conjugate" ilk="function" signature="conjugate()" doc="Returns the conjugate of the matrix. Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;  =&gt; 1+2i   i  0&#xA;        1   2  3&#xA;Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].conjugate&#xA;  =&gt; 1-2i  -i  0&#xA;        1   2  3" />
        <scope name="det" ilk="function" signature="det()" />
        <scope name="det_e" ilk="function" signature="det_e()" />
        <scope name="determinant" ilk="function" signature="determinant()" doc="Returns the determinant of the matrix. &#xA; Beware that using Float values can yield erroneous results because of their lack of precision. Consider using exact types like Rational or BigDecimal instead. &#xA; Matrix[[7,6], [3,9]].determinant&#xA;  =&gt; 45" />
        <scope name="determinant_e" ilk="function" signature="determinant_e()" doc="deprecated; use Matrix#determinant" />
        <scope name="diagonal?" ilk="function" signature="diagonal?()" doc="Returns +true+ is this is a diagonal matrix. Raises an error if matrix is not square." />
        <scope name="each" ilk="function" signature="each(which = :all)" doc="Yields all elements of the matrix, starting with those of the first row, or returns an Enumerator is no block given. Elements can be restricted by passing an argument: :all (default): yields all elements&#xA;:diagonal: yields only elements on the diagonal&#xA;:off_diagonal: yields all elements except on the diagonal&#xA;:lower: yields only elements on or below the diagonal&#xA;:strict_lower: yields only elements below the diagonal&#xA;:strict_upper: yields only elements above the diagonal&#xA;:upper: yields only elements on or above the diagonal &#xA; Matrix[ [1,2], [3,4] ].each { |e| puts e } # =&gt; prints the numbers 1 to 4&#xA; Matrix[ [1,2], [3,4] ].each(:strict_lower).to_a # =&gt; [3]" />
        <scope name="each_with_index" ilk="function" signature="each_with_index(which = :all)" doc="Same as #each, but the row index and column index in addition to the element &#xA; Matrix[ [1,2], [3,4] ].each_with_index do |e, row, col|&#xA;  puts &quot;#{e} at #{row}, #{col}&quot;&#xA;end&#xA;  # =&gt; Prints:&#xA;  #    1 at 0, 0&#xA;  #    2 at 0, 1&#xA;  #    3 at 1, 0&#xA;  #    4 at 1, 1" />
        <scope name="eigen" ilk="function" signature="eigen()" />
        <scope name="eigensystem" ilk="function" signature="eigensystem()" doc="Returns the Eigensystem of the matrix; see +EigenvalueDecomposition+. m = Matrix[[1, 2], [3, 4]]&#xA;v, d, v_inv = m.eigensystem&#xA;d.diagonal? # =&gt; true&#xA;v.inv == v_inv # =&gt; true&#xA;(v * d * v_inv).round(5) == m # =&gt; true" />
        <scope name="element" ilk="function" signature="element(i, j)" />
        <scope name="elements_to_f" ilk="function" signature="elements_to_f()" />
        <scope name="elements_to_i" ilk="function" signature="elements_to_i()" />
        <scope name="elements_to_r" ilk="function" signature="elements_to_r()" />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if this is an empty matrix, i.e. if the number of rows or the number of columns is 0." />
        <scope name="eql?" ilk="function" signature="eql?(other)" />
        <scope name="find_index" ilk="function" signature="find_index(*args)" />
        <scope name="hash" ilk="function" signature="hash()" doc="Returns a hash-code for the matrix." />
        <scope name="hermitian?" ilk="function" signature="hermitian?()" doc="Returns +true+ is this is an hermitian matrix. Raises an error if matrix is not square." />
        <scope name="imag" ilk="function" signature="imag()" />
        <scope name="imaginary" ilk="function" signature="imaginary()" doc="Returns the imaginary part of the matrix. Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;  =&gt; 1+2i  i  0&#xA;        1  2  3&#xA;Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].imaginary&#xA;  =&gt;   2i  i  0&#xA;        0  0  0" />
        <scope name="index" ilk="function" signature="index(*args)" doc="The index method is specialized to return the index as [row, column] It also accepts an optional +selector+ argument, see #each for details. &#xA; Matrix[ [1,2], [3,4] ].index(&amp;:even?) # =&gt; [0, 1]&#xA;Matrix[ [1,1], [1,1] ].index(1, :strict_lower) # =&gt; [1, 0]" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Overrides Object#inspect" />
        <scope name="inv" ilk="function" signature="inv()" />
        <scope name="inverse" ilk="function" signature="inverse()" doc="Returns the inverse of the matrix. Matrix[[-1, -1], [0, -1]].inverse&#xA;  =&gt; -1  1&#xA;      0 -1" />
        <scope name="lower_triangular?" ilk="function" signature="lower_triangular?()" doc="Returns +true+ is this is a lower triangular matrix." />
        <scope name="lup" ilk="function" signature="lup()" doc="Returns the LUP decomposition of the matrix; see +LUPDecomposition+. a = Matrix[[1, 2], [3, 4]]&#xA;l, u, p = a.lup&#xA;l.lower_triangular? # =&gt; true&#xA;u.upper_triangular? # =&gt; true&#xA;p.permutation?      # =&gt; true&#xA;l * u == a * p      # =&gt; true&#xA;a.lup.solve([2, 5]) # =&gt; Vector[(1/1), (1/2)]" />
        <scope name="lup_decomposition" ilk="function" signature="lup_decomposition()" />
        <scope name="map" ilk="function" signature="map()" />
        <scope name="minor" ilk="function" signature="minor(*param)" doc="Returns a section of the matrix.  The parameters are either: start_row, nrows, start_col, ncols; OR&#xA;row_range, col_range &#xA; Matrix.diagonal(9, 5, -3).minor(0..1, 0..2)&#xA;  =&gt; 9 0 0&#xA;     0 5 0&#xA; Like Array#[], negative indices count backward from the end of the row or column (-1 is the last element). Returns nil if the starting row or column is greater than row_size or column_size respectively." />
        <scope name="normal?" ilk="function" signature="normal?()" doc="Returns +true+ is this is a normal matrix. Raises an error if matrix is not square." />
        <scope name="orthogonal?" ilk="function" signature="orthogonal?()" doc="Returns +true+ is this is an orthogonal matrix Raises an error if matrix is not square." />
        <scope name="permutation?" ilk="function" signature="permutation?()" doc="Returns +true+ is this is a permutation matrix Raises an error if matrix is not square." />
        <scope name="rank" ilk="function" signature="rank()" doc="Returns the rank of the matrix. Beware that using Float values can yield erroneous results because of their lack of precision. Consider using exact types like Rational or BigDecimal instead. &#xA; Matrix[[7,6], [3,9]].rank&#xA;  =&gt; 2" />
        <scope name="rank_e" ilk="function" signature="rank_e()" doc="deprecated; use Matrix#rank" />
        <scope name="real" ilk="function" signature="real()" doc="Returns the real part of the matrix. Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]]&#xA;  =&gt; 1+2i  i  0&#xA;        1  2  3&#xA;Matrix[[Complex(1,2), Complex(0,1), 0], [1, 2, 3]].real&#xA;  =&gt;    1  0  0&#xA;        1  2  3" />
        <scope name="real?" ilk="function" signature="real?()" doc="Returns +true+ if all entries of the matrix are real." />
        <scope name="rect" ilk="function" signature="rect()" doc="Returns an array containing matrices corresponding to the real and imaginary parts of the matrix &#xA; m.rect == [m.real, m.imag]  # ==&gt; true for all matrices m" />
        <scope name="rectangular" ilk="function" signature="rectangular()" />
        <scope name="regular?" ilk="function" signature="regular?()" doc="Returns +true+ if this is a regular (i.e. non-singular) matrix." />
        <scope name="round" ilk="function" signature="round(ndigits=0)" doc="Returns a matrix with entries rounded to the given precision (see Float#round)" />
        <scope name="row" ilk="function" signature="row(i)" doc="Returns row vector number +i+ of the matrix as a Vector (starting at 0 like an array).  When a block is given, the elements of that vector are iterated." />
        <scope name="row_size" ilk="function" signature="row_size()" doc="Returns the number of rows." />
        <scope name="row_vectors" ilk="function" signature="row_vectors()" doc="Returns an array of the row vectors of the matrix.  See Vector." />
        <scope name="singular?" ilk="function" signature="singular?()" doc="Returns +true+ is this is a singular matrix." />
        <scope name="square?" ilk="function" signature="square?()" doc="Returns +true+ is this is a square matrix." />
        <scope name="symmetric?" ilk="function" signature="symmetric?()" doc="Returns +true+ is this is a symmetric matrix. Raises an error if matrix is not square." />
        <scope name="t" ilk="function" signature="t()" />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns an array of arrays that describe the rows of the matrix." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Overrides Object#to_s" />
        <scope name="tr" ilk="function" signature="tr()" />
        <scope name="trace" ilk="function" signature="trace()" doc="Returns the trace (sum of diagonal elements) of the matrix. Matrix[[7,6], [3,9]].trace&#xA;  =&gt; 16" />
        <scope name="transpose" ilk="function" signature="transpose()" doc="Returns the transpose of the matrix. Matrix[[1,2], [3,4], [5,6]]&#xA;  =&gt; 1 2&#xA;     3 4&#xA;     5 6&#xA;Matrix[[1,2], [3,4], [5,6]].transpose&#xA;  =&gt; 1 3 5&#xA;     2 4 6" />
        <scope name="unitary?" ilk="function" signature="unitary?()" doc="Returns +true+ is this is a unitary matrix Raises an error if matrix is not square." />
        <scope name="upper_triangular?" ilk="function" signature="upper_triangular?()" doc="Returns +true+ is this is an upper triangular matrix." />
        <scope name="zero?" ilk="function" signature="zero?()" doc="Returns +true+ is this is a matrix with only zero elements" />
        <scope ilk="function" name="column_size" />
        <scope ilk="function" name="rows" />
        <variable name="SELECTORS" attributes="__const__" citdl="Object" />
      </scope>
      <scope name="Vector" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="elements" ilk="function" signature="elements(array, copy = true)" attributes="__classmethod__" doc="Creates a vector from an Array.  The optional second argument specifies whether the array itself or a copy is used internally." />
        <scope name="new" ilk="function" signature="new(array)" attributes="__classmethod__ __ctor__" doc="Vector.new is private; use Vector[] or Vector.elements to create." />
        <scope name="clone" ilk="function" signature="clone()" doc="Return a copy of the vector." />
        <scope name="coerce" ilk="function" signature="coerce(other)" doc="The coerce method provides support for Ruby type coercion. This coercion mechanism is used by Ruby to handle mixed-type numeric operations: it is intended to find a compatible common type between the two operands of the operator. See also Numeric#coerce." />
        <scope name="collect" ilk="function" signature="collect()" doc="Like Array#collect." />
        <scope name="collect2" ilk="function" signature="collect2(v)" doc="Collects (as in Enumerable#collect) over the elements of this vector and +v+ in conjunction." />
        <scope name="component" ilk="function" signature="component(i)" />
        <scope name="covector" ilk="function" signature="covector()" doc="Creates a single-row matrix from this vector." />
        <scope name="each" ilk="function" signature="each(&amp;block)" doc="Iterate over the elements of this vector" />
        <scope name="each2" ilk="function" signature="each2(v)" doc="Iterate over the elements of this vector and +v+ in conjunction." />
        <scope name="element" ilk="function" signature="element(i)" />
        <scope name="elements_to_f" ilk="function" signature="elements_to_f()" />
        <scope name="elements_to_i" ilk="function" signature="elements_to_i()" />
        <scope name="elements_to_r" ilk="function" signature="elements_to_r()" />
        <scope name="eql?" ilk="function" signature="eql?(other)" />
        <scope name="hash" ilk="function" signature="hash()" doc="Return a hash-code for the vector." />
        <scope name="inner_product" ilk="function" signature="inner_product(v)" doc="Returns the inner product of this vector with the other. Vector[4,7].inner_product Vector[10,1]  =&gt; 47" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Overrides Object#inspect" />
        <scope name="magnitude" ilk="function" signature="magnitude()" doc="Returns the modulus (Pythagorean distance) of the vector. Vector[5,8,2].r =&gt; 9.643650761" />
        <scope name="map" ilk="function" signature="map()" />
        <scope name="map2" ilk="function" signature="map2(v)" doc="Like Vector#collect2, but returns a Vector instead of an Array." />
        <scope name="norm" ilk="function" signature="norm()" />
        <scope name="normalize" ilk="function" signature="normalize()" doc="Returns a new vector with the same direction but with norm 1. v = Vector[5,8,2].normalize&#xA;# =&gt; Vector[0.5184758473652127, 0.8295613557843402, 0.20739033894608505]&#xA;v.norm =&gt; 1.0" />
        <scope name="r" ilk="function" signature="r()" />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of elements in the vector." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns the elements of the vector in an array." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Overrides Object#to_s" />
        <scope ilk="function" name="elements" />
        <scope name="ZeroVectorError" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="matrix/eigenvalue_decomposition" ilk="blob" lang="Ruby">
      <scope name="Matrix" ilk="namespace">
        <scope name="EigenvalueDecomposition" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(a)" attributes="__classmethod__ __ctor__" doc="Constructs the eigenvalue decomposition for a square matrix +A+" />
          <scope name="d" ilk="function" signature="d()" />
          <scope name="eigenvalue_matrix" ilk="function" signature="eigenvalue_matrix()" doc="Returns the block diagonal eigenvalue matrix +D+" />
          <scope name="eigenvalues" ilk="function" signature="eigenvalues()" doc="Returns the eigenvalues in an array" />
          <scope name="eigenvector_matrix" ilk="function" signature="eigenvector_matrix()" doc="Returns the eigenvector matrix +V+" />
          <scope name="eigenvector_matrix_inv" ilk="function" signature="eigenvector_matrix_inv()" doc="Returns the inverse of the eigenvector matrix +V+" />
          <scope name="eigenvectors" ilk="function" signature="eigenvectors()" doc="Returns an array of the eigenvectors" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="to_ary" ilk="function" signature="to_ary()" doc="Returns [eigenvector_matrix, eigenvalue_matrix, eigenvector_matrix_inv]" />
          <scope name="v" ilk="function" signature="v()" />
          <scope name="v_inv" ilk="function" signature="v_inv()" />
        </scope>
      </scope>
    </scope>
    <scope name="matrix/lup_decomposition" ilk="blob" lang="Ruby">
      <scope name="Matrix" ilk="namespace">
        <scope name="LUPDecomposition" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(a)" attributes="__classmethod__ __ctor__" />
          <scope name="det" ilk="function" signature="det()" doc="Returns the determinant of +A+, calculated efficiently from the factorization." />
          <scope name="determinant" ilk="function" signature="determinant()" />
          <scope name="l" ilk="function" signature="l()" />
          <scope name="p" ilk="function" signature="p()" doc="Returns the permutation matrix +P+" />
          <scope name="singular?" ilk="function" signature="singular?()" doc="Returns +true+ if +U+, and hence +A+, is singular." />
          <scope name="solve" ilk="function" signature="solve(b)" doc="Returns +m+ so that A*m = b, or equivalently so that L*U*m = P*b +b+ can be a Matrix or a Vector" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="to_ary" ilk="function" signature="to_ary()" doc="Returns +L+, +U+, +P+ in an array" />
          <scope name="u" ilk="function" signature="u()" doc="Returns the upper triangular factor +U+" />
          <scope ilk="function" name="pivots" />
        </scope>
      </scope>
    </scope>
    <scope name="minitest/mock" ilk="blob" lang="Ruby">
      <scope name="MiniTest" ilk="namespace">
        <variable name="MINI_DIR" attributes="__const__" citdl="Object" />
        <scope name="Mock" ilk="class" classrefs="Object">
          <scope name="expect" ilk="function" signature="expect(name, retval, args=[])" doc="Expect that method +name+ is called, optionally with +args+, and returns +retval+. &#xA; @mock.expect(:meaning_of_life, 42)&#xA;@mock.meaning_of_life # =&gt; 42&#xA;&#xA;@mock.expect(:do_something_with, true, [some_obj, true])&#xA;@mock.do_something_with(some_obj, true) # =&gt; true&#xA; +args+ is compared to the expected args using case equality (ie, the &apos;===&apos; operator), allowing for less specific expectations. &#xA; @mock.expect(:uses_any_string, true, [String])&#xA;@mock.uses_any_string(&quot;foo&quot;) # =&gt; true&#xA;@mock.verify  # =&gt; true&#xA;&#xA;@mock.expect(:uses_one_string, true, [&quot;foo&quot;]&#xA;@mock.uses_one_string(&quot;bar&quot;) # =&gt; true&#xA;@mock.verify  # =&gt; raises MockExpectationError" />
          <scope name="verify" ilk="function" signature="verify()" doc="Verify that all methods were called as expected. Raises +MockExpectationError+ if the mock object was not called as expected." />
        </scope>
      </scope>
      <scope name="MockExpectationError" ilk="class" classrefs="StandardError">
      </scope>
    </scope>
    <scope name="minitest/pride" ilk="blob" lang="Ruby">
      <scope name="PrideIO" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(io)" attributes="__classmethod__ __ctor__" />
        <scope name="method_missing" ilk="function" signature="method_missing(msg, *args)" />
        <scope name="pride" ilk="function" signature="pride(string)" />
        <scope name="print" ilk="function" signature="print(o)" />
        <scope name="puts" ilk="function" signature="puts(*o)" />
        <scope ilk="function" name="io" />
        <variable name="ESC" attributes="__const__" citdl="Object" />
        <variable name="NND" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="minitest/spec" ilk="blob" lang="Ruby">
      <scope name="MiniTest" ilk="namespace">
        <scope name="Expectations" ilk="namespace">
          <scope name="must_be" ilk="function" signature="must_be" doc="See MiniTest::Assertions#assert_operator &#xA; n.must_be :&lt;=, 42" />
          <scope name="must_be_empty" ilk="function" signature="must_be_empty" doc="See MiniTest::Assertions#assert_empty. &#xA; collection.must_be_empty" />
          <scope name="must_be_instance_of" ilk="function" signature="must_be_instance_of" doc="See MiniTest::Assertions#assert_instance_of &#xA; obj.must_be_instance_of klass" />
          <scope name="must_be_kind_of" ilk="function" signature="must_be_kind_of" doc="See MiniTest::Assertions#assert_kind_of &#xA; obj.must_be_kind_of mod" />
          <scope name="must_be_nil" ilk="function" signature="must_be_nil" doc="See MiniTest::Assertions#assert_nil &#xA; obj.must_be_nil" />
          <scope name="must_be_same_as" ilk="function" signature="must_be_same_as" doc="See MiniTest::Assertions#assert_same &#xA; a.must_be_same_as b" />
          <scope name="must_be_silent" ilk="function" signature="must_be_silent" doc="See MiniTest::Assertions#assert_silent &#xA; proc { ... }.must_be_silent" />
          <scope name="must_be_within_delta" ilk="function" signature="must_be_within_delta" doc="See MiniTest::Assertions#assert_in_delta &#xA; n.must_be_close_to m [, delta]" />
          <scope name="must_be_within_epsilon" ilk="function" signature="must_be_within_epsilon" doc="See MiniTest::Assertions#assert_in_epsilon &#xA; n.must_be_within_epsilon m [, epsilon]" />
          <scope name="must_equal" ilk="function" signature="must_equal" doc="See MiniTest::Assertions#assert_equal &#xA; a.must_equal b" />
          <scope name="must_include" ilk="function" signature="must_include" doc="See MiniTest::Assertions#assert_includes &#xA; collection.must_include obj" />
          <scope name="must_match" ilk="function" signature="must_match" doc="See MiniTest::Assertions#assert_match &#xA; a.must_match b" />
          <scope name="must_output" ilk="function" signature="must_output" doc="See MiniTest::Assertions#assert_output &#xA; proc { ... }.must_output out_or_nil [, err]" />
          <scope name="must_raise" ilk="function" signature="must_raise" doc="See MiniTest::Assertions#assert_raises &#xA; proc { ... }.must_raise exception" />
          <scope name="must_respond_to" ilk="function" signature="must_respond_to" doc="See MiniTest::Assertions#assert_respond_to &#xA; obj.must_respond_to msg" />
          <scope name="must_send" ilk="function" signature="must_send" doc="See MiniTest::Assertions#assert_send TODO: remove me &#xA; a.must_send" />
          <scope name="must_throw" ilk="function" signature="must_throw" doc="See MiniTest::Assertions#assert_throws &#xA; proc { ... }.must_throw sym" />
          <scope name="wont_be" ilk="function" signature="wont_be" doc="See MiniTest::Assertions#refute_operator &#xA; n.wont_be :&lt;=, 42" />
          <scope name="wont_be_close_to" ilk="function" signature="wont_be_close_to" />
          <scope name="wont_be_empty" ilk="function" signature="wont_be_empty" doc="See MiniTest::Assertions#refute_empty &#xA; collection.wont_be_empty" />
          <scope name="wont_be_instance_of" ilk="function" signature="wont_be_instance_of" doc="See MiniTest::Assertions#refute_instance_of &#xA; obj.wont_be_instance_of klass" />
          <scope name="wont_be_kind_of" ilk="function" signature="wont_be_kind_of" doc="See MiniTest::Assertions#refute_kind_of &#xA; obj.wont_be_kind_of mod" />
          <scope name="wont_be_nil" ilk="function" signature="wont_be_nil" doc="See MiniTest::Assertions#refute_nil &#xA; obj.wont_be_nil" />
          <scope name="wont_be_same_as" ilk="function" signature="wont_be_same_as" doc="See MiniTest::Assertions#refute_same &#xA; a.wont_be_same_as b" />
          <scope name="wont_be_within_delta" ilk="function" signature="wont_be_within_delta" doc="See MiniTest::Assertions#refute_in_delta &#xA; n.wont_be_close_to m [, delta]" />
          <scope name="wont_be_within_epsilon" ilk="function" signature="wont_be_within_epsilon" doc="See MiniTest::Assertions#refute_in_epsilon &#xA; n.wont_be_within_epsilon m [, epsilon]" />
          <scope name="wont_equal" ilk="function" signature="wont_equal" doc="See MiniTest::Assertions#refute_equal &#xA; a.wont_equal b" />
          <scope name="wont_include" ilk="function" signature="wont_include" doc="See MiniTest::Assertions#refute_includes &#xA; collection.wont_include obj" />
          <scope name="wont_match" ilk="function" signature="wont_match" doc="See MiniTest::Assertions#refute_match &#xA; a.wont_match b" />
          <scope name="wont_respond_to" ilk="function" signature="wont_respond_to" doc="See MiniTest::Assertions#refute_respond_to &#xA; obj.wont_respond_to msg" />
        </scope>
        <scope name="Spec" ilk="class" classrefs="MiniTest::Unit::TestCase">
          <scope name="after" ilk="function" signature="after(type = :each, &amp;block)" attributes="__classmethod__" doc="Define an &apos;after&apos; action. Inherits the way normal methods should. &#xA; NOTE: +type+ is ignored and is only there to make porting easier. &#xA; Equivalent to MiniTest::Unit::TestCase#teardown." />
          <scope name="before" ilk="function" signature="before(type = :each, &amp;block)" attributes="__classmethod__" doc="Define a &apos;before&apos; action. Inherits the way normal methods should. &#xA; NOTE: +type+ is ignored and is only there to make porting easier. &#xA; Equivalent to MiniTest::Unit::TestCase#setup." />
          <scope name="bench" ilk="function" signature="bench(name, &amp;block)" attributes="__classmethod__" doc="This is used to define a new benchmark method. You usually don&apos;t use this directly and is intended for those needing to write new performance curve fits (eg: you need a specific polynomial fit). &#xA; See ::bench_performance_linear for an example of how to use this." />
          <scope name="bench_performance_constant" ilk="function" signature="bench_performance_constant(name, threshold = 0.99, &amp;work)" attributes="__classmethod__" doc="Create a benchmark that verifies that the performance is constant. &#xA; describe &quot;my class&quot; do&#xA;  bench_performance_constant &quot;zoom_algorithm!&quot; do&#xA;    @obj.zoom_algorithm!&#xA;  end&#xA;end" />
          <scope name="bench_performance_exponential" ilk="function" signature="bench_performance_exponential(name, threshold = 0.99, &amp;work)" attributes="__classmethod__" doc="Create a benchmark that verifies that the performance is exponential. &#xA; describe &quot;my class&quot; do&#xA;  bench_performance_exponential &quot;algorithm&quot; do&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
          <scope name="bench_performance_linear" ilk="function" signature="bench_performance_linear(name, threshold = 0.99, &amp;work)" attributes="__classmethod__" doc="Create a benchmark that verifies that the performance is linear. &#xA; describe &quot;my class&quot; do&#xA;  bench_performance_linear &quot;fast_algorithm&quot;, 0.9999 do&#xA;    @obj.fast_algorithm&#xA;  end&#xA;end" />
          <scope name="bench_range" ilk="function" signature="bench_range(&amp;block)" attributes="__classmethod__" />
          <scope name="children" ilk="function" signature="children()" attributes="__classmethod__" doc="Returns the children of this spec." />
          <scope name="it" ilk="function" signature="it(desc, &amp;block)" attributes="__classmethod__" doc="Define an expectation with name +desc+. Name gets morphed to a proper test method name. For some freakish reason, people who write specs don&apos;t like class inheritence, so this goes way out of its way to make sure that expectations aren&apos;t inherited. &#xA; Hint: If you _do_ want inheritence, use minitest/unit. You can mix and match between assertions and expectations as much as you want." />
          <scope name="let" ilk="function" signature="let(name, &amp;block)" attributes="__classmethod__" />
          <scope name="register_spec_type" ilk="function" signature="register_spec_type(*args, &amp;block)" attributes="__classmethod__" doc="Register a new type of spec that matches the spec&apos;s description. This method can take either a Regexp and a spec class or a spec class and a block that takes the description and returns true if it matches. &#xA; Eg: &#xA; register_spec_type(/Controller$/, MiniTest::Spec::Rails)&#xA; or: &#xA; register_spec_type(MiniTest::Spec::RailsModel) do |desc|&#xA;  desc.superclass == ActiveRecord::Base&#xA;end" />
          <scope name="spec_type" ilk="function" signature="spec_type(desc)" attributes="__classmethod__" doc="Figure out the spec class to use based on a spec&apos;s description. Eg: &#xA; spec_type(&quot;BlahController&quot;) # =&gt; MiniTest::Spec::Rails" />
          <scope name="subject" ilk="function" signature="subject(&amp;block)" attributes="__classmethod__" />
          <variable name="TYPES" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="minitest/unit" ilk="blob" lang="Ruby">
      <scope name="MiniTest" ilk="namespace">
        <scope name="Assertion" ilk="class" classrefs="Exception">
        </scope>
        <scope name="Assertions" ilk="namespace">
          <scope name="diff" ilk="function" signature="diff()" attributes="__classmethod__" doc="Returns the diff command to use in #diff. Tries to intelligently figure out what diff to use." />
          <scope name="diff=" ilk="function" signature="diff=(o)" attributes="__classmethod__" doc="Set the diff command to use in #diff." />
          <scope name="assert" ilk="function" signature="assert(test, msg = nil)" doc="Fails unless +test+ is a true value." />
          <scope name="assert_block" ilk="function" signature="assert_block(msg = nil)" doc="Fails unless the block returns a true value." />
          <scope name="assert_empty" ilk="function" signature="assert_empty(obj, msg = nil)" doc="Fails unless +obj+ is empty." />
          <scope name="assert_equal" ilk="function" signature="assert_equal(exp, act, msg = nil)" doc="Fails unless exp == act printing the difference between the two, if possible. &#xA; If there is no visible difference but the assertion fails, you should suspect that your == is buggy, or your inspect output is missing crucial details. &#xA; For floats use assert_in_delta. &#xA; See also: MiniTest::Assertions.diff" />
          <scope name="assert_in_delta" ilk="function" signature="assert_in_delta(exp, act, delta = 0.001, msg = nil)" doc="For comparing Floats.  Fails unless +exp+ and +act+ are within +delta+ of each other. &#xA; assert_in_delta Math::PI, (22.0 / 7.0), 0.01" />
          <scope name="assert_in_epsilon" ilk="function" signature="assert_in_epsilon(a, b, epsilon = 0.001, msg = nil)" doc="For comparing Floats.  Fails unless +exp+ and +act+ have a relative error less than +epsilon+." />
          <scope name="assert_includes" ilk="function" signature="assert_includes(collection, obj, msg = nil)" doc="Fails unless +collection+ includes +obj+." />
          <scope name="assert_instance_of" ilk="function" signature="assert_instance_of(cls, obj, msg = nil)" doc="Fails unless +obj+ is an instace of +cls+." />
          <scope name="assert_kind_of" ilk="function" signature="assert_kind_of(cls, obj, msg = nil)" doc="Fails unless +obj+ is a kind of +cls+." />
          <scope name="assert_match" ilk="function" signature="assert_match(exp, act, msg = nil)" doc="Fails unless +exp+ is =~ +act+." />
          <scope name="assert_nil" ilk="function" signature="assert_nil(obj, msg = nil)" doc="Fails unless +obj+ is nil" />
          <scope name="assert_operator" ilk="function" signature="assert_operator(o1, op, o2, msg = nil)" doc="For testing equality operators and so-forth. &#xA; assert_operator 5, :&lt;=, 4" />
          <scope name="assert_output" ilk="function" signature="assert_output(stdout = nil, stderr = nil)" doc="Fails if stdout or stderr do not output the expected results. Pass in nil if you don&apos;t care about that streams output. Pass in &quot;&quot; if you require it to be silent. &#xA; See also: #assert_silent" />
          <scope name="assert_raises" ilk="function" signature="assert_raises(*exp)" doc="Fails unless the block raises one of +exp+" />
          <scope name="assert_respond_to" ilk="function" signature="assert_respond_to(obj, meth, msg = nil)" doc="Fails unless +obj+ responds to +meth+." />
          <scope name="assert_same" ilk="function" signature="assert_same(exp, act, msg = nil)" doc="Fails unless +exp+ and +act+ are #equal?" />
          <scope name="assert_send" ilk="function" signature="assert_send(send_ary, m = nil)" doc="+send_ary+ is a receiver, message and arguments. &#xA; Fails unless the call returns a true value TODO: I should prolly remove this from specs" />
          <scope name="assert_silent" ilk="function" signature="assert_silent()" doc="Fails if the block outputs anything to stderr or stdout. &#xA; See also: #assert_output" />
          <scope name="assert_throws" ilk="function" signature="assert_throws(sym, msg = nil)" doc="Fails unless the block throws +sym+" />
          <scope name="capture_io" ilk="function" signature="capture_io()" doc="Captures $stdout and $stderr into strings: &#xA; out, err = capture_io do&#xA;  warn &quot;You did a bad thing&quot;&#xA;end&#xA;&#xA;assert_match %r%bad%, err" />
          <scope name="diff" ilk="function" signature="diff(exp, act)" doc="Returns a diff between +exp+ and +act+. If there is no known diff command or if it doesn&apos;t make sense to diff the output (single line, short output), then it simply returns a basic comparison between the two." />
          <scope name="exception_details" ilk="function" signature="exception_details(e, msg)" doc="Returns details for exception +e+" />
          <scope name="flunk" ilk="function" signature="flunk(msg = nil)" doc="Fails with +msg+" />
          <scope name="message" ilk="function" signature="message(msg = nil, ending = &quot;.&quot;, &amp;default)" doc="Returns a proc that will output +msg+ along with the default message." />
          <scope name="mu_pp" ilk="function" signature="mu_pp(obj)" doc="This returns a human-readable version of +obj+. By default #inspect is called. You can override this to use #pretty_print if you want." />
          <scope name="mu_pp_for_diff" ilk="function" signature="mu_pp_for_diff(obj)" doc="This returns a diff-able human-readable version of +obj+. This differs from the regular mu_pp because it expands escaped newlines and makes hex-values generic (like object_ids). This uses mu_pp to do the first pass and then cleans it up." />
          <scope name="pass" ilk="function" signature="pass(msg = nil)" doc="used for counting assertions" />
          <scope name="refute" ilk="function" signature="refute(test, msg = nil)" doc="Fails if +test+ is a true value" />
          <scope name="refute_empty" ilk="function" signature="refute_empty(obj, msg = nil)" doc="Fails if +obj+ is empty." />
          <scope name="refute_equal" ilk="function" signature="refute_equal(exp, act, msg = nil)" doc="Fails if exp == act. &#xA; For floats use refute_in_delta." />
          <scope name="refute_in_delta" ilk="function" signature="refute_in_delta(exp, act, delta = 0.001, msg = nil)" doc="For comparing Floats.  Fails if +exp+ is within +delta+ of +act+ &#xA; refute_in_delta Math::PI, (22.0 / 7.0)" />
          <scope name="refute_in_epsilon" ilk="function" signature="refute_in_epsilon(a, b, epsilon = 0.001, msg = nil)" doc="For comparing Floats.  Fails if +exp+ and +act+ have a relative error less than +epsilon+." />
          <scope name="refute_includes" ilk="function" signature="refute_includes(collection, obj, msg = nil)" doc="Fails if +collection+ includes +obj+" />
          <scope name="refute_instance_of" ilk="function" signature="refute_instance_of(cls, obj, msg = nil)" doc="Fails if +obj+ is an instance of +cls+" />
          <scope name="refute_kind_of" ilk="function" signature="refute_kind_of(cls, obj, msg = nil)" doc="Fails if +obj+ is a kind of +cls+" />
          <scope name="refute_match" ilk="function" signature="refute_match(exp, act, msg = nil)" doc="Fails if +exp+ =~ +act+" />
          <scope name="refute_nil" ilk="function" signature="refute_nil(obj, msg = nil)" doc="Fails if +obj+ is nil." />
          <scope name="refute_operator" ilk="function" signature="refute_operator(o1, op, o2, msg = nil)" doc="Fails if +o1+ is not +op+ +o2+. Eg: &#xA; refute_operator 1, :&gt;, 2 =&gt; pass&#xA;refute_operator 1, :&lt;, 2 =&gt; fail" />
          <scope name="refute_respond_to" ilk="function" signature="refute_respond_to(obj, meth, msg = nil)" doc="Fails if +obj+ responds to the message +meth+." />
          <scope name="refute_same" ilk="function" signature="refute_same(exp, act, msg = nil)" doc="Fails if +exp+ is the same (by object identity) as +act+." />
          <scope name="skip" ilk="function" signature="skip(msg = nil, bt = caller)" doc="Skips the current test. Gets listed at the end of the run but doesn&apos;t cause a failure exit code." />
          <variable name="WINDOZE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Skip" ilk="class" classrefs="MiniTest::Assertion">
        </scope>
        <scope name="Unit" ilk="class" classrefs="Object">
          <scope name="after_tests" ilk="function" signature="after_tests()" attributes="__classmethod__" doc="A simple hook allowing you to run a block of code after the tests are done. Eg: &#xA; MiniTest::Unit.after_tests { p $debugging_info }" />
          <scope name="autorun" ilk="function" signature="autorun()" attributes="__classmethod__" doc="Registers MiniTest::Unit to run tests at process exit" />
          <scope name="out" ilk="function" signature="out()" attributes="__classmethod__" doc="Returns the stream to use for output. &#xA; DEPRECATED: use ::output instead." />
          <scope name="output" ilk="function" signature="output()" attributes="__classmethod__" doc="Returns the stream to use for output." />
          <scope name="output=" ilk="function" signature="output=(stream)" attributes="__classmethod__" doc="Sets MiniTest::Unit to write output to +stream+.  $stdout is the default output" />
          <scope name="plugins" ilk="function" signature="plugins()" attributes="__classmethod__" doc="Return all plugins&apos; run methods (methods that start with &quot;run_&quot;)." />
          <scope name="runner" ilk="function" signature="runner()" attributes="__classmethod__" doc="Returns the MiniTest::Unit subclass instance that will be used to run the tests. A MiniTest::Unit instance is the default runner." />
          <scope name="runner=" ilk="function" signature="runner=(runner)" attributes="__classmethod__" doc="Tells MiniTest::Unit to delegate to +runner+, an instance of a MiniTest::Unit subclass, when MiniTest::Unit#run is called." />
          <scope name="_run" ilk="function" signature="_run(args = [])" doc="Top level driver, controls all output and filtering." />
          <scope name="_run_anything" ilk="function" signature="_run_anything(type)" />
          <scope name="_run_suite" ilk="function" signature="_run_suite(suite, type)" />
          <scope name="_run_suites" ilk="function" signature="_run_suites(suites, type)" />
          <scope name="options" ilk="function" signature="options()" />
          <scope name="output" ilk="function" signature="output()" />
          <scope name="process_args" ilk="function" signature="process_args(args = [])" />
          <scope name="puke" ilk="function" signature="puke(klass, meth, e)" doc="Writes status for failed test +meth+ in +klass+ which finished with exception +e+" />
          <scope name="run" ilk="function" signature="run(args = [])" doc="Begins the full test run. Delegates to +runner+&apos;s #_run method." />
          <scope name="run_tests" ilk="function" signature="run_tests()" doc="Runs test suites matching +filter+." />
          <scope name="status" ilk="function" signature="status(io = self.output)" doc="Writes status to +io+" />
          <scope ilk="function" name="runner" />
          <scope ilk="function" name="runner=" />
          <variable name="VERSION" attributes="__const__" citdl="Object" />
          <scope name="TestCase" ilk="class" classrefs="Object">
            <import symbol="MiniTest::Assertions" />
            <scope name="add_setup_hook" ilk="function" signature="add_setup_hook(arg=nil, &amp;block)" attributes="__classmethod__" doc="Adds a block of code that will be executed before every TestCase is run. Equivalent to +setup+, but usable multiple times and without re-opening any classes. &#xA; All of the setup hooks will run in order after the +setup+ method, if one is defined. &#xA; The argument can be any object that responds to #call or a block. That means that this call, &#xA; MiniTest::TestCase.add_setup_hook { puts &quot;foo&quot; }&#xA; ... is equivalent to: &#xA; module MyTestSetup&#xA;  def call&#xA;    puts &quot;foo&quot;&#xA;  end&#xA;end&#xA;&#xA;MiniTest::TestCase.add_setup_hook MyTestSetup&#xA; The blocks passed to +add_setup_hook+ take an optional parameter that will be the TestCase instance that is executing the block." />
            <scope name="add_teardown_hook" ilk="function" signature="add_teardown_hook(arg=nil, &amp;block)" attributes="__classmethod__" doc="Adds a block of code that will be executed after every TestCase is run. Equivalent to +teardown+, but usable multiple times and without re-opening any classes. &#xA; All of the teardown hooks will run in reverse order after the +teardown+ method, if one is defined. &#xA; The argument can be any object that responds to #call or a block. That means that this call, &#xA; MiniTest::TestCase.add_teardown_hook { puts &quot;foo&quot; }&#xA; ... is equivalent to: &#xA; module MyTestTeardown&#xA;  def call&#xA;    puts &quot;foo&quot;&#xA;  end&#xA;end&#xA;&#xA;MiniTest::TestCase.add_teardown_hook MyTestTeardown&#xA; The blocks passed to +add_teardown_hook+ take an optional parameter that will be the TestCase instance that is executing the block." />
            <scope name="bench_exp" ilk="function" signature="bench_exp(min, max, base = 10)" attributes="__classmethod__" doc="Returns a set of ranges stepped exponentially from +min+ to +max+ by powers of +base+. Eg: &#xA; bench_exp(2, 16, 2) # =&gt; [2, 4, 8, 16]" />
            <scope name="bench_linear" ilk="function" signature="bench_linear(min, max, step = 10)" attributes="__classmethod__" doc="Returns a set of ranges stepped linearly from +min+ to +max+ by +step+. Eg: &#xA; bench_linear(20, 40, 10) # =&gt; [20, 30, 40]" />
            <scope name="bench_range" ilk="function" signature="bench_range()" attributes="__classmethod__" doc="Specifies the ranges used for benchmarking for that class. Defaults to exponential growth from 1 to 10k by powers of 10. Override if you need different ranges for your benchmarks. &#xA; See also: ::bench_exp and ::bench_linear." />
            <scope name="benchmark_suites" ilk="function" signature="benchmark_suites()" attributes="__classmethod__" doc="Returns all test suites that have benchmark methods." />
            <scope name="i_suck_and_my_tests_are_order_dependent!" ilk="function" signature="i_suck_and_my_tests_are_order_dependent!()" attributes="__classmethod__" doc="Call this at the top of your tests when you absolutely positively need to have ordered tests. In doing so, you&apos;re admitting that you suck and your tests are weak." />
            <scope name="assert_performance" ilk="function" signature="assert_performance(validation, &amp;work)" doc="Runs the given +work+, gathering the times of each run. Range and times are then passed to a given +validation+ proc. Outputs the benchmark name and times in tab-separated format, making it easy to paste into a spreadsheet for graphing or further analysis. &#xA; Ranges are specified by ::bench_range. &#xA; Eg: &#xA; def bench_algorithm&#xA;  validation = proc { |x, y| ... }&#xA;  assert_performance validation do |x|&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
            <scope name="assert_performance_constant" ilk="function" signature="assert_performance_constant(threshold = 0.99, &amp;work)" doc="Runs the given +work+ and asserts that the times gathered fit to match a constant rate (eg, linear slope == 0) within a given +threshold+. Note: because we&apos;re testing for a slope of 0, R^2 is not a good determining factor for the fit, so the threshold is applied against the slope itself. As such, you probably want to tighten it from the default. &#xA; See http://www.graphpad.com/curvefit/goodness_of_fit.htm for more details. &#xA; Fit is calculated by #fit_linear. &#xA; Ranges are specified by ::bench_range. &#xA; Eg: &#xA; def bench_algorithm&#xA;  assert_performance_constant 0.9999 do |x|&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
            <scope name="assert_performance_exponential" ilk="function" signature="assert_performance_exponential(threshold = 0.99, &amp;work)" doc="Runs the given +work+ and asserts that the times gathered fit to match a exponential curve within a given error +threshold+. &#xA; Fit is calculated by #fit_exponential. &#xA; Ranges are specified by ::bench_range. &#xA; Eg: &#xA; def bench_algorithm&#xA;  assert_performance_exponential 0.9999 do |x|&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
            <scope name="assert_performance_linear" ilk="function" signature="assert_performance_linear(threshold = 0.99, &amp;work)" doc="Runs the given +work+ and asserts that the times gathered fit to match a straight line within a given error +threshold+. &#xA; Fit is calculated by #fit_linear. &#xA; Ranges are specified by ::bench_range. &#xA; Eg: &#xA; def bench_algorithm&#xA;  assert_performance_linear 0.9999 do |x|&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
            <scope name="assert_performance_power" ilk="function" signature="assert_performance_power(threshold = 0.99, &amp;work)" doc="Runs the given +work+ and asserts that the times gathered curve fit to match a power curve within a given error +threshold+. &#xA; Fit is calculated by #fit_power. &#xA; Ranges are specified by ::bench_range. &#xA; Eg: &#xA; def bench_algorithm&#xA;  assert_performance_power 0.9999 do |x|&#xA;    @obj.algorithm&#xA;  end&#xA;end" />
            <scope name="fit_error" ilk="function" signature="fit_error(xys)" doc="Takes an array of x/y pairs and calculates the general R^2 value. &#xA; See: http://en.wikipedia.org/wiki/Coefficient_of_determination" />
            <scope name="fit_exponential" ilk="function" signature="fit_exponential(xs, ys)" doc="To fit a functional form: y = ae^(bx). &#xA; Takes x and y values and returns [a, b, r^2]. &#xA; See: http://mathworld.wolfram.com/LeastSquaresFittingExponential.html" />
            <scope name="fit_linear" ilk="function" signature="fit_linear(xs, ys)" doc="Fits the functional form: a + bx. &#xA; Takes x and y values and returns [a, b, r^2]. &#xA; See: http://mathworld.wolfram.com/LeastSquaresFitting.html" />
            <scope name="fit_power" ilk="function" signature="fit_power(xs, ys)" doc="To fit a functional form: y = ax^b. &#xA; Takes x and y values and returns [a, b, r^2]. &#xA; See: http://mathworld.wolfram.com/LeastSquaresFittingPowerLaw.html" />
            <scope name="io" ilk="function" signature="io()" />
            <scope name="io?" ilk="function" signature="io?()" />
            <scope name="passed?" ilk="function" signature="passed?()" doc="Returns true if the test passed." />
            <scope name="run" ilk="function" signature="run(runner)" doc="Runs the tests reporting the status to +runner+" />
            <scope name="setup" ilk="function" signature="setup()" doc="Runs before every test. Use this to refactor test initialization." />
            <scope name="sigma" ilk="function" signature="sigma(enum, &amp;block)" doc="Enumerates over +enum+ mapping +block+ if given, returning the sum of the result. Eg: &#xA; sigma([1, 2, 3])                # =&gt; 1 + 2 + 3 =&gt; 7&#xA;sigma([1, 2, 3]) { |n| n ** 2 } # =&gt; 1 + 4 + 9 =&gt; 14" />
            <scope name="teardown" ilk="function" signature="teardown()" doc="Runs after every test. Use this to refactor test cleanup." />
            <scope name="validation_for_fit" ilk="function" signature="validation_for_fit(msg, threshold)" doc="Returns a proc that calls the specified fit method and asserts that the error is within a tolerable threshold." />
            <variable name="PASSTHROUGH_EXCEPTIONS" attributes="__const__" citdl="Object" />
            <variable name="SUPPORTS_INFO_SIGNAL" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="mutex_m" ilk="blob" lang="Ruby">
      <scope name="Mutex_m" ilk="namespace">
        <scope name="append_features" ilk="function" signature="append_features(cl)" attributes="__classmethod__" />
        <scope name="define_aliases" ilk="function" signature="define_aliases(cl)" attributes="__classmethod__" />
        <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
        <scope name="mu_extended" ilk="function" signature="mu_extended()" />
        <scope name="mu_lock" ilk="function" signature="mu_lock()" />
        <scope name="mu_locked?" ilk="function" signature="mu_locked?()" />
        <scope name="mu_synchronize" ilk="function" signature="mu_synchronize(&amp;block)" doc="locking" />
        <scope name="mu_try_lock" ilk="function" signature="mu_try_lock()" />
        <scope name="mu_unlock" ilk="function" signature="mu_unlock()" />
        <scope name="sleep" ilk="function" signature="sleep(timeout = nil)" />
      </scope>
    </scope>
    <scope name="net/ftp" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="FTP" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(host = nil, user = nil, passwd = nil, acct = nil)" attributes="__classmethod__ __ctor__" doc="Creates and returns a new +FTP+ object. If a +host+ is given, a connection is made. Additionally, if the +user+ is given, the given user name, password, and (optionally) account are used to log in.  See #login." />
          <scope name="open" ilk="function" signature="open(host, user = nil, passwd = nil, acct = nil)" attributes="__classmethod__" doc="A synonym for FTP.new, but with a mandatory host parameter. &#xA; If a block is given, it is passed the +FTP+ object, which will be closed when the block finishes, or when an exception is raised." />
          <scope name="abort" ilk="function" signature="abort()" doc="Aborts the previous command (ABOR command)." />
          <scope name="acct" ilk="function" signature="acct(account)" doc="Sends the ACCT command. &#xA; This is a less common FTP command, to send account information if the destination host requires it." />
          <scope name="binary=" ilk="function" signature="binary=(newmode)" doc="A setter to toggle transfers in binary mode. +newmode+ is either +true+ or +false+" />
          <scope name="chdir" ilk="function" signature="chdir(dirname)" doc="Changes the (remote) directory." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the connection.  Further operations are impossible until you open a new connection with #connect." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Returns +true+ iff the connection is closed." />
          <scope name="connect" ilk="function" signature="connect(host, port = FTP_PORT)" doc="Establishes an FTP connection to host, optionally overriding the default port. If the environment variable +SOCKS_SERVER+ is set, sets up the connection through a SOCKS proxy. Raises an exception (typically Errno::ECONNREFUSED) if the connection cannot be established." />
          <scope name="delete" ilk="function" signature="delete(filename)" doc="Deletes a file on the server." />
          <scope name="dir" ilk="function" signature="dir(*args)" />
          <scope name="get" ilk="function" signature="get(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE)" doc="Retrieves +remotefile+ in whatever mode the session is set (text or binary).  See #gettextfile and #getbinaryfile." />
          <scope name="getbinaryfile" ilk="function" signature="getbinaryfile(remotefile, localfile = File.basename(remotefile), blocksize = DEFAULT_BLOCKSIZE)" doc="Retrieves +remotefile+ in binary mode, storing the result in +localfile+. If +localfile+ is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data in +blocksize+ chunks." />
          <scope name="getdir" ilk="function" signature="getdir()" />
          <scope name="gettextfile" ilk="function" signature="gettextfile(remotefile, localfile = File.basename(remotefile))" doc="Retrieves +remotefile+ in ASCII (text) mode, storing the result in +localfile+. If +localfile+ is nil, returns retrieved data. If a block is supplied, it is passed the retrieved data one line at a time." />
          <scope name="help" ilk="function" signature="help(arg = nil)" doc="Issues the HELP command." />
          <scope name="list" ilk="function" signature="list(*args)" doc="Returns an array of file information in the directory (the output is like `ls -l`).  If a block is given, it iterates through the listing." />
          <scope name="login" ilk="function" signature="login(user = &quot;anonymous&quot;, passwd = nil, acct = nil)" doc="Logs in to the remote host. The session must have been previously connected.  If +user+ is the string &quot;anonymous&quot; and the +password+ is +nil+, a password of user@host is synthesized. If the +acct+ parameter is not +nil+, an FTP ACCT command is sent following the successful login.  Raises an exception on error (typically Net::FTPPermError)." />
          <scope name="ls" ilk="function" signature="ls(*args)" />
          <scope name="mdtm" ilk="function" signature="mdtm(filename)" doc="Issues the MDTM command.  TODO: more info." />
          <scope name="mkdir" ilk="function" signature="mkdir(dirname)" doc="Creates a remote directory." />
          <scope name="mtime" ilk="function" signature="mtime(filename, local = false)" doc="Returns the last modification time of the (remote) file.  If +local+ is +true+, it is returned as a local time, otherwise it&apos;s a UTC time." />
          <scope name="nlst" ilk="function" signature="nlst(dir = nil)" doc="Returns an array of filenames in the remote directory." />
          <scope name="noop" ilk="function" signature="noop()" doc="Issues a NOOP command. &#xA; Does nothing except return a response." />
          <scope name="put" ilk="function" signature="put(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE, &amp;block)" doc="Transfers +localfile+ to the server in whatever mode the session is set (text or binary).  See #puttextfile and #putbinaryfile." />
          <scope name="putbinaryfile" ilk="function" signature="putbinaryfile(localfile, remotefile = File.basename(localfile), blocksize = DEFAULT_BLOCKSIZE)" doc="Transfers +localfile+ to the server in binary mode, storing the result in +remotefile+. If a block is supplied, calls it, passing in the transmitted data in +blocksize+ chunks." />
          <scope name="puttextfile" ilk="function" signature="puttextfile(localfile, remotefile = File.basename(localfile))" doc="Transfers +localfile+ to the server in ASCII (text) mode, storing the result in +remotefile+. If callback or an associated block is supplied, calls it, passing in the transmitted data one line at a time." />
          <scope name="pwd" ilk="function" signature="pwd()" doc="Returns the current remote directory." />
          <scope name="quit" ilk="function" signature="quit()" doc="Exits the FTP session." />
          <scope name="rename" ilk="function" signature="rename(fromname, toname)" doc="Renames a file on the server." />
          <scope name="retrbinary" ilk="function" signature="retrbinary(cmd, blocksize, rest_offset = nil)" doc="Puts the connection into binary (image) mode, issues the given command, and fetches the data returned, passing it to the associated block in chunks of +blocksize+ characters. Note that +cmd+ is a server command (such as &quot;RETR myfile&quot;)." />
          <scope name="retrlines" ilk="function" signature="retrlines(cmd)" doc="Puts the connection into ASCII (text) mode, issues the given command, and passes the resulting data, one line at a time, to the associated block. If no block is given, prints the lines. Note that +cmd+ is a server command (such as &quot;RETR myfile&quot;)." />
          <scope name="rmdir" ilk="function" signature="rmdir(dirname)" doc="Removes a remote directory." />
          <scope name="sendcmd" ilk="function" signature="sendcmd(cmd)" doc="Sends a command and returns the response." />
          <scope name="set_socket" ilk="function" signature="set_socket(sock, get_greeting = true)" doc="WRITEME or make private" />
          <scope name="site" ilk="function" signature="site(arg)" doc="Issues a SITE command." />
          <scope name="size" ilk="function" signature="size(filename)" doc="Returns the size of the given (remote) filename." />
          <scope name="status" ilk="function" signature="status()" doc="Returns the status (STAT command)." />
          <scope name="storbinary" ilk="function" signature="storbinary(cmd, file, blocksize, rest_offset = nil)" doc="Puts the connection into binary (image) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named +file+ to the server. If the optional block is given, it also passes it the data, in chunks of +blocksize+ characters." />
          <scope name="storlines" ilk="function" signature="storlines(cmd, file)" doc="Puts the connection into ASCII (text) mode, issues the given server-side command (such as &quot;STOR myfile&quot;), and sends the contents of the file named +file+ to the server, one line at a time. If the optional block is given, it also passes it the lines." />
          <scope name="system" ilk="function" signature="system()" doc="Returns system information." />
          <scope name="voidcmd" ilk="function" signature="voidcmd(cmd)" doc="Sends a command and expect a response beginning with &apos;2&apos;." />
          <scope ilk="function" name="binary" />
          <scope ilk="function" name="debug_mode" />
          <scope ilk="function" name="debug_mode=" />
          <scope ilk="function" name="last_response" />
          <scope ilk="function" name="last_response_code" />
          <scope ilk="function" name="lastresp" />
          <scope ilk="function" name="passive" />
          <scope ilk="function" name="passive=" />
          <scope ilk="function" name="resume" />
          <scope ilk="function" name="resume=" />
          <scope ilk="function" name="welcome" />
          <variable name="MDTM_REGEXP" attributes="__const__" citdl="Object" />
          <scope name="NullSocket" ilk="class" classrefs="Object">
          </scope>
        </scope>
        <scope name="FTPConnectionError" ilk="class" classrefs="Net::FTPError">
        </scope>
        <scope name="FTPError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="FTPPermError" ilk="class" classrefs="Net::FTPError">
        </scope>
        <scope name="FTPProtoError" ilk="class" classrefs="Net::FTPError">
        </scope>
        <scope name="FTPReplyError" ilk="class" classrefs="Net::FTPError">
        </scope>
        <scope name="FTPTempError" ilk="class" classrefs="Net::FTPError">
        </scope>
      </scope>
    </scope>
    <scope name="net/http" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="HTTP" ilk="class" classrefs="Protocol">
          <scope name="Proxy" ilk="function" signature="Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" doc="Creates an HTTP proxy class which behaves like Net::HTTP, but performs all access via the specified proxy. &#xA; The arguments are the DNS name or IP address of the proxy host, the port to use to access the proxy, and a username and password if authorization is required to use the proxy. &#xA; You can replace any use of the Net::HTTP class with use of the proxy class created. &#xA; If +p_addr+ is nil, this method returns self (a Net::HTTP object). &#xA; # Example&#xA;proxy_class = Net::HTTP::Proxy(&apos;proxy.example.com&apos;, 8080)&#xA;proxy_class.start(&apos;www.ruby-lang.org&apos;) {|http|&#xA;  # connecting proxy.foo.org:8080&#xA;}&#xA; You may use them to work with authorization-enabled proxies: &#xA; proxy_host = &apos;your.proxy.example&apos;&#xA;proxy_port = 8080&#xA;proxy_user = &apos;user&apos;" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="The default port to use for HTTP requests; defaults to 80." />
          <scope name="get" ilk="function" signature="get(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Sends a GET request to the target and returns the HTTP response as a string.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; print Net::HTTP.get(URI(&apos;http://www.example.com/index.html&apos;))&#xA; or: &#xA; print Net::HTTP.get(&apos;www.example.com&apos;, &apos;/index.html&apos;)" />
          <scope name="get_print" ilk="function" signature="get_print(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Gets the body text from the target and outputs it to $stdout.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; Net::HTTP.get_print URI(&apos;http://www.example.com/index.html&apos;)&#xA; or: &#xA; Net::HTTP.get_print &apos;www.example.com&apos;, &apos;/index.html&apos;" />
          <scope name="get_response" ilk="function" signature="get_response(uri_or_host, path = nil, port = nil, &amp;block)" attributes="__classmethod__" doc="Sends a GET request to the target and returns the HTTP response as a Net::HTTPResponse object.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; res = Net::HTTP.get_response(URI(&apos;http://www.example.com/index.html&apos;))&#xA;print res.body&#xA; or: &#xA; res = Net::HTTP.get_response(&apos;www.example.com&apos;, &apos;/index.html&apos;)&#xA;print res.body" />
          <scope name="http_default_port" ilk="function" signature="http_default_port()" attributes="__classmethod__" doc="The default port to use for HTTP requests; defaults to 80." />
          <scope name="https_default_port" ilk="function" signature="https_default_port()" attributes="__classmethod__" doc="The default port to use for HTTPS requests; defaults to 443." />
          <scope name="is_version_1_2?" ilk="function" signature="is_version_1_2?()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(address, port = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::HTTP object for the specified server address, without opening the TCP connection or initializing the HTTP session. The +address+ should be a DNS hostname or IP address." />
          <scope name="newobj" ilk="function" signature="newobj(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" />
          <scope name="post_form" ilk="function" signature="post_form(url, params)" attributes="__classmethod__" doc="Posts HTML form data to the specified URI object. The form data must be provided as a Hash mapping from String to String. Example: &#xA; { &quot;cmd&quot; =&gt; &quot;search&quot;, &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }&#xA; This method also does Basic Authentication iff +url+.user exists. But userinfo for authentication is deprecated (RFC3986). So this feature will be removed. &#xA; Example: &#xA; require &apos;net/http&apos;&#xA;require &apos;uri&apos;&#xA;&#xA;HTTP.post_form URI(&apos;http://www.example.com/search.cgi&apos;),&#xA;               { &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }" />
          <scope name="proxy_class?" ilk="function" signature="proxy_class?()" attributes="__classmethod__" doc="returns true if self is a class which was created by HTTP::Proxy." />
          <scope name="start" ilk="function" signature="start(address, *arg)" attributes="__classmethod__" doc="Creates a new Net::HTTP object, then additionally opens the TCP connection and HTTP session. &#xA; Arguments are the following: hostname or IP address of the server&#xA;port of the server&#xA;address of proxy&#xA;port of proxy&#xA;user of proxy&#xA;pass of proxy&#xA;optional hash &#xA; _opt_ sets following values by its accessor. The keys are ca_file, ca_path, cert, cert_store, ciphers, close_on_empty_response, key, open_timeout, read_timeout, ssl_timeout, ssl_version, use_ssl, verify_callback, verify_depth and verify_mode. If you set :use_ssl as true, you can use https and default value of verify_mode is set as OpenSSL::SSL::VERIFY_PEER. &#xA; If the optional block is given, the newly created Net::HTTP object is passed to it and closed when the block finishes.  In this case, the return value of this method is the return value of the block.  If no block is given, the return value of this method is the newly created Net::HTTP object itself, and the caller is responsible for closing it upon completion using the finish() method." />
          <scope name="version_1_2" ilk="function" signature="version_1_2()" attributes="__classmethod__" doc="Turns on net/http 1.2 (ruby 1.8) features. Defaults to ON in ruby 1.8 or later." />
          <scope name="version_1_2?" ilk="function" signature="version_1_2?()" attributes="__classmethod__" doc="Returns true if net/http is in version 1.2 mode. Defaults to true." />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="continue_timeout=" ilk="function" signature="continue_timeout=(sec)" doc="Setter for the continue_timeout attribute." />
          <scope name="copy" ilk="function" signature="copy(path, initheader = nil)" doc="Sends a COPY request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="delete" ilk="function" signature="delete(path, initheader = {&apos;Depth&apos; =&gt; &apos;Infinity&apos;})" doc="Sends a DELETE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the HTTP session and closes the TCP connection. Raises IOError if the session has not been started." />
          <scope name="get" ilk="function" signature="get(path, initheader = {}, dest = nil)" doc="Gets data from +path+ on the connected-to host. +initheader+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }, and it defaults to an empty hash. If +initheader+ doesn&apos;t have the key &apos;accept-encoding&apos;, then a value of &quot;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&quot; is used, so that gzip compression is used in preference to deflate compression, which is used in preference to no compression. Ruby doesn&apos;t have libraries to support the compress (Lempel-Ziv) compression, so that is not supported.  The intent of this is to reduce bandwidth by default.   If this routine sets up compression, then it does the decompression also, removing the header as well to prevent confusion.  Otherwise it leaves the body as it found it. &#xA; This method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it is read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; This method never raises an exception. &#xA; response = http.get(&apos;/index.html&apos;)&#xA;&#xA;# using block&#xA;File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;  http.get(&apos;/~foo/&apos;) do |str|&#xA;    f.write str&#xA;  end&#xA;}" />
          <scope name="get2" ilk="function" signature="get2(path, initheader = nil)" />
          <scope name="head" ilk="function" signature="head(path, initheader = nil)" doc="Gets only the header from +path+ on the connected-to host. +header+ is a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }. &#xA; This method returns a Net::HTTPResponse object. &#xA; This method never raises an exception. &#xA; response = nil&#xA;Net::HTTP.start(&apos;some.www.server&apos;, 80) {|http|&#xA;  response = http.head(&apos;/index.html&apos;)&#xA;}&#xA;p response[&apos;content-type&apos;]" />
          <scope name="head2" ilk="function" signature="head2(path, initheader = nil, &amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="lock" ilk="function" signature="lock(path, body, initheader = nil)" doc="Sends a LOCK request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="mkcol" ilk="function" signature="mkcol(path, body = nil, initheader = nil)" doc="Sends a MKCOL request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="move" ilk="function" signature="move(path, initheader = nil)" doc="Sends a MOVE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="options" ilk="function" signature="options(path, initheader = nil)" doc="Sends a OPTIONS request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="patch" ilk="function" signature="patch(path, data, initheader = nil, dest = nil)" doc="Sends a PATCH request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="peer_cert" ilk="function" signature="peer_cert()" doc="Returns the X.509 certificates the server presented." />
          <scope name="post" ilk="function" signature="post(path, data, initheader = nil, dest = nil)" doc="Posts +data+ (must be a String) to +path+. +header+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }. &#xA; This method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it is read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; This method never raises exception. &#xA; response = http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;)&#xA;# using block&#xA;File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;  http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;) do |str|&#xA;    f.write str&#xA;  end&#xA;}&#xA; You should set Content-Type: header field for POST. If no Content-Type: field given, this method uses &quot;application/x-www-form-urlencoded&quot; by default." />
          <scope name="post2" ilk="function" signature="post2(path, data, initheader = nil)" />
          <scope name="propfind" ilk="function" signature="propfind(path, body = nil, initheader = {&apos;Depth&apos; =&gt; &apos;0&apos;})" doc="Sends a PROPFIND request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="proppatch" ilk="function" signature="proppatch(path, body, initheader = nil)" doc="Sends a PROPPATCH request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="proxy?" ilk="function" signature="proxy?()" doc="True if self is a HTTP proxy class." />
          <scope name="proxy_address" ilk="function" signature="proxy_address()" doc="A convenience method for accessing value of proxy_address from Net::HTTP." />
          <scope name="proxy_pass" ilk="function" signature="proxy_pass()" doc="A convenience method for accessing value of proxy_pass from Net::HTTP." />
          <scope name="proxy_port" ilk="function" signature="proxy_port()" doc="A convenience method for accessing value of proxy_port from Net::HTTP." />
          <scope name="proxy_user" ilk="function" signature="proxy_user()" doc="A convenience method for accessing value of proxy_user from Net::HTTP." />
          <scope name="proxyaddr" ilk="function" signature="proxyaddr()" />
          <scope name="proxyport" ilk="function" signature="proxyport()" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Setter for the read_timeout attribute." />
          <scope name="request" ilk="function" signature="request(req, body = nil)" doc="Sends an HTTPRequest object +req+ to the HTTP server. &#xA; If +req+ is a Net::HTTP::Post or Net::HTTP::Put request containing data, the data is also sent. Providing data for a Net::HTTP::Head or Net::HTTP::Get request results in an ArgumentError. &#xA; Returns an HTTPResponse object. &#xA; When called with a block, passes an HTTPResponse object to the block. The body of the response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; This method never raises Net::* exceptions." />
          <scope name="request_get" ilk="function" signature="request_get(path, initheader = nil)" doc="Sends a GET request to the +path+. Returns the response as a Net::HTTPResponse object. &#xA; When called with a block, passes an HTTPResponse object to the block. The body of the response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; response = http.request_get(&apos;/index.html&apos;)&#xA;# The entity body is already read in this case.&#xA;p response[&apos;content-type&apos;]&#xA;puts response.body&#xA;# Using a block&#xA;http.request_get(&apos;/index.html&apos;) {|response|&#xA;  p response[&apos;content-type&apos;]&#xA;  response.read_body do |str|   # read body now&#xA;    print str" />
          <scope name="request_head" ilk="function" signature="request_head(path, initheader = nil, &amp;block)" doc="Sends a HEAD request to the +path+ and returns the response as a Net::HTTPResponse object. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; response = http.request_head(&apos;/index.html&apos;)&#xA;p response[&apos;content-type&apos;]" />
          <scope name="request_post" ilk="function" signature="request_post(path, data, initheader = nil)" doc="Sends a POST request to the +path+. &#xA; Returns the response as a Net::HTTPResponse object. &#xA; When called with a block, the block is passed an HTTPResponse object.  The body of that response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; # example&#xA;response = http.request_post(&apos;/cgi-bin/nice.rb&apos;, &apos;datadatadata...&apos;)&#xA;p response.status&#xA;puts response.body          # body is already read in this case&#xA;# using block&#xA;http.request_post(&apos;/cgi-bin/nice.rb&apos;, &apos;datadatadata...&apos;) {|response|&#xA;  p response.status&#xA;  p response[&apos;content-type&apos;]" />
          <scope name="send_request" ilk="function" signature="send_request(name, path, data = nil, header = nil)" doc="Sends an HTTP request to the HTTP server. Also sends a DATA string if +data+ is given. &#xA; Returns a Net::HTTPResponse object. &#xA; This method never raises Net::* exceptions. &#xA; response = http.send_request(&apos;GET&apos;, &apos;/index.html&apos;)&#xA;puts response.body" />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(output)" doc="*WARNING* This method opens a serious security hole. Never use this method in production code. &#xA; Sets an output stream for debugging. &#xA; http = Net::HTTP.new&#xA;http.set_debug_output $stderr&#xA;http.start { .... }" />
          <scope name="start" ilk="function" signature="start()" doc="Opens a TCP connection and HTTP session. &#xA; When this method is called with a block, it passes the Net::HTTP object to the block, and closes the TCP connection and HTTP session after the block has been executed. &#xA; When called with a block, it returns the return value of the block; otherwise, it returns self." />
          <scope name="started?" ilk="function" signature="started?()" doc="Returns true if the HTTP session has been started." />
          <scope name="trace" ilk="function" signature="trace(path, initheader = nil)" doc="Sends a TRACE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="unlock" ilk="function" signature="unlock(path, body, initheader = nil)" doc="Sends a UNLOCK request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="use_ssl=" ilk="function" signature="use_ssl=(flag)" doc="Turn on/off SSL. This flag must be set before starting session. If you change use_ssl value after session started, a Net::HTTP object raises IOError." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="Returns true if SSL/TLS is being used with HTTP." />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="ca_file" />
          <scope ilk="function" name="ca_file=" />
          <scope ilk="function" name="ca_path" />
          <scope ilk="function" name="ca_path=" />
          <scope ilk="function" name="cert" />
          <scope ilk="function" name="cert=" />
          <scope ilk="function" name="cert_store" />
          <scope ilk="function" name="cert_store=" />
          <scope ilk="function" name="ciphers" />
          <scope ilk="function" name="ciphers=" />
          <scope ilk="function" name="close_on_empty_response" />
          <scope ilk="function" name="close_on_empty_response=" />
          <scope ilk="function" name="continue_timeout" />
          <scope ilk="function" name="key" />
          <scope ilk="function" name="key=" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="proxy_address" />
          <scope ilk="function" name="proxy_pass" />
          <scope ilk="function" name="proxy_port" />
          <scope ilk="function" name="proxy_user" />
          <scope ilk="function" name="read_timeout" />
          <scope ilk="function" name="ssl_timeout" />
          <scope ilk="function" name="ssl_timeout=" />
          <scope ilk="function" name="ssl_version" />
          <scope ilk="function" name="ssl_version=" />
          <scope ilk="function" name="verify_callback" />
          <scope ilk="function" name="verify_callback=" />
          <scope ilk="function" name="verify_depth" />
          <scope ilk="function" name="verify_depth=" />
          <scope ilk="function" name="verify_mode" />
          <scope ilk="function" name="verify_mode=" />
          <variable name="SSL_ATTRIBUTES" attributes="__const__" citdl="Object" />
          <scope name="Copy" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Delete" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Get" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Head" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Lock" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Mkcol" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Move" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Options" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Patch" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Post" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Propfind" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Proppatch" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Put" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Trace" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Unlock" ilk="class" classrefs="Net::HTTPRequest">
            <variable name="METHOD" attributes="__const__" citdl="Object" />
            <variable name="REQUEST_HAS_BODY" attributes="__const__" citdl="Object" />
            <variable name="RESPONSE_HAS_BODY" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="HTTPAccepted" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPBadGateway" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
        <scope name="HTTPBadRequest" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPBadResponse" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="HTTPClientError" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPConflict" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPContinue" ilk="class" classrefs="Net::HTTPInformation">
        </scope>
        <scope name="HTTPCreated" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPError" ilk="class" classrefs="ProtocolError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPExceptions" ilk="namespace">
          <scope ilk="function" name="data" />
          <scope ilk="function" name="response" />
        </scope>
        <scope name="HTTPExpectationFailed" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPFatalError" ilk="class" classrefs="ProtoFatalError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPForbidden" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPFound" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPGatewayTimeOut" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
        <scope name="HTTPGenericRequest" ilk="class" classrefs="Object">
          <import symbol="HTTPHeader" />
          <scope name="new" ilk="function" signature="new(m, reqbody, resbody, path, initheader = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="body=" ilk="function" signature="body=(str)" />
          <scope name="body_exist?" ilk="function" signature="body_exist?()" />
          <scope name="body_stream=" ilk="function" signature="body_stream=(input)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="request_body_permitted?" ilk="function" signature="request_body_permitted?()" />
          <scope name="response_body_permitted?" ilk="function" signature="response_body_permitted?()" />
          <scope ilk="function" name="body" />
          <scope ilk="function" name="body_stream" />
          <scope ilk="function" name="method" />
          <scope ilk="function" name="path" />
        </scope>
        <scope name="HTTPGone" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPHeader" ilk="namespace">
          <scope name="add_field" ilk="function" signature="add_field(key, val)" doc="Adds a value to a named header field, instead of replacing its value. Second argument +val+ must be a String. See also #[]=, #[] and #get_fields. &#xA; request.add_field &apos;X-My-Header&apos;, &apos;a&apos;&#xA;p request[&apos;X-My-Header&apos;]              =&gt; &quot;a&quot;&#xA;p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;]&#xA;request.add_field &apos;X-My-Header&apos;, &apos;b&apos;&#xA;p request[&apos;X-My-Header&apos;]              =&gt; &quot;a, b&quot;&#xA;p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;, &quot;b&quot;]&#xA;request.add_field &apos;X-My-Header&apos;, &apos;c&apos;&#xA;p request[&apos;X-My-Header&apos;]              =&gt; &quot;a, b, c&quot;&#xA;p request.get_fields(&apos;X-My-Header&apos;)   =&gt; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]" />
          <scope name="basic_auth" ilk="function" signature="basic_auth(account, password)" doc="Set the Authorization: header for &quot;Basic&quot; authorization." />
          <scope name="canonical_each" ilk="function" signature="canonical_each()" />
          <scope name="chunked?" ilk="function" signature="chunked?()" doc="Returns &quot;true&quot; if the &quot;transfer-encoding&quot; header is present and set to &quot;chunked&quot;.  This is an HTTP/1.1 feature, allowing the the content to be sent in &quot;chunks&quot; without at the outset stating the entire content length." />
          <scope name="connection_close?" ilk="function" signature="connection_close?()" />
          <scope name="connection_keep_alive?" ilk="function" signature="connection_keep_alive?()" />
          <scope name="content_length" ilk="function" signature="content_length()" doc="Returns an Integer object which represents the HTTP Content-Length: header field, or +nil+ if that field was not provided." />
          <scope name="content_length=" ilk="function" signature="content_length=(len)" />
          <scope name="content_range" ilk="function" signature="content_range()" doc="Returns a Range object which represents the value of the Content-Range: header field. For a partial entity body, this indicates where this fragment fits inside the full entity body, as range of byte offsets." />
          <scope name="content_type" ilk="function" signature="content_type()" doc="Returns a content type string such as &quot;text/html&quot;. This method returns nil if Content-Type: header field does not exist." />
          <scope name="content_type=" ilk="function" signature="content_type=(type, params = {})" />
          <scope name="delete" ilk="function" signature="delete(key)" doc="Removes a header field, specified by case-insensitive key." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_capitalized" ilk="function" signature="each_capitalized()" doc="As for #each_header, except the keys are provided in capitalized form. &#xA; Note that header names are capitalized systematically; capitalization may not match that used by the remote HTTP server in its response." />
          <scope name="each_capitalized_name" ilk="function" signature="each_capitalized_name()" doc="Iterates through the header names in the header, passing capitalized header names to the code block. &#xA; Note that header names are capitalized systematically; capitalization may not match that used by the remote HTTP server in its response." />
          <scope name="each_header" ilk="function" signature="each_header()" doc="Iterates through the header names and values, passing in the name and value to the code block supplied. &#xA; Example: &#xA; response.header.each_header {|key,value| puts &quot;#{key} = #{value}&quot; }" />
          <scope name="each_key" ilk="function" signature="each_key()" />
          <scope name="each_name" ilk="function" signature="each_name()" doc="Iterates through the header names in the header, passing each header name to the code block." />
          <scope name="each_value" ilk="function" signature="each_value()" doc="Iterates through header values, passing each value to the code block." />
          <scope name="fetch" ilk="function" signature="fetch(key, *args)" doc="Returns the header field corresponding to the case-insensitive key. Returns the default value +args+, or the result of the block, or raises an IndexError if there&apos;s no header field named +key+ See Hash#fetch" />
          <scope name="form_data=" ilk="function" signature="form_data=(params, sep = &apos;&amp;&apos;)" />
          <scope name="get_fields" ilk="function" signature="get_fields(key)" doc="Returns an array of header field strings corresponding to the case-insensitive +key+.  This method allows you to get duplicated header fields without any processing.  See also #[]. &#xA; p response.get_fields(&apos;Set-Cookie&apos;)&#xA;  =&gt; [&quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23&quot;,&#xA;       &quot;query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;]&#xA;p response[&apos;Set-Cookie&apos;]&#xA;  =&gt; &quot;session=al98axx; expires=Fri, 31-Dec-1999 23:58:23, query=rubyscript; expires=Fri, 31-Dec-1999 23:58:23&quot;" />
          <scope name="initialize_http_header" ilk="function" signature="initialize_http_header(initheader)" />
          <scope name="key?" ilk="function" signature="key?(key)" doc="true if +key+ header exists." />
          <scope name="main_type" ilk="function" signature="main_type()" doc="Returns a content type string such as &quot;text&quot;. This method returns nil if Content-Type: header field does not exist." />
          <scope name="proxy_basic_auth" ilk="function" signature="proxy_basic_auth(account, password)" doc="Set Proxy-Authorization: header for &quot;Basic&quot; authorization." />
          <scope name="range" ilk="function" signature="range()" doc="Returns an Array of Range objects which represent the Range: HTTP header field, or +nil+ if there is no such header." />
          <scope name="range=" ilk="function" signature="range=(r, e = nil)" />
          <scope name="range_length" ilk="function" signature="range_length()" doc="The length of the range represented in Content-Range: header." />
          <scope name="set_content_type" ilk="function" signature="set_content_type(type, params = {})" doc="Sets the content type in an HTTP header. The +type+ should be a full HTTP content type, e.g. &quot;text/html&quot;. The +params+ are an optional Hash of parameters to add after the content type, e.g. {&apos;charset&apos; =&gt; &apos;iso-8859-1&apos;}" />
          <scope name="set_form" ilk="function" signature="set_form(params, enctype=&apos;application/x-www-form-urlencoded&apos;, formopt={})" doc="Set a HTML form data set. +params+ is the form data set; it is an Array of Arrays or a Hash +enctype is the type to encode the form data set. It is application/x-www-form-urlencoded or multipart/form-data. +formpot+ is an optional hash to specify the detail. &#xA; the boundary of the multipart message&#xA;the charset of the message. All names and the values of non-file fields are encoded as the charset. &#xA; Each item of params is an array and contains following items: the name of the field&#xA;the value of the field, it should be a String or a File&#xA;an optional hash to specify additional information &#xA; Each item is a file field or a normal field. If +value+ is a File object or the +opt+ have a filename key, the item is treated as a file field. &#xA; If Transfer-Encoding is set as chunked, this send the request in chunked encoding. Because chunked encoding is HTTP/1.1 feature, you must confirm the server to support HTTP/1.1 before sending it. &#xA; Example: http.set_form([[&quot;q&quot;, &quot;ruby&quot;], [&quot;lang&quot;, &quot;en&quot;]])&#xA; See also RFC 2388, RFC 2616, HTML 4.01, and HTML5" />
          <scope name="set_form_data" ilk="function" signature="set_form_data(params, sep = &apos;&amp;&apos;)" doc="Set header fields and a body from HTML form data. +params+ should be an Array of Arrays or a Hash containing HTML form data. Optional argument +sep+ means data record separator. &#xA; Values are URL encoded as necessary and the content-type is set to application/x-www-form-urlencoded &#xA; Example: http.form_data = {&quot;q&quot; =&gt; &quot;ruby&quot;, &quot;lang&quot; =&gt; &quot;en&quot;}&#xA;http.form_data = {&quot;q&quot; =&gt; [&quot;ruby&quot;, &quot;perl&quot;], &quot;lang&quot; =&gt; &quot;en&quot;}&#xA;http.set_form_data({&quot;q&quot; =&gt; &quot;ruby&quot;, &quot;lang&quot; =&gt; &quot;en&quot;}, &apos;;&apos;)" />
          <scope name="set_range" ilk="function" signature="set_range(r, e = nil)" doc="Sets the HTTP Range: header. Accepts either a Range object as a single argument, or a beginning index and a length from that index. Example: &#xA; req.range = (0..1023)&#xA;req.set_range 0, 1023" />
          <scope name="sub_type" ilk="function" signature="sub_type()" doc="Returns a content type string such as &quot;html&quot;. This method returns nil if Content-Type: header field does not exist or sub-type is not given (e.g. &quot;Content-Type: text&quot;)." />
          <scope name="to_hash" ilk="function" signature="to_hash()" doc="Returns a Hash consisting of header names and values. e.g. {&quot;cache-control&quot; =&gt; &quot;private&quot;, &quot;content-type&quot; =&gt; &quot;text/html&quot;,&#xA;&quot;date&quot; =&gt; &quot;Wed, 22 Jun 2005 22:11:50 GMT&quot;}" />
          <scope name="type_params" ilk="function" signature="type_params()" doc="Any parameters specified for the content type, returned as a Hash. For example, a header of Content-Type: text/html; charset=EUC-JP would result in type_params returning {&apos;charset&apos; =&gt; &apos;EUC-JP&apos;}" />
        </scope>
        <scope name="HTTPHeaderSyntaxError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="HTTPInformation" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPInternalServerError" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
        <scope name="HTTPLengthRequired" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPMethodNotAllowed" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPMovedPermanently" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPMultipleChoice" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPNoContent" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPNonAuthoritativeInformation" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPNotAcceptable" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPNotFound" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPNotImplemented" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
        <scope name="HTTPNotModified" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPOK" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPPartialContent" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPPaymentRequired" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPPreconditionFailed" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPProxyAuthenticationRequired" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPRedirection" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPRequest" ilk="class" classrefs="Net::HTTPGenericRequest">
          <scope name="new" ilk="function" signature="new(path, initheader = nil)" attributes="__classmethod__ __ctor__" doc="Creates HTTP request object." />
        </scope>
        <scope name="HTTPRequestEntityTooLarge" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPRequestTimeOut" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPRequestURITooLong" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPRequestedRangeNotSatisfiable" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPResetContent" ilk="class" classrefs="Net::HTTPSuccess">
        </scope>
        <scope name="HTTPResponse" ilk="class" classrefs="Object">
          <import symbol="HTTPHeader" />
          <scope name="body_permitted?" ilk="function" signature="body_permitted?()" attributes="__classmethod__" doc="true if the response has a body." />
          <scope name="body" ilk="function" signature="body()" doc="Returns the full entity body. &#xA; Calling this method a second or subsequent time will return the string already read. &#xA; http.request_get(&apos;/index.html&apos;) {|res|&#xA;  puts res.body&#xA;}&#xA;&#xA;http.request_get(&apos;/index.html&apos;) {|res|&#xA;  p res.body.object_id   # 538149362&#xA;  p res.body.object_id   # 538149362&#xA;}" />
          <scope name="body=" ilk="function" signature="body=(value)" doc="Because it may be necessary to modify the body, Eg, decompression this method facilitates that." />
          <scope name="entity" ilk="function" signature="entity()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="read_body" ilk="function" signature="read_body(dest = nil, &amp;block)" doc="Gets the entity body returned by the remote HTTP server. &#xA; If a block is given, the body is passed to the block, and the body is provided in fragments, as it is read in from the socket. &#xA; Calling this method a second or subsequent time for the same HTTPResponse object will return the value already read. &#xA; http.request_get(&apos;/index.html&apos;) {|res|&#xA;  puts res.read_body&#xA;}&#xA;http.request_get(&apos;/index.html&apos;) {|res|&#xA;  p res.read_body.object_id   # 538149362&#xA;  p res.read_body.object_id   # 538149362&#xA;}&#xA;# using iterator&#xA;http.request_get(&apos;/index.html&apos;) {|res|&#xA;  res.read_body do |segment|" />
          <scope name="value" ilk="function" signature="value()" doc="Raises an HTTP error if the response is not 2xx (success)." />
          <scope ilk="function" name="code" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="message" />
          <scope ilk="function" name="msg" />
          <variable name="CODE_CLASS_TO_OBJ" attributes="__const__" citdl="Object" />
          <variable name="CODE_TO_OBJ" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="HTTPRetriableError" ilk="class" classrefs="ProtoRetriableError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPSeeOther" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPServerError" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPServerException" ilk="class" classrefs="ProtoServerError">
          <import symbol="HTTPExceptions" />
        </scope>
        <scope name="HTTPServiceUnavailable" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
        <scope name="HTTPSession" ilk="class" classrefs="Protocol">
          <scope name="Proxy" ilk="function" signature="Proxy(p_addr, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" doc="Creates an HTTP proxy class which behaves like Net::HTTP, but performs all access via the specified proxy. &#xA; The arguments are the DNS name or IP address of the proxy host, the port to use to access the proxy, and a username and password if authorization is required to use the proxy. &#xA; You can replace any use of the Net::HTTP class with use of the proxy class created. &#xA; If +p_addr+ is nil, this method returns self (a Net::HTTP object). &#xA; # Example&#xA;proxy_class = Net::HTTP::Proxy(&apos;proxy.example.com&apos;, 8080)&#xA;proxy_class.start(&apos;www.ruby-lang.org&apos;) {|http|&#xA;  # connecting proxy.foo.org:8080&#xA;}&#xA; You may use them to work with authorization-enabled proxies: &#xA; proxy_host = &apos;your.proxy.example&apos;&#xA;proxy_port = 8080&#xA;proxy_user = &apos;user&apos;" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="The default port to use for HTTP requests; defaults to 80." />
          <scope name="get" ilk="function" signature="get(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Sends a GET request to the target and returns the HTTP response as a string.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; print Net::HTTP.get(URI(&apos;http://www.example.com/index.html&apos;))&#xA; or: &#xA; print Net::HTTP.get(&apos;www.example.com&apos;, &apos;/index.html&apos;)" />
          <scope name="get_print" ilk="function" signature="get_print(uri_or_host, path = nil, port = nil)" attributes="__classmethod__" doc="Gets the body text from the target and outputs it to $stdout.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; Net::HTTP.get_print URI(&apos;http://www.example.com/index.html&apos;)&#xA; or: &#xA; Net::HTTP.get_print &apos;www.example.com&apos;, &apos;/index.html&apos;" />
          <scope name="get_response" ilk="function" signature="get_response(uri_or_host, path = nil, port = nil, &amp;block)" attributes="__classmethod__" doc="Sends a GET request to the target and returns the HTTP response as a Net::HTTPResponse object.  The target can either be specified as (+uri+), or as (+host+, +path+, +port+ = 80); so: &#xA; res = Net::HTTP.get_response(URI(&apos;http://www.example.com/index.html&apos;))&#xA;print res.body&#xA; or: &#xA; res = Net::HTTP.get_response(&apos;www.example.com&apos;, &apos;/index.html&apos;)&#xA;print res.body" />
          <scope name="http_default_port" ilk="function" signature="http_default_port()" attributes="__classmethod__" doc="The default port to use for HTTP requests; defaults to 80." />
          <scope name="https_default_port" ilk="function" signature="https_default_port()" attributes="__classmethod__" doc="The default port to use for HTTPS requests; defaults to 443." />
          <scope name="is_version_1_2?" ilk="function" signature="is_version_1_2?()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(address, port = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::HTTP object for the specified server address, without opening the TCP connection or initializing the HTTP session. The +address+ should be a DNS hostname or IP address." />
          <scope name="newobj" ilk="function" signature="newobj(address, port = nil, p_addr = nil, p_port = nil, p_user = nil, p_pass = nil)" attributes="__classmethod__" />
          <scope name="post_form" ilk="function" signature="post_form(url, params)" attributes="__classmethod__" doc="Posts HTML form data to the specified URI object. The form data must be provided as a Hash mapping from String to String. Example: &#xA; { &quot;cmd&quot; =&gt; &quot;search&quot;, &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }&#xA; This method also does Basic Authentication iff +url+.user exists. But userinfo for authentication is deprecated (RFC3986). So this feature will be removed. &#xA; Example: &#xA; require &apos;net/http&apos;&#xA;require &apos;uri&apos;&#xA;&#xA;HTTP.post_form URI(&apos;http://www.example.com/search.cgi&apos;),&#xA;               { &quot;q&quot; =&gt; &quot;ruby&quot;, &quot;max&quot; =&gt; &quot;50&quot; }" />
          <scope name="proxy_class?" ilk="function" signature="proxy_class?()" attributes="__classmethod__" doc="returns true if self is a class which was created by HTTP::Proxy." />
          <scope name="start" ilk="function" signature="start(address, *arg)" attributes="__classmethod__" doc="Creates a new Net::HTTP object, then additionally opens the TCP connection and HTTP session. &#xA; Arguments are the following: hostname or IP address of the server&#xA;port of the server&#xA;address of proxy&#xA;port of proxy&#xA;user of proxy&#xA;pass of proxy&#xA;optional hash &#xA; _opt_ sets following values by its accessor. The keys are ca_file, ca_path, cert, cert_store, ciphers, close_on_empty_response, key, open_timeout, read_timeout, ssl_timeout, ssl_version, use_ssl, verify_callback, verify_depth and verify_mode. If you set :use_ssl as true, you can use https and default value of verify_mode is set as OpenSSL::SSL::VERIFY_PEER. &#xA; If the optional block is given, the newly created Net::HTTP object is passed to it and closed when the block finishes.  In this case, the return value of this method is the return value of the block.  If no block is given, the return value of this method is the newly created Net::HTTP object itself, and the caller is responsible for closing it upon completion using the finish() method." />
          <scope name="version_1_2" ilk="function" signature="version_1_2()" attributes="__classmethod__" doc="Turns on net/http 1.2 (ruby 1.8) features. Defaults to ON in ruby 1.8 or later." />
          <scope name="version_1_2?" ilk="function" signature="version_1_2?()" attributes="__classmethod__" doc="Returns true if net/http is in version 1.2 mode. Defaults to true." />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="continue_timeout=" ilk="function" signature="continue_timeout=(sec)" doc="Setter for the continue_timeout attribute." />
          <scope name="copy" ilk="function" signature="copy(path, initheader = nil)" doc="Sends a COPY request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="delete" ilk="function" signature="delete(path, initheader = {&apos;Depth&apos; =&gt; &apos;Infinity&apos;})" doc="Sends a DELETE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the HTTP session and closes the TCP connection. Raises IOError if the session has not been started." />
          <scope name="get" ilk="function" signature="get(path, initheader = {}, dest = nil)" doc="Gets data from +path+ on the connected-to host. +initheader+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }, and it defaults to an empty hash. If +initheader+ doesn&apos;t have the key &apos;accept-encoding&apos;, then a value of &quot;gzip;q=1.0,deflate;q=0.6,identity;q=0.3&quot; is used, so that gzip compression is used in preference to deflate compression, which is used in preference to no compression. Ruby doesn&apos;t have libraries to support the compress (Lempel-Ziv) compression, so that is not supported.  The intent of this is to reduce bandwidth by default.   If this routine sets up compression, then it does the decompression also, removing the header as well to prevent confusion.  Otherwise it leaves the body as it found it. &#xA; This method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it is read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; This method never raises an exception. &#xA; response = http.get(&apos;/index.html&apos;)&#xA;&#xA;# using block&#xA;File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;  http.get(&apos;/~foo/&apos;) do |str|&#xA;    f.write str&#xA;  end&#xA;}" />
          <scope name="get2" ilk="function" signature="get2(path, initheader = nil)" />
          <scope name="head" ilk="function" signature="head(path, initheader = nil)" doc="Gets only the header from +path+ on the connected-to host. +header+ is a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }. &#xA; This method returns a Net::HTTPResponse object. &#xA; This method never raises an exception. &#xA; response = nil&#xA;Net::HTTP.start(&apos;some.www.server&apos;, 80) {|http|&#xA;  response = http.head(&apos;/index.html&apos;)&#xA;}&#xA;p response[&apos;content-type&apos;]" />
          <scope name="head2" ilk="function" signature="head2(path, initheader = nil, &amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="lock" ilk="function" signature="lock(path, body, initheader = nil)" doc="Sends a LOCK request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="mkcol" ilk="function" signature="mkcol(path, body = nil, initheader = nil)" doc="Sends a MKCOL request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="move" ilk="function" signature="move(path, initheader = nil)" doc="Sends a MOVE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="options" ilk="function" signature="options(path, initheader = nil)" doc="Sends a OPTIONS request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="patch" ilk="function" signature="patch(path, data, initheader = nil, dest = nil)" doc="Sends a PATCH request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="peer_cert" ilk="function" signature="peer_cert()" doc="Returns the X.509 certificates the server presented." />
          <scope name="post" ilk="function" signature="post(path, data, initheader = nil, dest = nil)" doc="Posts +data+ (must be a String) to +path+. +header+ must be a Hash like { &apos;Accept&apos; =&gt; &apos;*/*&apos;, ... }. &#xA; This method returns a Net::HTTPResponse object. &#xA; If called with a block, yields each fragment of the entity body in turn as a string as it is read from the socket.  Note that in this case, the returned response object will *not* contain a (meaningful) body. &#xA; +dest+ argument is obsolete. It still works but you must not use it. &#xA; This method never raises exception. &#xA; response = http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;)&#xA;# using block&#xA;File.open(&apos;result.txt&apos;, &apos;w&apos;) {|f|&#xA;  http.post(&apos;/cgi-bin/search.rb&apos;, &apos;query=foo&apos;) do |str|&#xA;    f.write str&#xA;  end&#xA;}&#xA; You should set Content-Type: header field for POST. If no Content-Type: field given, this method uses &quot;application/x-www-form-urlencoded&quot; by default." />
          <scope name="post2" ilk="function" signature="post2(path, data, initheader = nil)" />
          <scope name="propfind" ilk="function" signature="propfind(path, body = nil, initheader = {&apos;Depth&apos; =&gt; &apos;0&apos;})" doc="Sends a PROPFIND request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="proppatch" ilk="function" signature="proppatch(path, body, initheader = nil)" doc="Sends a PROPPATCH request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="proxy?" ilk="function" signature="proxy?()" doc="True if self is a HTTP proxy class." />
          <scope name="proxy_address" ilk="function" signature="proxy_address()" doc="A convenience method for accessing value of proxy_address from Net::HTTP." />
          <scope name="proxy_pass" ilk="function" signature="proxy_pass()" doc="A convenience method for accessing value of proxy_pass from Net::HTTP." />
          <scope name="proxy_port" ilk="function" signature="proxy_port()" doc="A convenience method for accessing value of proxy_port from Net::HTTP." />
          <scope name="proxy_user" ilk="function" signature="proxy_user()" doc="A convenience method for accessing value of proxy_user from Net::HTTP." />
          <scope name="proxyaddr" ilk="function" signature="proxyaddr()" />
          <scope name="proxyport" ilk="function" signature="proxyport()" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Setter for the read_timeout attribute." />
          <scope name="request" ilk="function" signature="request(req, body = nil)" doc="Sends an HTTPRequest object +req+ to the HTTP server. &#xA; If +req+ is a Net::HTTP::Post or Net::HTTP::Put request containing data, the data is also sent. Providing data for a Net::HTTP::Head or Net::HTTP::Get request results in an ArgumentError. &#xA; Returns an HTTPResponse object. &#xA; When called with a block, passes an HTTPResponse object to the block. The body of the response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; This method never raises Net::* exceptions." />
          <scope name="request_get" ilk="function" signature="request_get(path, initheader = nil)" doc="Sends a GET request to the +path+. Returns the response as a Net::HTTPResponse object. &#xA; When called with a block, passes an HTTPResponse object to the block. The body of the response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; response = http.request_get(&apos;/index.html&apos;)&#xA;# The entity body is already read in this case.&#xA;p response[&apos;content-type&apos;]&#xA;puts response.body&#xA;# Using a block&#xA;http.request_get(&apos;/index.html&apos;) {|response|&#xA;  p response[&apos;content-type&apos;]&#xA;  response.read_body do |str|   # read body now&#xA;    print str" />
          <scope name="request_head" ilk="function" signature="request_head(path, initheader = nil, &amp;block)" doc="Sends a HEAD request to the +path+ and returns the response as a Net::HTTPResponse object. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; response = http.request_head(&apos;/index.html&apos;)&#xA;p response[&apos;content-type&apos;]" />
          <scope name="request_post" ilk="function" signature="request_post(path, data, initheader = nil)" doc="Sends a POST request to the +path+. &#xA; Returns the response as a Net::HTTPResponse object. &#xA; When called with a block, the block is passed an HTTPResponse object.  The body of that response will not have been read yet; the block can process it using HTTPResponse#read_body, if desired. &#xA; Returns the response. &#xA; This method never raises Net::* exceptions. &#xA; # example&#xA;response = http.request_post(&apos;/cgi-bin/nice.rb&apos;, &apos;datadatadata...&apos;)&#xA;p response.status&#xA;puts response.body          # body is already read in this case&#xA;# using block&#xA;http.request_post(&apos;/cgi-bin/nice.rb&apos;, &apos;datadatadata...&apos;) {|response|&#xA;  p response.status&#xA;  p response[&apos;content-type&apos;]" />
          <scope name="send_request" ilk="function" signature="send_request(name, path, data = nil, header = nil)" doc="Sends an HTTP request to the HTTP server. Also sends a DATA string if +data+ is given. &#xA; Returns a Net::HTTPResponse object. &#xA; This method never raises Net::* exceptions. &#xA; response = http.send_request(&apos;GET&apos;, &apos;/index.html&apos;)&#xA;puts response.body" />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(output)" doc="*WARNING* This method opens a serious security hole. Never use this method in production code. &#xA; Sets an output stream for debugging. &#xA; http = Net::HTTP.new&#xA;http.set_debug_output $stderr&#xA;http.start { .... }" />
          <scope name="start" ilk="function" signature="start()" doc="Opens a TCP connection and HTTP session. &#xA; When this method is called with a block, it passes the Net::HTTP object to the block, and closes the TCP connection and HTTP session after the block has been executed. &#xA; When called with a block, it returns the return value of the block; otherwise, it returns self." />
          <scope name="started?" ilk="function" signature="started?()" doc="Returns true if the HTTP session has been started." />
          <scope name="trace" ilk="function" signature="trace(path, initheader = nil)" doc="Sends a TRACE request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="unlock" ilk="function" signature="unlock(path, body, initheader = nil)" doc="Sends a UNLOCK request to the +path+ and gets a response, as an HTTPResponse object." />
          <scope name="use_ssl=" ilk="function" signature="use_ssl=(flag)" doc="Turn on/off SSL. This flag must be set before starting session. If you change use_ssl value after session started, a Net::HTTP object raises IOError." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="Returns true if SSL/TLS is being used with HTTP." />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="ca_file" />
          <scope ilk="function" name="ca_file=" />
          <scope ilk="function" name="ca_path" />
          <scope ilk="function" name="ca_path=" />
          <scope ilk="function" name="cert" />
          <scope ilk="function" name="cert=" />
          <scope ilk="function" name="cert_store" />
          <scope ilk="function" name="cert_store=" />
          <scope ilk="function" name="ciphers" />
          <scope ilk="function" name="ciphers=" />
          <scope ilk="function" name="close_on_empty_response" />
          <scope ilk="function" name="close_on_empty_response=" />
          <scope ilk="function" name="continue_timeout" />
          <scope ilk="function" name="key" />
          <scope ilk="function" name="key=" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="proxy_address" />
          <scope ilk="function" name="proxy_pass" />
          <scope ilk="function" name="proxy_port" />
          <scope ilk="function" name="proxy_user" />
          <scope ilk="function" name="read_timeout" />
          <scope ilk="function" name="ssl_timeout" />
          <scope ilk="function" name="ssl_timeout=" />
          <scope ilk="function" name="ssl_version" />
          <scope ilk="function" name="ssl_version=" />
          <scope ilk="function" name="verify_callback" />
          <scope ilk="function" name="verify_callback=" />
          <scope ilk="function" name="verify_depth" />
          <scope ilk="function" name="verify_depth=" />
          <scope ilk="function" name="verify_mode" />
          <scope ilk="function" name="verify_mode=" />
          <variable name="SSL_ATTRIBUTES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="HTTPSuccess" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPSwitchProtocol" ilk="class" classrefs="Net::HTTPInformation">
        </scope>
        <scope name="HTTPTemporaryRedirect" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPUnauthorized" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPUnknownResponse" ilk="class" classrefs="Net::HTTPResponse">
        </scope>
        <scope name="HTTPUnsupportedMediaType" ilk="class" classrefs="Net::HTTPClientError">
        </scope>
        <scope name="HTTPUseProxy" ilk="class" classrefs="Net::HTTPRedirection">
        </scope>
        <scope name="HTTPVersionNotSupported" ilk="class" classrefs="Net::HTTPServerError">
        </scope>
      </scope>
    </scope>
    <scope name="net/imap" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="IMAP" ilk="class" classrefs="Object">
          <import symbol="MonitorMixin" />
          <import symbol="OpenSSL" />
          <import symbol="SSL" />
          <scope name="add_authenticator" ilk="function" signature="add_authenticator(auth_type, authenticator)" attributes="__classmethod__" doc="Adds an authenticator for Net::IMAP#authenticate.  +auth_type+ is the type of authentication this authenticator supports (for instance, &quot;LOGIN&quot;).  The +authenticator+ is an object which defines a process() method to handle authentication with the server.  See Net::IMAP::LoginAuthenticator, Net::IMAP::CramMD5Authenticator, and Net::IMAP::DigestMD5Authenticator for examples. &#xA; If +auth_type+ refers to an existing authenticator, it will be replaced by the new one." />
          <scope name="debug" ilk="function" signature="debug()" attributes="__classmethod__" doc="Returns the debug mode." />
          <scope name="debug=" ilk="function" signature="debug=(val)" attributes="__classmethod__" doc="Sets the debug mode." />
          <scope name="decode_utf7" ilk="function" signature="decode_utf7(s)" attributes="__classmethod__" doc="Decode a string from modified UTF-7 format to UTF-8. &#xA; UTF-7 is a 7-bit encoding of Unicode [UTF7].  IMAP uses a slightly modified version of this to encode mailbox names containing non-ASCII characters; see [IMAP] section 5.1.3. &#xA; Net::IMAP does _not_ automatically encode and decode mailbox names to and from utf7." />
          <scope name="encode_utf7" ilk="function" signature="encode_utf7(s)" attributes="__classmethod__" doc="Encode a string from UTF-8 format to modified UTF-7." />
          <scope name="format_date" ilk="function" signature="format_date(time)" attributes="__classmethod__" doc="Formats +time+ as an IMAP-style date." />
          <scope name="format_datetime" ilk="function" signature="format_datetime(time)" attributes="__classmethod__" doc="Formats +time+ as an IMAP-style date-time." />
          <scope name="max_flag_count" ilk="function" signature="max_flag_count()" attributes="__classmethod__" doc="Returns the max number of flags interned to symbols." />
          <scope name="max_flag_count=" ilk="function" signature="max_flag_count=(count)" attributes="__classmethod__" doc="Sets the max number of flags interned to symbols." />
          <scope name="new" ilk="function" signature="new(host, port_or_options = {}, usessl = false, certs = nil, verify = true)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::IMAP object and connects it to the specified +host+. &#xA; +options+ is an option hash, each key of which is a symbol. &#xA; The available options are: &#xA; port number (default value is 143 for imap, or 993 for imaps)&#xA;if options[:ssl] is true, then an attempt will be made to use SSL (now TLS) to connect to the server.  For this to work OpenSSL [OSSL] and the Ruby OpenSSL [RSSL] extensions need to be installed. if options[:ssl] is a hash, it&apos;s passed to OpenSSL::SSL::SSLContext#set_params as parameters. &#xA; The most common errors are: &#xA; connection refused by +host+ or an intervening firewall.&#xA;connection timed out (possibly due to packets being dropped by an intervening firewall).&#xA;there is no route to that network.&#xA;hostname not known or other socket error.&#xA;we connected to the host, but they immediately said goodbye to us." />
          <scope name="add_response_handler" ilk="function" signature="add_response_handler(handler = Proc.new)" doc="Adds a response handler. For example, to detect when the server sends us a new EXISTS response (which normally indicates new messages being added to the mail box), you could add the following handler after selecting the mailbox. &#xA; imap.add_response_handler { |resp|&#xA;  if resp.kind_of?(Net::IMAP::UntaggedResponse) and resp.name == &quot;EXISTS&quot;&#xA;    puts &quot;Mailbox now has #{resp.data} messages&quot;&#xA;  end&#xA;}" />
          <scope name="append" ilk="function" signature="append(mailbox, message, flags = nil, date_time = nil)" doc="Sends a APPEND command to append the +message+ to the end of the +mailbox+. The optional +flags+ argument is an array of flags to initially passing to the new message.  The optional +date_time+ argument specifies the creation time to assign to the new message; it defaults to the current time. For example: &#xA; imap.append(&quot;inbox&quot;, &lt;&lt;EOF.gsub(/\n/, &quot;\r\n&quot;), [:Seen], Time.now)&#xA;Subject: hello&#xA;From: shugo@ruby-lang.org&#xA;To: shugo@ruby-lang.org&#xA;&#xA;hello world&#xA;EOF&#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist (it is not created automatically), or if the flags, date_time, or message arguments contain errors." />
          <scope name="authenticate" ilk="function" signature="authenticate(auth_type, *args)" doc="Sends an AUTHENTICATE command to authenticate the client. The +auth_type+ parameter is a string that represents the authentication mechanism to be used. Currently Net::IMAP supports authentication mechanisms: &#xA; LOGIN:: login using cleartext user and password.&#xA;CRAM-MD5:: login with cleartext user and encrypted password&#xA;           (see [RFC-2195] for a full description).  This&#xA;           mechanism requires that the server have the user&apos;s&#xA;           password stored in clear-text password.&#xA; For both these mechanisms, there should be two +args+: username and (cleartext) password.  A server may not support one or other of these mechanisms; check #capability() for a capability of the form &quot;AUTH=LOGIN&quot; or &quot;AUTH=CRAM-MD5&quot;. &#xA; Authentication is done using the appropriate authenticator object: see @@authenticators for more information on plugging in your own authenticator. &#xA; For example: &#xA; imap.authenticate(&apos;LOGIN&apos;, user, password)&#xA; A Net::IMAP::NoResponseError is raised if authentication fails." />
          <scope name="capability" ilk="function" signature="capability()" doc="Sends a CAPABILITY command, and returns an array of capabilities that the server supports.  Each capability is a string.  See [IMAP] for a list of possible capabilities. &#xA; Note that the Net::IMAP class does not modify its behaviour according to the capabilities of the server; it is up to the user of the class to ensure that a certain capability is supported by a server before using it." />
          <scope name="check" ilk="function" signature="check()" doc="Sends a CHECK command to request a checkpoint of the currently selected mailbox.  This performs implementation-specific housekeeping, for instance, reconciling the mailbox&apos;s in-memory and on-disk state." />
          <scope name="close" ilk="function" signature="close()" doc="Sends a CLOSE command to close the currently selected mailbox. The CLOSE command permanently removes from the mailbox all messages that have the \Deleted flag set." />
          <scope name="copy" ilk="function" signature="copy(set, mailbox)" doc="Sends a COPY command to copy the specified message(s) to the end of the specified destination +mailbox+. The +set+ parameter is a number or an array of numbers or a Range object. The number is a message sequence number." />
          <scope name="create" ilk="function" signature="create(mailbox)" doc="Sends a CREATE command to create a new +mailbox+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be created." />
          <scope name="delete" ilk="function" signature="delete(mailbox)" doc="Sends a DELETE command to remove the +mailbox+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with that name cannot be deleted, either because it does not exist or because the client does not have permission to delete it." />
          <scope name="disconnect" ilk="function" signature="disconnect()" doc="Disconnects from the server." />
          <scope name="disconnected?" ilk="function" signature="disconnected?()" doc="Returns true if disconnected from the server." />
          <scope name="examine" ilk="function" signature="examine(mailbox)" doc="Sends a EXAMINE command to select a +mailbox+ so that messages in the +mailbox+ can be accessed.  Behaves the same as #select(), except that the selected +mailbox+ is identified as read-only. &#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-examinable." />
          <scope name="expunge" ilk="function" signature="expunge()" doc="Sends a EXPUNGE command to permanently remove from the currently selected mailbox all messages that have the \Deleted flag set." />
          <scope name="fetch" ilk="function" signature="fetch(set, attr)" doc="Sends a FETCH command to retrieve data associated with a message in the mailbox. The +set+ parameter is a number or an array of numbers or a Range object. The number is a message sequence number.  +attr+ is a list of attributes to fetch; see the documentation for Net::IMAP::FetchData for a list of valid attributes. The return value is an array of Net::IMAP::FetchData. For example: &#xA; p imap.fetch(6..8, &quot;UID&quot;)&#xA;=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;UID&quot;=&gt;98}&gt;, \\&#xA;     #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;UID&quot;=&gt;99}&gt;, \\&#xA;     #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;UID&quot;=&gt;100}&gt;]&#xA;p imap.fetch(6, &quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;)&#xA;=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;BODY[HEADER.FIELDS (SUBJECT)]&quot;=&gt;&quot;Subject: test\r\n\r\n&quot;}&gt;]&#xA;data = imap.uid_fetch(98, [&quot;RFC822.SIZE&quot;, &quot;INTERNALDATE&quot;])[0]&#xA;p data.seqno&#xA;=&gt; 6&#xA;p data.attr[&quot;RFC822.SIZE&quot;]&#xA;=&gt; 611&#xA;p data.attr[&quot;INTERNALDATE&quot;]" />
          <scope name="getacl" ilk="function" signature="getacl(mailbox)" doc="Send the GETACL command along with specified +mailbox+. If this mailbox exists, an array containing objects of Net::IMAP::MailboxACLItem will be returned." />
          <scope name="getquota" ilk="function" signature="getquota(mailbox)" doc="Sends the GETQUOTA command along with specified +mailbox+. If this mailbox exists, then an array containing a Net::IMAP::MailboxQuota object is returned.  This command generally is only available to server admin." />
          <scope name="getquotaroot" ilk="function" signature="getquotaroot(mailbox)" doc="Sends the GETQUOTAROOT command along with specified +mailbox+. This command is generally available to both admin and user. If mailbox exists, returns an array containing objects of Net::IMAP::MailboxQuotaRoot and Net::IMAP::MailboxQuota." />
          <scope name="idle" ilk="function" signature="idle(&amp;response_handler)" doc="Sends an IDLE command that waits for notifications of new or expunged messages.  Yields responses from the server during the IDLE. &#xA; Use #idle_done() to leave IDLE." />
          <scope name="idle_done" ilk="function" signature="idle_done()" doc="Leaves IDLE." />
          <scope name="list" ilk="function" signature="list(refname, mailbox)" doc="Sends a LIST command, and returns a subset of names from the complete set of all names available to the client. +refname+ provides a context (for instance, a base directory in a directory-based mailbox hierarchy).  +mailbox+ specifies a mailbox or (via wildcards) mailboxes under that context. Two wildcards may be used in +mailbox+: &apos;*&apos;, which matches all characters *including* the hierarchy delimiter (for instance, &apos;/&apos; on a UNIX-hosted directory-based mailbox hierarchy); and &apos;%&apos;, which matches all characters *except* the hierarchy delimiter. &#xA; If +refname+ is empty, +mailbox+ is used directly to determine which mailboxes to match.  If +mailbox+ is empty, the root name of +refname+ and the hierarchy delimiter are returned. &#xA; The return value is an array of +Net::IMAP::MailboxList+. For example: &#xA; imap.create(&quot;foo/bar&quot;)&#xA;imap.create(&quot;foo/baz&quot;)&#xA;p imap.list(&quot;&quot;, &quot;foo/%&quot;)&#xA;=&gt; [#&lt;Net::IMAP::MailboxList attr=[:Noselect], delim=&quot;/&quot;, name=&quot;foo/&quot;&gt;, \\&#xA;     #&lt;Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=&quot;/&quot;, name=&quot;foo/bar&quot;&gt;, \\&#xA;     #&lt;Net::IMAP::MailboxList attr=[:Noinferiors], delim=&quot;/&quot;, name=&quot;foo/baz&quot;&gt;]" />
          <scope name="login" ilk="function" signature="login(user, password)" doc="Sends a LOGIN command to identify the client and carries the plaintext +password+ authenticating this +user+.  Note that, unlike calling #authenticate() with an +auth_type+ of &quot;LOGIN&quot;, #login() does *not* use the login authenticator. &#xA; A Net::IMAP::NoResponseError is raised if authentication fails." />
          <scope name="logout" ilk="function" signature="logout()" doc="Sends a LOGOUT command to inform the server that the client is done with the connection." />
          <scope name="lsub" ilk="function" signature="lsub(refname, mailbox)" doc="Sends a LSUB command, and returns a subset of names from the set of names that the user has declared as being &quot;active&quot; or &quot;subscribed&quot;.  +refname+ and +mailbox+ are interpreted as for #list(). The return value is an array of +Net::IMAP::MailboxList+." />
          <scope name="noop" ilk="function" signature="noop()" doc="Sends a NOOP command to the server. It does nothing." />
          <scope name="remove_response_handler" ilk="function" signature="remove_response_handler(handler)" doc="Removes the response handler." />
          <scope name="rename" ilk="function" signature="rename(mailbox, newname)" doc="Sends a RENAME command to change the name of the +mailbox+ to +newname+. &#xA; A Net::IMAP::NoResponseError is raised if a mailbox with the name +mailbox+ cannot be renamed to +newname+ for whatever reason; for instance, because +mailbox+ does not exist, or because there is already a mailbox with the name +newname+." />
          <scope name="search" ilk="function" signature="search(keys, charset = nil)" doc="Sends a SEARCH command to search the mailbox for messages that match the given searching criteria, and returns message sequence numbers.  +keys+ can either be a string holding the entire search string, or a single-dimension array of search keywords and arguments.  The following are some common search criteria; see [IMAP] section 6.4.4 for a full list. &#xA; a set of message sequence numbers.  &apos;,&apos; indicates an interval, &apos;:&apos; indicates a range.  For instance, &apos;2,10:12,15&apos; means &quot;2,10,11,12,15&quot;. &#xA;messages with an internal date strictly before &lt;date&gt;.  The date argument has a format similar to 8-Aug-2002. &#xA;messages that contain &lt;string&gt; within their body. &#xA;messages containing &lt;string&gt; in their CC field. &#xA;messages that contain &lt;string&gt; in their FROM field. &#xA;messages with the \Recent, but not the \Seen, flag set. &#xA;negate the following search key. &#xA;&quot;or&quot; two search keys together. &#xA;messages with an internal date exactly equal to &lt;date&gt;, which has a format similar to 8-Aug-2002. &#xA;messages with an internal date on or after &lt;date&gt;. &#xA;messages with &lt;string&gt; in their subject. &#xA;messages with &lt;string&gt; in their TO field. " />
          <scope name="select" ilk="function" signature="select(mailbox)" doc="Sends a SELECT command to select a +mailbox+ so that messages in the +mailbox+ can be accessed. &#xA; After you have selected a mailbox, you may retrieve the number of items in that mailbox from @responses[&quot;EXISTS&quot;][-1], and the number of recent messages from @responses[&quot;RECENT&quot;][-1]. Note that these values can change if new messages arrive during a session; see #add_response_handler() for a way of detecting this event. &#xA; A Net::IMAP::NoResponseError is raised if the mailbox does not exist or is for some reason non-selectable." />
          <scope name="setacl" ilk="function" signature="setacl(mailbox, user, rights)" doc="Sends the SETACL command along with +mailbox+, +user+ and the +rights+ that user is to have on that mailbox.  If +rights+ is nil, then that user will be stripped of any rights to that mailbox. The IMAP ACL commands are described in [RFC-2086]." />
          <scope name="setquota" ilk="function" signature="setquota(mailbox, quota)" doc="Sends a SETQUOTA command along with the specified +mailbox+ and +quota+.  If +quota+ is nil, then quota will be unset for that mailbox.  Typically one needs to be logged in as server admin for this to work.  The IMAP quota commands are described in [RFC-2087]." />
          <scope name="sort" ilk="function" signature="sort(sort_keys, search_keys, charset)" doc="Sends a SORT command to sort messages in the mailbox. Returns an array of message sequence numbers. For example: &#xA; p imap.sort([&quot;FROM&quot;], [&quot;ALL&quot;], &quot;US-ASCII&quot;)&#xA;=&gt; [1, 2, 3, 5, 6, 7, 8, 4, 9]&#xA;p imap.sort([&quot;DATE&quot;], [&quot;SUBJECT&quot;, &quot;hello&quot;], &quot;US-ASCII&quot;)&#xA;=&gt; [6, 7, 8, 1]&#xA; See [SORT-THREAD-EXT] for more details." />
          <scope name="starttls" ilk="function" signature="starttls(options = {}, verify = true)" doc="Sends a STARTTLS command to start TLS session." />
          <scope name="status" ilk="function" signature="status(mailbox, attr)" doc="Sends a STATUS command, and returns the status of the indicated +mailbox+. +attr+ is a list of one or more attributes that we are request the status of.  Supported attributes include: &#xA; MESSAGES:: the number of messages in the mailbox.&#xA;RECENT:: the number of recent messages in the mailbox.&#xA;UNSEEN:: the number of unseen messages in the mailbox.&#xA; The return value is a hash of attributes. For example: &#xA; p imap.status(&quot;inbox&quot;, [&quot;MESSAGES&quot;, &quot;RECENT&quot;])&#xA;=&gt; {&quot;RECENT&quot;=&gt;0, &quot;MESSAGES&quot;=&gt;44}&#xA; A Net::IMAP::NoResponseError is raised if status values for +mailbox+ cannot be returned, for instance because it does not exist." />
          <scope name="store" ilk="function" signature="store(set, attr, flags)" doc="Sends a STORE command to alter data associated with messages in the mailbox, in particular their flags. The +set+ parameter is a number or an array of numbers or a Range object. Each number is a message sequence number.  +attr+ is the name of a data item to store: &apos;FLAGS&apos; means to replace the message&apos;s flag list with the provided one; &apos;+FLAGS&apos; means to add the provided flags; and &apos;-FLAGS&apos; means to remove them.  +flags+ is a list of flags. &#xA; The return value is an array of Net::IMAP::FetchData. For example: &#xA; p imap.store(6..8, &quot;+FLAGS&quot;, [:Deleted])&#xA;=&gt; [#&lt;Net::IMAP::FetchData seqno=6, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \\&#xA;     #&lt;Net::IMAP::FetchData seqno=7, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;, \\&#xA;     #&lt;Net::IMAP::FetchData seqno=8, attr={&quot;FLAGS&quot;=&gt;[:Seen, :Deleted]}&gt;]" />
          <scope name="subscribe" ilk="function" signature="subscribe(mailbox)" doc="Sends a SUBSCRIBE command to add the specified +mailbox+ name to the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes as returned by #lsub(). &#xA; A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be subscribed to, for instance because it does not exist." />
          <scope name="thread" ilk="function" signature="thread(algorithm, search_keys, charset)" doc="As for #search(), but returns message sequence numbers in threaded format, as a Net::IMAP::ThreadMember tree.  The supported algorithms are: &#xA; split into single-level threads according to subject, ordered by date.&#xA;split into threads by parent/child relationships determined by which message is a reply to which. &#xA; Unlike #search(), +charset+ is a required argument.  US-ASCII and UTF-8 are sample values. &#xA; See [SORT-THREAD-EXT] for more details." />
          <scope name="uid_copy" ilk="function" signature="uid_copy(set, mailbox)" doc="As for #copy(), but +set+ contains unique identifiers." />
          <scope name="uid_fetch" ilk="function" signature="uid_fetch(set, attr)" doc="As for #fetch(), but +set+ contains unique identifiers." />
          <scope name="uid_search" ilk="function" signature="uid_search(keys, charset = nil)" doc="As for #search(), but returns unique identifiers." />
          <scope name="uid_sort" ilk="function" signature="uid_sort(sort_keys, search_keys, charset)" doc="As for #sort(), but returns an array of unique identifiers." />
          <scope name="uid_store" ilk="function" signature="uid_store(set, attr, flags)" doc="As for #store(), but +set+ contains unique identifiers." />
          <scope name="uid_thread" ilk="function" signature="uid_thread(algorithm, search_keys, charset)" doc="As for #thread(), but returns unique identifiers instead of message sequence numbers." />
          <scope name="unsubscribe" ilk="function" signature="unsubscribe(mailbox)" doc="Sends a UNSUBSCRIBE command to remove the specified +mailbox+ name from the server&apos;s set of &quot;active&quot; or &quot;subscribed&quot; mailboxes. &#xA; A Net::IMAP::NoResponseError is raised if +mailbox+ cannot be unsubscribed from, for instance because the client is not currently subscribed to it." />
          <scope name="xlist" ilk="function" signature="xlist(refname, mailbox)" doc="Sends a XLIST command, and returns a subset of names from the complete set of all names available to the client. +refname+ provides a context (for instance, a base directory in a directory-based mailbox hierarchy).  +mailbox+ specifies a mailbox or (via wildcards) mailboxes under that context. Two wildcards may be used in +mailbox+: &apos;*&apos;, which matches all characters *including* the hierarchy delimiter (for instance, &apos;/&apos; on a UNIX-hosted directory-based mailbox hierarchy); and &apos;%&apos;, which matches all characters *except* the hierarchy delimiter. &#xA; If +refname+ is empty, +mailbox+ is used directly to determine which mailboxes to match.  If +mailbox+ is empty, the root name of +refname+ and the hierarchy delimiter are returned. &#xA; The XLIST command is like the LIST command except that the flags returned refer to the function of the folder/mailbox, e.g. :Sent &#xA; The return value is an array of +Net::IMAP::MailboxList+. For example: &#xA; imap.create(&quot;foo/bar&quot;)&#xA;imap.create(&quot;foo/baz&quot;)&#xA;p imap.xlist(&quot;&quot;, &quot;foo/%&quot;)&#xA;=&gt; [#&lt;Net::IMAP::MailboxList attr=[:Noselect], delim=&quot;/&quot;, name=&quot;foo/&quot;&gt;, \\&#xA;     #&lt;Net::IMAP::MailboxList attr=[:Noinferiors, :Marked], delim=&quot;/&quot;, name=&quot;foo/bar&quot;&gt;, \\&#xA;     #&lt;Net::IMAP::MailboxList attr=[:Noinferiors], delim=&quot;/&quot;, name=&quot;foo/baz&quot;&gt;]" />
          <scope ilk="function" name="client_thread" />
          <scope ilk="function" name="client_thread=" />
          <scope ilk="function" name="greeting" />
          <scope ilk="function" name="response_handlers" />
          <scope ilk="function" name="responses" />
          <variable name="SEEN" attributes="__const__" citdl="Object" />
          <variable name="ANSWERED" attributes="__const__" citdl="Object" />
          <variable name="FLAGGED" attributes="__const__" citdl="Object" />
          <variable name="DELETED" attributes="__const__" citdl="Object" />
          <variable name="DRAFT" attributes="__const__" citdl="Object" />
          <variable name="RECENT" attributes="__const__" citdl="Object" />
          <variable name="NOINFERIORS" attributes="__const__" citdl="Object" />
          <variable name="NOSELECT" attributes="__const__" citdl="Object" />
          <variable name="MARKED" attributes="__const__" citdl="Object" />
          <variable name="UNMARKED" attributes="__const__" citdl="Object" />
          <variable name="CRLF" attributes="__const__" citdl="Object" />
          <variable name="PORT" attributes="__const__" citdl="Object" />
          <variable name="SSL_PORT" attributes="__const__" citdl="Object" />
          <variable name="DATE_MONTH" attributes="__const__" citdl="Object" />
          <scope name="BadResponseError" ilk="class" classrefs="Net::IMAP::ResponseError">
          </scope>
          <scope name="BodyTypeBasic" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                      :param, :content_id,                                      :description, :encoding, :size,                                      :md5, :disposition, :language,                                      :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeMessage" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                        :param, :content_id,                                        :description, :encoding, :size,                                        :envelope, :body, :lines,                                        :md5, :disposition, :language,                                        :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeMultipart" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                          :parts,                                          :param, :disposition, :language,                                          :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="BodyTypeText" ilk="class" classrefs="Struct.new(:media_type, :subtype,                                     :param, :content_id,                                     :description, :encoding, :size,                                     :lines,                                     :md5, :disposition, :language,                                     :extension)">
            <scope name="media_subtype" ilk="function" signature="media_subtype()" doc="Obsolete: use +subtype+ instead.  Calling this will generate a warning message to +stderr+, then return the value of +subtype+." />
            <scope name="multipart?" ilk="function" signature="multipart?()" />
          </scope>
          <scope name="ByeResponseError" ilk="class" classrefs="Net::IMAP::ResponseError">
          </scope>
          <scope name="CramMD5Authenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(challenge)" />
          </scope>
          <scope name="DataFormatError" ilk="class" classrefs="Net::IMAP::Error">
          </scope>
          <scope name="DigestMD5Authenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password, authname = nil)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(challenge)" />
            <variable name="STAGE_ONE" attributes="__const__" citdl="Object" />
            <variable name="STAGE_TWO" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Error" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="FlagCountError" ilk="class" classrefs="Net::IMAP::Error">
          </scope>
          <scope name="LoginAuthenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(data)" />
            <variable name="STATE_USER" attributes="__const__" citdl="Object" />
            <variable name="STATE_PASSWORD" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="NoResponseError" ilk="class" classrefs="Net::IMAP::ResponseError">
          </scope>
          <scope name="PlainAuthenticator" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user, password)" attributes="__classmethod__ __ctor__" />
            <scope name="process" ilk="function" signature="process(data)" />
          </scope>
          <scope name="ResponseError" ilk="class" classrefs="Net::IMAP::Error">
            <scope name="new" ilk="function" signature="new(response)" attributes="__classmethod__ __ctor__" />
            <scope ilk="function" name="response" />
            <scope ilk="function" name="response=" />
          </scope>
          <scope name="ResponseParseError" ilk="class" classrefs="Net::IMAP::Error">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="net/pop" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="APOP" ilk="class" classrefs="Net::POP3">
          <scope name="apop?" ilk="function" signature="apop?()" doc="Always returns true." />
        </scope>
        <scope name="APOPSession" ilk="class" classrefs="Net::POP3">
          <scope name="apop?" ilk="function" signature="apop?()" doc="Always returns true." />
        </scope>
        <scope name="POP" ilk="class" classrefs="Protocol">
          <scope name="APOP" ilk="function" signature="APOP(isapop)" attributes="__classmethod__" doc="Returns the APOP class if +isapop+ is true; otherwise, returns the POP class.  For example: &#xA; # Example 1&#xA;pop = Net::POP3::APOP($is_apop).new(addr, port)&#xA;&#xA;# Example 2&#xA;Net::POP3::APOP($is_apop).start(addr, port) do |pop|&#xA;  ....&#xA;end" />
          <scope name="auth_only" ilk="function" signature="auth_only(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Opens a POP3 session, attempts authentication, and quits. &#xA; This method raises POPAuthenticationError if authentication fails. &#xA; Example: normal POP3 &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;)&#xA; Example: APOP &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;, true)" />
          <scope name="certs" ilk="function" signature="certs()" attributes="__classmethod__" doc="returns the :ca_file or :ca_path from POP3.ssh_params" />
          <scope name="create_ssl_params" ilk="function" signature="create_ssl_params(verify_or_params = {}, certs = nil)" attributes="__classmethod__" doc="Constructs proper parameters from arguments" />
          <scope name="default_pop3_port" ilk="function" signature="default_pop3_port()" attributes="__classmethod__" doc="The default port for POP3 connections, port 110" />
          <scope name="default_pop3s_port" ilk="function" signature="default_pop3s_port()" attributes="__classmethod__" doc="The default port for POP3S connections, port 995" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="returns the port for POP3" />
          <scope name="delete_all" ilk="function" signature="delete_all(address, port = nil, account = nil, password = nil, isapop = false, &amp;block)" attributes="__classmethod__" doc="Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted. &#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.delete_all(&apos;pop.example.com&apos;, 110,&#xA;                     &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" attributes="__classmethod__" doc="Disable SSL for all new instances." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(*args)" attributes="__classmethod__" doc="Enable SSL for all new instances. +params+ is passed to OpenSSL::SSLContext#set_params." />
          <scope name="foreach" ilk="function" signature="foreach(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Starts a POP3 session and iterates over each POPMail object, yielding it to the +block+. This method is equivalent to: &#xA; Net::POP3.start(address, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    yield m&#xA;  end&#xA;end&#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.foreach(&apos;pop.example.com&apos;, 110,&#xA;                  &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;  m.delete if $DELETE&#xA;end" />
          <scope name="new" ilk="function" signature="new(addr, port = nil, isapop = false)" attributes="__classmethod__ __ctor__" doc="Creates a new POP3 object. &#xA; +address+ is the hostname or ip address of your POP3 server. &#xA; The optional +port+ is the port to connect to. &#xA; The optional +isapop+ specifies whether this connection is going to use APOP authentication; it defaults to +false+. &#xA; This method does *not* open the TCP connection." />
          <scope name="ssl_params" ilk="function" signature="ssl_params()" attributes="__classmethod__" doc="returns the SSL Parameters &#xA; see also POP3.enable_ssl" />
          <scope name="start" ilk="function" signature="start(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Creates a new POP3 object and open the connection.  Equivalent to &#xA; Net::POP3.new(address, port, isapop).start(account, password)&#xA; If +block+ is provided, yields the newly-opened POP3 object to it, and automatically closes it at the end of the session. &#xA; Example &#xA; Net::POP3.start(addr, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    file.write m.pop&#xA;    m.delete&#xA;  end&#xA;end" />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" attributes="__classmethod__" doc="returns +true+ if POP3.ssl_params is set" />
          <scope name="verify" ilk="function" signature="verify()" attributes="__classmethod__" doc="returns whether verify_mode is enable from POP3.ssl_params" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="apop?" ilk="function" signature="apop?()" doc="Does this instance use APOP authentication?" />
          <scope name="auth_only" ilk="function" signature="auth_only(account, password)" doc="Starts a pop3 session, attempts authentication, and quits. This method must not be called while POP3 session is opened. This method raises POPAuthenticationError if authentication fails." />
          <scope name="delete_all" ilk="function" signature="delete_all()" doc="Deletes all messages on the server. &#xA; If called with a block, yields each message in turn before deleting it. &#xA; Example &#xA; n = 1&#xA;pop.delete_all do |m|&#xA;  File.open(&quot;inbox/#{n}&quot;) do |f|&#xA;    f.write m.pop&#xA;  end&#xA;  n += 1&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" doc="Disable SSL for all new instances." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_mail" ilk="function" signature="each_mail()" doc="Yields each message to the passed-in block in turn. Equivalent to: &#xA; pop3.mails.each do |popmail|&#xA;  ....&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(verify_or_params = {}, certs = nil, port = nil)" doc="Enables SSL for this instance.  Must be called before the connection is established to have any effect. +params[:port]+ is port to establish the SSL connection on; Defaults to 995. +params+ (except :port) is passed to OpenSSL::SSLContext#set_params." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes a POP3 session and closes TCP connection." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="logging" ilk="function" signature="logging(msg)" doc="deguging output for +msg+" />
          <scope name="mails" ilk="function" signature="mails()" doc="Returns an array of Net::POPMail objects, representing all the messages on the server.  This array is renewed when the session restarts; otherwise, it is fetched from the server the first time this method is called (directly or indirectly) and cached. &#xA; This method raises a POPError if an error occurs." />
          <scope name="n_bytes" ilk="function" signature="n_bytes()" doc="Returns the total size in bytes of all the messages on the POP server." />
          <scope name="n_mails" ilk="function" signature="n_mails()" doc="Returns the number of messages on the POP server." />
          <scope name="port" ilk="function" signature="port()" doc="The port number to connect to." />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the read timeout." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the session.  This clears all &quot;deleted&quot; marks from messages. &#xA; This method raises a POPError if an error occurs." />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" doc="*WARNING*: This method causes a serious security hole. Use this method only for debugging. &#xA; Set an output stream for debugging. &#xA; Example &#xA; pop = Net::POP.new(addr, port)&#xA;pop.set_debug_output $stderr&#xA;pop.start(account, passwd) do |pop|&#xA;  ....&#xA;end" />
          <scope name="start" ilk="function" signature="start(account, password)" doc="Starts a POP3 session. &#xA; When called with block, gives a POP3 object to the block and closes the session after block call finishes. &#xA; This method raises a POPAuthenticationError if authentication fails." />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the POP3 session has started." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="does this instance use SSL?" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="read_timeout" />
        </scope>
        <scope name="POP3" ilk="class" classrefs="Protocol">
          <scope name="APOP" ilk="function" signature="APOP(isapop)" attributes="__classmethod__" doc="Returns the APOP class if +isapop+ is true; otherwise, returns the POP class.  For example: &#xA; # Example 1&#xA;pop = Net::POP3::APOP($is_apop).new(addr, port)&#xA;&#xA;# Example 2&#xA;Net::POP3::APOP($is_apop).start(addr, port) do |pop|&#xA;  ....&#xA;end" />
          <scope name="auth_only" ilk="function" signature="auth_only(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Opens a POP3 session, attempts authentication, and quits. &#xA; This method raises POPAuthenticationError if authentication fails. &#xA; Example: normal POP3 &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;)&#xA; Example: APOP &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;, true)" />
          <scope name="certs" ilk="function" signature="certs()" attributes="__classmethod__" doc="returns the :ca_file or :ca_path from POP3.ssh_params" />
          <scope name="create_ssl_params" ilk="function" signature="create_ssl_params(verify_or_params = {}, certs = nil)" attributes="__classmethod__" doc="Constructs proper parameters from arguments" />
          <scope name="default_pop3_port" ilk="function" signature="default_pop3_port()" attributes="__classmethod__" doc="The default port for POP3 connections, port 110" />
          <scope name="default_pop3s_port" ilk="function" signature="default_pop3s_port()" attributes="__classmethod__" doc="The default port for POP3S connections, port 995" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="returns the port for POP3" />
          <scope name="delete_all" ilk="function" signature="delete_all(address, port = nil, account = nil, password = nil, isapop = false, &amp;block)" attributes="__classmethod__" doc="Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted. &#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.delete_all(&apos;pop.example.com&apos;, 110,&#xA;                     &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" attributes="__classmethod__" doc="Disable SSL for all new instances." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(*args)" attributes="__classmethod__" doc="Enable SSL for all new instances. +params+ is passed to OpenSSL::SSLContext#set_params." />
          <scope name="foreach" ilk="function" signature="foreach(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Starts a POP3 session and iterates over each POPMail object, yielding it to the +block+. This method is equivalent to: &#xA; Net::POP3.start(address, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    yield m&#xA;  end&#xA;end&#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.foreach(&apos;pop.example.com&apos;, 110,&#xA;                  &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;  m.delete if $DELETE&#xA;end" />
          <scope name="new" ilk="function" signature="new(addr, port = nil, isapop = false)" attributes="__classmethod__ __ctor__" doc="Creates a new POP3 object. &#xA; +address+ is the hostname or ip address of your POP3 server. &#xA; The optional +port+ is the port to connect to. &#xA; The optional +isapop+ specifies whether this connection is going to use APOP authentication; it defaults to +false+. &#xA; This method does *not* open the TCP connection." />
          <scope name="ssl_params" ilk="function" signature="ssl_params()" attributes="__classmethod__" doc="returns the SSL Parameters &#xA; see also POP3.enable_ssl" />
          <scope name="start" ilk="function" signature="start(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Creates a new POP3 object and open the connection.  Equivalent to &#xA; Net::POP3.new(address, port, isapop).start(account, password)&#xA; If +block+ is provided, yields the newly-opened POP3 object to it, and automatically closes it at the end of the session. &#xA; Example &#xA; Net::POP3.start(addr, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    file.write m.pop&#xA;    m.delete&#xA;  end&#xA;end" />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" attributes="__classmethod__" doc="returns +true+ if POP3.ssl_params is set" />
          <scope name="verify" ilk="function" signature="verify()" attributes="__classmethod__" doc="returns whether verify_mode is enable from POP3.ssl_params" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="apop?" ilk="function" signature="apop?()" doc="Does this instance use APOP authentication?" />
          <scope name="auth_only" ilk="function" signature="auth_only(account, password)" doc="Starts a pop3 session, attempts authentication, and quits. This method must not be called while POP3 session is opened. This method raises POPAuthenticationError if authentication fails." />
          <scope name="delete_all" ilk="function" signature="delete_all()" doc="Deletes all messages on the server. &#xA; If called with a block, yields each message in turn before deleting it. &#xA; Example &#xA; n = 1&#xA;pop.delete_all do |m|&#xA;  File.open(&quot;inbox/#{n}&quot;) do |f|&#xA;    f.write m.pop&#xA;  end&#xA;  n += 1&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" doc="Disable SSL for all new instances." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_mail" ilk="function" signature="each_mail()" doc="Yields each message to the passed-in block in turn. Equivalent to: &#xA; pop3.mails.each do |popmail|&#xA;  ....&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(verify_or_params = {}, certs = nil, port = nil)" doc="Enables SSL for this instance.  Must be called before the connection is established to have any effect. +params[:port]+ is port to establish the SSL connection on; Defaults to 995. +params+ (except :port) is passed to OpenSSL::SSLContext#set_params." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes a POP3 session and closes TCP connection." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="logging" ilk="function" signature="logging(msg)" doc="deguging output for +msg+" />
          <scope name="mails" ilk="function" signature="mails()" doc="Returns an array of Net::POPMail objects, representing all the messages on the server.  This array is renewed when the session restarts; otherwise, it is fetched from the server the first time this method is called (directly or indirectly) and cached. &#xA; This method raises a POPError if an error occurs." />
          <scope name="n_bytes" ilk="function" signature="n_bytes()" doc="Returns the total size in bytes of all the messages on the POP server." />
          <scope name="n_mails" ilk="function" signature="n_mails()" doc="Returns the number of messages on the POP server." />
          <scope name="port" ilk="function" signature="port()" doc="The port number to connect to." />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the read timeout." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the session.  This clears all &quot;deleted&quot; marks from messages. &#xA; This method raises a POPError if an error occurs." />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" doc="*WARNING*: This method causes a serious security hole. Use this method only for debugging. &#xA; Set an output stream for debugging. &#xA; Example &#xA; pop = Net::POP.new(addr, port)&#xA;pop.set_debug_output $stderr&#xA;pop.start(account, passwd) do |pop|&#xA;  ....&#xA;end" />
          <scope name="start" ilk="function" signature="start(account, password)" doc="Starts a POP3 session. &#xA; When called with block, gives a POP3 object to the block and closes the session after block call finishes. &#xA; This method raises a POPAuthenticationError if authentication fails." />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the POP3 session has started." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="does this instance use SSL?" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="read_timeout" />
        </scope>
        <scope name="POP3Session" ilk="class" classrefs="Protocol">
          <scope name="APOP" ilk="function" signature="APOP(isapop)" attributes="__classmethod__" doc="Returns the APOP class if +isapop+ is true; otherwise, returns the POP class.  For example: &#xA; # Example 1&#xA;pop = Net::POP3::APOP($is_apop).new(addr, port)&#xA;&#xA;# Example 2&#xA;Net::POP3::APOP($is_apop).start(addr, port) do |pop|&#xA;  ....&#xA;end" />
          <scope name="auth_only" ilk="function" signature="auth_only(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Opens a POP3 session, attempts authentication, and quits. &#xA; This method raises POPAuthenticationError if authentication fails. &#xA; Example: normal POP3 &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;)&#xA; Example: APOP &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;, true)" />
          <scope name="certs" ilk="function" signature="certs()" attributes="__classmethod__" doc="returns the :ca_file or :ca_path from POP3.ssh_params" />
          <scope name="create_ssl_params" ilk="function" signature="create_ssl_params(verify_or_params = {}, certs = nil)" attributes="__classmethod__" doc="Constructs proper parameters from arguments" />
          <scope name="default_pop3_port" ilk="function" signature="default_pop3_port()" attributes="__classmethod__" doc="The default port for POP3 connections, port 110" />
          <scope name="default_pop3s_port" ilk="function" signature="default_pop3s_port()" attributes="__classmethod__" doc="The default port for POP3S connections, port 995" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="returns the port for POP3" />
          <scope name="delete_all" ilk="function" signature="delete_all(address, port = nil, account = nil, password = nil, isapop = false, &amp;block)" attributes="__classmethod__" doc="Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted. &#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.delete_all(&apos;pop.example.com&apos;, 110,&#xA;                     &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" attributes="__classmethod__" doc="Disable SSL for all new instances." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(*args)" attributes="__classmethod__" doc="Enable SSL for all new instances. +params+ is passed to OpenSSL::SSLContext#set_params." />
          <scope name="foreach" ilk="function" signature="foreach(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Starts a POP3 session and iterates over each POPMail object, yielding it to the +block+. This method is equivalent to: &#xA; Net::POP3.start(address, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    yield m&#xA;  end&#xA;end&#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.foreach(&apos;pop.example.com&apos;, 110,&#xA;                  &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;  m.delete if $DELETE&#xA;end" />
          <scope name="new" ilk="function" signature="new(addr, port = nil, isapop = false)" attributes="__classmethod__ __ctor__" doc="Creates a new POP3 object. &#xA; +address+ is the hostname or ip address of your POP3 server. &#xA; The optional +port+ is the port to connect to. &#xA; The optional +isapop+ specifies whether this connection is going to use APOP authentication; it defaults to +false+. &#xA; This method does *not* open the TCP connection." />
          <scope name="ssl_params" ilk="function" signature="ssl_params()" attributes="__classmethod__" doc="returns the SSL Parameters &#xA; see also POP3.enable_ssl" />
          <scope name="start" ilk="function" signature="start(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Creates a new POP3 object and open the connection.  Equivalent to &#xA; Net::POP3.new(address, port, isapop).start(account, password)&#xA; If +block+ is provided, yields the newly-opened POP3 object to it, and automatically closes it at the end of the session. &#xA; Example &#xA; Net::POP3.start(addr, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    file.write m.pop&#xA;    m.delete&#xA;  end&#xA;end" />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" attributes="__classmethod__" doc="returns +true+ if POP3.ssl_params is set" />
          <scope name="verify" ilk="function" signature="verify()" attributes="__classmethod__" doc="returns whether verify_mode is enable from POP3.ssl_params" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="apop?" ilk="function" signature="apop?()" doc="Does this instance use APOP authentication?" />
          <scope name="auth_only" ilk="function" signature="auth_only(account, password)" doc="Starts a pop3 session, attempts authentication, and quits. This method must not be called while POP3 session is opened. This method raises POPAuthenticationError if authentication fails." />
          <scope name="delete_all" ilk="function" signature="delete_all()" doc="Deletes all messages on the server. &#xA; If called with a block, yields each message in turn before deleting it. &#xA; Example &#xA; n = 1&#xA;pop.delete_all do |m|&#xA;  File.open(&quot;inbox/#{n}&quot;) do |f|&#xA;    f.write m.pop&#xA;  end&#xA;  n += 1&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" doc="Disable SSL for all new instances." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_mail" ilk="function" signature="each_mail()" doc="Yields each message to the passed-in block in turn. Equivalent to: &#xA; pop3.mails.each do |popmail|&#xA;  ....&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(verify_or_params = {}, certs = nil, port = nil)" doc="Enables SSL for this instance.  Must be called before the connection is established to have any effect. +params[:port]+ is port to establish the SSL connection on; Defaults to 995. +params+ (except :port) is passed to OpenSSL::SSLContext#set_params." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes a POP3 session and closes TCP connection." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="logging" ilk="function" signature="logging(msg)" doc="deguging output for +msg+" />
          <scope name="mails" ilk="function" signature="mails()" doc="Returns an array of Net::POPMail objects, representing all the messages on the server.  This array is renewed when the session restarts; otherwise, it is fetched from the server the first time this method is called (directly or indirectly) and cached. &#xA; This method raises a POPError if an error occurs." />
          <scope name="n_bytes" ilk="function" signature="n_bytes()" doc="Returns the total size in bytes of all the messages on the POP server." />
          <scope name="n_mails" ilk="function" signature="n_mails()" doc="Returns the number of messages on the POP server." />
          <scope name="port" ilk="function" signature="port()" doc="The port number to connect to." />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the read timeout." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the session.  This clears all &quot;deleted&quot; marks from messages. &#xA; This method raises a POPError if an error occurs." />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" doc="*WARNING*: This method causes a serious security hole. Use this method only for debugging. &#xA; Set an output stream for debugging. &#xA; Example &#xA; pop = Net::POP.new(addr, port)&#xA;pop.set_debug_output $stderr&#xA;pop.start(account, passwd) do |pop|&#xA;  ....&#xA;end" />
          <scope name="start" ilk="function" signature="start(account, password)" doc="Starts a POP3 session. &#xA; When called with block, gives a POP3 object to the block and closes the session after block call finishes. &#xA; This method raises a POPAuthenticationError if authentication fails." />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the POP3 session has started." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="does this instance use SSL?" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="read_timeout" />
        </scope>
        <scope name="POPAuthenticationError" ilk="class" classrefs="ProtoAuthError">
        </scope>
        <scope name="POPBadResponse" ilk="class" classrefs="Net::POPError">
        </scope>
        <scope name="POPError" ilk="class" classrefs="ProtocolError">
        </scope>
        <scope name="POPMail" ilk="class" classrefs="Object">
          <scope name="all" ilk="function" signature="all( dest = &apos;&apos; )" />
          <scope name="delete" ilk="function" signature="delete()" doc="Marks a message for deletion on the server.  Deletion does not actually occur until the end of the session; deletion may be cancelled for _all_ marked messages by calling POP3#reset(). &#xA; This method raises a POPError if an error occurs. &#xA; Example &#xA; POP3.start(&apos;pop.example.com&apos;, 110,&#xA;           &apos;YourAccount, &apos;YourPassword&apos;) do |pop|&#xA;  n = 1&#xA;  pop.mails.each do |popmail|&#xA;    File.open(&quot;inbox/#{n}&quot;, &apos;w&apos;) do |f|&#xA;      f.write popmail.pop&#xA;    end&#xA;    popmail.delete         ####&#xA;    n += 1&#xA;  end" />
          <scope name="delete!" ilk="function" signature="delete!()" />
          <scope name="deleted?" ilk="function" signature="deleted?()" doc="True if the mail has been deleted." />
          <scope name="header" ilk="function" signature="header(dest = &apos;&apos;)" doc="Fetches the message header. &#xA; The optional +dest+ argument is obsolete. &#xA; This method raises a POPError if an error occurs." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="mail" ilk="function" signature="mail( dest = &apos;&apos; )" />
          <scope name="pop" ilk="function" signature="pop( dest = &apos;&apos; )" doc="This method fetches the message.  If called with a block, the message is yielded to the block one chunk at a time.  If called without a block, the message is returned as a String.  The optional +dest+ argument will be prepended to the returned String; this argument is essentially obsolete. &#xA; Example without block &#xA; POP3.start(&apos;pop.example.com&apos;, 110,&#xA;           &apos;YourAccount, &apos;YourPassword&apos;) do |pop|&#xA;  n = 1&#xA;  pop.mails.each do |popmail|&#xA;    File.open(&quot;inbox/#{n}&quot;, &apos;w&apos;) do |f|&#xA;      f.write popmail.pop&#xA;    end&#xA;    popmail.delete&#xA;    n += 1&#xA;  end&#xA;end" />
          <scope name="top" ilk="function" signature="top(lines, dest = &apos;&apos;)" doc="Fetches the message header and +lines+ lines of body. &#xA; The optional +dest+ argument is obsolete. &#xA; This method raises a POPError if an error occurs." />
          <scope name="uidl" ilk="function" signature="uidl()" />
          <scope name="unique_id" ilk="function" signature="unique_id()" doc="Returns the unique-id of the message. Normally the unique-id is a hash string of the message. &#xA; This method raises a POPError if an error occurs." />
          <scope ilk="function" name="length" />
          <scope ilk="function" name="number" />
          <scope ilk="function" name="size" />
        </scope>
        <scope name="POPSession" ilk="class" classrefs="Protocol">
          <scope name="APOP" ilk="function" signature="APOP(isapop)" attributes="__classmethod__" doc="Returns the APOP class if +isapop+ is true; otherwise, returns the POP class.  For example: &#xA; # Example 1&#xA;pop = Net::POP3::APOP($is_apop).new(addr, port)&#xA;&#xA;# Example 2&#xA;Net::POP3::APOP($is_apop).start(addr, port) do |pop|&#xA;  ....&#xA;end" />
          <scope name="auth_only" ilk="function" signature="auth_only(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Opens a POP3 session, attempts authentication, and quits. &#xA; This method raises POPAuthenticationError if authentication fails. &#xA; Example: normal POP3 &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;)&#xA; Example: APOP &#xA; Net::POP3.auth_only(&apos;pop.example.com&apos;, 110,&#xA;                    &apos;YourAccount&apos;, &apos;YourPassword&apos;, true)" />
          <scope name="certs" ilk="function" signature="certs()" attributes="__classmethod__" doc="returns the :ca_file or :ca_path from POP3.ssh_params" />
          <scope name="create_ssl_params" ilk="function" signature="create_ssl_params(verify_or_params = {}, certs = nil)" attributes="__classmethod__" doc="Constructs proper parameters from arguments" />
          <scope name="default_pop3_port" ilk="function" signature="default_pop3_port()" attributes="__classmethod__" doc="The default port for POP3 connections, port 110" />
          <scope name="default_pop3s_port" ilk="function" signature="default_pop3s_port()" attributes="__classmethod__" doc="The default port for POP3S connections, port 995" />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="returns the port for POP3" />
          <scope name="delete_all" ilk="function" signature="delete_all(address, port = nil, account = nil, password = nil, isapop = false, &amp;block)" attributes="__classmethod__" doc="Starts a POP3 session and deletes all messages on the server. If a block is given, each POPMail object is yielded to it before being deleted. &#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.delete_all(&apos;pop.example.com&apos;, 110,&#xA;                     &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" attributes="__classmethod__" doc="Disable SSL for all new instances." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(*args)" attributes="__classmethod__" doc="Enable SSL for all new instances. +params+ is passed to OpenSSL::SSLContext#set_params." />
          <scope name="foreach" ilk="function" signature="foreach(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Starts a POP3 session and iterates over each POPMail object, yielding it to the +block+. This method is equivalent to: &#xA; Net::POP3.start(address, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    yield m&#xA;  end&#xA;end&#xA; This method raises a POPAuthenticationError if authentication fails. &#xA; Example &#xA; Net::POP3.foreach(&apos;pop.example.com&apos;, 110,&#xA;                  &apos;YourAccount&apos;, &apos;YourPassword&apos;) do |m|&#xA;  file.write m.pop&#xA;  m.delete if $DELETE&#xA;end" />
          <scope name="new" ilk="function" signature="new(addr, port = nil, isapop = false)" attributes="__classmethod__ __ctor__" doc="Creates a new POP3 object. &#xA; +address+ is the hostname or ip address of your POP3 server. &#xA; The optional +port+ is the port to connect to. &#xA; The optional +isapop+ specifies whether this connection is going to use APOP authentication; it defaults to +false+. &#xA; This method does *not* open the TCP connection." />
          <scope name="ssl_params" ilk="function" signature="ssl_params()" attributes="__classmethod__" doc="returns the SSL Parameters &#xA; see also POP3.enable_ssl" />
          <scope name="start" ilk="function" signature="start(address, port = nil, account = nil, password = nil, isapop = false)" attributes="__classmethod__" doc="Creates a new POP3 object and open the connection.  Equivalent to &#xA; Net::POP3.new(address, port, isapop).start(account, password)&#xA; If +block+ is provided, yields the newly-opened POP3 object to it, and automatically closes it at the end of the session. &#xA; Example &#xA; Net::POP3.start(addr, port, account, password) do |pop|&#xA;  pop.each_mail do |m|&#xA;    file.write m.pop&#xA;    m.delete&#xA;  end&#xA;end" />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" attributes="__classmethod__" doc="returns +true+ if POP3.ssl_params is set" />
          <scope name="verify" ilk="function" signature="verify()" attributes="__classmethod__" doc="returns whether verify_mode is enable from POP3.ssl_params" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="apop?" ilk="function" signature="apop?()" doc="Does this instance use APOP authentication?" />
          <scope name="auth_only" ilk="function" signature="auth_only(account, password)" doc="Starts a pop3 session, attempts authentication, and quits. This method must not be called while POP3 session is opened. This method raises POPAuthenticationError if authentication fails." />
          <scope name="delete_all" ilk="function" signature="delete_all()" doc="Deletes all messages on the server. &#xA; If called with a block, yields each message in turn before deleting it. &#xA; Example &#xA; n = 1&#xA;pop.delete_all do |m|&#xA;  File.open(&quot;inbox/#{n}&quot;) do |f|&#xA;    f.write m.pop&#xA;  end&#xA;  n += 1&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" doc="Disable SSL for all new instances." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_mail" ilk="function" signature="each_mail()" doc="Yields each message to the passed-in block in turn. Equivalent to: &#xA; pop3.mails.each do |popmail|&#xA;  ....&#xA;end&#xA; This method raises a POPError if an error occurs." />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(verify_or_params = {}, certs = nil, port = nil)" doc="Enables SSL for this instance.  Must be called before the connection is established to have any effect. +params[:port]+ is port to establish the SSL connection on; Defaults to 995. +params+ (except :port) is passed to OpenSSL::SSLContext#set_params." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes a POP3 session and closes TCP connection." />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="logging" ilk="function" signature="logging(msg)" doc="deguging output for +msg+" />
          <scope name="mails" ilk="function" signature="mails()" doc="Returns an array of Net::POPMail objects, representing all the messages on the server.  This array is renewed when the session restarts; otherwise, it is fetched from the server the first time this method is called (directly or indirectly) and cached. &#xA; This method raises a POPError if an error occurs." />
          <scope name="n_bytes" ilk="function" signature="n_bytes()" doc="Returns the total size in bytes of all the messages on the POP server." />
          <scope name="n_mails" ilk="function" signature="n_mails()" doc="Returns the number of messages on the POP server." />
          <scope name="port" ilk="function" signature="port()" doc="The port number to connect to." />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the read timeout." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the session.  This clears all &quot;deleted&quot; marks from messages. &#xA; This method raises a POPError if an error occurs." />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" doc="*WARNING*: This method causes a serious security hole. Use this method only for debugging. &#xA; Set an output stream for debugging. &#xA; Example &#xA; pop = Net::POP.new(addr, port)&#xA;pop.set_debug_output $stderr&#xA;pop.start(account, passwd) do |pop|&#xA;  ....&#xA;end" />
          <scope name="start" ilk="function" signature="start(account, password)" doc="Starts a POP3 session. &#xA; When called with block, gives a POP3 object to the block and closes the session after block call finishes. &#xA; This method raises a POPAuthenticationError if authentication fails." />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the POP3 session has started." />
          <scope name="use_ssl?" ilk="function" signature="use_ssl?()" doc="does this instance use SSL?" />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="read_timeout" />
        </scope>
      </scope>
    </scope>
    <scope name="net/smtp" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <scope name="SMTP" ilk="class" classrefs="Object">
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="The default SMTP port number, 25." />
          <scope name="default_ssl_context" ilk="function" signature="default_ssl_context()" attributes="__classmethod__" />
          <scope name="default_ssl_port" ilk="function" signature="default_ssl_port()" attributes="__classmethod__" />
          <scope name="default_submission_port" ilk="function" signature="default_submission_port()" attributes="__classmethod__" doc="The default mail submission port number, 587." />
          <scope name="default_tls_port" ilk="function" signature="default_tls_port()" attributes="__classmethod__" doc="The default SMTPS port number, 465." />
          <scope name="new" ilk="function" signature="new(address, port = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::SMTP object. &#xA; +address+ is the hostname or ip address of your SMTP server.  +port+ is the port to connect to; it defaults to port 25. &#xA; This method does not open the TCP connection.  You can use SMTP.start instead of SMTP.new if you want to do everything at once.  Otherwise, follow SMTP.new with SMTP#start." />
          <scope name="start" ilk="function" signature="start(address, port = nil, helo = &apos;localhost&apos;, user = nil, secret = nil, authtype = nil)" attributes="__classmethod__" doc="Creates a new Net::SMTP object and connects to the server. &#xA; This method is equivalent to: &#xA; Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)&#xA; Example &#xA; Net::SMTP.start(&apos;your.smtp.server&apos;) do |smtp|&#xA;  smtp.send_message msgstr, &apos;from@example.com&apos;, [&apos;dest@example.com&apos;]&#xA;end&#xA; Block Usage &#xA; If called with a block, the newly-opened Net::SMTP object is yielded to the block, and automatically closed when the block finishes.  If called without a block, the newly-opened Net::SMTP object is returned to the caller, and it is the caller&apos;s responsibility to close it when finished. &#xA; Parameters &#xA; +address+ is the hostname or ip address of your smtp server. &#xA; +port+ is the port to connect to; it defaults to port 25. &#xA; +helo+ is the _HELO_ _domain_ provided by the client to the server (see overview comments); it defaults to &apos;localhost&apos;. " />
          <scope name="auth_cram_md5" ilk="function" signature="auth_cram_md5(user, secret)" />
          <scope name="auth_login" ilk="function" signature="auth_login(user, secret)" />
          <scope name="auth_plain" ilk="function" signature="auth_plain(user, secret)" />
          <scope name="authenticate" ilk="function" signature="authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)" />
          <scope name="capable_auth_types" ilk="function" signature="capable_auth_types()" doc="Returns supported authentication methods on this server. You cannot get valid value before opening SMTP session." />
          <scope name="capable_cram_md5_auth?" ilk="function" signature="capable_cram_md5_auth?()" doc="true if server advertises AUTH CRAM-MD5. You cannot get valid value before opening SMTP session." />
          <scope name="capable_login_auth?" ilk="function" signature="capable_login_auth?()" doc="true if server advertises AUTH LOGIN. You cannot get valid value before opening SMTP session." />
          <scope name="capable_plain_auth?" ilk="function" signature="capable_plain_auth?()" doc="true if server advertises AUTH PLAIN. You cannot get valid value before opening SMTP session." />
          <scope name="capable_starttls?" ilk="function" signature="capable_starttls?()" doc="true if server advertises STARTTLS. You cannot get valid value before opening SMTP session." />
          <scope name="data" ilk="function" signature="data(msgstr = nil)" doc="This method sends a message. If +msgstr+ is given, sends it as a message. If block is given, yield a message writer stream. You must write message before the block is closed. &#xA; # Example 1 (by string)&#xA;smtp.data(&lt;&lt;EndMessage)&#xA;From: john@example.com&#xA;To: betty@example.com&#xA;Subject: I found a bug&#xA;Check vm.c:58879.&#xA;EndMessage&#xA;# Example 2 (by block)&#xA;smtp.data {|f|&#xA;  f.puts &quot;From: john@example.com&quot;&#xA;  f.puts &quot;To: betty@example.com&quot;&#xA;  f.puts &quot;Subject: I found a bug&quot;" />
          <scope name="debug_output=" ilk="function" signature="debug_output=(arg)" doc="WARNING: This method causes serious security holes. Use this method for only debugging. &#xA; Set an output stream for debug logging. You must call this before #start. &#xA; # example&#xA;smtp = Net::SMTP.new(addr, port)&#xA;smtp.set_debug_output $stderr&#xA;smtp.start do |smtp|&#xA;  ....&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" />
          <scope name="disable_starttls" ilk="function" signature="disable_starttls()" doc="Disables SMTP/TLS (STARTTLS) for this object.  Must be called before the connection is established to have any effect." />
          <scope name="disable_tls" ilk="function" signature="disable_tls()" doc="Disables SMTP/TLS for this object.  Must be called before the connection is established to have any effect." />
          <scope name="ehlo" ilk="function" signature="ehlo(domain)" />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(context = SMTP.default_ssl_context)" />
          <scope name="enable_starttls" ilk="function" signature="enable_starttls(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (STARTTLS) for this object. +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="enable_starttls_auto" ilk="function" signature="enable_starttls_auto(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (STARTTLS) for this object if server accepts. +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="enable_tls" ilk="function" signature="enable_tls(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for this object.  Must be called before the connection is established to have any effect.  +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the SMTP session and closes TCP connection. Raises IOError if not started." />
          <scope name="helo" ilk="function" signature="helo(domain)" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="mailfrom" ilk="function" signature="mailfrom(from_addr)" />
          <scope name="open_message_stream" ilk="function" signature="open_message_stream(from_addr, *to_addrs)" doc="Opens a message writer stream and gives it to the block. The stream is valid only in the block, and has these methods: &#xA; outputs STR and CR LF.&#xA;outputs STR.&#xA;outputs sprintf(fmt,*args).&#xA;outputs STR and returns the length of written bytes.&#xA;outputs STR and returns self. &#xA; If a single CR (&quot;\r&quot;) or LF (&quot;\n&quot;) is found in the message, it is converted to the CR LF pair.  You cannot send a binary message with this method. &#xA; Parameters &#xA; +from_addr+ is a String representing the source mail address. &#xA; +to_addr+ is a String or Strings or Array of Strings, representing the destination mail address or addresses. &#xA; Example &#xA; Net::SMTP.start(&apos;smtp.example.com&apos;, 25) do |smtp|&#xA;  smtp.open_message_stream(&apos;from@example.com&apos;, [&apos;dest@example.com&apos;]) do |f|" />
          <scope name="quit" ilk="function" signature="quit()" />
          <scope name="rcptto" ilk="function" signature="rcptto(to_addr)" />
          <scope name="rcptto_list" ilk="function" signature="rcptto_list(to_addrs)" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the number of seconds to wait until timing-out a read(2) call." />
          <scope name="ready" ilk="function" signature="ready(from_addr, *to_addrs)" />
          <scope name="send_mail" ilk="function" signature="send_mail(msgstr, from_addr, *to_addrs)" />
          <scope name="send_message" ilk="function" signature="send_message(msgstr, from_addr, *to_addrs)" doc="Sends +msgstr+ as a message.  Single CR (&quot;\r&quot;) and LF (&quot;\n&quot;) found in the +msgstr+, are converted into the CR LF pair.  You cannot send a binary message with this method. +msgstr+ should include both the message headers and body. &#xA; +from_addr+ is a String representing the source mail address. &#xA; +to_addr+ is a String or Strings or Array of Strings, representing the destination mail address or addresses. &#xA; Example &#xA; Net::SMTP.start(&apos;smtp.example.com&apos;) do |smtp|&#xA;  smtp.send_message msgstr,&#xA;                    &apos;from@example.com&apos;,&#xA;                    [&apos;dest@example.com&apos;, &apos;dest2@example.com&apos;]&#xA;end&#xA; Errors &#xA; This method may raise: &#xA; Net::SMTPServerBusy&#xA;Net::SMTPSyntaxError" />
          <scope name="sendmail" ilk="function" signature="sendmail(msgstr, from_addr, *to_addrs)" />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" />
          <scope name="ssl?" ilk="function" signature="ssl?()" />
          <scope name="start" ilk="function" signature="start(helo = &apos;localhost&apos;, user = nil, secret = nil, authtype = nil)" doc="Opens a TCP connection and starts the SMTP session. &#xA; Parameters &#xA; +helo+ is the _HELO_ _domain_ that you&apos;ll dispatch mails from; see the discussion in the overview notes. &#xA; If both of +user+ and +secret+ are given, SMTP authentication will be attempted using the AUTH command.  +authtype+ specifies the type of authentication to attempt; it must be one of :login, :plain, and :cram_md5.  See the notes on SMTP Authentication in the overview. &#xA; Block Usage &#xA; When this methods is called with a block, the newly-started SMTP object is yielded to the block, and automatically closed after the block call finishes.  Otherwise, it is the caller&apos;s responsibility to close the session when finished. &#xA; Example &#xA; This is very similar to the class method SMTP.start. &#xA; require &apos;net/smtp&apos;&#xA;smtp = Net::SMTP.new(&apos;smtp.mail.server&apos;, 25)&#xA;smtp.start(helo_domain, account, password, authtype) do |smtp|&#xA;  smtp.send_message msgstr, &apos;from@example.com&apos;, [&apos;dest@example.com&apos;]&#xA;end" />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the SMTP session has been started." />
          <scope name="starttls" ilk="function" signature="starttls()" doc="SMTP command dispatcher" />
          <scope name="starttls?" ilk="function" signature="starttls?()" doc="Returns truth value if this object uses STARTTLS. If this object always uses STARTTLS, returns :always. If this object uses STARTTLS when the server support TLS, returns :auto." />
          <scope name="starttls_always?" ilk="function" signature="starttls_always?()" doc="true if this object uses STARTTLS." />
          <scope name="starttls_auto?" ilk="function" signature="starttls_auto?()" doc="true if this object uses STARTTLS when server advertises STARTTLS." />
          <scope name="tls?" ilk="function" signature="tls?()" doc="true if this object uses SMTP/TLS (SMTPS)." />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="esmtp" />
          <scope ilk="function" name="esmtp=" />
          <scope ilk="function" name="esmtp?" />
          <scope ilk="function" name="esmtp?=" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="read_timeout" />
          <variable name="DEFAULT_AUTH_TYPE" attributes="__const__" citdl="Object" />
          <variable name="IMASK" attributes="__const__" citdl="Object" />
          <variable name="OMASK" attributes="__const__" citdl="Object" />
          <variable name="CRAM_BUFSIZE" attributes="__const__" citdl="Object" />
          <scope name="Response" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(status, string)" attributes="__classmethod__ __ctor__" doc="Creates a new instance of the Response class and sets the status and string attributes" />
            <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" doc="Parses the received response and separates the reply code and the human readable reply text" />
            <scope name="capabilities" ilk="function" signature="capabilities()" doc="Returns a hash of the human readable reply text in the response if it is multiple lines. It does not return the first line. The key of the hash is the first word the value of the hash is an array with each word thereafter being a value in the array" />
            <scope name="continue?" ilk="function" signature="continue?()" doc="Determines whether the response received was a Positive Intermediate reply (3xx reply code)" />
            <scope name="cram_md5_challenge" ilk="function" signature="cram_md5_challenge()" doc="Creates a CRAM-MD5 challenge. You can view more information on CRAM-MD5 on Wikipedia: http://en.wikipedia.org/wiki/CRAM-MD5" />
            <scope name="exception_class" ilk="function" signature="exception_class()" doc="Determines whether there was an error and raies the appropriate error based on the reply code of the response" />
            <scope name="message" ilk="function" signature="message()" doc="The first line of the human readable reply text" />
            <scope name="status_type_char" ilk="function" signature="status_type_char()" doc="Takes the first digit of the reply code to determine the status type" />
            <scope name="success?" ilk="function" signature="success?()" doc="Determines whether the response received was a Positive Completion reply (2xx reply code)" />
            <scope ilk="function" name="status" />
            <scope ilk="function" name="string" />
          </scope>
        </scope>
        <scope name="SMTPAuthenticationError" ilk="class" classrefs="ProtoAuthError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPError" ilk="namespace">
        </scope>
        <scope name="SMTPFatalError" ilk="class" classrefs="ProtoFatalError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPServerBusy" ilk="class" classrefs="ProtoServerError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPSession" ilk="class" classrefs="Object">
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="The default SMTP port number, 25." />
          <scope name="default_ssl_context" ilk="function" signature="default_ssl_context()" attributes="__classmethod__" />
          <scope name="default_ssl_port" ilk="function" signature="default_ssl_port()" attributes="__classmethod__" />
          <scope name="default_submission_port" ilk="function" signature="default_submission_port()" attributes="__classmethod__" doc="The default mail submission port number, 587." />
          <scope name="default_tls_port" ilk="function" signature="default_tls_port()" attributes="__classmethod__" doc="The default SMTPS port number, 465." />
          <scope name="new" ilk="function" signature="new(address, port = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::SMTP object. &#xA; +address+ is the hostname or ip address of your SMTP server.  +port+ is the port to connect to; it defaults to port 25. &#xA; This method does not open the TCP connection.  You can use SMTP.start instead of SMTP.new if you want to do everything at once.  Otherwise, follow SMTP.new with SMTP#start." />
          <scope name="start" ilk="function" signature="start(address, port = nil, helo = &apos;localhost&apos;, user = nil, secret = nil, authtype = nil)" attributes="__classmethod__" doc="Creates a new Net::SMTP object and connects to the server. &#xA; This method is equivalent to: &#xA; Net::SMTP.new(address, port).start(helo_domain, account, password, authtype)&#xA; Example &#xA; Net::SMTP.start(&apos;your.smtp.server&apos;) do |smtp|&#xA;  smtp.send_message msgstr, &apos;from@example.com&apos;, [&apos;dest@example.com&apos;]&#xA;end&#xA; Block Usage &#xA; If called with a block, the newly-opened Net::SMTP object is yielded to the block, and automatically closed when the block finishes.  If called without a block, the newly-opened Net::SMTP object is returned to the caller, and it is the caller&apos;s responsibility to close it when finished. &#xA; Parameters &#xA; +address+ is the hostname or ip address of your smtp server. &#xA; +port+ is the port to connect to; it defaults to port 25. &#xA; +helo+ is the _HELO_ _domain_ provided by the client to the server (see overview comments); it defaults to &apos;localhost&apos;. " />
          <scope name="auth_cram_md5" ilk="function" signature="auth_cram_md5(user, secret)" />
          <scope name="auth_login" ilk="function" signature="auth_login(user, secret)" />
          <scope name="auth_plain" ilk="function" signature="auth_plain(user, secret)" />
          <scope name="authenticate" ilk="function" signature="authenticate(user, secret, authtype = DEFAULT_AUTH_TYPE)" />
          <scope name="capable_auth_types" ilk="function" signature="capable_auth_types()" doc="Returns supported authentication methods on this server. You cannot get valid value before opening SMTP session." />
          <scope name="capable_cram_md5_auth?" ilk="function" signature="capable_cram_md5_auth?()" doc="true if server advertises AUTH CRAM-MD5. You cannot get valid value before opening SMTP session." />
          <scope name="capable_login_auth?" ilk="function" signature="capable_login_auth?()" doc="true if server advertises AUTH LOGIN. You cannot get valid value before opening SMTP session." />
          <scope name="capable_plain_auth?" ilk="function" signature="capable_plain_auth?()" doc="true if server advertises AUTH PLAIN. You cannot get valid value before opening SMTP session." />
          <scope name="capable_starttls?" ilk="function" signature="capable_starttls?()" doc="true if server advertises STARTTLS. You cannot get valid value before opening SMTP session." />
          <scope name="data" ilk="function" signature="data(msgstr = nil)" doc="This method sends a message. If +msgstr+ is given, sends it as a message. If block is given, yield a message writer stream. You must write message before the block is closed. &#xA; # Example 1 (by string)&#xA;smtp.data(&lt;&lt;EndMessage)&#xA;From: john@example.com&#xA;To: betty@example.com&#xA;Subject: I found a bug&#xA;Check vm.c:58879.&#xA;EndMessage&#xA;# Example 2 (by block)&#xA;smtp.data {|f|&#xA;  f.puts &quot;From: john@example.com&quot;&#xA;  f.puts &quot;To: betty@example.com&quot;&#xA;  f.puts &quot;Subject: I found a bug&quot;" />
          <scope name="debug_output=" ilk="function" signature="debug_output=(arg)" doc="WARNING: This method causes serious security holes. Use this method for only debugging. &#xA; Set an output stream for debug logging. You must call this before #start. &#xA; # example&#xA;smtp = Net::SMTP.new(addr, port)&#xA;smtp.set_debug_output $stderr&#xA;smtp.start do |smtp|&#xA;  ....&#xA;end" />
          <scope name="disable_ssl" ilk="function" signature="disable_ssl()" />
          <scope name="disable_starttls" ilk="function" signature="disable_starttls()" doc="Disables SMTP/TLS (STARTTLS) for this object.  Must be called before the connection is established to have any effect." />
          <scope name="disable_tls" ilk="function" signature="disable_tls()" doc="Disables SMTP/TLS for this object.  Must be called before the connection is established to have any effect." />
          <scope name="ehlo" ilk="function" signature="ehlo(domain)" />
          <scope name="enable_ssl" ilk="function" signature="enable_ssl(context = SMTP.default_ssl_context)" />
          <scope name="enable_starttls" ilk="function" signature="enable_starttls(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (STARTTLS) for this object. +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="enable_starttls_auto" ilk="function" signature="enable_starttls_auto(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (STARTTLS) for this object if server accepts. +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="enable_tls" ilk="function" signature="enable_tls(context = SMTP.default_ssl_context)" doc="Enables SMTP/TLS (SMTPS: SMTP over direct TLS connection) for this object.  Must be called before the connection is established to have any effect.  +context+ is a OpenSSL::SSL::SSLContext object." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the SMTP session and closes TCP connection. Raises IOError if not started." />
          <scope name="helo" ilk="function" signature="helo(domain)" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Provide human-readable stringification of class state." />
          <scope name="mailfrom" ilk="function" signature="mailfrom(from_addr)" />
          <scope name="open_message_stream" ilk="function" signature="open_message_stream(from_addr, *to_addrs)" doc="Opens a message writer stream and gives it to the block. The stream is valid only in the block, and has these methods: &#xA; outputs STR and CR LF.&#xA;outputs STR.&#xA;outputs sprintf(fmt,*args).&#xA;outputs STR and returns the length of written bytes.&#xA;outputs STR and returns self. &#xA; If a single CR (&quot;\r&quot;) or LF (&quot;\n&quot;) is found in the message, it is converted to the CR LF pair.  You cannot send a binary message with this method. &#xA; Parameters &#xA; +from_addr+ is a String representing the source mail address. &#xA; +to_addr+ is a String or Strings or Array of Strings, representing the destination mail address or addresses. &#xA; Example &#xA; Net::SMTP.start(&apos;smtp.example.com&apos;, 25) do |smtp|&#xA;  smtp.open_message_stream(&apos;from@example.com&apos;, [&apos;dest@example.com&apos;]) do |f|" />
          <scope name="quit" ilk="function" signature="quit()" />
          <scope name="rcptto" ilk="function" signature="rcptto(to_addr)" />
          <scope name="rcptto_list" ilk="function" signature="rcptto_list(to_addrs)" />
          <scope name="read_timeout=" ilk="function" signature="read_timeout=(sec)" doc="Set the number of seconds to wait until timing-out a read(2) call." />
          <scope name="ready" ilk="function" signature="ready(from_addr, *to_addrs)" />
          <scope name="send_mail" ilk="function" signature="send_mail(msgstr, from_addr, *to_addrs)" />
          <scope name="send_message" ilk="function" signature="send_message(msgstr, from_addr, *to_addrs)" doc="Sends +msgstr+ as a message.  Single CR (&quot;\r&quot;) and LF (&quot;\n&quot;) found in the +msgstr+, are converted into the CR LF pair.  You cannot send a binary message with this method. +msgstr+ should include both the message headers and body. &#xA; +from_addr+ is a String representing the source mail address. &#xA; +to_addr+ is a String or Strings or Array of Strings, representing the destination mail address or addresses. &#xA; Example &#xA; Net::SMTP.start(&apos;smtp.example.com&apos;) do |smtp|&#xA;  smtp.send_message msgstr,&#xA;                    &apos;from@example.com&apos;,&#xA;                    [&apos;dest@example.com&apos;, &apos;dest2@example.com&apos;]&#xA;end&#xA; Errors &#xA; This method may raise: &#xA; Net::SMTPServerBusy&#xA;Net::SMTPSyntaxError" />
          <scope name="sendmail" ilk="function" signature="sendmail(msgstr, from_addr, *to_addrs)" />
          <scope name="set_debug_output" ilk="function" signature="set_debug_output(arg)" />
          <scope name="ssl?" ilk="function" signature="ssl?()" />
          <scope name="start" ilk="function" signature="start(helo = &apos;localhost&apos;, user = nil, secret = nil, authtype = nil)" doc="Opens a TCP connection and starts the SMTP session. &#xA; Parameters &#xA; +helo+ is the _HELO_ _domain_ that you&apos;ll dispatch mails from; see the discussion in the overview notes. &#xA; If both of +user+ and +secret+ are given, SMTP authentication will be attempted using the AUTH command.  +authtype+ specifies the type of authentication to attempt; it must be one of :login, :plain, and :cram_md5.  See the notes on SMTP Authentication in the overview. &#xA; Block Usage &#xA; When this methods is called with a block, the newly-started SMTP object is yielded to the block, and automatically closed after the block call finishes.  Otherwise, it is the caller&apos;s responsibility to close the session when finished. &#xA; Example &#xA; This is very similar to the class method SMTP.start. &#xA; require &apos;net/smtp&apos;&#xA;smtp = Net::SMTP.new(&apos;smtp.mail.server&apos;, 25)&#xA;smtp.start(helo_domain, account, password, authtype) do |smtp|&#xA;  smtp.send_message msgstr, &apos;from@example.com&apos;, [&apos;dest@example.com&apos;]&#xA;end" />
          <scope name="started?" ilk="function" signature="started?()" doc="+true+ if the SMTP session has been started." />
          <scope name="starttls" ilk="function" signature="starttls()" doc="SMTP command dispatcher" />
          <scope name="starttls?" ilk="function" signature="starttls?()" doc="Returns truth value if this object uses STARTTLS. If this object always uses STARTTLS, returns :always. If this object uses STARTTLS when the server support TLS, returns :auto." />
          <scope name="starttls_always?" ilk="function" signature="starttls_always?()" doc="true if this object uses STARTTLS." />
          <scope name="starttls_auto?" ilk="function" signature="starttls_auto?()" doc="true if this object uses STARTTLS when server advertises STARTTLS." />
          <scope name="tls?" ilk="function" signature="tls?()" doc="true if this object uses SMTP/TLS (SMTPS)." />
          <scope ilk="function" name="address" />
          <scope ilk="function" name="esmtp" />
          <scope ilk="function" name="esmtp=" />
          <scope ilk="function" name="esmtp?" />
          <scope ilk="function" name="esmtp?=" />
          <scope ilk="function" name="open_timeout" />
          <scope ilk="function" name="open_timeout=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="read_timeout" />
          <variable name="DEFAULT_AUTH_TYPE" attributes="__const__" citdl="Object" />
          <variable name="IMASK" attributes="__const__" citdl="Object" />
          <variable name="OMASK" attributes="__const__" citdl="Object" />
          <variable name="CRAM_BUFSIZE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="SMTPSyntaxError" ilk="class" classrefs="ProtoSyntaxError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPUnknownError" ilk="class" classrefs="ProtoUnknownError">
          <import symbol="SMTPError" />
        </scope>
        <scope name="SMTPUnsupportedCommand" ilk="class" classrefs="ProtocolError">
          <import symbol="SMTPError" />
        </scope>
      </scope>
    </scope>
    <scope name="net/telnet" ilk="blob" lang="Ruby">
      <scope name="Net" ilk="namespace">
        <variable name="POP" attributes="__const__" citdl="Object" />
        <scope name="Telnet" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(options)" attributes="__classmethod__ __ctor__" doc="Creates a new Net::Telnet object. &#xA; Attempts to connect to the host (unless the Proxy option is provided: see below).  If a block is provided, it is yielded status messages on the attempt to connect to the server, of the form: &#xA; Trying localhost...&#xA;Connected to localhost.&#xA; +options+ is a hash of options.  The following example lists all options and their default values. &#xA; host = Net::Telnet::new(&#xA;         &quot;Host&quot;       =&gt; &quot;localhost&quot;,  # default: &quot;localhost&quot;&#xA;         &quot;Port&quot;       =&gt; 23,           # default: 23&#xA;         &quot;Binmode&quot;    =&gt; false,        # default: false&#xA;         &quot;Output_log&quot; =&gt; &quot;output_log&quot;, # default: nil (no output)&#xA;         &quot;Dump_log&quot;   =&gt; &quot;dump_log&quot;,   # default: nil (no output)&#xA;         &quot;Prompt&quot;     =&gt; /[$%#&gt;] \z/n, # default: /[$%#&gt;] \z/n&#xA;         &quot;Telnetmode&quot; =&gt; true,         # default: true" />
          <scope name="binmode" ilk="function" signature="binmode(mode = nil)" doc="Turn newline conversion on (+mode+ == false) or off (+mode+ == true), or return the current value (+mode+ is not specified)." />
          <scope name="binmode=" ilk="function" signature="binmode=(mode)" doc="Turn newline conversion on (false) or off (true)." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the connection" />
          <scope name="cmd" ilk="function" signature="cmd(options)" doc="Send a command to the host. &#xA; More exactly, sends a string to the host, and reads in all received data until is sees the prompt or other matched sequence. &#xA; If a block is given, the received data will be yielded to it as it is read in.  Whether a block is given or not, the received data will be return as a string.  Note that the received data includes the prompt and in most cases the host&apos;s echo of our command. &#xA; +options+ is either a String, specified the string or command to send to the host; or it is a hash of options.  If a hash, the following options can be specified: &#xA; the command or other string to send to the host.&#xA;a regular expression, the sequence to look for in the received data before returning.  If not specified, the Prompt option value specified when this instance was created will be used, or, failing that, the default prompt of /[$%#&gt;] \z/n.&#xA;the seconds to wait for data from the host before raising a Timeout error.  If not specified, the Timeout option value specified when this instance was created will be used, or, failing that, the default value of 10 seconds. &#xA; The command or other string will have the newline sequence appended to it." />
          <scope name="login" ilk="function" signature="login(options, password = nil)" doc="Login to the host with a given username and password. &#xA; The username and password can either be provided as two string arguments in that order, or as a hash with keys &quot;Name&quot; and &quot;Password&quot;. &#xA; This method looks for the strings &quot;login&quot; and &quot;Password&quot; from the host to determine when to send the username and password.  If the login sequence does not follow this pattern (for instance, you are connecting to a service other than telnet), you will need to handle login yourself. &#xA; The password can be omitted, either by only provided one String argument, which will be used as the username, or by providing a has that has no &quot;Password&quot; key.  In this case, the method will not look for the &quot;Password:&quot; prompt; if it is sent, it will have to be dealt with by later calls. &#xA; The method returns all data received during the login process from the host, including the echoed username but not the password (which the host should not echo).  If a block is passed in, this received data is also yielded to the block as it is received." />
          <scope name="preprocess" ilk="function" signature="preprocess(string)" doc="Preprocess received data from the host. &#xA; Performs newline conversion and detects telnet command sequences. Called automatically by #waitfor().  You should only use this method yourself if you have read input directly using sysread() or similar, and even then only if in telnet mode." />
          <scope name="print" ilk="function" signature="print(string)" doc="Sends a string to the host. &#xA; This does _not_ automatically append a newline to the string.  Embedded newlines may be converted and telnet command sequences escaped depending upon the values of telnetmode, binmode, and telnet options set by the host." />
          <scope name="puts" ilk="function" signature="puts(string)" doc="Sends a string to the host. &#xA; Same as #print(), but appends a newline to the string." />
          <scope name="telnetmode" ilk="function" signature="telnetmode(mode = nil)" doc="Set telnet command interpretation on (+mode+ == true) or off (+mode+ == false), or return the current value (+mode+ not provided).  It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP." />
          <scope name="telnetmode=" ilk="function" signature="telnetmode=(mode)" doc="Turn telnet command interpretation on (true) or off (false).  It should be on for true telnet sessions, off if using Net::Telnet to connect to a non-telnet service such as SMTP." />
          <scope name="waitfor" ilk="function" signature="waitfor(options)" doc="Read data from the host until a certain sequence is matched. &#xA; If a block is given, the received data will be yielded as it is read in (not necessarily all in one go), or nil if EOF occurs before any data is received.  Whether a block is given or not, all data read will be returned in a single string, or again nil if EOF occurs before any data is received.  Note that received data includes the matched sequence we were looking for. &#xA; +options+ can be either a regular expression or a hash of options. If a regular expression, this specifies the data to wait for. If a hash, this can specify the following options: &#xA; a regular expression, specifying the data to wait for.&#xA;as for Match; used only if Match is not specified.&#xA;as for Match, except a string that will be converted into a regular expression.  Used only if Match and Prompt are not specified.&#xA;the number of seconds to wait for data from the host before raising a TimeoutError.  If set to false, no timeout will occur.  If not specified, the Timeout option value specified when this instance was created will be used, or, failing that, the default value of 10 seconds.&#xA;the number of seconds to wait after matching against the input data to see if more data arrives.  If more data arrives within this time, we will judge ourselves not to have matched successfully, and will continue trying to match.  If not specified, the Waittime option value specified when this instance was created will be used, or, failing that, the default value of 0 seconds, which means not to wait for more input.&#xA;if true, when the remote end closes the connection then an EOFError will be raised. Otherwise, defaults to the old behaviour that the function will return whatever data has been received already, or nil if nothing was received." />
          <scope name="write" ilk="function" signature="write(string)" doc="Write +string+ to the host. &#xA; Does not perform any conversions on +string+.  Will log +string+ to the dumplog, if the Dump_log option is set." />
          <scope ilk="function" name="sock" />
        </scope>
      </scope>
    </scope>
    <scope name="nkf" ilk="blob" lang="Ruby">
      <scope name="NKF" ilk="namespace">
        <scope name="guess" ilk="function" signature="guess(p1)" attributes="__classmethod__" doc="Returns guessed encoding of _str_ by nkf routine." />
        <scope name="nkf" ilk="function" signature="nkf(p1, p2)" attributes="__classmethod__" doc="Convert _str_ and return converted result. Conversion details are specified by _opt_ as String. &#xA; require &apos;nkf&apos;&#xA;output = NKF.nkf(&quot;-s&quot;, input)" />
        <variable name="AUTO" attributes="__const__" citdl="Object" />
        <variable name="NOCONV" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="JIS" attributes="__const__" citdl="Object" />
        <variable name="EUC" attributes="__const__" citdl="Object" />
        <variable name="SJIS" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="NKF_VERSION" attributes="__const__" citdl="Object" />
        <variable name="NKF_RELEASE_DATE" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="observer" ilk="blob" lang="Ruby">
      <scope name="Observable" ilk="namespace">
        <scope name="add_observer" ilk="function" signature="add_observer(observer, func=:update)" doc="Add +observer+ as an observer on this object. so that it will receive notifications. &#xA; the object that will be notified of changes.&#xA;Symbol naming the method that will be called when this Observable has changes. &#xA; This method must return true for +observer.respond_to?+ and will receive *arg when #notify_observers is called, where *arg is the value passed to #notify_observers by this Observable" />
        <scope name="changed" ilk="function" signature="changed(state=true)" doc="Set the changed state of this object.  Notifications will be sent only if the changed +state+ is +true+. &#xA; Boolean indicating the changed state of this Observable." />
        <scope name="changed?" ilk="function" signature="changed?()" doc="Returns true if this object&apos;s state has been changed since the last #notify_observers call." />
        <scope name="count_observers" ilk="function" signature="count_observers()" doc="Return the number of observers associated with this object." />
        <scope name="delete_observer" ilk="function" signature="delete_observer(observer)" doc="Remove +observer+ as an observer on this object so that it will no longer receive notifications. &#xA; An observer of this Observable" />
        <scope name="delete_observers" ilk="function" signature="delete_observers()" doc="Remove all observers associated with this object." />
        <scope name="notify_observers" ilk="function" signature="notify_observers(*arg)" doc="Notify observers of a change in state *if* this object&apos;s changed state is +true+. &#xA; This will invoke the method named in #add_observer, pasing *arg. The changed state is then set to +false+. &#xA; Any arguments to pass to the observers." />
      </scope>
    </scope>
    <scope name="open-uri" ilk="blob" lang="Ruby">
      <scope name="OpenURI" ilk="namespace">
        <scope name="HTTPError" ilk="class" classrefs="StandardError">
          <scope name="new" ilk="function" signature="new(message, io)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="io" />
        </scope>
        <scope name="HTTPRedirect" ilk="class" classrefs="OpenURI::HTTPError">
          <scope name="new" ilk="function" signature="new(message, io, uri)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="Meta" ilk="namespace">
          <scope name="charset" ilk="function" signature="charset()" doc="returns a charset parameter in Content-Type field. It is downcased for canonicalization. &#xA; If charset parameter is not given but a block is given, the block is called and its result is returned. It can be used to guess charset. &#xA; If charset parameter and block is not given, nil is returned except text type in HTTP. In that case, &quot;iso-8859-1&quot; is returned as defined by RFC2616 3.7.1." />
          <scope name="content_encoding" ilk="function" signature="content_encoding()" doc="returns a list of encodings in Content-Encoding field as an Array of String. The encodings are downcased for canonicalization." />
          <scope name="content_type" ilk="function" signature="content_type()" doc="returns &quot;type/subtype&quot; which is MIME Content-Type. It is downcased for canonicalization. Content-Type parameters are stripped." />
          <scope name="last_modified" ilk="function" signature="last_modified()" doc="returns a Time that represents the Last-Modified field." />
          <scope ilk="function" name="base_uri" />
          <scope ilk="function" name="base_uri=" />
          <scope ilk="function" name="meta" />
          <scope ilk="function" name="status" />
          <scope ilk="function" name="status=" />
          <variable name="RE_LWS" attributes="__const__" citdl="Object" />
          <variable name="RE_TOKEN" attributes="__const__" citdl="Object" />
          <variable name="RE_QUOTED_STRING" attributes="__const__" citdl="Object" />
          <variable name="RE_PARAMETERS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="OpenRead" ilk="namespace">
          <scope name="open" ilk="function" signature="open(*rest, &amp;block)" doc="OpenURI::OpenRead#open provides `open&apos; for URI::HTTP and URI::FTP. &#xA; OpenURI::OpenRead#open takes optional 3 arguments as: &#xA; OpenURI::OpenRead#open([mode [, perm]] [, options]) [{|io| ... }]&#xA; OpenURI::OpenRead#open returns an IO-like object if block is not given. Otherwise it yields the IO object and return the value of the block. The IO object is extended with OpenURI::Meta. &#xA; +mode+ and +perm+ are the same as Kernel#open. &#xA; However, +mode+ must be read mode because OpenURI::OpenRead#open doesn&apos;t support write mode (yet). Also +perm+ is ignored because it is meaningful only for file creation. &#xA; +options+ must be a hash. &#xA; Each option with a string key specifies an extra header field for HTTP. I.e., it is ignored for FTP without HTTP proxy. &#xA; The hash may include other options, where keys are symbols: &#xA; Synopsis: :proxy =&gt; &quot;http://proxy.foo.com:8000/&quot;&#xA;:proxy =&gt; URI.parse(&quot;http://proxy.foo.com:8000/&quot;)&#xA;:proxy =&gt; true&#xA;:proxy =&gt; false" />
          <scope name="read" ilk="function" signature="read(options={})" doc="OpenURI::OpenRead#read([options]) reads a content referenced by self and returns the content as string. The string is extended with OpenURI::Meta. The argument +options+ is same as OpenURI::OpenRead#open." />
        </scope>
      </scope>
    </scope>
    <scope name="open3" ilk="blob" lang="Ruby">
      <scope name="Open3" ilk="namespace">
        <scope name="capture2" ilk="function" signature="capture2(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture2 captures the standard output of a command. &#xA; stdout_str, status = Open3.capture2([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:binmode].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA; # factor is a command for integer factorization.&#xA;o, s = Open3.capture2(&quot;factor&quot;, :stdin_data=&gt;&quot;42&quot;)&#xA;p o =&gt; &quot;42: 2 3 7\n&quot;&#xA;# generate x**2 graph in png using gnuplot.&#xA;gnuplot_commands = &lt;&lt;&quot;End&quot;&#xA;  set terminal png&#xA;  plot x**2, &quot;-&quot; with lines" />
        <scope name="capture2e" ilk="function" signature="capture2e(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture2e captures the standard output and the standard error of a command. &#xA; stdout_and_stderr_str, status = Open3.capture2e([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:binmode].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA; # capture make log&#xA;make_log, s = Open3.capture2e(&quot;make&quot;)" />
        <scope name="capture3" ilk="function" signature="capture3(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.capture3 captures the standard output and the standard error of a command. &#xA; stdout_str, stderr_str, status = Open3.capture3([env,] cmd... [, opts])&#xA; The arguments env, cmd and opts are passed to Open3.popen3 except opts[:stdin_data] and opts[:binmode].  See Process.spawn. &#xA; If opts[:stdin_data] is specified, it is sent to the command&apos;s standard input. &#xA; If opts[:binmode] is true, internal pipes are set to binary mode. &#xA; Example: &#xA; # dot is a command of graphviz.&#xA;graph = &lt;&lt;&apos;End&apos;&#xA;  digraph g {&#xA;    a -&gt; b&#xA;  }&#xA;End&#xA;layouted_graph, dot_log = Open3.capture3(&quot;dot -v&quot;, :stdin_data=&gt;graph)" />
        <scope name="pipeline" ilk="function" signature="pipeline(*cmds)" attributes="__classmethod__" doc="Open3.pipeline starts a list of commands as a pipeline. It waits the finish of the commands. No pipe made for stdin of the first command and stdout of the last command. &#xA; status_list = Open3.pipeline(cmd1, cmd2, ... [, opts])&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA; cmd:&#xA;  commandline                              command line string which is passed to a shell&#xA;  [env, commandline, opts]                 command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)&#xA;Note that env and opts are optional, as Process.spawn.&#xA; Example: &#xA; fname = &quot;/usr/share/man/man1/ruby.1.gz&quot;&#xA;p Open3.pipeline([&quot;zcat&quot;, fname], &quot;nroff -man&quot;, &quot;less&quot;)&#xA;=&gt; [#&lt;Process::Status: pid 11817 exit 0&gt;," />
        <scope name="pipeline_r" ilk="function" signature="pipeline_r(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_r starts a list of commands as a pipeline with a pipe which connects stdout of the last command. &#xA; Open3.pipeline_r(cmd1, cmd2, ... [, opts]) {|last_stdout, wait_threads|&#xA;  ...&#xA;}&#xA;last_stdout, wait_threads = Open3.pipeline_r(cmd1, cmd2, ... [, opts])&#xA;...&#xA;last_stdout.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA; cmd:&#xA;  commandline                              command line string which is passed to a shell&#xA;  [env, commandline, opts]                 command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)" />
        <scope name="pipeline_rw" ilk="function" signature="pipeline_rw(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_rw starts a list of commands as a pipeline with pipes which connects stdin of the first command and stdout of the last command. &#xA; Open3.pipeline_rw(cmd1, cmd2, ... [, opts]) {|first_stdin, last_stdout, wait_threads|&#xA;  ...&#xA;}&#xA;first_stdin, last_stdout, wait_threads = Open3.pipeline_rw(cmd1, cmd2, ... [, opts])&#xA;...&#xA;first_stdin.close&#xA;last_stdout.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA; cmd:&#xA;  commandline                              command line string which is passed to a shell&#xA;  [env, commandline, opts]                 command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)" />
        <scope name="pipeline_start" ilk="function" signature="pipeline_start(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_start starts a list of commands as a pipeline. No pipe made for stdin of the first command and stdout of the last command. &#xA; Open3.pipeline_start(cmd1, cmd2, ... [, opts]) {|wait_threads|&#xA;  ...&#xA;}&#xA;wait_threads = Open3.pipeline_start(cmd1, cmd2, ... [, opts])&#xA;...&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA; cmd:&#xA;  commandline                              command line string which is passed to a shell&#xA;  [env, commandline, opts]                 command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)&#xA;Note that env and opts are optional, as Process.spawn." />
        <scope name="pipeline_w" ilk="function" signature="pipeline_w(*cmds, &amp;block)" attributes="__classmethod__" doc="Open3.pipeline_w starts a list of commands as a pipeline with a pipe which connects stdin of the first command. &#xA; Open3.pipeline_w(cmd1, cmd2, ... [, opts]) {|first_stdin, wait_threads|&#xA;  ...&#xA;}&#xA;first_stdin, wait_threads = Open3.pipeline_w(cmd1, cmd2, ... [, opts])&#xA;...&#xA;first_stdin.close&#xA; Each cmd is a string or an array. If it is an array, the elements are passed to Process.spawn. &#xA; cmd:&#xA;  commandline                              command line string which is passed to a shell&#xA;  [env, commandline, opts]                 command line string which is passed to a shell&#xA;  [env, cmdname, arg1, ..., opts]          command name and one or more arguments (no shell)&#xA;  [env, [cmdname, argv0], arg1, ..., opts] command name and arguments including argv[0] (no shell)" />
        <scope name="popen2" ilk="function" signature="popen2(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.popen2 is similer to Open3.popen3 except it doesn&apos;t make a pipe for the standard error stream. &#xA; Block form: &#xA; Open3.popen2([env,] cmd... [, opts]) {|stdin, stdout, wait_thr|&#xA;  pid = wait_thr.pid # pid of the started process.&#xA;  ...&#xA;  exit_status = wait_thr.value # Process::Status object returned.&#xA;}&#xA; Non-block form: &#xA; stdin, stdout, wait_thr = Open3.popen2([env,] cmd... [, opts])&#xA;...&#xA;stdin.close  # stdin and stdout should be closed explicitly in this form.&#xA;stdout.close&#xA; See Process.spawn for the optional hash arguments _env_ and _opts_. " />
        <scope name="popen2e" ilk="function" signature="popen2e(*cmd, &amp;block)" attributes="__classmethod__" doc="Open3.popen2e is similer to Open3.popen3 except it merges the standard output stream and the standard error stream. &#xA; Block form: &#xA; Open3.popen2e([env,] cmd... [, opts]) {|stdin, stdout_and_stderr, wait_thr|&#xA;  pid = wait_thr.pid # pid of the started process.&#xA;  ...&#xA;  exit_status = wait_thr.value # Process::Status object returned.&#xA;}&#xA; Non-block form: &#xA; stdin, stdout_and_stderr, wait_thr = Open3.popen2e([env,] cmd... [, opts])&#xA;...&#xA;stdin.close  # stdin and stdout_and_stderr should be closed explicitly in this form.&#xA;stdout_and_stderr.close&#xA; See Process.spawn for the optional hash arguments _env_ and _opts_. " />
        <scope name="popen3" ilk="function" signature="popen3(*cmd, &amp;block)" attributes="__classmethod__" doc="Open stdin, stdout, and stderr streams and start external executable. In addition, a thread for waiting the started process is noticed. The thread has a pid method and thread variable :pid which is the pid of the started process. &#xA; Block form: &#xA; Open3.popen3([env,] cmd... [, opts]) {|stdin, stdout, stderr, wait_thr|&#xA;  pid = wait_thr.pid # pid of the started process.&#xA;  ...&#xA;  exit_status = wait_thr.value # Process::Status object returned.&#xA;}&#xA; Non-block form: &#xA; stdin, stdout, stderr, wait_thr = Open3.popen3([env,] cmd... [, opts])&#xA;pid = wait_thr[:pid]  # pid of the started process.&#xA;...&#xA;stdin.close  # stdin, stdout and stderr should be closed explicitly in this form.&#xA;stdout.close" />
      </scope>
    </scope>
    <scope name="openssl" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="ASN1" ilk="namespace">
          <scope name="decode" ilk="function" signature="decode(p1)" attributes="__classmethod__" doc="Decodes a BER- or DER-encoded value and creates an ASN1Data instance. +der+ may be a +String+ or any object that features a +#to_der+ method transforming it into a BER-/DER-encoded +String+. &#xA; Example der = File.binread(&apos;asn1data&apos;)&#xA;asn1 = OpenSSL::ASN1.decode(der)" />
          <scope name="decode_all" ilk="function" signature="decode_all(p1)" attributes="__classmethod__" doc="Similar to +decode+ with the difference that +decode+ expects one distinct value represented in +der+. +decode_all+ on the contrary decodes a sequence of sequential BER/DER values lined up in +der+ and returns them as an array. &#xA; Example ders = File.binread(&apos;asn1data_seq&apos;)&#xA;asn1_ary = OpenSSL::ASN1.decode_all(ders)" />
          <scope name="traverse" ilk="function" signature="traverse(p1)" attributes="__classmethod__" doc="If a block is given, it prints out each of the elements encountered. Block parameters are (in that order): depth: The recursion depth, plus one with each constructed value being encountered (Number)&#xA;offset: Current byte offset (Number)&#xA;header length: Combined length in bytes of the Tag and Length headers. (Number)&#xA;length: The overall remaining length of the entire data (Number)&#xA;constructed: Whether this value is constructed or not (Boolean)&#xA;tag_class: Current tag class (Symbol)&#xA;tag: The current tag (Number) &#xA; Example der = File.binread(&apos;asn1data.der&apos;)&#xA;OpenSSL::ASN1.traverse(der) do | depth, offset, header_len, length, constructed, tag_class, tag|&#xA;  puts &quot;Depth: #{depth} Offset: #{offset} Length: #{length}&quot;&#xA;  puts &quot;Header length: #{header_len} Tag: #{tag} Tag class: #{tag_class} Constructed: #{constructed}&quot;&#xA;end" />
          <variable name="UNIVERSAL_TAG_NAME" attributes="__const__" citdl="Object" />
          <scope name="ASN1Data" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1, p2, p3)" attributes="__classmethod__ __ctor__" doc="+value+: Please have a look at Constructive and Primitive to see how Ruby types are mapped to ASN.1 types and vice versa. &#xA; +tag+: A +Number+ indicating the tag number. &#xA; +tag_class+: A +Symbol+ indicating the tag class. Please cf. ASN1 for possible values. &#xA; Example asn1_int = OpenSSL::ASN1Data.new(42, 2, :UNIVERSAL) # =&gt; Same as OpenSSL::ASN1::Integer.new(42)&#xA;tagged_int = OpenSSL::ASN1Data.new(42, 0, :CONTEXT_SPECIFIC) # implicitly 0-tagged INTEGER" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Encodes this ASN1Data into a DER-encoded String value. The result is DER-encoded except for the possibility of infinite length encodings. Infinite length encodings are not allowed in strict DER, so strictly speaking the result of such an encoding would be a BER-encoding." />
            <scope ilk="function" name="infinite_length" />
            <scope ilk="function" name="infinite_length=" />
            <scope ilk="function" name="tag" />
            <scope ilk="function" name="tag=" />
            <scope ilk="function" name="tag_class" />
            <scope ilk="function" name="tag_class=" />
            <scope ilk="function" name="value" />
            <scope ilk="function" name="value=" />
          </scope>
          <scope name="ASN1Error" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Constructive" ilk="class" classrefs="OpenSSL::ASN1::ASN1Data">
            <import symbol="Enumerable" />
            <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="+value+: is mandatory. &#xA; +tag+: optional, may be specified for tagged values. If no +tag+ is specified, the UNIVERSAL tag corresponding to the Primitive sub-class is used by default. &#xA; +tagging+: may be used as an encoding hint to encode a value either explicitly or implicitly, see ASN1 for possible values. &#xA; +tag_class+: if +tag+ and +tagging+ are +nil+ then this is set to +:UNIVERSAL+ by default. If either +tag+ or +tagging+ are set then +:CONTEXT_SPECIFIC+ is used as the default. For possible values please cf. ASN1. &#xA; Example int = OpenSSL::ASN1::Integer.new(42)&#xA;zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)&#xA;private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)" />
            <scope name="each" ilk="function" signature="each()" doc="Calls block once for each element in +self+, passing that element as parameter +asn1+. If no block is given, an enumerator is returned instead. &#xA; Example asn1_ary.each do |asn1|&#xA;  puts asn1&#xA;end" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="See ASN1Data#to_der for details." />
            <scope ilk="function" name="tagging" />
            <scope ilk="function" name="tagging=" />
          </scope>
          <scope name="Primitive" ilk="class" classrefs="OpenSSL::ASN1::ASN1Data">
            <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="+value+: is mandatory. &#xA; +tag+: optional, may be specified for tagged values. If no +tag+ is specified, the UNIVERSAL tag corresponding to the Primitive sub-class is used by default. &#xA; +tagging+: may be used as an encoding hint to encode a value either explicitly or implicitly, see ASN1 for possible values. &#xA; +tag_class+: if +tag+ and +tagging+ are +nil+ then this is set to +:UNIVERSAL+ by default. If either +tag+ or +tagging+ are set then +:CONTEXT_SPECIFIC+ is used as the default. For possible values please cf. ASN1. &#xA; Example int = OpenSSL::ASN1::Integer.new(42)&#xA;zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :IMPLICIT)&#xA;private_explicit_zero_tagged_int = OpenSSL::ASN1::Integer.new(42, 0, :EXPLICIT, :PRIVATE)" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="See ASN1Data#to_der for details. *" />
            <scope ilk="function" name="tagging" />
            <scope ilk="function" name="tagging=" />
          </scope>
        </scope>
        <scope name="Cipher" ilk="class" classrefs="Object">
          <scope name="ciphers" ilk="function" signature="ciphers()" attributes="__classmethod__" doc="Returns the names of all available ciphers in an array." />
          <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="The string must contain a valid cipher name like &quot;AES-128-CBC&quot; or &quot;3DES&quot;. &#xA; A list of cipher names is available by calling OpenSSL::Cipher.ciphers." />
          <scope name="decrypt" ilk="function" signature="decrypt(*args)" doc="Initializes the Cipher for decryption. &#xA; Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the following methods: &#xA; Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 0)." />
          <scope name="encrypt" ilk="function" signature="encrypt(*args)" doc="Initializes the Cipher for encryption. &#xA; Make sure to call Cipher#encrypt or Cipher#decrypt before using any of the following methods: &#xA; Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, 1)." />
          <scope name="final" ilk="function" signature="final()" doc="Returns the remaining data held in the cipher object.  Further calls to Cipher#update or Cipher#final will return garbage. &#xA; See EVP_CipherFinal_ex for further information." />
          <scope name="iv=" ilk="function" signature="iv=(p1)" doc="Sets the cipher IV. Please note that since you should never be using ECB mode, an IV is always explicitly required and should be set prior to encryption. The IV itself can be safely transmitted in public, but it should be unpredictable to prevent certain kinds of attacks. You may use Cipher#random_iv to create a secure random IV. &#xA; Only call this method after calling Cipher#encrypt or Cipher#decrypt. &#xA; If not explicitly set, the OpenSSL default of an all-zeroes (&quot;\\0&quot;) IV is used." />
          <scope name="key=" ilk="function" signature="key=(p1)" doc="Sets the cipher key. To generate a key, you should either use a secure random byte string or, if the key is to be derived from a password, you should rely on PBKDF2 functionality provided by OpenSSL::PKCS5. To generate a secure random-based key, Cipher#random_key may be used. &#xA; Only call this method after calling Cipher#encrypt or Cipher#decrypt." />
          <scope name="key_len=" ilk="function" signature="key_len=(p1)" doc="Sets the key length of the cipher.  If the cipher is a fixed length cipher then attempting to set the key length to any value other than the fixed value is an error. &#xA; Under normal circumstances you do not need to call this method (and probably shouldn&apos;t). &#xA; See EVP_CIPHER_CTX_set_key_length for further information." />
          <scope name="name" ilk="function" signature="name()" doc="Returns the name of the cipher which may differ slightly from the original name provided." />
          <scope name="padding=" ilk="function" signature="padding=(p1)" doc="Enables or disables padding. By default encryption operations are padded using standard block padding and the padding is checked and removed when decrypting. If the pad parameter is zero then no padding is performed, the total amount of data encrypted or decrypted must then be a multiple of the block size or an error will occur. &#xA; See EVP_CIPHER_CTX_set_padding for further information." />
          <scope name="pkcs5_keyivgen" ilk="function" signature="pkcs5_keyivgen(p1, p2 = v2, p3 = v3, p4 = v4)" doc="Generates and sets the key/IV based on a password. &#xA; WARNING: This method is only PKCS5 v1.5 compliant when using RC2, RC4-40, or DES with MD5 or SHA1. Using anything else (like AES) will generate the key/iv using an OpenSSL specific method. This method is deprecated and should no longer be used. Use a PKCS5 v2 key generation method from OpenSSL::PKCS5 instead. &#xA; Parameters +salt+ must be an 8 byte string if provided. +iterations+ is a integer with a default of 2048. +digest+ is a Digest object that defaults to &apos;MD5&apos; &#xA; A minimum of 1000 iterations is recommended." />
          <scope name="random_iv" ilk="function" signature="random_iv()" doc="Generate, set, and return a random iv. You must call cipher.encrypt or cipher.decrypt before calling this method." />
          <scope name="random_key" ilk="function" signature="random_key()" doc="Generate, set, and return a random key. You must call cipher.encrypt or cipher.decrypt before calling this method." />
          <scope name="reset" ilk="function" signature="reset()" doc="Fully resets the internal state of the Cipher. By using this, the same Cipher instance may be used several times for en- or decryption tasks. &#xA; Internally calls EVP_CipherInit_ex(ctx, NULL, NULL, NULL, NULL, -1)." />
          <scope name="update" ilk="function" signature="update(p1, p2 = v2)" doc="Encrypts data in a streaming fashion. Hand consecutive blocks of data to the +update+ method in order to encrypt it. Returns the encrypted data chunk. When done, the output of Cipher#final should be additionally added to the result. &#xA; Parameters +data+ is a nonempty string. +buffer+ is an optional string to store the result." />
          <scope name="CipherError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="Digest" ilk="class" classrefs="OpenSSL::Digest::Class">
          <scope name="digest" ilk="function" signature="digest(name, data)" attributes="__classmethod__" doc="Return the +data+ hash computed with +name+ Digest. +name+ is either the long name or short name of a supported digest algorithm. &#xA; Examples &#xA; OpenSSL::Digest.digest(&quot;SHA256, &quot;abc&quot;)&#xA; which is equivalent to: &#xA; OpenSSL::Digest::SHA256.digest(&quot;abc&quot;)" />
          <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Creates a Digest instance based on +string+, which is either the ln (long name) or sn (short name) of a supported digest algorithm. If +data+ (a +String+) is given, it is used as the initial input to the Digest instance, i.e. digest = OpenSSL::Digest.new(&apos;sha256&apos;, &apos;digestdata&apos;)&#xA; is equal to digest = OpenSSL::Digest.new(&apos;sha256&apos;)&#xA;digest.update(&apos;digestdata&apos;)&#xA; Example digest = OpenSSL::Digest.new(&apos;sha1&apos;)" />
          <scope name="block_length" ilk="function" signature="block_length()" doc="Returns the block length of the digest algorithm, i.e. the length in bytes of an individual block. Most modern algorithms partition a message to be digested into a sequence of fix-sized blocks that are processed consecutively. &#xA; Example digest = OpenSSL::Digest::SHA1.new&#xA;puts digest.block_length # =&gt; 64" />
          <scope name="digest_length" ilk="function" signature="digest_length()" doc="Returns the output size of the digest, i.e. the length in bytes of the final message digest result. &#xA; Example digest = OpenSSL::Digest::SHA1.new&#xA;puts digest.digest_length # =&gt; 20" />
          <scope name="name" ilk="function" signature="name()" doc="Returns the sn of this Digest instance. &#xA; Example digest = OpenSSL::Digest::SHA512.new&#xA;puts digest.name # =&gt; SHA512" />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets the Digest in the sense that any Digest#update that has been performed is abandoned and the Digest is set to its initial state again." />
          <scope name="update" ilk="function" signature="update(p1)" doc="Not every message digest can be computed in one single pass. If a message digest is to be computed from several subsequent sources, then each may be passed individually to the Digest instance. &#xA; Example digest = OpenSSL::Digest::SHA256.new&#xA;digest.update(&apos;First input&apos;)&#xA;digest &lt;&lt; &apos;Second input&apos; # equivalent to digest.update(&apos;Second input&apos;)&#xA;result = digest.digest" />
          <scope name="DigestError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="read" ilk="function" signature="read(p1, p2 = v2)" attributes="__classmethod__" doc="Parameters +string+ is a DER- or PEM-encoded string containing an arbitrary private or public key. +file+ is an instance of +File+ containing a DER- or PEM-encoded arbitrary private or public key. +pwd+ is an optional password in case +string+ or +file+ is an encrypted PEM resource." />
          <scope name="EC" ilk="class" classrefs="cPKey">
            <scope name="builtin_curves" ilk="function" signature="builtin_curves()" attributes="__classmethod__" doc="See the OpenSSL documentation for EC_builtin_curves()" />
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for: EC_KEY_*" />
            <scope name="check_key" ilk="function" signature="check_key()" doc="Raises an exception if the key is invalid. &#xA; See the OpenSSL documentation for EC_KEY_check_key()" />
            <scope name="dh_compute_key" ilk="function" signature="dh_compute_key(p1)" doc="See the OpenSSL documentation for ECDH_compute_key()" />
            <scope name="dsa_sign_asn1" ilk="function" signature="dsa_sign_asn1(p1)" doc="See the OpenSSL documentation for ECDSA_sign()" />
            <scope name="dsa_verify_asn1" ilk="function" signature="dsa_verify_asn1(p1, p2)" doc="See the OpenSSL documentation for ECDSA_verify()" />
            <scope name="generate_key" ilk="function" signature="generate_key()" doc="See the OpenSSL documentation for EC_KEY_generate_key()" />
            <scope name="group" ilk="function" signature="group()" doc="Returns a constant OpenSSL::EC::Group that is tied to the key. Modifying the returned group can make the key invalid." />
            <scope name="group=" ilk="function" signature="group=(p1)" doc="Returns the same object passed, not the group object associated with the key. If you wish to access the group object tied to the key call key.group after setting the group. &#xA; Setting the group will immediately destroy any previously assigned group object. The group is internally copied by OpenSSL.  Modifying the original group after assignment will not effect the internal key structure. (your changes may be lost).  BE CAREFUL. &#xA; EC_KEY_set_group calls EC_GROUP_free(key-&gt;group) then EC_GROUP_dup(), not EC_GROUP_copy. This documentation is accurate for OpenSSL 0.9.8b." />
            <scope name="private_key" ilk="function" signature="private_key()" doc="See the OpenSSL documentation for EC_KEY_get0_private_key()" />
            <scope name="private_key=" ilk="function" signature="private_key=(p1)" doc="See the OpenSSL documentation for EC_KEY_set_private_key()" />
            <scope name="private_key?" ilk="function" signature="private_key?()" doc="Both public_key? and private_key? may return false at the same time unlike other PKey classes." />
            <scope name="public_key" ilk="function" signature="public_key()" doc="See the OpenSSL documentation for EC_KEY_get0_public_key()" />
            <scope name="public_key=" ilk="function" signature="public_key=(p1)" doc="See the OpenSSL documentation for EC_KEY_set_public_key()" />
            <scope name="public_key?" ilk="function" signature="public_key?()" doc="Both public_key? and private_key? may return false at the same time unlike other PKey classes." />
            <scope name="to_der" ilk="function" signature="to_der()" doc="See the OpenSSL documentation for i2d_ECPrivateKey_bio()" />
            <scope name="to_pem" ilk="function" signature="to_pem(p1 = v1, p2 = v2)" doc="Outputs the EC key in PEM encoding.  If +cipher+ and +pass_phrase+ are given they will be used to encrypt the key.  +cipher+ must be an OpenSSL::Cipher::Cipher instance. Note that encryption will only be effective for a private key, public keys will always be encoded in plain text." />
            <scope name="to_text" ilk="function" signature="to_text()" doc="See the OpenSSL documentation for EC_KEY_print()" />
            <variable name="NAMED_CURVE" attributes="__const__" citdl="Object" />
            <scope name="Group" ilk="class" classrefs="Object">
              <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for EC_GROUP_*" />
              <scope name="asn1_flag" ilk="function" signature="asn1_flag()" doc="See the OpenSSL documentation for EC_GROUP_get_asn1_flag()" />
              <scope name="asn1_flag=" ilk="function" signature="asn1_flag=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_asn1_flag()" />
              <scope name="cofactor" ilk="function" signature="cofactor()" doc="See the OpenSSL documentation for EC_GROUP_get_cofactor()" />
              <scope name="curve_name" ilk="function" signature="curve_name()" doc="See the OpenSSL documentation for EC_GROUP_get_curve_name()" />
              <scope name="degree" ilk="function" signature="degree()" doc="See the OpenSSL documentation for EC_GROUP_get_degree()" />
              <scope name="eql?" ilk="function" signature="eql?(p1)" />
              <scope name="generator" ilk="function" signature="generator()" doc="See the OpenSSL documentation for EC_GROUP_get0_generator()" />
              <scope name="order" ilk="function" signature="order()" doc="See the OpenSSL documentation for EC_GROUP_get_order()" />
              <scope name="point_conversion_form" ilk="function" signature="point_conversion_form()" doc="See the OpenSSL documentation for EC_GROUP_get_point_conversion_form()" />
              <scope name="point_conversion_form=" ilk="function" signature="point_conversion_form=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_point_conversion_form()" />
              <scope name="seed" ilk="function" signature="seed()" doc="See the OpenSSL documentation for EC_GROUP_get0_seed()" />
              <scope name="seed=" ilk="function" signature="seed=(p1)" doc="See the OpenSSL documentation for EC_GROUP_set_seed()" />
              <scope name="set_generator" ilk="function" signature="set_generator(p1, p2, p3)" doc="See the OpenSSL documentation for EC_GROUP_set_generator()" />
              <scope name="to_der" ilk="function" signature="to_der()" doc="See the OpenSSL documentation for i2d_ECPKParameters_bio()" />
              <scope name="to_pem" ilk="function" signature="to_pem()" doc="See the OpenSSL documentation for PEM_write_bio_ECPKParameters()" />
              <scope name="to_text" ilk="function" signature="to_text()" doc="See the OpenSSL documentation for ECPKParameters_print()" />
              <scope name="Error" ilk="class" classrefs="eOSSLError">
              </scope>
            </scope>
            <scope name="Point" ilk="class" classrefs="Object">
              <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="See the OpenSSL documentation for EC_POINT_*" />
              <scope name="eql?" ilk="function" signature="eql?(p1)" />
              <scope name="infinity?" ilk="function" signature="infinity?()" />
              <scope name="invert!" ilk="function" signature="invert!()" />
              <scope name="make_affine!" ilk="function" signature="make_affine!()" />
              <scope name="on_curve?" ilk="function" signature="on_curve?()" />
              <scope name="set_to_infinity!" ilk="function" signature="set_to_infinity!()" />
              <scope name="to_bn" ilk="function" signature="to_bn()" doc="See the OpenSSL documentation for EC_POINT_point2bn()" />
              <scope ilk="function" name="group" />
              <scope name="Error" ilk="class" classrefs="eOSSLError">
              </scope>
            </scope>
          </scope>
          <scope name="ECError" ilk="class" classrefs="ePKeyError">
          </scope>
          <scope name="PKey" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Because PKey is an abstract class, actually calling this method explicitly will raise a +NotImplementedError+." />
            <scope name="sign" ilk="function" signature="sign(p1, p2)" doc="To sign the +String+ +data+, +digest+, an instance of OpenSSL::Digest, must be provided. The return value is again a +String+ containing the signature. A PKeyError is raised should errors occur. Any previous state of the +Digest+ instance is irrelevant to the signature outcome, the digest instance is reset to its initial state during the operation. &#xA; Example data = &apos;Sign me!&apos;&#xA;digest = OpenSSL::Digest::SHA256.new&#xA;pkey = OpenSSL::PKey::RSA.new(2048)&#xA;signature = pkey.sign(digest, data)" />
            <scope name="verify" ilk="function" signature="verify(p1, p2, p3)" doc="To verify the +String+ +signature+, +digest+, an instance of OpenSSL::Digest, must be provided to re-compute the message digest of the original +data+, also a +String+. The return value is +true+ if the signature is valid, +false+ otherwise. A PKeyError is raised should errors occur. Any previous state of the +Digest+ instance is irrelevant to the validation outcome, the digest instance is reset to its initial state during the operation. &#xA; Example data = &apos;Sign me!&apos;&#xA;digest = OpenSSL::Digest::SHA256.new&#xA;pkey = OpenSSL::PKey::RSA.new(2048)&#xA;signature = pkey.sign(digest, data)&#xA;pub_key = pkey.public_key&#xA;puts pub_key.verify(digest, signature, data) # =&gt; true" />
          </scope>
          <scope name="PKeyError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="DH" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(p1, p2 = v2)" attributes="__classmethod__" doc="Creates a new DH instance from scratch by generating the private and public components alike. &#xA; Parameters +size+ is an integer representing the desired key size. Keys smaller than 1024 bits should be considered insecure.&#xA;+generator+ is a small number &gt; 1, typically 2 or 5." />
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Either generates a DH instance from scratch or by reading already existing DH parameters from +string+. Note that when reading a DH instance from data that was encoded from a DH instance by using DH#to_pem or DH#to_der the result will *not* contain a public/private key pair yet. This needs to be generated using DH#generate_key! first. &#xA; Parameters +size+ is an integer representing the desired key size. Keys smaller than 1024 bits should be considered insecure.&#xA;+generator+ is a small number &gt; 1, typically 2 or 5.&#xA;+string+ contains the DER or PEM encoded key. &#xA; Examples DH.new # -&gt; dh&#xA;DH.new(1024) # -&gt; dh&#xA;DH.new(1024, 5) # -&gt; dh&#xA;#Reading DH parameters&#xA;dh = DH.new(File.read(&apos;parameters.pem&apos;)) # -&gt; dh, but no public/private key yet&#xA;dh.generate_key! # -&gt; dh with public and private key" />
            <scope name="compute_key" ilk="function" signature="compute_key(p1)" doc="Returns a String containing a shared secret computed from the other party&apos;s public value. See DH_compute_key() for further information. &#xA; Parameters +pub_bn+ is a OpenSSL::BN, *not* the DH instance returned by DH#public_key as that contains the DH parameters only." />
            <scope name="export" ilk="function" signature="export()" doc="Encodes this DH to its PEM encoding. Note that any existing per-session public/private keys will *not* get encoded, just the Diffie-Hellman parameters will be encoded." />
            <scope name="generate_key!" ilk="function" signature="generate_key!()" doc="Generates a private and public key unless a private key already exists. If this DH instance was generated from public DH parameters (e.g. by encoding the result of DH#public_key), then this method needs to be called first in order to generate the per-session keys before performing the actual key exchange. &#xA; Example dh = OpenSSL::PKey::DH.new(2048)&#xA;public_key = dh.public_key #contains no private/public key yet&#xA;public_key.generate_key!&#xA;puts public_key.private? # =&gt; true" />
            <scope name="params" ilk="function" signature="params()" doc="Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
            <scope name="params_ok?" ilk="function" signature="params_ok?()" doc="Validates the Diffie-Hellman parameters associated with this instance. It checks whether a safe prime and a suitable generator are used. If this is not the case, +false+ is returned." />
            <scope name="private?" ilk="function" signature="private?()" doc="Indicates whether this DH instance has a private key associated with it or not. The private key may be retrieved with DH#priv_key." />
            <scope name="public?" ilk="function" signature="public?()" doc="Indicates whether this DH instance has a public key associated with it or not. The public key may be retrieved with DH#pub_key." />
            <scope name="public_key" ilk="function" signature="public_key()" doc="Returns a new DH instance that carries just the public information, i.e. the prime +p+ and the generator +g+, but no public/private key yet. Such a pair may be generated using DH#generate_key!. The &quot;public key&quot; needed for a key exchange with DH#compute_key is considered as per-session information and may be retrieved with DH#pub_key once a key pair has been generated. If the current instance already contains private information (and thus a valid public/private key pair), this information will no longer be present in the new instance generated by DH#public_key. This feature is helpful for publishing the Diffie-Hellman parameters without leaking any of the private per-session information. &#xA; Example dh = OpenSSL::PKey::DH.new(2048) # has public and private key set&#xA;public_key = dh.public_key # contains only prime and generator&#xA;parameters = public_key.to_der # it&apos;s safe to publish this" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Encodes this DH to its DER encoding. Note that any existing per-session public/private keys will *not* get encoded, just the Diffie-Hellman parameters will be encoded." />
            <scope name="to_pem" ilk="function" signature="to_pem()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" doc="Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="DHError" ilk="class" classrefs="ePKeyError">
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="DSA" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(p1)" attributes="__classmethod__" doc="Creates a new DSA instance by generating a private/public key pair from scratch. &#xA; Parameters +size+ is an integer representing the desired key size." />
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Creates a new DSA instance by reading an existing key from +string+. &#xA; Parameters +size+ is an integer representing the desired key size.&#xA;+string+ contains a DER or PEM encoded key.&#xA;+pass+ is a string that contains an optional password. &#xA; Examples DSA.new -&gt; dsa&#xA;DSA.new(1024) -&gt; dsa&#xA;DSA.new(File.read(&apos;dsa.pem&apos;)) -&gt; dsa&#xA;DSA.new(File.read(&apos;dsa.pem&apos;), &apos;mypassword&apos;) -&gt; dsa" />
            <scope name="export" ilk="function" signature="export(p1 = v1, p2 = v2)" doc="Encodes this DSA to its PEM encoding. &#xA; Parameters +cipher+ is an OpenSSL::Cipher.&#xA;+password+ is a string containing your password. &#xA; Examples DSA.to_pem -&gt; aString&#xA;DSA.to_pem(cipher, &apos;mypassword&apos;) -&gt; aString" />
            <scope name="params" ilk="function" signature="params()" doc="Stores all parameters of key to the hash INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
            <scope name="private?" ilk="function" signature="private?()" doc="Indicates whether this DSA instance has a private key associated with it or not. The private key may be retrieved with DSA#private_key." />
            <scope name="public?" ilk="function" signature="public?()" doc="Indicates whether this DSA instance has a public key associated with it or not. The public key may be retrieved with DSA#public_key." />
            <scope name="public_key" ilk="function" signature="public_key()" doc="Returns a new DSA instance that carries just the public key information. If the current instance has also private key information, this will no longer be present in the new instance. This feature is helpful for publishing the public key information without leaking any of the private information. &#xA; Example dsa = OpenSSL::PKey::DSA.new(2048) # has public and private information&#xA;pub_key = dsa.public_key # has only the public part available&#xA;pub_key_der = pub_key.to_der # it&apos;s safe to publish this" />
            <scope name="syssign" ilk="function" signature="syssign(p1)" doc="Computes and returns the DSA signature of +string+, where +string+ is expected to be an already-computed message digest of the original input data. The signature is issued using the private key of this DSA instance. &#xA; Parameters +string+ is a message digest of the original input data to be signed &#xA; Example dsa = OpenSSL::PKey::DSA.new(2048)&#xA;doc = &quot;Sign me&quot;&#xA;digest = OpenSSL::Digest::SHA1.digest(doc)&#xA;sig = dsa.syssign(digest)" />
            <scope name="sysverify" ilk="function" signature="sysverify(p1, p2)" doc="Verifies whether the signature is valid given the message digest input. It does so by validating +sig+ using the public key of this DSA instance. &#xA; Parameters +digest+ is a message digest of the original input data to be signed&#xA;+sig+ is a DSA signature value &#xA; Example dsa = OpenSSL::PKey::DSA.new(2048)&#xA;doc = &quot;Sign me&quot;&#xA;digest = OpenSSL::Digest::SHA1.digest(doc)&#xA;sig = dsa.syssign(digest)&#xA;puts dsa.sysverify(digest, sig) # =&gt; true" />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Encodes this DSA to its DER encoding." />
            <scope name="to_pem" ilk="function" signature="to_pem(p1 = v1, p2 = v2)" />
            <scope name="to_s" ilk="function" signature="to_s(p1 = v1, p2 = v2)" />
            <scope name="to_text" ilk="function" signature="to_text()" doc="Prints all parameters of key to buffer INSECURE: PRIVATE INFORMATIONS CAN LEAK OUT!!! Don&apos;t use :-)) (I&apos;s up to you)" />
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="DSAError" ilk="class" classrefs="ePKeyError">
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="RSA" ilk="class" classrefs="cPKey">
            <scope name="generate" ilk="function" signature="generate(p1, p2 = v2)" attributes="__classmethod__" doc="Generates an RSA keypair.  +size+ is an integer representing the desired key size.  Keys smaller than 1024 should be considered insecure.  +exponent+ is an odd number normally 3, 17, or 65537." />
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Generates or loads an RSA keypair.  If an integer +key_size+ is given it represents the desired key size.  Keys less than 1024 bits should be considered insecure. &#xA; A key can instead be loaded from an +encoded_key+ which must be PEM or DER encoded.  A +pass_phrase+ can be used to decrypt the key.  If none is given OpenSSL will prompt for the pass phrase. &#xA; Examples &#xA; OpenSSL::PKey::RSA.new 2048&#xA;OpenSSL::PKey::RSA.new File.read &apos;rsa.pem&apos;&#xA;OpenSSL::PKey::RSA.new File.read(&apos;rsa.pem&apos;), &apos;my pass phrase&apos;" />
            <scope name="blinding_off!" ilk="function" signature="blinding_off!()" />
            <scope name="blinding_on!" ilk="function" signature="blinding_on!()" />
            <scope name="export" ilk="function" signature="export(p1 = v1, p2 = v2)" doc="Outputs this keypair in PEM encoding.  If +cipher+ and +pass_phrase+ are given they will be used to encrypt the key.  +cipher+ must be an OpenSSL::Cipher::Cipher instance." />
            <scope name="params" ilk="function" signature="params()" doc="THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!! &#xA; Stores all parameters of key to the hash.  The hash has keys &apos;n&apos;, &apos;e&apos;, &apos;d&apos;, &apos;p&apos;, &apos;q&apos;, &apos;dmp1&apos;, &apos;dmq1&apos;, &apos;iqmp&apos;. &#xA; Don&apos;t use :-)) (It&apos;s up to you)" />
            <scope name="private?" ilk="function" signature="private?()" doc="Does this keypair contain a private key?" />
            <scope name="private_decrypt" ilk="function" signature="private_decrypt(p1, p2 = v2)" doc="Decrypt +string+, which has been encrypted with the public key, with the private key.  +padding+ defaults to PKCS1_PADDING." />
            <scope name="private_encrypt" ilk="function" signature="private_encrypt(p1, p2 = v2)" doc="Encrypt +string+ with the private key.  +padding+ defaults to PKCS1_PADDING. The encrypted string output can be decrypted using #public_decrypt." />
            <scope name="public?" ilk="function" signature="public?()" doc="The return value is always true since every private key is also a public key." />
            <scope name="public_decrypt" ilk="function" signature="public_decrypt(p1, p2 = v2)" doc="Decrypt +string+, which has been encrypted with the private key, with the public key.  +padding+ defaults to PKCS1_PADDING." />
            <scope name="public_encrypt" ilk="function" signature="public_encrypt(p1, p2 = v2)" doc="Encrypt +string+ with the public key.  +padding+ defaults to PKCS1_PADDING. The encrypted string output can be decrypted using #private_decrypt." />
            <scope name="public_key" ilk="function" signature="public_key()" doc="Makes new RSA instance containing the public key from the private key." />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Outputs this keypair in DER encoding." />
            <scope name="to_pem" ilk="function" signature="to_pem(p1 = v1, p2 = v2)" />
            <scope name="to_s" ilk="function" signature="to_s(p1 = v1, p2 = v2)" />
            <scope name="to_text" ilk="function" signature="to_text()" doc="THIS METHOD IS INSECURE, PRIVATE INFORMATION CAN LEAK OUT!!! &#xA; Dumps all parameters of a keypair to a String &#xA; Don&apos;t use :-)) (It&apos;s up to you)" />
          </scope>
        </scope>
        <scope name="PKey" ilk="namespace">
          <scope name="RSAError" ilk="class" classrefs="ePKeyError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="openssl/buffering" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="Buffering" ilk="namespace">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="close" ilk="function" signature="close()" doc="Closes the SSLSocket and flushes any unwritten data." />
          <scope name="each" ilk="function" signature="each(eol=$/)" doc="Executes the block for every line in the stream where lines are separated by +eol+. &#xA; See also #gets" />
          <scope name="each_byte" ilk="function" signature="each_byte()" doc="Calls the given block once for each byte in the stream." />
          <scope name="each_line" ilk="function" signature="each_line(eol=$/)" />
          <scope name="eof" ilk="function" signature="eof()" />
          <scope name="eof?" ilk="function" signature="eof?()" doc="Returns true if the stream is at file which means there is no more data to be read." />
          <scope name="flush" ilk="function" signature="flush()" doc="Flushes buffered data to the SSLSocket." />
          <scope name="getc" ilk="function" signature="getc()" doc="Reads one character from the stream.  Returns nil if called at end of file." />
          <scope name="gets" ilk="function" signature="gets(eol=$/, limit=nil)" doc="Reads the next &quot;line+ from the stream.  Lines are separated by +eol+.  If +limit+ is provided the result will not be longer than the given number of bytes. &#xA; +eol+ may be a String or Regexp. &#xA; Unlike IO#gets the line read will not be assigned to +$_+. &#xA; Unlike IO#gets the separator must be provided if a limit is provided." />
          <scope name="print" ilk="function" signature="print(*args)" doc="Writes +args+ to the stream. &#xA; See IO#print for full details." />
          <scope name="printf" ilk="function" signature="printf(s, *args)" doc="Formats and writes to the stream converting parameters under control of the format string. &#xA; See Kernel#sprintf for format string details." />
          <scope name="puts" ilk="function" signature="puts(*args)" doc="Writes +args+ to the stream along with a record separator. &#xA; See IO#puts for full details." />
          <scope name="read" ilk="function" signature="read(size=nil, buf=nil)" doc="Reads +size+ bytes from the stream.  If +buf+ is provided it must reference a string which will receive the data. &#xA; See IO#read for full details." />
          <scope name="read_nonblock" ilk="function" signature="read_nonblock(maxlen, buf=nil)" doc="Reads at most +maxlen+ bytes in the non-blocking manner. &#xA; When no data can be read without blocking it raises OpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable. &#xA; IO::WaitReadable means SSL needs to read internally so read_nonblock should be called again when the underlying IO is readable. &#xA; IO::WaitWritable means SSL needs to write internally so read_nonblock should be called again after the underlying IO is writable. &#xA; OpenSSL::Buffering#read_nonblock needs two rescue clause as follows: &#xA; # emulates blocking read (readpartial).&#xA;begin&#xA;  result = ssl.read_nonblock(maxlen)&#xA;rescue IO::WaitReadable&#xA;  IO.select([io])&#xA;  retry&#xA;rescue IO::WaitWritable&#xA;  IO.select(nil, [io])" />
          <scope name="readchar" ilk="function" signature="readchar()" doc="Reads a one-character string from the stream.  Raises an EOFError at end of file." />
          <scope name="readline" ilk="function" signature="readline(eol=$/)" doc="Reads a line from the stream which is separated by +eol+. &#xA; Raises EOFError if at end of file." />
          <scope name="readlines" ilk="function" signature="readlines(eol=$/)" doc="Reads lines from the stream which are separated by +eol+. &#xA; See also #gets" />
          <scope name="readpartial" ilk="function" signature="readpartial(maxlen, buf=nil)" doc="Reads at most +maxlen+ bytes from the stream.  If +buf+ is provided it must reference a string which will receive the data. &#xA; See IO#readpartial for full details." />
          <scope name="ungetc" ilk="function" signature="ungetc(c)" doc="Pushes character +c+ back onto the stream such that a subsequent buffered character read will return it. &#xA; Unlike IO#getc multiple bytes may be pushed back onto the stream. &#xA; Has no effect on unbuffered reads (such as #sysread)." />
          <scope name="write" ilk="function" signature="write(s)" doc="Writes +s+ to the stream.  If the argument is not a string it will be converted using String#to_s.  Returns the number of bytes written." />
          <scope name="write_nonblock" ilk="function" signature="write_nonblock(s)" doc="Writes +str+ in the non-blocking manner. &#xA; If there is buffered data, it is flushed first.  This may block. &#xA; write_nonblock returns number of bytes written to the SSL connection. &#xA; When no data can be written without blocking it raises OpenSSL::SSL::SSLError extended by IO::WaitReadable or IO::WaitWritable. &#xA; IO::WaitReadable means SSL needs to read internally so write_nonblock should be called again after the underlying IO is readable. &#xA; IO::WaitWritable means SSL needs to write internally so write_nonblock should be called again after underlying IO is writable. &#xA; So OpenSSL::Buffering#write_nonblock needs two rescue clause as follows. &#xA; # emulates blocking write.&#xA;begin&#xA;  result = ssl.write_nonblock(str)&#xA;rescue IO::WaitReadable&#xA;  IO.select([io])&#xA;  retry" />
          <scope ilk="function" name="sync" />
          <scope ilk="function" name="sync=" />
          <variable name="BLOCK_SIZE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="openssl/cipher" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="Cipher" ilk="namespace">
          <scope name="Cipher" ilk="class" classrefs="OpenSSL::Cipher">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="openssl/digest" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="Digest" ilk="namespace">
          <scope name="Digest" ilk="class" classrefs="OpenSSL::Digest">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="openssl/x509-internal" ilk="blob" lang="Ruby">
      <scope name="OpenSSL" ilk="namespace">
        <scope name="debug" ilk="function" signature="debug()" attributes="__classmethod__" />
        <scope name="debug=" ilk="function" signature="debug=(p1)" attributes="__classmethod__" doc="Turns on or off CRYPTO_MEM_CHECK. Also shows some debugging message on stderr." />
        <scope name="errors" ilk="function" signature="errors()" attributes="__classmethod__" doc="See any remaining errors held in queue. &#xA; Any errors you see here are probably due to a bug in ruby&apos;s OpenSSL implementation." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="OPENSSL_VERSION" attributes="__const__" citdl="Object" />
        <variable name="OPENSSL_VERSION_NUMBER" attributes="__const__" citdl="Object" />
        <scope name="BN" ilk="class" classrefs="Object">
          <import symbol="Comparable" />
          <scope name="generate_prime" ilk="function" signature="generate_prime(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__" doc="Parameters +bits+ - integer&#xA;+safe+ - boolean&#xA;+add+ - BN&#xA;+rem+ - BN" />
          <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" />
          <scope name="bit_set?" ilk="function" signature="bit_set?(p1)" />
          <scope name="coerce" ilk="function" signature="coerce(p1)" />
          <scope name="copy" ilk="function" signature="copy(p1)" />
          <scope name="eql?" ilk="function" signature="eql?(p1)" />
          <scope name="prime?" ilk="function" signature="prime?(p1 = v1)" doc="Parameters +checks+ - integer" />
          <scope name="prime_fasttest?" ilk="function" signature="prime_fasttest?(p1 = v1, p2 = v2)" doc="Parameters +checks+ - integer&#xA;+trial_div+ - boolean" />
          <scope name="to_bn" ilk="function" signature="to_bn()" />
          <scope name="to_i" ilk="function" signature="to_i()" />
          <scope name="to_int" ilk="function" signature="to_int()" />
          <scope name="to_s" ilk="function" signature="to_s(p1 = v1)" doc="Parameters +base+ - integer&#xA;Valid values:&#xA;0 - MPI&#xA;2 - binary&#xA;10 - the default&#xA;16 - hex" />
        </scope>
        <scope name="BNError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Config" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(filename = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" />
          <scope name="parse_config" ilk="function" signature="parse_config(io)" attributes="__classmethod__" />
          <scope name="add_value" ilk="function" signature="add_value(section, key, value)" />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="get_value" ilk="function" signature="get_value(section, key)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="section" ilk="function" signature="section(name)" />
          <scope name="sections" ilk="function" signature="sections()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="value" ilk="function" signature="value(arg1, arg2 = nil)" />
          <variable name="QUOTE_REGEXP_SQ" attributes="__const__" citdl="Object" />
          <variable name="QUOTE_REGEXP_DQ" attributes="__const__" citdl="Object" />
          <variable name="ESCAPE_MAP" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_CONFIG_FILE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ConfigError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Engine" ilk="class" classrefs="Object">
          <scope name="by_id" ilk="function" signature="by_id(p1)" attributes="__classmethod__" />
          <scope name="cleanup" ilk="function" signature="cleanup()" attributes="__classmethod__" />
          <scope name="engines" ilk="function" signature="engines()" attributes="__classmethod__" />
          <scope name="load" ilk="function" signature="load(p1 = v1)" attributes="__classmethod__" />
          <scope name="cipher" ilk="function" signature="cipher(p1)" />
          <scope name="cmds" ilk="function" signature="cmds()" />
          <scope name="ctrl_cmd" ilk="function" signature="ctrl_cmd(p1, p2 = v2)" />
          <scope name="digest" ilk="function" signature="digest(p1)" />
          <scope name="finish" ilk="function" signature="finish()" />
          <scope name="id" ilk="function" signature="id()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="load_private_key" ilk="function" signature="load_private_key(p1 = v1, p2 = v2)" />
          <scope name="load_public_key" ilk="function" signature="load_public_key(p1 = v1, p2 = v2)" />
          <scope name="name" ilk="function" signature="name()" />
          <scope name="set_default" ilk="function" signature="set_default(p1)" />
          <scope name="EngineError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="HMAC" ilk="class" classrefs="Object">
          <scope name="digest" ilk="function" signature="digest(p1, p2, p3)" attributes="__classmethod__" />
          <scope name="hexdigest" ilk="function" signature="hexdigest(p1, p2, p3)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" />
          <scope name="digest" ilk="function" signature="digest()" />
          <scope name="hexdigest" ilk="function" signature="hexdigest()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="reset" ilk="function" signature="reset()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="update" ilk="function" signature="update(p1)" />
        </scope>
        <scope name="HMACError" ilk="class" classrefs="eOSSLError">
        </scope>
        <scope name="Netscape" ilk="namespace">
          <scope name="SPKI" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" />
            <scope name="challenge" ilk="function" signature="challenge()" />
            <scope name="challenge=" ilk="function" signature="challenge=(p1)" />
            <scope name="public_key" ilk="function" signature="public_key()" />
            <scope name="public_key=" ilk="function" signature="public_key=(p1)" />
            <scope name="sign" ilk="function" signature="sign(p1, p2)" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" />
            <scope name="verify" ilk="function" signature="verify(p1)" doc="Checks that cert signature is made with PRIVversion of this PUBLIC &apos;key&apos;" />
          </scope>
          <scope name="SPKIError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="OCSP" ilk="namespace">
          <scope name="BasicResponse" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="add_nonce" ilk="function" signature="add_nonce(p1 = v1)" />
            <scope name="add_status" ilk="function" signature="add_status(p1, p2, p3, p4, p5, p6, p7)" />
            <scope name="copy_nonce" ilk="function" signature="copy_nonce(p1)" />
            <scope name="sign" ilk="function" signature="sign(p1, p2, p3 = v3, p4 = v4)" />
            <scope name="status" ilk="function" signature="status()" />
            <scope name="verify" ilk="function" signature="verify(p1, p2, p3 = v3)" />
          </scope>
          <scope name="CertificateId" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3)" attributes="__classmethod__ __ctor__" />
            <scope name="cmp" ilk="function" signature="cmp(p1)" />
            <scope name="cmp_issuer" ilk="function" signature="cmp_issuer(p1)" />
            <scope name="serial" ilk="function" signature="serial()" />
          </scope>
          <scope name="OCSPError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Request" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" />
            <scope name="add_certid" ilk="function" signature="add_certid(p1)" />
            <scope name="add_nonce" ilk="function" signature="add_nonce(p1 = v1)" />
            <scope name="certid" ilk="function" signature="certid()" />
            <scope name="check_nonce" ilk="function" signature="check_nonce(p1)" doc="Check nonce validity in a request and response. Return value reflects result: 1: nonces present and equal.&#xA;2: nonces both absent.&#xA;3: nonce present in response only.&#xA;0: nonces both present and not equal.&#xA; -1: nonce in request only. &#xA; For most responders clients can check return &gt; 0.&#xA;If responder doesn&apos;t handle nonces return != 0 may be&#xA;necessary. return == 0 is always an error." />
            <scope name="sign" ilk="function" signature="sign(p1, p2, p3 = v3, p4 = v4)" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="verify" ilk="function" signature="verify(p1, p2, p3 = v3)" />
          </scope>
          <scope name="Response" ilk="class" classrefs="Object">
            <scope name="create" ilk="function" signature="create(p1, p2)" attributes="__classmethod__" doc="OCSP::Response" />
            <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" />
            <scope name="basic" ilk="function" signature="basic()" />
            <scope name="status" ilk="function" signature="status()" />
            <scope name="status_string" ilk="function" signature="status_string()" />
            <scope name="to_der" ilk="function" signature="to_der()" />
          </scope>
        </scope>
        <scope name="OpenSSLError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="PKCS12" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(p1, p2, p3, p4, p5 = v5, p6 = v6, p7 = v7, p8 = v8, p9 = v9, p10 = v10)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+name+ - A string describing the key.&#xA;+key+ - Any PKey.&#xA;+cert+ - A X509::Certificate.&#xA;The public_key portion of the certificate must contain a valid public key.&#xA;The not_before and not_after fields must be filled in.&#xA;+ca+ - An optional array of X509::Certificate&apos;s.&#xA;+key_pbe+ - string&#xA;+cert_pbe+ - string&#xA;+key_iter+ - integer&#xA;+mac_iter+ - integer&#xA;+keytype+ - An integer representing an MSIE specific extension. &#xA; Any optional arguments may be supplied as nil to preserve the OpenSSL defaults. " />
          <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" doc="Parameters +str+ - Must be a DER encoded PKCS12 string.&#xA;+pass+ - string" />
          <scope name="to_der" ilk="function" signature="to_der()" />
          <scope ilk="function" name="ca_certs" />
          <scope ilk="function" name="certificate" />
          <scope ilk="function" name="key" />
          <scope name="PKCS12Error" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKCS5" ilk="namespace">
          <scope name="pbkdf2_hmac" ilk="function" signature="pbkdf2_hmac(p1, p2, p3, p4, p5)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+salt+ - string&#xA;+iter+ - integer - should be greater than 1000.  2000 is better.&#xA;+keylen+ - integer&#xA;+digest+ - a string or OpenSSL::Digest object. &#xA; Available in OpenSSL 0.9.9?. &#xA; Digests other than SHA1 may not be supported by other cryptography libraries." />
          <scope name="pbkdf2_hmac_sha1" ilk="function" signature="pbkdf2_hmac_sha1(p1, p2, p3, p4)" attributes="__classmethod__" doc="Parameters +pass+ - string&#xA;+salt+ - string&#xA;+iter+ - integer - should be greater than 1000.  2000 is better.&#xA;+keylen+ - integer &#xA; This method is available almost any version OpenSSL. &#xA; Conforms to rfc2898." />
          <scope name="PKCS5Error" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="PKCS7" ilk="class" classrefs="Object">
          <scope name="encrypt" ilk="function" signature="encrypt(p1, p2, p3 = v3, p4 = v4)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" doc="Many methods in this class aren&apos;t documented." />
          <scope name="read_smime" ilk="function" signature="read_smime(p1)" attributes="__classmethod__" />
          <scope name="sign" ilk="function" signature="sign(p1, p2, p3, p4 = v4, p5 = v5)" attributes="__classmethod__" />
          <scope name="write_smime" ilk="function" signature="write_smime(p1, p2 = v2, p3 = v3)" attributes="__classmethod__" />
          <scope name="add_certificate" ilk="function" signature="add_certificate(p1)" />
          <scope name="add_crl" ilk="function" signature="add_crl(p1)" />
          <scope name="add_data" ilk="function" signature="add_data(p1)" />
          <scope name="add_recipient" ilk="function" signature="add_recipient(p1)" />
          <scope name="add_signer" ilk="function" signature="add_signer(p1)" />
          <scope name="certificates" ilk="function" signature="certificates()" />
          <scope name="certificates=" ilk="function" signature="certificates=(p1)" />
          <scope name="cipher=" ilk="function" signature="cipher=(p1)" />
          <scope name="crls" ilk="function" signature="crls()" />
          <scope name="crls=" ilk="function" signature="crls=(p1)" />
          <scope name="data=" ilk="function" signature="data=(p1)" />
          <scope name="decrypt" ilk="function" signature="decrypt(p1, p2, p3 = v3)" />
          <scope name="detached" ilk="function" signature="detached()" />
          <scope name="detached=" ilk="function" signature="detached=(p1)" />
          <scope name="detached?" ilk="function" signature="detached?()" />
          <scope name="recipients" ilk="function" signature="recipients()" />
          <scope name="signers" ilk="function" signature="signers()" />
          <scope name="to_der" ilk="function" signature="to_der()" />
          <scope name="to_pem" ilk="function" signature="to_pem()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="type" ilk="function" signature="type()" />
          <scope name="type=" ilk="function" signature="type=(p1)" />
          <scope name="verify" ilk="function" signature="verify(p1, p2, p3 = v3, p4 = v4)" />
          <scope ilk="function" name="data" />
          <scope ilk="function" name="error_string" />
          <scope ilk="function" name="error_string=" />
          <scope name="PKCS7Error" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="RecipientInfo" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" />
            <scope name="enc_key" ilk="function" signature="enc_key()" />
            <scope name="issuer" ilk="function" signature="issuer()" />
            <scope name="serial" ilk="function" signature="serial()" />
          </scope>
          <scope name="SignerInfo" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1, p2, p3)" attributes="__classmethod__ __ctor__" />
            <scope name="issuer" ilk="function" signature="issuer()" />
            <scope name="name" ilk="function" signature="name()" />
            <scope name="serial" ilk="function" signature="serial()" />
            <scope name="signed_time" ilk="function" signature="signed_time()" />
          </scope>
        </scope>
        <scope name="Random" ilk="namespace">
          <scope name="RandomError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
        <scope name="SSL" ilk="namespace">
          <scope name="verify_certificate_identity" ilk="function" signature="verify_certificate_identity(cert, hostname)" attributes="__classmethod__" />
          <scope name="Nonblock" ilk="namespace">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          </scope>
          <scope name="SSLError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="SSLServer" ilk="class" classrefs="Object">
            <import symbol="SocketForwarder" />
            <scope name="new" ilk="function" signature="new(svr, ctx)" attributes="__classmethod__ __ctor__" />
            <scope name="accept" ilk="function" signature="accept()" />
            <scope name="close" ilk="function" signature="close()" />
            <scope name="listen" ilk="function" signature="listen(backlog=5)" />
            <scope name="shutdown" ilk="function" signature="shutdown(how=Socket::SHUT_RDWR)" />
            <scope name="to_io" ilk="function" signature="to_io()" />
            <scope ilk="function" name="start_immediately" />
            <scope ilk="function" name="start_immediately=" />
          </scope>
          <scope name="Session" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="Parameters +SSLSocket+ is an OpenSSL::SSL::SSLSocket +string+ must be a DER or PEM encoded Session." />
            <scope name="id" ilk="function" signature="id()" doc="Returns the Session ID." />
            <scope name="time" ilk="function" signature="time()" doc="Gets start time of the session." />
            <scope name="time=" ilk="function" signature="time=(p1)" doc="Sets start time of the session. Time resolution is in seconds." />
            <scope name="timeout" ilk="function" signature="timeout()" doc="Gets how long until the session expires in seconds." />
            <scope name="timeout=" ilk="function" signature="timeout=(p1)" doc="Sets how long until the session expires in seconds." />
            <scope name="to_der" ilk="function" signature="to_der()" doc="Returns an ASN1 encoded String that contains the Session object." />
            <scope name="to_pem" ilk="function" signature="to_pem()" doc="Returns a PEM encoded String that contains the Session object." />
            <scope name="to_text" ilk="function" signature="to_text()" doc="Shows everything in the Session object." />
            <scope name="SessionError" ilk="class" classrefs="eOSSLError">
            </scope>
          </scope>
          <scope name="SocketForwarder" ilk="namespace">
            <scope name="addr" ilk="function" signature="addr()" />
            <scope name="closed?" ilk="function" signature="closed?()" />
            <scope name="do_not_reverse_lookup=" ilk="function" signature="do_not_reverse_lookup=(flag)" />
            <scope name="fcntl" ilk="function" signature="fcntl(*args)" />
            <scope name="getsockopt" ilk="function" signature="getsockopt(level, optname)" />
            <scope name="peeraddr" ilk="function" signature="peeraddr()" />
            <scope name="setsockopt" ilk="function" signature="setsockopt(level, optname, optval)" />
          </scope>
        </scope>
        <scope name="X509" ilk="namespace">
          <scope name="Attribute" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" />
            <scope name="oid" ilk="function" signature="oid()" />
            <scope name="oid=" ilk="function" signature="oid=(p1)" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="value" ilk="function" signature="value()" />
            <scope name="value=" ilk="function" signature="value=(p1)" />
          </scope>
          <scope name="AttributeError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="CRL" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" />
            <scope name="add_extension" ilk="function" signature="add_extension(p1)" />
            <scope name="add_revoked" ilk="function" signature="add_revoked(p1)" />
            <scope name="extensions" ilk="function" signature="extensions()" doc="Gets X509v3 extensions as array of X509Ext objects" />
            <scope name="extensions=" ilk="function" signature="extensions=(p1)" doc="Sets X509_EXTENSIONs" />
            <scope name="issuer" ilk="function" signature="issuer()" />
            <scope name="issuer=" ilk="function" signature="issuer=(p1)" />
            <scope name="last_update" ilk="function" signature="last_update()" />
            <scope name="last_update=" ilk="function" signature="last_update=(p1)" />
            <scope name="next_update" ilk="function" signature="next_update()" />
            <scope name="next_update=" ilk="function" signature="next_update=(p1)" />
            <scope name="revoked" ilk="function" signature="revoked()" />
            <scope name="revoked=" ilk="function" signature="revoked=(p1)" />
            <scope name="sign" ilk="function" signature="sign(p1, p2)" />
            <scope name="signature_algorithm" ilk="function" signature="signature_algorithm()" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" />
            <scope name="verify" ilk="function" signature="verify(p1)" />
            <scope name="version" ilk="function" signature="version()" />
            <scope name="version=" ilk="function" signature="version=(p1)" />
          </scope>
          <scope name="CRLError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="CertificateError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Extension" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Creates an X509 extension. &#xA; The extension may be created from +asn1+ data or from an extension +name+ and +value+.  The +name+ may be either an OID or an extension name.  If +critical+ is true the extension is marked critical." />
            <scope name="critical=" ilk="function" signature="critical=(p1)" />
            <scope name="critical?" ilk="function" signature="critical?()" />
            <scope name="oid" ilk="function" signature="oid()" />
            <scope name="oid=" ilk="function" signature="oid=(p1)" />
            <scope name="to_a" ilk="function" signature="to_a()" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_h" ilk="function" signature="to_h()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="value" ilk="function" signature="value()" />
            <scope name="value=" ilk="function" signature="value=(p1)" />
          </scope>
          <scope name="ExtensionError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="ExtensionFactory" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" />
            <scope name="config=" ilk="function" signature="config=(p1)" />
            <scope name="create_ext" ilk="function" signature="create_ext(p1, p2, p3 = v3)" doc="Array to X509_EXTENSION Structure: or&#xA;or&#xA;or the same for sn&#xA;&gt; not critical" />
            <scope name="create_ext_from_array" ilk="function" signature="create_ext_from_array(ary)" />
            <scope name="create_ext_from_hash" ilk="function" signature="create_ext_from_hash(hash)" />
            <scope name="create_ext_from_string" ilk="function" signature="create_ext_from_string(str)" />
            <scope name="create_extension" ilk="function" signature="create_extension(*arg)" />
            <scope name="crl=" ilk="function" signature="crl=(p1)" />
            <scope name="issuer_certificate=" ilk="function" signature="issuer_certificate=(p1)" />
            <scope name="subject_certificate=" ilk="function" signature="subject_certificate=(p1)" />
            <scope name="subject_request=" ilk="function" signature="subject_request=(p1)" />
            <scope ilk="function" name="config" />
            <scope ilk="function" name="crl" />
            <scope ilk="function" name="issuer_certificate" />
            <scope ilk="function" name="subject_certificate" />
            <scope ilk="function" name="subject_request" />
          </scope>
          <scope name="Name" ilk="class" classrefs="Object">
            <import symbol="Comparable" />
            <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2)" attributes="__classmethod__ __ctor__" />
            <scope name="parse" ilk="function" signature="parse(str, template=OBJECT_TYPE_TEMPLATE)" attributes="__classmethod__" />
            <scope name="parse_openssl" ilk="function" signature="parse_openssl(str, template=OBJECT_TYPE_TEMPLATE)" attributes="__classmethod__" />
            <scope name="parse_rfc2253" ilk="function" signature="parse_rfc2253(str, template=OBJECT_TYPE_TEMPLATE)" attributes="__classmethod__" />
            <scope name="add_entry" ilk="function" signature="add_entry(p1, p2, p3 = v3)" />
            <scope name="cmp" ilk="function" signature="cmp(p1)" doc="Compares this Name with +other+ and returns 0 if they are the same and -1 or +1 if they are greater or less than each other respectively." />
            <scope name="eql?" ilk="function" signature="eql?(p1)" />
            <scope name="hash" ilk="function" signature="hash()" doc="The hash value returned is suitable for use as a certificate&apos;s filename in a CA path." />
            <scope name="hash_old" ilk="function" signature="hash_old()" doc="hash_old returns MD5 based hash used in OpenSSL 0.9.X." />
            <scope name="to_a" ilk="function" signature="to_a()" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_s" ilk="function" signature="to_s(p1 = v1)" />
            <variable name="DEFAULT_OBJECT_TYPE" attributes="__const__" citdl="Object" />
            <variable name="OBJECT_TYPE_TEMPLATE" attributes="__const__" citdl="Object" />
            <variable name="COMPAT" attributes="__const__" citdl="Object" />
            <variable name="ONELINE" attributes="__const__" citdl="Object" />
            <variable name="MULTILINE" attributes="__const__" citdl="Object" />
            <scope name="RFC2253DN" ilk="namespace">
              <scope name="expand_hexstring" ilk="function" signature="expand_hexstring(str)" />
              <scope name="expand_pair" ilk="function" signature="expand_pair(str)" />
              <scope name="expand_value" ilk="function" signature="expand_value(str1, str2, str3)" />
              <scope name="scan" ilk="function" signature="scan(dn)" />
            </scope>
          </scope>
          <scope name="NameError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Request" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" />
            <scope name="add_attribute" ilk="function" signature="add_attribute(p1)" />
            <scope name="attributes" ilk="function" signature="attributes()" />
            <scope name="attributes=" ilk="function" signature="attributes=(p1)" />
            <scope name="public_key" ilk="function" signature="public_key()" />
            <scope name="public_key=" ilk="function" signature="public_key=(p1)" />
            <scope name="sign" ilk="function" signature="sign(p1, p2)" />
            <scope name="signature_algorithm" ilk="function" signature="signature_algorithm()" />
            <scope name="subject" ilk="function" signature="subject()" />
            <scope name="subject=" ilk="function" signature="subject=(p1)" />
            <scope name="to_der" ilk="function" signature="to_der()" />
            <scope name="to_pem" ilk="function" signature="to_pem()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="to_text" ilk="function" signature="to_text()" />
            <scope name="verify" ilk="function" signature="verify(p1)" doc="Checks that cert signature is made with PRIVversion of this PUBLIC &apos;key&apos;" />
            <scope name="version" ilk="function" signature="version()" />
            <scope name="version=" ilk="function" signature="version=(p1)" />
          </scope>
          <scope name="RequestError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Revoked" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="add_extension" ilk="function" signature="add_extension(p1)" />
            <scope name="extensions" ilk="function" signature="extensions()" doc="Gets X509v3 extensions as array of X509Ext objects" />
            <scope name="extensions=" ilk="function" signature="extensions=(p1)" doc="Sets X509_EXTENSIONs" />
            <scope name="serial" ilk="function" signature="serial()" />
            <scope name="serial=" ilk="function" signature="serial=(p1)" />
            <scope name="time" ilk="function" signature="time()" />
            <scope name="time=" ilk="function" signature="time=(p1)" />
          </scope>
          <scope name="RevokedError" ilk="class" classrefs="eOSSLError">
          </scope>
          <scope name="Store" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="add_cert" ilk="function" signature="add_cert(p1)" />
            <scope name="add_crl" ilk="function" signature="add_crl(p1)" />
            <scope name="add_file" ilk="function" signature="add_file(p1)" />
            <scope name="add_path" ilk="function" signature="add_path(p1)" />
            <scope name="flags=" ilk="function" signature="flags=(p1)" />
            <scope name="purpose=" ilk="function" signature="purpose=(p1)" />
            <scope name="set_default_paths" ilk="function" signature="set_default_paths()" />
            <scope name="time=" ilk="function" signature="time=(p1)" />
            <scope name="trust=" ilk="function" signature="trust=(p1)" />
            <scope name="verify" ilk="function" signature="verify(p1, p2 = v2)" />
            <scope name="verify_callback=" ilk="function" signature="verify_callback=(p1)" doc="General callback for OpenSSL verify" />
            <scope ilk="function" name="chain" />
            <scope ilk="function" name="error" />
            <scope ilk="function" name="error_string" />
            <scope ilk="function" name="verify_callback" />
          </scope>
          <scope name="StoreContext" ilk="class" classrefs="Object">
            <scope name="cleanup" ilk="function" signature="cleanup()" />
          </scope>
          <scope name="StoreError" ilk="class" classrefs="eOSSLError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="optparse" ilk="blob" lang="Ruby">
      <scope name="OptionParser" ilk="class" classrefs="Object">
        <scope name="accept" ilk="function" signature="accept(*args, &amp;blk)" attributes="__classmethod__" doc="See #accept." />
        <scope name="each_const" ilk="function" signature="each_const(path, base = ::Object)" attributes="__classmethod__" />
        <scope name="getopts" ilk="function" signature="getopts(*args)" attributes="__classmethod__" doc="See #getopts." />
        <scope name="inc" ilk="function" signature="inc(arg, default = nil)" attributes="__classmethod__" doc="Returns an incremented value of +default+ according to +arg+." />
        <scope name="new" ilk="function" signature="new(banner = nil, width = 32, indent = &apos; &apos; * 4)" attributes="__classmethod__ __ctor__" doc="Initializes the instance and yields itself if called with a block. &#xA; Banner message.&#xA;Summary width.&#xA;Summary indent." />
        <scope name="reject" ilk="function" signature="reject(*args, &amp;blk)" attributes="__classmethod__" doc="See #reject." />
        <scope name="search_const" ilk="function" signature="search_const(klass, name)" attributes="__classmethod__" />
        <scope name="show_version" ilk="function" signature="show_version(*pkgs)" attributes="__classmethod__" />
        <scope name="terminate" ilk="function" signature="terminate(arg = nil)" attributes="__classmethod__" />
        <scope name="top" ilk="function" signature="top()" attributes="__classmethod__" />
        <scope name="with" ilk="function" signature="with(*args, &amp;block)" attributes="__classmethod__" doc="Initializes a new instance and evaluates the optional block in context of the instance. Arguments +args+ are passed to #new, see there for description of parameters. &#xA; This method is *deprecated*, its behavior corresponds to the older #new method." />
        <scope name="abort" ilk="function" signature="abort(mesg = $!)" />
        <scope name="accept" ilk="function" signature="accept(*args, &amp;blk)" doc="Directs to accept specified class +t+. The argument string is passed to the block in which it should be converted to the desired class. &#xA; Argument class specifier, any object including Class.&#xA;Pattern for argument, defaults to +t+ if it responds to match. &#xA; accept(t, pat, &amp;block)" />
        <scope name="banner" ilk="function" doc="Heading banner preceding summary." />
        <scope name="base" ilk="function" signature="base()" doc="Subject of #on_tail." />
        <scope name="candidate" ilk="function" signature="candidate(word)" />
        <scope name="def_head_option" ilk="function" signature="def_head_option(*opts, &amp;block)" />
        <scope name="def_option" ilk="function" signature="def_option(*opts, &amp;block)" />
        <scope name="def_tail_option" ilk="function" signature="def_tail_option(*opts, &amp;block)" />
        <scope name="define" ilk="function" signature="define(*opts, &amp;block)" />
        <scope name="define_head" ilk="function" signature="define_head(*opts, &amp;block)" />
        <scope name="define_tail" ilk="function" signature="define_tail(*opts, &amp;block)" />
        <scope name="environment" ilk="function" signature="environment(env = File.basename($0, &apos;.*&apos;))" doc="Parses environment variable +env+ or its uppercase with splitting like a shell. &#xA; +env+ defaults to the basename of the program." />
        <scope name="getopts" ilk="function" signature="getopts(*args)" doc="Wrapper method for getopts.rb. &#xA; params = ARGV.getopts(&quot;ab:&quot;, &quot;foo&quot;, &quot;bar:&quot;)&#xA;# params[:a] = true   # -a&#xA;# params[:b] = &quot;1&quot;    # -b1&#xA;# params[:foo] = &quot;1&quot;  # --foo&#xA;# params[:bar] = &quot;x&quot;  # --bar x" />
        <scope name="help" ilk="function" signature="help()" doc="Returns option summary string." />
        <scope name="inc" ilk="function" signature="inc(*args)" />
        <scope name="load" ilk="function" signature="load(filename = nil)" doc="Loads options from file names as +filename+. Does nothing when the file is not present. Returns whether successfully loaded. &#xA; +filename+ defaults to basename of the program without suffix in a directory ~/.options." />
        <scope name="make_switch" ilk="function" signature="make_switch(opts, block = nil)" doc="Creates an OptionParser::Switch from the parameters. The parsed argument value is passed to the given block, where it can be processed. &#xA; See at the beginning of OptionParser for some full examples. &#xA; +opts+ can include the following elements: &#xA; One of the following: :NONE, :REQUIRED, :OPTIONAL&#xA;Acceptable option argument format, must be pre-defined with OptionParser.accept or OptionParser#accept, or Regexp. This can appear once or assigned as String if not present, otherwise causes an ArgumentError. Examples: Float, Time, Array&#xA;Hash or Array. [:text, :binary, :auto]&#xA;%w[iso-2022-jp shift_jis euc-jp utf8 binary]&#xA;{ &quot;jis&quot; =&gt; &quot;iso-2022-jp&quot;, &quot;sjis&quot; =&gt; &quot;shift_jis&quot; }&#xA;Specifies a long style switch which takes a mandatory, optional or no argument. It&apos;s a string of the following form: &quot;--switch=MANDATORY&quot; or &quot;--switch MANDATORY&quot;&#xA;&quot;--switch[=OPTIONAL]&quot;&#xA;&quot;--switch&quot;&#xA;Specifies short style switch which takes a mandatory, optional or no argument. It&apos;s a string of the following form: &quot;-xMANDATORY&quot;&#xA;&quot;-x[OPTIONAL]&quot;" />
        <scope name="new" ilk="function" signature="new()" doc="Pushes a new List." />
        <scope name="on" ilk="function" signature="on(*opts, &amp;block)" doc="Add option switch and handler. See #make_switch for an explanation of parameters." />
        <scope name="on_head" ilk="function" signature="on_head(*opts, &amp;block)" doc="Add option switch like with #on, but at head of summary." />
        <scope name="on_tail" ilk="function" signature="on_tail(*opts, &amp;block)" doc="Add option switch like with #on, but at tail of summary." />
        <scope name="order" ilk="function" signature="order(*argv, &amp;block)" doc="Parses command line arguments +argv+ in order. When a block is given, each non-option argument is yielded. &#xA; Returns the rest of +argv+ left unparsed." />
        <scope name="order!" ilk="function" signature="order!(argv = default_argv, &amp;nonopt)" doc="Same as #order, but removes switches destructively." />
        <scope name="parse" ilk="function" signature="parse(*argv)" doc="Parses command line arguments +argv+ in order when environment variable POSIXLY_CORRECT is set, and in permutation mode otherwise." />
        <scope name="parse!" ilk="function" signature="parse!(argv = default_argv)" doc="Same as #parse, but removes switches destructively." />
        <scope name="permute" ilk="function" signature="permute(*argv)" doc="Parses command line arguments +argv+ in permutation mode and returns list of non-option arguments." />
        <scope name="permute!" ilk="function" signature="permute!(argv = default_argv)" doc="Same as #permute, but removes switches destructively." />
        <scope name="program_name" ilk="function" doc="Program name to be emitted in error message and default banner, defaults to $0." />
        <scope name="reject" ilk="function" signature="reject(*args, &amp;blk)" doc="Directs to reject specified class argument. &#xA; Argument class specifier, any object including Class. &#xA; reject(t)" />
        <scope name="release" ilk="function" doc="Release code" />
        <scope name="remove" ilk="function" signature="remove()" doc="Removes the last List." />
        <scope name="separator" ilk="function" signature="separator(string)" doc="Add separator in summary." />
        <scope name="summarize" ilk="function" signature="summarize(to = [], width = @summary_width, max = width - 1, indent = @summary_indent, &amp;blk)" doc="Puts option summary into +to+ and returns +to+. Yields each line if a block is given. &#xA; Output destination, which must have method &lt;&lt;. Defaults to [].&#xA;Width of left side, defaults to @summary_width.&#xA;Maximum length allowed for left side, defaults to +width+ - 1.&#xA;Indentation, defaults to @summary_indent." />
        <scope name="terminate" ilk="function" signature="terminate(arg = nil)" doc="Terminates option parsing. Optional parameter +arg+ is a string pushed back to be the first non-option argument." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Returns option summary list." />
        <scope name="to_s" ilk="function" signature="to_s()" />
        <scope name="top" ilk="function" signature="top()" doc="Subject of #on / #on_head, #accept / #reject" />
        <scope name="ver" ilk="function" signature="ver()" doc="Returns version string from program_name, version and release." />
        <scope name="version" ilk="function" doc="Version" />
        <scope name="warn" ilk="function" signature="warn(mesg = $!)" />
        <scope ilk="function" name="banner=" />
        <scope ilk="function" name="default_argv" />
        <scope ilk="function" name="default_argv=" />
        <scope ilk="function" name="program_name=" />
        <scope ilk="function" name="release=" />
        <scope ilk="function" name="set_banner=" />
        <scope ilk="function" name="set_program_name=" />
        <scope ilk="function" name="set_summary_indent" />
        <scope ilk="function" name="set_summary_indent=" />
        <scope ilk="function" name="set_summary_width" />
        <scope ilk="function" name="set_summary_width=" />
        <scope ilk="function" name="summary_indent" />
        <scope ilk="function" name="summary_indent=" />
        <scope ilk="function" name="summary_width" />
        <scope ilk="function" name="summary_width=" />
        <scope ilk="function" name="version=" />
        <variable name="SPLAT_PROC" attributes="__const__" citdl="Object" />
        <scope name="Acceptables" ilk="namespace">
        </scope>
        <scope name="AmbiguousArgument" ilk="class" classrefs="OptionParser::InvalidArgument">
        </scope>
        <scope name="AmbiguousOption" ilk="class" classrefs="OptionParser::ParseError">
        </scope>
        <scope name="Arguable" ilk="namespace">
          <scope name="extend_object" ilk="function" signature="extend_object(obj)" attributes="__classmethod__" doc="Initializes instance variable." />
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="getopts" ilk="function" signature="getopts(*args)" doc="Substitution of getopts is possible as follows. Also see OptionParser#getopts. &#xA; def getopts(*args)&#xA;  ($OPT = ARGV.getopts(*args)).each do |opt, val|&#xA;    eval &quot;$OPT_#{opt.gsub(/[^A-Za-z0-9_]/, &apos;_&apos;)} = val&quot;&#xA;  end&#xA;rescue OptionParser::ParseError&#xA;end" />
          <scope name="options" ilk="function" signature="options()" doc="Actual OptionParser object, automatically created if nonexistent. &#xA; If called with a block, yields the OptionParser object and returns the result of the block. If an OptionParser::ParseError exception occurs in the block, it is rescued, a error message printed to STDERR and +nil+ returned." />
          <scope name="options=" ilk="function" signature="options=(opt)" doc="Sets OptionParser object, when +opt+ is +false+ or +nil+, methods OptionParser::Arguable#options and OptionParser::Arguable#options= are undefined. Thus, there is no ways to access the OptionParser object via the receiver object." />
          <scope name="order!" ilk="function" signature="order!(&amp;blk)" doc="Parses +self+ destructively in order and returns +self+ containing the rest arguments left unparsed." />
          <scope name="parse!" ilk="function" signature="parse!()" doc="Parses +self+ destructively and returns +self+ containing the rest arguments left unparsed." />
          <scope name="permute!" ilk="function" signature="permute!()" doc="Parses +self+ destructively in permutation mode and returns +self+ containing the rest arguments left unparsed." />
        </scope>
        <scope name="CompletingHash" ilk="class" classrefs="Hash">
          <import symbol="Completion" />
          <scope name="match" ilk="function" signature="match(key)" doc="Completion for hash key." />
        </scope>
        <scope name="Completion" ilk="namespace">
          <scope name="candidate" ilk="function" signature="candidate(key, icase = false, pat = nil, &amp;block)" attributes="__classmethod__" />
          <scope name="regexp" ilk="function" signature="regexp(key, icase)" attributes="__classmethod__" />
          <scope name="candidate" ilk="function" signature="candidate(key, icase = false, pat = nil)" />
          <scope name="complete" ilk="function" signature="complete(key, icase = false, pat = nil)" />
          <scope name="convert" ilk="function" signature="convert(opt = nil, val = nil, *)" />
        </scope>
        <scope name="InvalidArgument" ilk="class" classrefs="OptionParser::ParseError">
        </scope>
        <scope name="InvalidOption" ilk="class" classrefs="OptionParser::ParseError">
        </scope>
        <scope name="List" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Just initializes all instance variables." />
          <scope name="accept" ilk="function" signature="accept(t, pat = /.*/m, &amp;block)" doc="See OptionParser.accept." />
          <scope name="append" ilk="function" signature="append(*args)" doc="Appends +switch+ at the tail of the list, and associates short, long and negated long options. Arguments are: &#xA; OptionParser::Switch instance to be inserted.&#xA;List of short style options.&#xA;List of long style options.&#xA;List of long style options with &quot;no-&quot; prefix. &#xA; append(switch, short_opts, long_opts, nolong_opts)" />
          <scope name="complete" ilk="function" signature="complete(id, opt, icase = false, *pat, &amp;block)" doc="Searches list +id+ for +opt+ and the optional patterns for completion +pat+. If +icase+ is true, the search is case insensitive. The result is returned or yielded if a block is given. If it isn&apos;t found, nil is returned." />
          <scope name="each_option" ilk="function" signature="each_option(&amp;block)" doc="Iterates over each option, passing the option to the +block+." />
          <scope name="prepend" ilk="function" signature="prepend(*args)" doc="Inserts +switch+ at the head of the list, and associates short, long and negated long options. Arguments are: &#xA; OptionParser::Switch instance to be inserted.&#xA;List of short style options.&#xA;List of long style options.&#xA;List of long style options with &quot;no-&quot; prefix. &#xA; prepend(switch, short_opts, long_opts, nolong_opts)" />
          <scope name="reject" ilk="function" signature="reject(t)" doc="See OptionParser.reject." />
          <scope name="search" ilk="function" signature="search(id, key)" doc="Searches +key+ in +id+ list. The result is returned or yielded if a block is given. If it isn&apos;t found, nil is returned." />
          <scope name="summarize" ilk="function" signature="summarize(*args, &amp;block)" doc="Creates the summary table, passing each line to the +block+ (without newline). The arguments +args+ are passed along to the summarize method which is called on every option." />
          <scope ilk="function" name="atype" />
          <scope ilk="function" name="list" />
          <scope ilk="function" name="long" />
          <scope ilk="function" name="short" />
        </scope>
        <scope name="MissingArgument" ilk="class" classrefs="OptionParser::ParseError">
        </scope>
        <scope name="NeedlessArgument" ilk="class" classrefs="OptionParser::ParseError">
        </scope>
        <scope name="OptionMap" ilk="class" classrefs="Hash">
          <import symbol="Completion" />
        </scope>
        <scope name="ParseError" ilk="class" classrefs="RuntimeError">
          <scope name="filter_backtrace" ilk="function" signature="filter_backtrace(array)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="message" ilk="function" signature="message()" doc="Default stringizing method to emit standard error message." />
          <scope name="reason" ilk="function" />
          <scope name="recover" ilk="function" signature="recover(argv)" doc="Pushes back erred argument(s) to +argv+." />
          <scope name="set_backtrace" ilk="function" signature="set_backtrace(array)" />
          <scope name="set_option" ilk="function" signature="set_option(opt, eq)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="args" />
          <scope ilk="function" name="reason=" />
        </scope>
        <scope name="Switch" ilk="class" classrefs="Object">
          <scope name="guess" ilk="function" signature="guess(arg)" attributes="__classmethod__" doc="Guesses argument style from +arg+.  Returns corresponding OptionParser::Switch class (OptionalArgument, etc.)." />
          <scope name="incompatible_argument_styles" ilk="function" signature="incompatible_argument_styles(arg, t)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(pattern = nil, conv = nil, short = nil, long = nil, arg = nil, desc = ([] if short or long), block = Proc.new)" attributes="__classmethod__ __ctor__" />
          <scope name="pattern" ilk="function" signature="pattern()" attributes="__classmethod__" />
          <scope name="summarize" ilk="function" signature="summarize(sdone = [], ldone = [], width = 1, max = width - 1, indent = &quot;&quot;)" doc="Produces the summary text. Each line of the summary is yielded to the block (without newline). &#xA; Already summarized short style options keyed hash.&#xA;Already summarized long style options keyed hash.&#xA;Width of left side (option part). In other words, the right side (description part) starts after +width+ columns.&#xA;Maximum width of left side -&gt; the options are filled within +max+ columns.&#xA;Prefix string indents all summarized lines." />
          <scope name="switch_name" ilk="function" signature="switch_name()" doc="Main name of the switch." />
          <scope ilk="function" name="arg" />
          <scope ilk="function" name="block" />
          <scope ilk="function" name="conv" />
          <scope ilk="function" name="desc" />
          <scope ilk="function" name="long" />
          <scope ilk="function" name="pattern" />
          <scope ilk="function" name="short" />
          <scope name="NoArgument" ilk="class" classrefs="self">
            <scope name="incompatible_argument_styles" ilk="function" signature="incompatible_argument_styles(*)" attributes="__classmethod__" />
            <scope name="pattern" ilk="function" signature="pattern()" attributes="__classmethod__" />
            <scope name="parse" ilk="function" signature="parse(arg, argv)" doc="Raises an exception if any arguments given." />
          </scope>
          <scope name="OptionalArgument" ilk="class" classrefs="self">
            <scope name="parse" ilk="function" signature="parse(arg, argv, &amp;error)" doc="Parses argument if given, or uses default value." />
          </scope>
          <scope name="PlacedArgument" ilk="class" classrefs="self">
            <scope name="parse" ilk="function" signature="parse(arg, argv, &amp;error)" doc="Returns nil if argument is not present or begins with &apos;-&apos;." />
          </scope>
          <scope name="RequiredArgument" ilk="class" classrefs="self">
            <scope name="parse" ilk="function" signature="parse(arg, argv)" doc="Raises an exception if argument is not present." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="ostruct" ilk="blob" lang="Ruby">
      <scope name="OpenStruct" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(hash=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new OpenStruct object.  By default, the resulting OpenStruct object will have no attributes. &#xA; The optional +hash+, if given, will generate attributes and values. For example: &#xA; require &apos;ostruct&apos;&#xA;hash = { &quot;country&quot; =&gt; &quot;Australia&quot;, :population =&gt; 20_000_000 }&#xA;data = OpenStruct.new(hash)&#xA;&#xA;p data        # -&gt; &lt;OpenStruct country=&quot;Australia&quot; population=20000000&gt;" />
        <scope name="delete_field" ilk="function" signature="delete_field(name)" doc="Remove the named field from the object. Returns the value that the field contained if it was defined. &#xA; require &apos;ostruct&apos;&#xA;&#xA;person = OpenStruct.new(&apos;name&apos; =&gt; &apos;John Smith&apos;, &apos;age&apos; =&gt; 70)&#xA;&#xA;person.delete_field(&apos;name&apos;)  # =&gt; &apos;John Smith&apos;" />
        <scope name="initialize_copy" ilk="function" signature="initialize_copy(orig)" doc="Duplicate an OpenStruct object members." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a detailed summary of the keys and values." />
        <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Provides marshalling support for use by the Marshal library. Returning the underlying Hash table that contains the functions defined as the keys and the values assigned to them. &#xA; require &apos;ostruct&apos;&#xA;&#xA;person = OpenStruct.new&#xA;person.name = &apos;John Smith&apos;&#xA;person.age  = 70&#xA;&#xA;person.marshal_dump # =&gt; { :name =&gt; &apos;John Smith&apos;, :age =&gt; 70 }" />
        <scope name="marshal_load" ilk="function" signature="marshal_load(x)" doc="Provides marshalling support for use by the Marshal library. Accepting a Hash of keys and values which will be used to populate the internal table &#xA; require &apos;ostruct&apos;&#xA;&#xA;event = OpenStruct.new&#xA;hash = { &apos;time&apos; =&gt; Time.now, &apos;title&apos; =&gt; &apos;Birthday Party&apos; }&#xA;event.marshal_load(hash)&#xA;event.title # =&gt; &apos;Birthday Party&apos;" />
        <scope name="new_ostruct_member" ilk="function" signature="new_ostruct_member(name)" doc="new_ostruct_member is used internally to defined properties on the OpenStruct. It does this by using the metaprogramming function define_method for both the getter method and the setter method." />
        <scope name="to_s" ilk="function" signature="to_s()" />
      </scope>
    </scope>
    <scope name="pathname" ilk="blob" lang="Ruby">
      <scope name="Pathname" ilk="class" classrefs="Object">
        <scope name="getwd" ilk="function" signature="getwd()" attributes="__classmethod__" doc="See Dir.getwd.  Returns the current working directory as a Pathname." />
        <scope name="glob" ilk="function" signature="glob(p1, p2 = v2)" attributes="__classmethod__" doc="See Dir.glob.  Returns or yields Pathname objects." />
        <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="Create a Pathname object from the given String (or String-like object). If +path+ contains a NUL character (\0), an ArgumentError is raised." />
        <scope name="pwd" ilk="function" signature="pwd()" attributes="__classmethod__" doc="See Dir.getwd.  Returns the current working directory as a Pathname." />
        <scope name="absolute?" ilk="function" signature="absolute?()" doc="Predicate method for testing whether a path is absolute. It returns +true+ if the pathname begins with a slash." />
        <scope name="ascend" ilk="function" signature="ascend()" doc="Iterates over and yields a new Pathname object for each element in the given path in ascending order. &#xA; Pathname.new(&apos;/path/to/some/file.rb&apos;).ascend {|v| p v}&#xA;   #&lt;Pathname:/path/to/some/file.rb&gt;&#xA;   #&lt;Pathname:/path/to/some&gt;&#xA;   #&lt;Pathname:/path/to&gt;&#xA;   #&lt;Pathname:/path&gt;&#xA;   #&lt;Pathname:/&gt;&#xA;Pathname.new(&apos;path/to/some/file.rb&apos;).ascend {|v| p v}&#xA;   #&lt;Pathname:path/to/some/file.rb&gt;&#xA;   #&lt;Pathname:path/to/some&gt;&#xA;   #&lt;Pathname:path/to&gt;&#xA;   #&lt;Pathname:path&gt;&#xA; It doesn&apos;t access actual filesystem. " />
        <scope name="atime" ilk="function" signature="atime()" doc="See File.atime.  Returns last access time." />
        <scope name="basename" ilk="function" signature="basename(p1 = v1)" doc="See File.basename.  Returns the last component of the path." />
        <scope name="binread" ilk="function" signature="binread(p1 = v1, p2 = v2)" doc="See IO.binread.  Returns all the bytes from the file, or the first +N+ if specified." />
        <scope name="blockdev?" ilk="function" signature="blockdev?()" doc="See FileTest.blockdev?." />
        <scope name="chardev?" ilk="function" signature="chardev?()" doc="See FileTest.chardev?." />
        <scope name="children" ilk="function" signature="children(with_directory=true)" doc="Returns the children of the directory (files and subdirectories, not recursive) as an array of Pathname objects.  By default, the returned pathnames will have enough information to access the files.  If you set +with_directory+ to +false+, then the returned pathnames will contain the filename only. &#xA; For example: pn = Pathname(&quot;/usr/lib/ruby/1.8&quot;)&#xA;pn.children&#xA;    # -&gt; [ Pathname:/usr/lib/ruby/1.8/English.rb,&#xA;           Pathname:/usr/lib/ruby/1.8/Env.rb,&#xA;           Pathname:/usr/lib/ruby/1.8/abbrev.rb, ... ]&#xA;pn.children(false)&#xA;    # -&gt; [ Pathname:English.rb, Pathname:Env.rb, Pathname:abbrev.rb, ... ]&#xA; Note that the results never contain the entries . and .. in the directory because they are not children. &#xA; This method has existed since 1.8.1." />
        <scope name="chmod" ilk="function" signature="chmod(p1)" doc="See File.chmod.  Changes permissions." />
        <scope name="chown" ilk="function" signature="chown(p1, p2)" doc="See File.chown.  Change owner and group of file." />
        <scope name="cleanpath" ilk="function" signature="cleanpath(consider_symlink=false)" doc="Returns clean pathname of +self+ with consecutive slashes and useless dots removed.  The filesystem is not accessed. &#xA; If +consider_symlink+ is +true+, then a more conservative algorithm is used to avoid breaking symbolic linkages.  This may retain more .. entries than absolutely necessary, but without accessing the filesystem, this can&apos;t be avoided.  See #realpath." />
        <scope name="ctime" ilk="function" signature="ctime()" doc="See File.ctime.  Returns last (directory entry, not file) change time." />
        <scope name="delete" ilk="function" signature="delete()" doc="Removes a file or directory, using File.unlink or Dir.unlink as necessary." />
        <scope name="descend" ilk="function" signature="descend()" doc="Iterates over and yields a new Pathname object for each element in the given path in descending order. &#xA; Pathname.new(&apos;/path/to/some/file.rb&apos;).descend {|v| p v}&#xA;   #&lt;Pathname:/&gt;&#xA;   #&lt;Pathname:/path&gt;&#xA;   #&lt;Pathname:/path/to&gt;&#xA;   #&lt;Pathname:/path/to/some&gt;&#xA;   #&lt;Pathname:/path/to/some/file.rb&gt;&#xA;Pathname.new(&apos;path/to/some/file.rb&apos;).descend {|v| p v}&#xA;   #&lt;Pathname:path&gt;&#xA;   #&lt;Pathname:path/to&gt;&#xA;   #&lt;Pathname:path/to/some&gt;&#xA;   #&lt;Pathname:path/to/some/file.rb&gt;&#xA; It doesn&apos;t access actual filesystem. " />
        <scope name="directory?" ilk="function" signature="directory?()" doc="See FileTest.directory?." />
        <scope name="dirname" ilk="function" signature="dirname()" doc="See File.dirname.  Returns all but the last component of the path." />
        <scope name="each_child" ilk="function" signature="each_child(with_directory=true, &amp;b)" doc="Iterates over the children of the directory (files and subdirectories, not recursive). It yields Pathname object for each child. By default, the yielded pathnames will have enough information to access the files. If you set +with_directory+ to +false+, then the returned pathnames will contain the filename only. &#xA; Pathname(&quot;/usr/local&quot;).each_child {|f| p f }&#xA;=&gt; #&lt;Pathname:/usr/local/share&gt;&#xA;#   #&lt;Pathname:/usr/local/bin&gt;&#xA;#   #&lt;Pathname:/usr/local/games&gt;&#xA;#   #&lt;Pathname:/usr/local/lib&gt;&#xA;#   #&lt;Pathname:/usr/local/include&gt;&#xA;#   #&lt;Pathname:/usr/local/sbin&gt;&#xA;#   #&lt;Pathname:/usr/local/src&gt;&#xA;#   #&lt;Pathname:/usr/local/man&gt;&#xA;Pathname(&quot;/usr/local&quot;).each_child(false) {|f| p f }&#xA;=&gt; #&lt;Pathname:share&gt;&#xA;#   #&lt;Pathname:bin&gt;" />
        <scope name="each_entry" ilk="function" signature="each_entry()" doc="Iterates over the entries (files and subdirectories) in the directory.  It yields a Pathname object for each entry. &#xA; This method has available since 1.8.1." />
        <scope name="each_filename" ilk="function" signature="each_filename()" doc="Iterates over each component of the path. &#xA; Pathname.new(&quot;/usr/bin/ruby&quot;).each_filename {|filename| ... }&#xA;  # yields &quot;usr&quot;, &quot;bin&quot;, and &quot;ruby&quot;." />
        <scope name="each_line" ilk="function" signature="each_line(p1 = v1, p2 = v2, p3 = v3)" doc="#each_line iterates over the line in the file.  It yields a String object for each line. &#xA; This method is availabel since 1.8.1." />
        <scope name="entries" ilk="function" signature="entries()" doc="Return the entries (files and subdirectories) in the directory, each as a Pathname object. &#xA; The result may contain the current directory #&lt;Pathname:.&gt; and the parent directory #&lt;Pathname:..&gt;." />
        <scope name="eql?" ilk="function" signature="eql?(p1)" doc="Compare this pathname with +other+.  The comparison is string-based. Be aware that two different paths (foo.txt and ./foo.txt) can refer to the same file." />
        <scope name="executable?" ilk="function" signature="executable?()" doc="See FileTest.executable?." />
        <scope name="executable_real?" ilk="function" signature="executable_real?()" doc="See FileTest.executable_real?." />
        <scope name="exist?" ilk="function" signature="exist?()" doc="See FileTest.exist?." />
        <scope name="expand_path" ilk="function" signature="expand_path(p1 = v1)" doc="See File.expand_path." />
        <scope name="extname" ilk="function" signature="extname()" doc="See File.extname.  Returns the file&apos;s extension." />
        <scope name="file?" ilk="function" signature="file?()" doc="See FileTest.file?." />
        <scope name="find" ilk="function" signature="find()" doc="Pathname#find is an iterator to traverse a directory tree in a depth first manner.  It yields a Pathname for each file under &quot;this&quot; directory. &#xA; Since it is implemented by find.rb, Find.prune can be used to control the traversal. &#xA; If +self+ is ., yielded pathnames begin with a filename in the current directory, not ./." />
        <scope name="fnmatch" ilk="function" signature="fnmatch(p1, p2 = v2)" doc="See File.fnmatch.  Return +true+ if the receiver matches the given pattern." />
        <scope name="fnmatch?" ilk="function" signature="fnmatch?(p1, p2 = v2)" doc="See File.fnmatch.  Return +true+ if the receiver matches the given pattern." />
        <scope name="freeze" ilk="function" signature="freeze()" />
        <scope name="ftype" ilk="function" signature="ftype()" doc="See File.ftype.  Returns &quot;type&quot; of file (&quot;file&quot;, &quot;directory&quot;, etc)." />
        <scope name="grpowned?" ilk="function" signature="grpowned?()" doc="See FileTest.grpowned?." />
        <scope name="join" ilk="function" signature="join(*args)" doc="Pathname#join joins pathnames. &#xA; path0.join(path1, ..., pathN) is the same as path0 + path1 + ... + pathN." />
        <scope name="lchmod" ilk="function" signature="lchmod(p1)" doc="See File.lchmod." />
        <scope name="lchown" ilk="function" signature="lchown(p1, p2)" doc="See File.lchown." />
        <scope name="lstat" ilk="function" signature="lstat()" doc="See File.lstat." />
        <scope name="make_link" ilk="function" signature="make_link(p1)" doc="See File.link.  Creates a hard link at _pathname_." />
        <scope name="make_symlink" ilk="function" signature="make_symlink(p1)" doc="See File.symlink.  Creates a symbolic link." />
        <scope name="mkdir" ilk="function" signature="mkdir(p1 = v1)" doc="See Dir.mkdir.  Create the referenced directory." />
        <scope name="mkpath" ilk="function" signature="mkpath()" doc="See FileUtils.mkpath.  Creates a full path, including any intermediate directories that don&apos;t yet exist." />
        <scope name="mountpoint?" ilk="function" signature="mountpoint?()" doc="mountpoint? returns +true+ if self points to a mountpoint." />
        <scope name="mtime" ilk="function" signature="mtime()" doc="See File.mtime.  Returns last modification time." />
        <scope name="open" ilk="function" signature="open(p1 = v1, p2 = v2, p3 = v3)" doc="See File.open.  Opens the file for reading or writing." />
        <scope name="opendir" ilk="function" signature="opendir()" doc="See Dir.open." />
        <scope name="owned?" ilk="function" signature="owned?()" doc="See FileTest.owned?." />
        <scope name="parent" ilk="function" signature="parent()" doc="#parent returns the parent directory. &#xA; This is same as self + &apos;..&apos;." />
        <scope name="pipe?" ilk="function" signature="pipe?()" doc="See FileTest.pipe?." />
        <scope name="read" ilk="function" signature="read(p1 = v1, p2 = v2, p3 = v3)" doc="See IO.read.  Returns all data from the file, or the first +N+ bytes if specified." />
        <scope name="readable?" ilk="function" signature="readable?()" doc="See FileTest.readable?." />
        <scope name="readable_real?" ilk="function" signature="readable_real?()" doc="See FileTest.readable_real?." />
        <scope name="readlines" ilk="function" signature="readlines(p1 = v1, p2 = v2, p3 = v3)" doc="See IO.readlines.  Returns all the lines from the file." />
        <scope name="readlink" ilk="function" signature="readlink()" doc="See File.readlink.  Read symbolic link." />
        <scope name="realdirpath" ilk="function" signature="realdirpath(p1 = v1)" doc="Returns the real (absolute) pathname of +self+ in the actual filesystem. The real pathname doesn&apos;t contain symlinks or useless dots. &#xA; The last component of the real pathname can be nonexistent." />
        <scope name="realpath" ilk="function" signature="realpath(p1 = v1)" doc="Returns the real (absolute) pathname of +self+ in the actual filesystem not containing symlinks or useless dots. &#xA; All components of the pathname must exist when this method is called." />
        <scope name="relative?" ilk="function" signature="relative?()" doc="The opposite of #absolute?" />
        <scope name="relative_path_from" ilk="function" signature="relative_path_from(base_directory)" doc="#relative_path_from returns a relative path from the argument to the receiver.  If +self+ is absolute, the argument must be absolute too.  If +self+ is relative, the argument must be relative too. &#xA; #relative_path_from doesn&apos;t access the filesystem.  It assumes no symlinks. &#xA; ArgumentError is raised when it cannot find a relative path. &#xA; This method has existed since 1.8.1." />
        <scope name="rename" ilk="function" signature="rename(p1)" doc="See File.rename.  Rename the file." />
        <scope name="rmdir" ilk="function" signature="rmdir()" doc="See Dir.rmdir.  Remove the referenced directory." />
        <scope name="rmtree" ilk="function" signature="rmtree()" doc="See FileUtils.rm_r.  Deletes a directory and all beneath it." />
        <scope name="root?" ilk="function" signature="root?()" doc="#root? is a predicate for root directories.  I.e. it returns +true+ if the pathname consists of consecutive slashes. &#xA; It doesn&apos;t access actual filesystem.  So it may return +false+ for some pathnames which points to roots such as /usr/..." />
        <scope name="setgid?" ilk="function" signature="setgid?()" doc="See FileTest.setgid?." />
        <scope name="setuid?" ilk="function" signature="setuid?()" doc="See FileTest.setuid?." />
        <scope name="size" ilk="function" signature="size()" doc="See FileTest.size." />
        <scope name="size?" ilk="function" signature="size?()" doc="See FileTest.size?." />
        <scope name="socket?" ilk="function" signature="socket?()" doc="See FileTest.socket?." />
        <scope name="split" ilk="function" signature="split()" doc="See File.split.  Returns the #dirname and the #basename in an Array." />
        <scope name="stat" ilk="function" signature="stat()" doc="See File.stat.  Returns a File::Stat object." />
        <scope name="sticky?" ilk="function" signature="sticky?()" doc="See FileTest.sticky?." />
        <scope name="sub" ilk="function" signature="sub(*args)" doc="Return a pathname which is substituted by String#sub." />
        <scope name="sub_ext" ilk="function" signature="sub_ext(p1)" doc="Return a pathname which the extension of the basename is substituted by repl. &#xA; If self has no extension part, repl is appended." />
        <scope name="symlink?" ilk="function" signature="symlink?()" doc="See FileTest.symlink?." />
        <scope name="sysopen" ilk="function" signature="sysopen(p1 = v1, p2 = v2)" doc="See IO.sysopen." />
        <scope name="taint" ilk="function" signature="taint()" />
        <scope name="to_path" ilk="function" signature="to_path()" doc="Return the path as a String. &#xA; to_path is implemented so Pathname objects are usable with File.open, etc." />
        <scope name="to_s" ilk="function" signature="to_s()" doc="Return the path as a String. &#xA; to_path is implemented so Pathname objects are usable with File.open, etc." />
        <scope name="truncate" ilk="function" signature="truncate(p1)" doc="See File.truncate.  Truncate the file to +length+ bytes." />
        <scope name="unlink" ilk="function" signature="unlink()" doc="Removes a file or directory, using File.unlink or Dir.unlink as necessary." />
        <scope name="untaint" ilk="function" signature="untaint()" />
        <scope name="utime" ilk="function" signature="utime(p1, p2)" doc="See File.utime.  Update the access and modification times." />
        <scope name="world_readable?" ilk="function" signature="world_readable?()" doc="See FileTest.world_readable?." />
        <scope name="world_writable?" ilk="function" signature="world_writable?()" doc="See FileTest.world_writable?." />
        <scope name="writable?" ilk="function" signature="writable?()" doc="See FileTest.writable?." />
        <scope name="writable_real?" ilk="function" signature="writable_real?()" doc="See FileTest.writable_real?." />
        <scope name="zero?" ilk="function" signature="zero?()" doc="See FileTest.zero?." />
        <variable name="SEPARATOR_LIST" attributes="__const__" citdl="Object" />
        <variable name="SEPARATOR_PAT" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="pp" ilk="blob" lang="Ruby">
      <scope name="PP" ilk="class" classrefs="PrettyPrint">
        <import symbol="PPMethods" />
        <scope name="pp" ilk="function" signature="pp(obj, out=$&gt;, width=79)" attributes="__classmethod__" doc="Outputs +obj+ to +out+ in pretty printed format of +width+ columns in width. &#xA; If +out+ is omitted, +$&gt;+ is assumed. If +width+ is omitted, 79 is assumed. &#xA; PP.pp returns +out+." />
        <scope name="singleline_pp" ilk="function" signature="singleline_pp(obj, out=$&gt;)" attributes="__classmethod__" doc="Outputs +obj+ to +out+ like PP.pp but with no indent and newline. &#xA; PP.singleline_pp returns +out+." />
        <scope ilk="function" name="sharing_detection" />
        <scope ilk="function" name="sharing_detection=" />
        <scope name="ObjectMixin" ilk="namespace">
          <scope name="pretty_print" ilk="function" signature="pretty_print(q)" doc="A default pretty printing method for general objects. It calls #pretty_print_instance_variables to list instance variables. &#xA; If +self+ has a customized (redefined) #inspect method, the result of self.inspect is used but it obviously has no line break hints. &#xA; This module provides predefined #pretty_print methods for some of the most commonly used built-in classes for convenience." />
          <scope name="pretty_print_cycle" ilk="function" signature="pretty_print_cycle(q)" doc="A default pretty printing method for general objects that are detected as part of a cycle." />
          <scope name="pretty_print_inspect" ilk="function" signature="pretty_print_inspect()" doc="Is #inspect implementation using #pretty_print. If you implement #pretty_print, it can be used as follows. &#xA; alias inspect pretty_print_inspect&#xA; However, doing this requires that every class that #inspect is called on implement #pretty_print, or a RuntimeError will be raised." />
          <scope name="pretty_print_instance_variables" ilk="function" signature="pretty_print_instance_variables()" doc="Returns a sorted array of instance variable names. &#xA; This method should return an array of names of instance variables as symbols or strings as: +[:@a, :@b]+." />
        </scope>
        <scope name="PPMethods" ilk="namespace">
          <scope name="check_inspect_key" ilk="function" signature="check_inspect_key(id)" />
          <scope name="comma_breakable" ilk="function" signature="comma_breakable()" doc="A convenience method which is same as follows: &#xA; text &apos;,&apos;&#xA;breakable" />
          <scope name="guard_inspect_key" ilk="function" signature="guard_inspect_key()" />
          <scope name="object_address_group" ilk="function" signature="object_address_group(obj, &amp;block)" />
          <scope name="object_group" ilk="function" signature="object_group(obj)" doc="A convenience method which is same as follows: &#xA; group(1, &apos;#&lt;&apos; + obj.class.name, &apos;&gt;&apos;) { ... }" />
          <scope name="pop_inspect_key" ilk="function" signature="pop_inspect_key(id)" />
          <scope name="pp" ilk="function" signature="pp(obj)" doc="Adds +obj+ to the pretty printing buffer using Object#pretty_print or Object#pretty_print_cycle. &#xA; Object#pretty_print_cycle is used when +obj+ is already printed, a.k.a the object reference chain has a cycle." />
          <scope name="pp_hash" ilk="function" signature="pp_hash(obj)" />
          <scope name="pp_object" ilk="function" signature="pp_object(obj)" />
          <scope name="push_inspect_key" ilk="function" signature="push_inspect_key(id)" />
          <scope name="seplist" ilk="function" signature="seplist(list, sep=nil, iter_method=:each)" doc="Adds a separated list. The list is separated by comma with breakable space, by default. &#xA; #seplist iterates the +list+ using +iter_method+. It yields each object to the block given for #seplist. The procedure +separator_proc+ is called between each yields. &#xA; If the iteration is zero times, +separator_proc+ is not called at all. &#xA; If +separator_proc+ is nil or not given, +lambda { comma_breakable }+ is used. If +iter_method+ is not given, :each is used. &#xA; For example, following 3 code fragments has similar effect. &#xA; q.seplist([1,2,3]) {|v| xxx v }&#xA;&#xA;q.seplist([1,2,3], lambda { q.comma_breakable }, :each) {|v| xxx v }&#xA;&#xA;xxx 1&#xA;q.comma_breakable&#xA;xxx 2&#xA;q.comma_breakable&#xA;xxx 3" />
        </scope>
        <scope name="SingleLine" ilk="class" classrefs="PrettyPrint::SingleLine">
          <import symbol="PPMethods" />
        </scope>
      </scope>
    </scope>
    <scope name="prettyprint" ilk="blob" lang="Ruby">
      <scope name="PrettyPrint" ilk="class" classrefs="Object">
        <scope name="format" ilk="function" signature="format(output=&apos;&apos;, maxwidth=79, newline=&quot;\n&quot;, genspace=lambda {|n| &apos; &apos; * n})" attributes="__classmethod__" doc="This is a convenience method which is same as follows: &#xA; begin&#xA;  q = PrettyPrint.new(output, maxwidth, newline, &amp;genspace)&#xA;  ...&#xA;  q.flush&#xA;  output&#xA;end" />
        <scope name="new" ilk="function" signature="new(output=&apos;&apos;, maxwidth=79, newline=&quot;\n&quot;, &amp;genspace)" attributes="__classmethod__ __ctor__" doc="Creates a buffer for pretty printing. &#xA; +output+ is an output target. If it is not specified, &apos;&apos; is assumed. It should have a &lt;&lt; method which accepts the first argument +obj+ of PrettyPrint#text, the first argument +sep+ of PrettyPrint#breakable, the first argument +newline+ of PrettyPrint.new, and the result of a given block for PrettyPrint.new. &#xA; +maxwidth+ specifies maximum line length. If it is not specified, 79 is assumed. However actual outputs may overflow +maxwidth+ if long non-breakable texts are provided. &#xA; +newline+ is used for line breaks. &quot;\n&quot; is used if it is not specified. &#xA; The block is used to generate spaces. {|width| &apos; &apos; * width} is used if it is not given." />
        <scope name="singleline_format" ilk="function" signature="singleline_format(output=&apos;&apos;, maxwidth=nil, newline=nil, genspace=nil)" attributes="__classmethod__" doc="This is similar to PrettyPrint::format but the result has no breaks. &#xA; +maxwidth+, +newline+ and +genspace+ are ignored. &#xA; The invocation of +breakable+ in the block doesn&apos;t break a line and is treated as just an invocation of +text+." />
        <scope name="break_outmost_groups" ilk="function" signature="break_outmost_groups()" doc="Breaks the buffer into lines that are shorter than #maxwidth" />
        <scope name="breakable" ilk="function" signature="breakable(sep=&apos; &apos;, width=sep.length)" doc="This says &quot;you can break a line here if necessary&quot;, and a +width+\-column text +sep+ is inserted if a line is not broken at the point. &#xA; If +sep+ is not specified, &quot; &quot; is used. &#xA; If +width+ is not specified, +sep.length+ is used. You will have to specify this when +sep+ is a multibyte character, for example." />
        <scope name="current_group" ilk="function" signature="current_group()" doc="Returns the group most recently added to the stack." />
        <scope name="fill_breakable" ilk="function" signature="fill_breakable(sep=&apos; &apos;, width=sep.length)" doc="This is similar to #breakable except the decision to break or not is determined individually. &#xA; Two #fill_breakable under a group may cause 4 results: (break,break), (break,non-break), (non-break,break), (non-break,non-break). This is different to #breakable because two #breakable under a group may cause 2 results: (break,break), (non-break,non-break). &#xA; The text sep+ is inserted if a line is not broken at this point. &#xA; If +sep+ is not specified, &quot; &quot; is used. &#xA; If +width+ is not specified, +sep.length+ is used. You will have to specify this when +sep+ is a multibyte character, for example." />
        <scope name="first?" ilk="function" signature="first?()" doc="first? is a predicate to test the call is a first call to first? with current group. &#xA; It is useful to format comma separated values as: &#xA; q.group(1, &apos;[&apos;, &apos;]&apos;) {&#xA;  xxx.each {|yyy|&#xA;    unless q.first?&#xA;      q.text &apos;,&apos;&#xA;      q.breakable&#xA;    end&#xA;    ... pretty printing yyy ...&#xA;  }&#xA;}&#xA; first? is obsoleted in 1.8.2." />
        <scope name="flush" ilk="function" signature="flush()" doc="outputs buffered data." />
        <scope name="group" ilk="function" signature="group(indent=0, open_obj=&apos;&apos;, close_obj=&apos;&apos;, open_width=open_obj.length, close_width=close_obj.length)" doc="Groups line break hints added in the block. The line break hints are all to be used or not. &#xA; If +indent+ is specified, the method call is regarded as nested by nest(indent) { ... }. &#xA; If +open_obj+ is specified, text open_obj, open_width is called before grouping. If +close_obj+ is specified, text close_obj, close_width is called after grouping." />
        <scope name="group_sub" ilk="function" signature="group_sub()" />
        <scope name="nest" ilk="function" signature="nest(indent)" doc="Increases left margin after newline with +indent+ for line breaks added in the block." />
        <scope name="text" ilk="function" signature="text(obj, width=obj.length)" doc="This adds +obj+ as a text of +width+ columns in width. &#xA; If +width+ is not specified, obj.length is used." />
        <scope ilk="function" name="genspace" />
        <scope ilk="function" name="group_queue" />
        <scope ilk="function" name="indent" />
        <scope ilk="function" name="maxwidth" />
        <scope ilk="function" name="newline" />
        <scope ilk="function" name="output" />
        <scope name="Breakable" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(sep, width, q)" attributes="__classmethod__ __ctor__" />
          <scope name="output" ilk="function" signature="output(out, output_width)" />
          <scope ilk="function" name="indent" />
          <scope ilk="function" name="obj" />
          <scope ilk="function" name="width" />
        </scope>
        <scope name="Group" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(depth)" attributes="__classmethod__ __ctor__" />
          <scope name="break" ilk="function" signature="break()" />
          <scope name="break?" ilk="function" signature="break?()" />
          <scope name="first?" ilk="function" signature="first?()" />
          <scope ilk="function" name="breakables" />
          <scope ilk="function" name="depth" />
        </scope>
        <scope name="GroupQueue" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*groups)" attributes="__classmethod__ __ctor__" />
          <scope name="delete" ilk="function" signature="delete(group)" />
          <scope name="deq" ilk="function" signature="deq()" />
          <scope name="enq" ilk="function" signature="enq(group)" />
        </scope>
        <scope name="SingleLine" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(output, maxwidth=nil, newline=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="breakable" ilk="function" signature="breakable(sep=&apos; &apos;, width=nil)" />
          <scope name="first?" ilk="function" signature="first?()" />
          <scope name="flush" ilk="function" signature="flush()" />
          <scope name="group" ilk="function" signature="group(indent=nil, open_obj=&apos;&apos;, close_obj=&apos;&apos;, open_width=nil, close_width=nil)" />
          <scope name="nest" ilk="function" signature="nest(indent)" />
          <scope name="text" ilk="function" signature="text(obj, width=nil)" />
        </scope>
        <scope name="Text" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="add" ilk="function" signature="add(obj, width)" />
          <scope name="output" ilk="function" signature="output(out, output_width)" />
          <scope ilk="function" name="width" />
        </scope>
      </scope>
    </scope>
    <scope name="prime" ilk="blob" lang="Ruby">
      <scope name="Prime" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="instance" ilk="function" signature="instance()" attributes="__classmethod__" doc="Returns the default instance of Prime." />
        <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="obsolete. Use +Prime+::+instance+ or class methods of +Prime+." />
        <scope name="each" ilk="function" signature="each(ubound = nil, generator = EratosthenesGenerator.new, &amp;block)" doc="Iterates the given block over all prime numbers. &#xA; Parameters &#xA; Optional. An arbitrary positive number. The upper bound of enumeration. The method enumerates prime numbers infinitely if +ubound+ is nil.&#xA;Optional. An implementation of pseudo-prime generator. &#xA; Return value &#xA; An evaluated value of the given block at the last time. Or an enumerator which is compatible to an +Enumerator+ if no block given. &#xA; Description &#xA; Calls +block+ once for each prime number, passing the prime as a parameter. &#xA; Upper bound of prime numbers. The iterator stops after yields all prime numbers p &lt;= +ubound+. &#xA; Note &#xA; +Prime+.+new+ returns a object extended by +Prime+::+OldCompatibility+ in order to compatibility to Ruby 1.8, and +Prime+#each is overwritten by +Prime+::+OldCompatibility+#+each+. &#xA; +Prime+.+new+ is now obsolete. Use +Prime+.+instance+.+each+ or simply +Prime+.+each+." />
        <scope name="int_from_prime_division" ilk="function" signature="int_from_prime_division(pd)" doc="Re-composes a prime factorization and returns the product. &#xA; Parameters Array of pairs of integers. The each internal pair consists of a prime number -- a prime factor -- and a natural number -- an exponent. &#xA; Example For [[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]], it returns: &#xA; p_1**e_1 * p_2**e_2 * .... * p_n**e_n.&#xA;&#xA;Prime.int_from_prime_division([[2,2], [3,1]])  =&gt; 12" />
        <scope name="prime?" ilk="function" signature="prime?(value, generator = Prime::Generator23.new)" doc="Returns true if +value+ is prime, false for a composite. &#xA; Parameters &#xA; an arbitrary integer to be checked.&#xA;optional. A pseudo-prime generator." />
        <scope name="prime_division" ilk="function" signature="prime_division(value, generator= Prime::Generator23.new)" doc="Returns the factorization of +value+. &#xA; Parameters An arbitrary integer.&#xA;Optional. A pseudo-prime generator. +generator+.succ must return the next pseudo-prime number in the ascendent order. It must generate all prime numbers, but may generate non prime numbers. &#xA; Exceptions when +value+ is zero. &#xA; Example For an arbitrary integer: &#xA; n = p_1**e_1 * p_2**e_2 * .... * p_n**e_n,&#xA; prime_division(n) returns: &#xA; [[p_1, e_1], [p_2, e_2], ...., [p_n, e_n]].&#xA;&#xA;Prime.prime_division(12) =&gt; [[2,2], [3,1]]" />
        <scope name="EratosthenesGenerator" ilk="class" classrefs="Prime::PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
        <scope name="EratosthenesSieve" ilk="class" classrefs="Object">
          <import symbol="Singleton" />
          <scope name="next_to" ilk="function" signature="next_to(n)" doc="returns the least odd prime number which is greater than +n+." />
          <variable name="BITS_PER_ENTRY" attributes="__const__" citdl="Object" />
          <variable name="NUMS_PER_ENTRY" attributes="__const__" citdl="Object" />
          <variable name="ENTRIES_PER_TABLE" attributes="__const__" citdl="Object" />
          <variable name="NUMS_PER_TABLE" attributes="__const__" citdl="Object" />
          <variable name="FILLED_ENTRY" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Generator23" ilk="class" classrefs="Prime::PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
        <scope name="OldCompatibility" ilk="namespace">
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Overwrites Prime#each. &#xA; Iterates the given block over all prime numbers. Note that enumeration starts from the current position of internal pointer, not rewound." />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="succ" ilk="function" signature="succ()" doc="Returns the next prime number and forwards internal pointer." />
        </scope>
        <scope name="PseudoPrimeGenerator" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(ubound = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Iterates the given block for each prime numbers." />
          <scope name="next" ilk="function" signature="next()" doc="alias of +succ+." />
          <scope name="rewind" ilk="function" signature="rewind()" doc="Rewinds the internal position for enumeration. &#xA; See +Enumerator+#rewind." />
          <scope name="succ" ilk="function" signature="succ()" doc="returns the next pseudo-prime number, and move the internal position forward. &#xA; +PseudoPrimeGenerator+#succ raises +NotImplementedError+." />
          <scope name="upper_bound" ilk="function" signature="upper_bound()" />
          <scope name="upper_bound=" ilk="function" signature="upper_bound=(ubound)" />
          <scope name="with_object" ilk="function" signature="with_object(obj)" doc="see +Enumerator+#with_object." />
        </scope>
        <scope name="TrialDivision" ilk="class" classrefs="Object">
          <import symbol="Singleton" />
          <scope name="cache" ilk="function" signature="cache()" doc="Returns the cached prime numbers." />
          <scope name="primes" ilk="function" signature="primes()" />
          <scope name="primes_so_far" ilk="function" signature="primes_so_far()" />
        </scope>
        <scope name="TrialDivisionGenerator" ilk="class" classrefs="Prime::PseudoPrimeGenerator">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="next" ilk="function" signature="next()" />
          <scope name="rewind" ilk="function" signature="rewind()" />
          <scope name="succ" ilk="function" signature="succ()" />
        </scope>
      </scope>
    </scope>
    <scope name="pstore" ilk="blob" lang="Ruby">
      <scope name="PStore" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(file, thread_safe = false)" attributes="__classmethod__ __ctor__" doc="To construct a PStore object, pass in the _file_ path where you would like the data to be stored. &#xA; PStore objects are always reentrant. But if _thread_safe_ is set to true, then it will become thread-safe at the cost of a minor performance hit." />
        <scope name="abort" ilk="function" signature="abort()" doc="Ends the current PStore#transaction, discarding any changes to the data store. &#xA; Example: &#xA; require &quot;pstore&quot;&#xA;&#xA;store = PStore.new(&quot;data_file.pstore&quot;)&#xA;store.transaction do  # begin transaction&#xA;  store[:one] = 1     # this change is not applied, see below...&#xA;  store[:two] = 2     # this change is not applied, see below...&#xA;&#xA;  store.abort         # end transaction here, discard all changes&#xA;&#xA;  store[:three] = 3   # this change is never reached&#xA;end&#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="commit" ilk="function" signature="commit()" doc="Ends the current PStore#transaction, committing any changes to the data store immediately. &#xA; Example: &#xA; require &quot;pstore&quot;&#xA;&#xA;store = PStore.new(&quot;data_file.pstore&quot;)&#xA;store.transaction do  # begin transaction&#xA;  # load some data into the store...&#xA;  store[:one] = 1&#xA;  store[:two] = 2&#xA;&#xA;  store.commit        # end transaction here, committing changes&#xA;&#xA;  store[:three] = 3   # this change is never reached&#xA;end&#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="delete" ilk="function" signature="delete(name)" doc="Removes an object hierarchy from the data store, by _name_. &#xA; *WARNING*:  This method is only valid in a PStore#transaction and it cannot be read-only.  It will raise PStore::Error if called at any other time." />
        <scope name="fetch" ilk="function" signature="fetch(name, default=PStore::Error)" doc="This method is just like PStore#[], save that you may also provide a _default_ value for the object.  In the event the specified _name_ is not found in the data store, your _default_ will be returned instead.  If you do not specify a default, PStore::Error will be raised if the object is not found. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="path" ilk="function" signature="path()" doc="Returns the path to the data store file." />
        <scope name="root?" ilk="function" signature="root?(name)" doc="Returns true if the supplied _name_ is currently in the data store. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="roots" ilk="function" signature="roots()" doc="Returns the names of all object hierarchies currently in the store. &#xA; *WARNING*:  This method is only valid in a PStore#transaction.  It will raise PStore::Error if called at any other time." />
        <scope name="transaction" ilk="function" signature="transaction(read_only = false)" doc="Opens a new transaction for the data store.  Code executed inside a block passed to this method may read and write data to and from the data store file. &#xA; At the end of the block, changes are committed to the data store automatically.  You may exit the transaction early with a call to either PStore#commit or PStore#abort.  See those methods for details about how changes are handled.  Raising an uncaught Exception in the block is equivalent to calling PStore#abort. &#xA; If _read_only_ is set to +true+, you will only be allowed to read from the data store during the transaction and any attempts to change the data will raise a PStore::Error. &#xA; Note that PStore does not support nested transactions." />
        <scope ilk="function" name="ultra_safe" />
        <scope ilk="function" name="ultra_safe=" />
        <variable name="RDWR_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="RD_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="WR_ACCESS" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_STRING" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_MARSHAL_DATA" attributes="__const__" citdl="Object" />
        <variable name="EMPTY_MARSHAL_CHECKSUM" attributes="__const__" citdl="Object" />
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="pty" ilk="blob" lang="Ruby">
      <scope name="PTY" ilk="namespace">
        <scope name="check" ilk="function" signature="check(p1, p2 = v2)" attributes="__classmethod__" doc="Checks the status of the child process specified by +pid+. Returns +nil+ if the process is still alive.  If the process is not alive, will return a Process::Status or raise a PTY::ChildExited (if +raise+ was true). &#xA; The process id of the process to check&#xA;If true and the process identified by +pid+ is no longer alive a PTY::ChildExited is raised. &#xA; Returns nil or a Process::Status when +raise+ is false." />
        <scope name="getpty" ilk="function" signature="getpty(*args)" attributes="__classmethod__" doc="Spawns the specified command on a newly allocated pty. &#xA; The command&apos;s controlling tty is set to the slave device of the pty and its standard input/output/error is redirected to the slave device. &#xA; The full command line to run&#xA;The command to run, as a String.&#xA;Zero or more arguments, as Strings, representing the arguments to +command+ &#xA; In the non-block form this returns an array of size three, [r, w, pid].  In the block form the block will be called with these as arguments, |r,w,pid|: &#xA; An IO that can be read from that contains the command&apos;s standard output and standard error&#xA;An IO that can be written to that is the command&apos;s standard input&#xA;The process identifier for the command." />
        <scope name="open" ilk="function" signature="open()" attributes="__classmethod__" doc="Allocates a pty (pseudo-terminal). &#xA; In the non-block form, returns a two element array, [master_io, slave_file]. &#xA; In the block form, yields two arguments master_io, slave_file and the value of the block is returned from +open+. &#xA; The IO and File are both closed after the block completes if they haven&apos;t been already closed. &#xA; The arguments in both forms are: &#xA; the master of the pty, as an IO.&#xA;the slave of the pty, as a File.  The path to the terminal device is available via slave_file.path &#xA; Example &#xA; PTY.open {|m, s|&#xA;  p m      =&gt; #&lt;IO:masterpty:/dev/pts/1&gt;&#xA;  p s      =&gt; #&lt;File:/dev/pts/1&gt;&#xA;  p s.path =&gt; &quot;/dev/pts/1&quot;&#xA;}" />
        <scope name="spawn" ilk="function" signature="spawn(*args)" attributes="__classmethod__" doc="Spawns the specified command on a newly allocated pty. &#xA; The command&apos;s controlling tty is set to the slave device of the pty and its standard input/output/error is redirected to the slave device. &#xA; The full command line to run&#xA;The command to run, as a String.&#xA;Zero or more arguments, as Strings, representing the arguments to +command+ &#xA; In the non-block form this returns an array of size three, [r, w, pid].  In the block form the block will be called with these as arguments, |r,w,pid|: &#xA; An IO that can be read from that contains the command&apos;s standard output and standard error&#xA;An IO that can be written to that is the command&apos;s standard input&#xA;The process identifier for the command." />
        <scope name="ChildExited" ilk="class" classrefs="RuntimeError">
          <scope name="status" ilk="function" signature="status()" doc="Returns the exit status of the child for which PTY#check raised this exception" />
        </scope>
      </scope>
    </scope>
    <scope name="racc/parser" ilk="blob" lang="Ruby">
      <scope name="Racc" ilk="namespace">
        <scope name="ParseError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="racc_runtime_type" ilk="function" signature="racc_runtime_type()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/alt_system" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="AltSystem" ilk="namespace">
          <scope name="define_module_function" ilk="function" signature="define_module_function(name, &amp;block)" attributes="__classmethod__" />
          <scope name="backticks" ilk="function" signature="backticks(cmd)" />
          <scope name="find_runnable" ilk="function" signature="find_runnable(file)" />
          <scope name="repair_command" ilk="function" signature="repair_command(cmd)" />
          <scope name="system" ilk="function" signature="system(cmd, *args)" />
          <variable name="WINDOWS" attributes="__const__" citdl="Object" />
          <variable name="RUNNABLE_EXTS" attributes="__const__" citdl="Object" />
          <variable name="RUNNABLE_PATTERN" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/application" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="Application" ilk="class" classrefs="Object">
          <import symbol="TaskManager" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Initialize a Rake::Application object." />
          <scope name="add_import" ilk="function" signature="add_import(fn)" doc="Add a file to the list of files to be imported." />
          <scope name="add_loader" ilk="function" signature="add_loader(ext, loader)" doc="Add a loader to handle imported files ending in the extension +ext+." />
          <scope name="collect_tasks" ilk="function" signature="collect_tasks()" doc="Collect the list of tasks on the command line.  If no tasks are given, return a list containing only the default task. Environmental assignments are processed at this time as well." />
          <scope name="const_warning" ilk="function" signature="const_warning(const_name)" doc="Warn about deprecated use of top level constant names." />
          <scope name="deprecate" ilk="function" signature="deprecate(old_usage, new_usage, call_site)" doc="Warn about deprecated usage. &#xA; Example: Rake.application.deprecate(&quot;import&quot;, &quot;Rake.import&quot;, caller.first)" />
          <scope name="display_error_message" ilk="function" signature="display_error_message(ex)" doc="Display the error message that caused the exception." />
          <scope name="display_prerequisites" ilk="function" signature="display_prerequisites()" doc="Display the tasks and prerequisites" />
          <scope name="display_tasks_and_comments" ilk="function" signature="display_tasks_and_comments()" doc="Display the tasks and comments." />
          <scope name="dynamic_width" ilk="function" signature="dynamic_width()" doc="Calculate the dynamic width of the" />
          <scope name="dynamic_width_stty" ilk="function" signature="dynamic_width_stty()" />
          <scope name="dynamic_width_tput" ilk="function" signature="dynamic_width_tput()" />
          <scope name="find_rakefile_location" ilk="function" signature="find_rakefile_location()" />
          <scope name="handle_options" ilk="function" signature="handle_options()" doc="Read and handle the command line options." />
          <scope name="have_rakefile" ilk="function" signature="have_rakefile()" doc="True if one of the files in RAKEFILES is in the current directory. If a match is found, it is copied into @rakefile." />
          <scope name="init" ilk="function" signature="init(app_name=&apos;rake&apos;)" doc="Initialize the command line parameters and app name." />
          <scope name="invoke_task" ilk="function" signature="invoke_task(task_string)" doc="private ----------------------------------------------------------------" />
          <scope name="load_imports" ilk="function" signature="load_imports()" doc="Load the pending list of imported files." />
          <scope name="load_rakefile" ilk="function" signature="load_rakefile()" doc="Find the rakefile and then load it and any pending imports." />
          <scope name="options" ilk="function" signature="options()" doc="Application options from the command line" />
          <scope name="parse_task_string" ilk="function" signature="parse_task_string(string)" />
          <scope name="print_rakefile_directory" ilk="function" signature="print_rakefile_directory(location)" />
          <scope name="rake_require" ilk="function" signature="rake_require(file_name, paths=$LOAD_PATH, loaded=$&quot;)" doc="Similar to the regular Ruby +require+ command, but will check for *.rake files in addition to *.rb files." />
          <scope name="rakefile_location" ilk="function" signature="rakefile_location(backtrace = caller)" />
          <scope name="run" ilk="function" signature="run()" doc="Run the Rake application.  The run method performs the following three steps: &#xA; Initialize the command line options (+init+).&#xA;Define the tasks (+load_rakefile+).&#xA;Run the top level tasks (+run_tasks+). &#xA; If you wish to build a custom rake command, you should call +init+ on your application.  Then define any tasks.  Finally, call +top_level+ to run your top level tasks." />
          <scope name="standard_exception_handling" ilk="function" signature="standard_exception_handling()" doc="Provide standard exception handling for the given block." />
          <scope name="standard_rake_options" ilk="function" signature="standard_rake_options()" doc="A list of all the standard options used in rake, suitable for passing to OptionParser." />
          <scope name="system_dir" ilk="function" signature="system_dir()" doc="The directory path containing the system wide rakefiles." />
          <scope name="terminal_width" ilk="function" signature="terminal_width()" />
          <scope name="top_level" ilk="function" signature="top_level()" doc="Run the top level tasks of a Rake application." />
          <scope name="truncate" ilk="function" signature="truncate(string, width)" />
          <scope name="truncate_output?" ilk="function" signature="truncate_output?()" doc="We will truncate output if we are outputting to a TTY or if we&apos;ve been given an explicit column width to honor" />
          <scope name="tty_output=" ilk="function" signature="tty_output=( tty_output_state )" doc="Override the detected TTY output state (mostly for testing)" />
          <scope name="tty_output?" ilk="function" signature="tty_output?()" doc="True if we are outputting to TTY, false otherwise" />
          <scope name="unix?" ilk="function" signature="unix?()" />
          <scope name="windows?" ilk="function" signature="windows?()" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="original_dir" />
          <scope ilk="function" name="rakefile" />
          <scope ilk="function" name="terminal_columns" />
          <scope ilk="function" name="terminal_columns=" />
          <scope ilk="function" name="top_level_tasks" />
          <variable name="DEFAULT_RAKEFILES" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/cloneable" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="Cloneable" ilk="namespace">
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="dup" ilk="function" signature="dup()" doc="Clone an object by making a new object and setting all the instance variables to the same values." />
        </scope>
      </scope>
    </scope>
    <scope name="rake/contrib/compositepublisher" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="CompositePublisher" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="add" ilk="function" signature="add(pub)" doc="Add a publisher to the composite." />
          <scope name="upload" ilk="function" signature="upload()" doc="Upload all the individual publishers." />
        </scope>
      </scope>
    </scope>
    <scope name="rake/contrib/ftptools" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="FtpFile" ilk="class" classrefs="Object">
          <scope name="date" ilk="function" signature="date()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(path, entry)" attributes="__classmethod__ __ctor__" />
          <scope name="time" ilk="function" signature="time()" attributes="__classmethod__" />
          <scope name="directory?" ilk="function" signature="directory?()" />
          <scope name="mode" ilk="function" signature="mode()" />
          <scope name="path" ilk="function" signature="path()" />
          <scope name="symlink?" ilk="function" signature="symlink?()" />
          <scope ilk="function" name="group" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="owner" />
          <scope ilk="function" name="size" />
          <scope ilk="function" name="time" />
        </scope>
        <scope name="FtpUploader" ilk="class" classrefs="Object">
          <scope name="connect" ilk="function" signature="connect(path, host, account, password)" attributes="__classmethod__" doc="Create an uploader and pass it to the given block as +up+. When the block is complete, close the uploader." />
          <scope name="new" ilk="function" signature="new(path, host, account, password)" attributes="__classmethod__ __ctor__" doc="Create an FTP uploader targeting the directory +path+ on +host+ using the given account and password.  +path+ will be the root path of the uploader." />
          <scope name="close" ilk="function" signature="close()" doc="Close the uploader." />
          <scope name="makedirs" ilk="function" signature="makedirs(path)" doc="Create the directory +path+ in the uploader root path." />
          <scope name="upload_files" ilk="function" signature="upload_files(wildcard)" doc="Upload all files matching +wildcard+ to the uploader&apos;s root path." />
          <scope ilk="function" name="verbose" />
          <scope ilk="function" name="verbose=" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/contrib/publisher" ilk="blob" lang="Ruby">
      <scope name="CompositePublisher" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        <scope name="add" ilk="function" signature="add(pub)" doc="Add a publisher to the composite." />
        <scope name="upload" ilk="function" signature="upload()" doc="Upload all the individual publishers." />
      </scope>
      <scope name="SshDirPublisher" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(host, remote_dir, local_dir)" attributes="__classmethod__ __ctor__" />
        <scope name="upload" ilk="function" signature="upload()" />
      </scope>
      <scope name="SshFilePublisher" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(host, remote_dir, local_dir, *files)" attributes="__classmethod__ __ctor__" doc="Create a publisher using the give host information." />
        <scope name="upload" ilk="function" signature="upload()" doc="Upload the local directory to the remote directory." />
      </scope>
      <scope name="SshFreshDirPublisher" ilk="class" classrefs="SshDirPublisher">
        <scope name="upload" ilk="function" signature="upload()" />
      </scope>
    </scope>
    <scope name="rake/contrib/sshpublisher" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="SshDirPublisher" ilk="class" classrefs="Object">
          <import symbol="Rake::DSL" />
          <scope name="new" ilk="function" signature="new(host, remote_dir, local_dir)" attributes="__classmethod__ __ctor__" />
          <scope name="upload" ilk="function" signature="upload()" />
        </scope>
        <scope name="SshFilePublisher" ilk="class" classrefs="Object">
          <import symbol="Rake::DSL" />
          <scope name="new" ilk="function" signature="new(host, remote_dir, local_dir, *files)" attributes="__classmethod__ __ctor__" doc="Create a publisher using the give host information." />
          <scope name="upload" ilk="function" signature="upload()" doc="Upload the local directory to the remote directory." />
        </scope>
        <scope name="SshFreshDirPublisher" ilk="class" classrefs="Rake::SshDirPublisher">
          <scope name="upload" ilk="function" signature="upload()" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/contrib/sys" ilk="blob" lang="Ruby">
      <scope name="Sys" ilk="namespace">
        <scope name="copy" ilk="function" signature="copy(file_name, dest_file)" doc="Copy a single file from +file_name+ to +dest_file+." />
        <scope name="copy_files" ilk="function" signature="copy_files(wildcard, dest_dir)" doc="Copy all files matching +wildcard+ into the directory +dest_dir+." />
        <scope name="delete" ilk="function" signature="delete(*wildcards)" doc="Remove all files matching +wildcard+.  If a matching file is a directory, it must be empty to be removed.  used +delete_all+ to recursively delete directories." />
        <scope name="delete_all" ilk="function" signature="delete_all(*wildcards)" doc="Recursively delete all files and directories matching +wildcard+." />
        <scope name="for_files" ilk="function" signature="for_files(*wildcards)" doc="Perform a block with each file matching a set of wildcards." />
        <scope name="indir" ilk="function" signature="indir(dir)" doc="Make +dir+ the current working directory for the duration of executing the given block." />
        <scope name="install" ilk="function" signature="install(wildcard, dest_dir, mode)" doc="Install all the files matching +wildcard+ into the +dest_dir+ directory.  The permission mode is set to +mode+." />
        <scope name="link" ilk="function" signature="link(file_name, dest_file)" doc="Link +file_name+ to +dest_file+." />
        <scope name="link_files" ilk="function" signature="link_files(wildcard, dest_dir)" doc="Link all files matching +wildcard+ into the directory +dest_dir+." />
        <scope name="log" ilk="function" signature="log(msg)" doc="Write a message to standard error if $verbose is enabled." />
        <scope name="makedirs" ilk="function" signature="makedirs(*dirs)" doc="Make the directories given in +dirs+." />
        <scope name="quiet" ilk="function" signature="quiet(&amp;block)" doc="Perform a block with $verbose disabled." />
        <scope name="ruby" ilk="function" signature="ruby(*args)" doc="Run a Ruby interpreter with the given arguments." />
        <scope name="run" ilk="function" signature="run(cmd)" doc="Run the system command +cmd+." />
        <scope name="split_all" ilk="function" signature="split_all(path)" doc="Split a file path into individual directory names. &#xA; For example: split_all(&quot;a/b/c&quot;) =&gt;  [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;]" />
        <scope name="symlink" ilk="function" signature="symlink(file_name, dest_file)" doc="Symlink +file_name+ to +dest_file+." />
        <scope name="symlink_files" ilk="function" signature="symlink_files(wildcard, dest_dir)" doc="Symlink all files matching +wildcard+ into the directory +dest_dir+." />
        <scope name="verbose" ilk="function" signature="verbose(&amp;block)" doc="Perform a block with $verbose enabled." />
        <variable name="RUBY" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="rake/default_loader" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="DefaultLoader" ilk="class" classrefs="Object">
          <scope name="load" ilk="function" signature="load(fn)" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/dsl_definition" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="DSL" ilk="namespace">
          <import symbol="FileUtilsExt" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/early_time" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="EarlyTime" ilk="class" classrefs="Object">
          <import symbol="Comparable" />
          <import symbol="Singleton" />
          <scope name="to_s" ilk="function" signature="to_s()" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/file_creation_task" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="FileCreationTask" ilk="class" classrefs="FileTask">
        </scope>
      </scope>
    </scope>
    <scope name="rake/file_list" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <import symbol="Test::Unit::Assertions" />
        <scope name="application" ilk="function" signature="application()" attributes="__classmethod__" doc="Current Rake Application" />
        <scope name="application=" ilk="function" signature="application=(app)" attributes="__classmethod__" doc="Set the current Rake application object." />
        <scope name="load_rakefile" ilk="function" signature="load_rakefile(path)" attributes="__classmethod__" doc="Load a rakefile." />
        <scope name="original_dir" ilk="function" signature="original_dir()" attributes="__classmethod__" doc="Return the original directory where the Rake application was started." />
        <scope name="run_tests" ilk="function" signature="run_tests(pattern=&apos;test/test*.rb&apos;, log_enabled=false)" />
        <variable name="EMPTY_TASK_ARGS" attributes="__const__" citdl="Object" />
        <variable name="EARLY" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <scope name="FileList" ilk="class" classrefs="Object">
          <import symbol="Cloneable" />
          <scope name="new" ilk="function" signature="new(*patterns)" attributes="__classmethod__ __ctor__" doc="Create a file list from the globbable patterns given.  If you wish to perform multiple includes or excludes at object build time, use the &quot;yield self&quot; pattern. &#xA; Example: file_list = FileList.new(&apos;lib/**/*.rb&apos;, &apos;test/test*.rb&apos;)&#xA;&#xA;pkg_files = FileList.new(&apos;lib/**/*&apos;) do |fl|&#xA;  fl.exclude(/\bCVS\b/)&#xA;end" />
          <scope name="add" ilk="function" signature="add(*filenames)" />
          <scope name="clear_exclude" ilk="function" signature="clear_exclude()" doc="Clear all the exclude patterns so that we exclude nothing." />
          <scope name="egrep" ilk="function" signature="egrep(pattern, *options)" doc="Grep each of the files in the filelist using the given pattern. If a block is given, call the block on each matching line, passing the file name, line number, and the matching line of text.  If no block is given, a standard emacs style file:linenumber:line message will be printed to standard out.  Returns the number of matched items." />
          <scope name="exclude" ilk="function" signature="exclude(*patterns, &amp;block)" doc="Register a list of file name patterns that should be excluded from the list.  Patterns may be regular expressions, glob patterns or regular strings.  In addition, a block given to exclude will remove entries that return true when given to the block. &#xA; Note that glob patterns are expanded against the file system. If a file is explicitly added to a file list, but does not exist in the file system, then an glob pattern in the exclude list will not exclude the file. &#xA; Examples: FileList[&apos;a.c&apos;, &apos;b.c&apos;].exclude(&quot;a.c&quot;) =&gt; [&apos;b.c&apos;]&#xA;FileList[&apos;a.c&apos;, &apos;b.c&apos;].exclude(/^a/)  =&gt; [&apos;b.c&apos;]&#xA; If &quot;a.c&quot; is a file, then ... FileList[&apos;a.c&apos;, &apos;b.c&apos;].exclude(&quot;a.*&quot;) =&gt; [&apos;b.c&apos;]&#xA; If &quot;a.c&quot; is not a file, then ... FileList[&apos;a.c&apos;, &apos;b.c&apos;].exclude(&quot;a.*&quot;) =&gt; [&apos;a.c&apos;, &apos;b.c&apos;]" />
          <scope name="exclude?" ilk="function" signature="exclude?(fn)" doc="Should the given file name be excluded?" />
          <scope name="existing" ilk="function" signature="existing()" doc="Return a new file list that only contains file names from the current file list that exist on the file system." />
          <scope name="existing!" ilk="function" signature="existing!()" doc="Modify the current file list so that it contains only file name that exist on the file system." />
          <scope name="ext" ilk="function" signature="ext(newext=&apos;&apos;)" doc="Return a new FileList with String#ext method applied to each member of the array. &#xA; This method is a shortcut for: &#xA; array.collect { |item| item.ext(newext) }&#xA; +ext+ is a user added method for the Array class." />
          <scope name="gsub" ilk="function" signature="gsub(pat, rep)" doc="Return a new FileList with the results of running +gsub+ against each element of the original list. &#xA; Example: FileList[&apos;lib/test/file&apos;, &apos;x/y&apos;].gsub(/\//, &quot;\\&quot;)&#xA;   =&gt; [&apos;lib\\test\\file&apos;, &apos;x\\y&apos;]" />
          <scope name="gsub!" ilk="function" signature="gsub!(pat, rep)" doc="Same as +gsub+ except that the original file list is modified." />
          <scope name="import" ilk="function" signature="import(array)" />
          <scope name="include" ilk="function" signature="include(*filenames)" doc="Add file names defined by glob patterns to the file list.  If an array is given, add each element of the array. &#xA; Example: file_list.include(&quot;*.java&quot;, &quot;*.cfg&quot;)&#xA;file_list.include %w( math.c lib.h *.o )" />
          <scope name="is_a?" ilk="function" signature="is_a?(klass)" doc="Lie about our class." />
          <scope name="kind_of?" ilk="function" signature="kind_of?(klass)" />
          <scope name="pathmap" ilk="function" signature="pathmap(spec=nil)" doc="Apply the pathmap spec to each of the included file names, returning a new file list with the modified paths.  (See String#pathmap for details.)" />
          <scope name="resolve" ilk="function" signature="resolve()" doc="Resolve all the pending adds now." />
          <scope name="sub" ilk="function" signature="sub(pat, rep)" doc="Return a new FileList with the results of running +sub+ against each element of the original list. &#xA; Example: FileList[&apos;a.c&apos;, &apos;b.c&apos;].sub(/\.c$/, &apos;.o&apos;)  =&gt; [&apos;a.o&apos;, &apos;b.o&apos;]" />
          <scope name="sub!" ilk="function" signature="sub!(pat, rep)" doc="Same as +sub+ except that the original file list is modified." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Return the internal array object." />
          <scope name="to_ary" ilk="function" signature="to_ary()" doc="Return the internal array object." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Convert a FileList to a string by joining all elements with a space." />
          <variable name="ARRAY_METHODS" attributes="__const__" citdl="Object" />
          <variable name="MUST_DEFINE" attributes="__const__" citdl="Object" />
          <variable name="MUST_NOT_DEFINE" attributes="__const__" citdl="Object" />
          <variable name="SPECIAL_RETURN" attributes="__const__" citdl="Object" />
          <variable name="DELEGATING_METHODS" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_IGNORE_PATTERNS" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_IGNORE_PROCS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="RubyForgePublisher" ilk="class" classrefs="SshDirPublisher">
          <scope name="new" ilk="function" signature="new(projname, user)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="proj_id" />
          <scope ilk="function" name="project" />
          <scope ilk="function" name="user" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/file_task" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="FileTask" ilk="class" classrefs="Rake::Task">
          <scope name="needed?" ilk="function" signature="needed?()" doc="Is this file task needed?  Yes if it doesn&apos;t exist, or if its time stamp is out of date." />
          <scope name="timestamp" ilk="function" signature="timestamp()" doc="Time stamp for file task." />
        </scope>
      </scope>
    </scope>
    <scope name="rake/file_utils_ext" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="FileUtilsExt" ilk="namespace">
          <import symbol="FileUtils" />
          <scope name="nowrite" ilk="function" signature="nowrite(value=nil)" doc="Get/set the nowrite flag controlling output from the FileUtils utilities.  If verbose is true, then the utility method is echoed to standard output. &#xA; Examples: nowrite              # return the current value of the&#xA;                     # nowrite flag&#xA;nowrite(v)           # set the nowrite flag to _v_.&#xA;nowrite(v) { code }  # Execute code with the nowrite flag set&#xA;                     # temporarily to _v_. Return to the&#xA;                     # original value when code is done." />
          <scope name="rake_check_options" ilk="function" signature="rake_check_options(options, *optdecl)" doc="Check that the options do not contain options not listed in +optdecl+.  An ArgumentError exception is thrown if non-declared options are found." />
          <scope name="rake_merge_option" ilk="function" signature="rake_merge_option(args, defaults)" doc="Merge the given options with the default values." />
          <scope name="rake_output_message" ilk="function" signature="rake_output_message(message)" doc="Send the message to the default rake output (which is $stderr)." />
          <scope name="verbose" ilk="function" signature="verbose(value=nil)" doc="Get/set the verbose flag controlling output from the FileUtils utilities.  If verbose is true, then the utility method is echoed to standard output. &#xA; Examples: verbose              # return the current value of the&#xA;                     # verbose flag&#xA;verbose(v)           # set the verbose flag to _v_.&#xA;verbose(v) { code }  # Execute code with the verbose flag set&#xA;                     # temporarily to _v_.  Return to the&#xA;                     # original value when code is done." />
          <scope name="when_writing" ilk="function" signature="when_writing(msg=nil)" doc="Use this function to prevent potentially destructive ruby code from running when the :nowrite flag is set. &#xA; Example: &#xA; when_writing(&quot;Building Project&quot;) do&#xA;  project.build&#xA;end&#xA; The following code will build the project under normal conditions. If the nowrite(true) flag is set, then the example will print: &#xA; DRYRUN: Building Project&#xA; instead of actually building the project." />
          <scope ilk="function" name="nowrite_flag" />
          <scope ilk="function" name="nowrite_flag=" />
          <scope ilk="function" name="verbose_flag" />
          <scope ilk="function" name="verbose_flag=" />
          <variable name="DEFAULT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/invocation_chain" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="InvocationChain" ilk="class" classrefs="Object">
          <scope name="append" ilk="function" signature="append(value, chain)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(value, tail)" attributes="__classmethod__ __ctor__" />
          <scope name="append" ilk="function" signature="append(value)" />
          <scope name="member?" ilk="function" signature="member?(obj)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <variable name="EMPTY" attributes="__const__" citdl="Object" />
          <scope name="EmptyInvocationChain" ilk="class" classrefs="Object">
            <scope name="append" ilk="function" signature="append(value)" />
            <scope name="member?" ilk="function" signature="member?(obj)" />
            <scope name="to_s" ilk="function" signature="to_s()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rake/invocation_exception_mixin" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="InvocationExceptionMixin" ilk="namespace">
          <scope name="chain" ilk="function" signature="chain()" doc="Return the invocation chain (list of Rake tasks) that were in effect when this exception was detected by rake.  May be null if no tasks were active." />
          <scope name="chain=" ilk="function" signature="chain=(value)" doc="Set the invocation chain in effect when this exception was detected." />
        </scope>
      </scope>
    </scope>
    <scope name="rake/loaders/makefile" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="MakefileLoader" ilk="class" classrefs="Object">
          <import symbol="Rake::DSL" />
          <scope name="load" ilk="function" signature="load(fn)" doc="Load the makefile dependencies in +fn+." />
          <variable name="SPACE_MARK" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/multi_task" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="MultiTask" ilk="class" classrefs="Rake::Task">
        </scope>
      </scope>
    </scope>
    <scope name="rake/name_space" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="NameSpace" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(task_manager, scope_list)" attributes="__classmethod__ __ctor__" doc="Create a namespace lookup object using the given task manager and the list of scopes." />
          <scope name="tasks" ilk="function" signature="tasks()" doc="Return the list of tasks defined in this and nested namespaces." />
        </scope>
      </scope>
    </scope>
    <scope name="rake/packagetask" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="PackageTask" ilk="class" classrefs="Rake::TaskLib">
          <scope name="new" ilk="function" signature="new(name=nil, version=nil)" attributes="__classmethod__ __ctor__" doc="Create a Package Task with the given name and version.  Use +:noversion+ as the version to build a package without a version or to provide a fully-versioned package name." />
          <scope name="define" ilk="function" signature="define()" doc="Create the tasks defined by this task library." />
          <scope name="init" ilk="function" signature="init(name, version)" doc="Initialization that bypasses the &quot;yield self&quot; and &quot;define&quot; step." />
          <scope name="package_dir_path" ilk="function" signature="package_dir_path()" />
          <scope name="package_name" ilk="function" signature="package_name()" />
          <scope name="tar_bz2_file" ilk="function" signature="tar_bz2_file()" />
          <scope name="tar_gz_file" ilk="function" signature="tar_gz_file()" />
          <scope name="tgz_file" ilk="function" signature="tgz_file()" />
          <scope name="zip_file" ilk="function" signature="zip_file()" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="need_tar" />
          <scope ilk="function" name="need_tar=" />
          <scope ilk="function" name="need_tar_bz2" />
          <scope ilk="function" name="need_tar_bz2=" />
          <scope ilk="function" name="need_tar_gz" />
          <scope ilk="function" name="need_tar_gz=" />
          <scope ilk="function" name="need_zip" />
          <scope ilk="function" name="need_zip=" />
          <scope ilk="function" name="package_dir" />
          <scope ilk="function" name="package_dir=" />
          <scope ilk="function" name="package_files" />
          <scope ilk="function" name="package_files=" />
          <scope ilk="function" name="tar_command" />
          <scope ilk="function" name="tar_command=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
          <scope ilk="function" name="zip_command" />
          <scope ilk="function" name="zip_command=" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/pseudo_status" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="PseudoStatus" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(code=0)" attributes="__classmethod__ __ctor__" />
          <scope name="exited?" ilk="function" signature="exited?()" />
          <scope name="stopped?" ilk="function" signature="stopped?()" />
          <scope name="to_i" ilk="function" signature="to_i()" />
          <scope ilk="function" name="exitstatus" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/rule_recursion_overflow_error" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="RuleRecursionOverflowError" ilk="class" classrefs="StandardError">
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="add_target" ilk="function" signature="add_target(target)" />
          <scope name="message" ilk="function" signature="message()" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/task" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="Task" ilk="class" classrefs="Object">
          <scope ilk="function" name="actions" />
          <scope ilk="function" name="application" />
          <scope ilk="function" name="application=" />
          <scope ilk="function" name="comment" />
          <scope ilk="function" name="full_comment" />
          <scope ilk="function" name="locations" />
          <scope ilk="function" name="prerequisites" />
          <scope ilk="function" name="scope" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/task_argument_error" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="TaskArgumentError" ilk="class" classrefs="ArgumentError">
        </scope>
      </scope>
    </scope>
    <scope name="rake/task_arguments" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="TaskArguments" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(names, values, parent=nil)" attributes="__classmethod__ __ctor__" doc="Create a TaskArgument object with a list of named arguments (given by :names) and a set of associated values (given by :values).  :parent is the parent argument object." />
          <scope name="each" ilk="function" signature="each(&amp;block)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="method_missing" ilk="function" signature="method_missing(sym, *args, &amp;block)" />
          <scope name="new_scope" ilk="function" signature="new_scope(names)" doc="Create a new argument scope using the prerequisite argument names." />
          <scope name="to_hash" ilk="function" signature="to_hash()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="values_at" ilk="function" signature="values_at(*keys)" />
          <scope name="with_defaults" ilk="function" signature="with_defaults(defaults)" doc="Specify a hash of default values for task arguments. Use the defaults only if there is no specific value for the given argument." />
          <scope ilk="function" name="names" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/task_manager" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="TaskManager" ilk="namespace">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="clear" ilk="function" signature="clear()" doc="Clear all tasks in this application." />
          <scope name="create_rule" ilk="function" signature="create_rule(*args, &amp;block)" />
          <scope name="current_scope" ilk="function" signature="current_scope()" doc="Return the list of scope names currently active in the task manager." />
          <scope name="define_task" ilk="function" signature="define_task(task_class, *args, &amp;block)" />
          <scope name="enhance_with_matching_rule" ilk="function" signature="enhance_with_matching_rule(task_name, level=0)" doc="If a rule can be found that matches the task name, enhance the task with the prerequisites and actions from the rule.  Set the source attribute of the task appropriately for the rule.  Return the enhanced task or nil of no rule was found." />
          <scope name="in_namespace" ilk="function" signature="in_namespace(name)" doc="Evaluate the block in a nested namespace named +name+.  Create an anonymous namespace if +name+ is nil." />
          <scope name="intern" ilk="function" signature="intern(task_class, task_name)" doc="Lookup a task.  Return an existing task if found, otherwise create a task of the current type." />
          <scope name="lookup" ilk="function" signature="lookup(task_name, initial_scope=nil)" doc="Lookup a task, using scope and the scope hints in the task name. This method performs straight lookups without trying to synthesize file tasks or rules.  Special scope names (e.g. &apos;^&apos;) are recognized.  If no scope argument is supplied, use the current scope.  Return nil if the task cannot be found." />
          <scope name="resolve_args" ilk="function" signature="resolve_args(args)" doc="Resolve the arguments for a task/rule.  Returns a triplet of [task_name, arg_name_list, prerequisites]." />
          <scope name="synthesize_file_task" ilk="function" signature="synthesize_file_task(task_name)" />
          <scope name="tasks" ilk="function" signature="tasks()" doc="List of all defined tasks in this application." />
          <scope name="tasks_in_scope" ilk="function" signature="tasks_in_scope(scope)" doc="List of all the tasks defined in the given scope (and its sub-scopes)." />
          <scope ilk="function" name="last_comment" />
          <scope ilk="function" name="last_comment=" />
          <scope ilk="function" name="last_description" />
          <scope ilk="function" name="last_description=" />
          <scope ilk="function" name="record_task_metadata" />
          <scope ilk="function" name="record_task_metadata=" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/tasklib" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="TaskLib" ilk="class" classrefs="Object">
          <import symbol="Cloneable" />
          <import symbol="Rake::DSL" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/testtask" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="TestTask" ilk="class" classrefs="Rake::TaskLib">
          <scope name="new" ilk="function" signature="new(name=:test)" attributes="__classmethod__ __ctor__" doc="Create a testing task." />
          <scope name="define" ilk="function" signature="define()" doc="Create the tasks defined by this task lib." />
          <scope name="file_list_string" ilk="function" signature="file_list_string()" />
          <scope name="lib_path" ilk="function" signature="lib_path()" />
          <scope name="ruby_opts_string" ilk="function" signature="ruby_opts_string()" />
          <scope name="ruby_version" ilk="function" signature="ruby_version()" />
          <scope name="run_code" ilk="function" signature="run_code()" />
          <scope name="test_files=" ilk="function" signature="test_files=(list)" doc="Explicitly define the list of test files to be included in a test.  +list+ is expected to be an array of file names (a FileList is acceptable).  If both +pattern+ and +test_files+ are used, then the list of test files is the union of the two." />
          <scope ilk="function" name="libs" />
          <scope ilk="function" name="libs=" />
          <scope ilk="function" name="loader" />
          <scope ilk="function" name="loader=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="options" />
          <scope ilk="function" name="options=" />
          <scope ilk="function" name="pattern" />
          <scope ilk="function" name="pattern=" />
          <scope ilk="function" name="ruby_opts" />
          <scope ilk="function" name="ruby_opts=" />
          <scope ilk="function" name="verbose" />
          <scope ilk="function" name="verbose=" />
          <scope ilk="function" name="warning" />
          <scope ilk="function" name="warning=" />
        </scope>
      </scope>
    </scope>
    <scope name="rake/win32" ilk="blob" lang="Ruby">
      <scope name="Rake" ilk="namespace">
        <scope name="Win32" ilk="namespace">
          <scope name="normalize" ilk="function" signature="normalize(path)" attributes="__classmethod__" doc="Normalize a win32 path so that the slashes are all forward slashes." />
          <scope name="rake_system" ilk="function" signature="rake_system(*cmd)" attributes="__classmethod__" doc="Run a command line on windows." />
          <scope name="windows?" ilk="function" signature="windows?()" attributes="__classmethod__" doc="True if running on a windows system." />
          <scope name="Win32HomeError" ilk="class" classrefs="RuntimeError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <variable name="KNOWN_CLASSES" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="VISIBILITIES" attributes="__const__" citdl="Object" />
        <variable name="DOT_DOC_FILENAME" attributes="__const__" citdl="Object" />
        <variable name="GENERAL_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="CLASS_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="ATTR_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="CONSTANT_MODIFIERS" attributes="__const__" citdl="Object" />
        <variable name="METHOD_MODIFIERS" attributes="__const__" citdl="Object" />
        <scope name="Error" ilk="class" classrefs="RuntimeError">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/alias" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Alias" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new(text, old_name, new_name, comment, singleton = false)" attributes="__classmethod__ __ctor__" doc="Creates a new Alias with a token stream of +text+ that aliases +old_name+ to +new_name+, has +comment+ and is a +singleton+ context." />
          <scope name="aref" ilk="function" signature="aref()" doc="HTML fragment reference for this alias" />
          <scope name="full_old_name" ilk="function" signature="full_old_name()" doc="Full old name including namespace" />
          <scope name="html_name" ilk="function" signature="html_name()" doc="HTML id-friendly version of +#new_name+." />
          <scope name="name_prefix" ilk="function" signature="name_prefix()" doc="&apos;::&apos; for the alias of a singleton method/attribute, &apos;#&apos; for instance-level." />
          <scope name="pretty_name" ilk="function" signature="pretty_name()" />
          <scope name="pretty_new_name" ilk="function" signature="pretty_new_name()" doc="New name with prefix &apos;::&apos; or &apos;#&apos;." />
          <scope name="pretty_old_name" ilk="function" signature="pretty_old_name()" doc="Old name with prefix &apos;::&apos; or &apos;#&apos;." />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="new_name" />
          <scope ilk="function" name="old_name" />
          <scope ilk="function" name="singleton" />
          <scope ilk="function" name="singleton=" />
          <scope ilk="function" name="text" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/anon_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="AnonClass" ilk="class" classrefs="RDoc::ClassModule">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/any_method" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="AnyMethod" ilk="class" classrefs="RDoc::MethodAttr">
          <import symbol="RDoc::Generator::Markup" />
          <import symbol="RDoc::TokenStream" />
          <scope name="new" ilk="function" signature="new(text, name)" attributes="__classmethod__ __ctor__" doc="Creates a new AnyMethod with a token stream +text+ and +name+" />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias, context = nil)" doc="Adds +an_alias+ as an alias for this method in +context+." />
          <scope name="add_line_numbers" ilk="function" signature="add_line_numbers(src)" doc="Prepend +src+ with line numbers.  Relies on the first line of a source code listing having: &#xA; # File xxxxx, line dddd&#xA; If it has, line numbers are added an &apos;, line dddd&apos; is removed." />
          <scope name="aref_prefix" ilk="function" signature="aref_prefix()" doc="Prefix for +aref+ is &apos;method&apos;." />
          <scope name="arglists" ilk="function" signature="arglists()" doc="The call_seq or the param_seq with method name, if there is no call_seq. &#xA; Use this for displaying a method&apos;s argument lists." />
          <scope name="markup_code" ilk="function" signature="markup_code()" doc="Turns the method&apos;s token stream into HTML. &#xA; Prepends line numbers if +add_line_numbers+ is true." />
          <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Dumps this AnyMethod for use by ri.  See also #marshal_load" />
          <scope name="marshal_load" ilk="function" signature="marshal_load(array)" doc="Loads this AnyMethod from +array+.  For a loaded AnyMethod the following methods will return cached values: &#xA; #full_name&#xA;#parent_name" />
          <scope name="name" ilk="function" signature="name()" doc="Method name &#xA; If the method has no assigned name, it extracts it from #call_seq." />
          <scope name="param_list" ilk="function" signature="param_list()" doc="A list of this method&apos;s method and yield parameters.  +call-seq+ params are preferred over parsed method and block params." />
          <scope name="param_seq" ilk="function" signature="param_seq()" doc="Pretty parameter list for this method.  If the method&apos;s parameters were given by +call-seq+ it is preferred over the parsed values." />
          <scope ilk="function" name="add_line_numbers" />
          <scope ilk="function" name="add_line_numbers=" />
          <scope ilk="function" name="c_function" />
          <scope ilk="function" name="c_function=" />
          <scope ilk="function" name="call_seq" />
          <scope ilk="function" name="call_seq=" />
          <scope ilk="function" name="dont_rename_initialize" />
          <scope ilk="function" name="dont_rename_initialize=" />
          <scope ilk="function" name="params" />
          <scope ilk="function" name="params=" />
          <variable name="MARSHAL_VERSION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/attr" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Attr" ilk="class" classrefs="RDoc::MethodAttr">
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new(text, name, rw, comment, singleton = false)" attributes="__classmethod__ __ctor__" doc="Creates a new Attr with body +text+, +name+, read/write status +rw+ and +comment+.  +singleton+ marks this as a class attribute." />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias, context)" doc="Add +an_alias+ as an attribute in +context+." />
          <scope name="aref_prefix" ilk="function" signature="aref_prefix()" doc="The #aref prefix for attributes" />
          <scope name="definition" ilk="function" signature="definition()" doc="Returns attr_reader, attr_writer or attr_accessor as appropriate." />
          <scope name="marshal_dump" ilk="function" signature="marshal_dump()" doc="Dumps this Attr for use by ri.  See also #marshal_load" />
          <scope name="marshal_load" ilk="function" signature="marshal_load(array)" doc="Loads this Attr from +array+.  For a loaded Attr the following methods will return cached values: &#xA; #full_name&#xA;#parent_name" />
          <scope ilk="function" name="rw" />
          <scope ilk="function" name="rw=" />
          <variable name="MARSHAL_VERSION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/class_module" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="ClassModule" ilk="class" classrefs="RDoc::Context">
          <scope name="from_module" ilk="function" signature="from_module(class_type, mod)" attributes="__classmethod__" doc="Return a RDoc::ClassModule of class +class_type+ that is a copy of module +module+. Used to promote modules to classes." />
          <scope name="new" ilk="function" signature="new(name, superclass = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new ClassModule with +name+ with optional +superclass+ &#xA; This is a constructor for subclasses, and must never be called directly." />
          <scope name="add_comment" ilk="function" signature="add_comment(comment, location)" doc="Adds +comment+ to this ClassModule&apos;s list of comments at +location+.  This method is preferred over #comment= since it allows ri data to be updated across multiple runs." />
          <scope name="ancestors" ilk="function" signature="ancestors()" doc="Ancestors list for this ClassModule: the list of included modules (classes will add their superclass if any). &#xA; Returns the included classes or modules, not the includes themselves. The returned values are either String or RDoc::NormalModule instances (see RDoc::Include#module). &#xA; The values are returned in reverse order of their inclusion, which is the order suitable for searching methods/attributes in the ancestors. The superclass, if any, comes last." />
          <scope name="clear_comment" ilk="function" signature="clear_comment()" doc="Clears the comment. Used by the ruby parser." />
          <scope name="comment=" ilk="function" signature="comment=(comment)" doc="This method is deprecated, use #add_comment instead. &#xA; Appends +comment+ to the current comment, but separated by a rule.  Works more like +=." />
          <scope name="complete" ilk="function" signature="complete(min_visibility)" doc="Prepares this ClassModule for use by a generator. &#xA; See RDoc::TopLevel::complete" />
          <scope name="each_ancestor" ilk="function" signature="each_ancestor()" doc="Iterates the ancestors of this class or module for which an RDoc::ClassModule exists." />
          <scope name="find_ancestor_local_symbol" ilk="function" signature="find_ancestor_local_symbol(symbol)" doc="Looks for a symbol in the #ancestors. See Context#find_local_symbol." />
          <scope name="find_class_named" ilk="function" signature="find_class_named(name)" doc="Finds a class or module with +name+ in this namespace or its descendants" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Return the fully qualified name of this class or module" />
          <scope name="merge" ilk="function" signature="merge(class_module)" doc="Merges +class_module+ into this ClassModule. &#xA; The data in +class_module+ is preferred over the receiver." />
          <scope name="module?" ilk="function" signature="module?()" doc="Does this object represent a module?" />
          <scope name="name=" ilk="function" signature="name=(new_name)" doc="Allows overriding the initial name. &#xA; Used for modules and classes that are constant aliases." />
          <scope name="name_for_path" ilk="function" signature="name_for_path()" doc="Name to use to generate the url: modules and classes that are aliases for another module or class return the name of the latter." />
          <scope name="non_aliases" ilk="function" signature="non_aliases()" doc="Returns the classes and modules that are not constants aliasing another class or module. For use by formatters only (caches its result)." />
          <scope name="parse" ilk="function" signature="parse(comment_location)" doc="Parses +comment_location+ into an RDoc::Markup::Document composed of multiple RDoc::Markup::Documents with their file set." />
          <scope name="path" ilk="function" signature="path()" doc="Path to this class or module" />
          <scope name="remove_nodoc_children" ilk="function" signature="remove_nodoc_children()" doc="Updates the child modules or classes of class/module +parent+ by deleting the ones that have been removed from the documentation. &#xA; +parent_hash+ is either parent.modules_hash or parent.classes_hash and +all_hash+ is ::all_modules_hash or ::all_classes_hash." />
          <scope name="superclass" ilk="function" signature="superclass()" doc="Get the superclass of this class.  Attempts to retrieve the superclass object, returns the name if it is not known." />
          <scope name="superclass=" ilk="function" signature="superclass=(superclass)" doc="Set the superclass of this class to +superclass+" />
          <scope name="type" ilk="function" signature="type()" doc="&apos;module&apos; or &apos;class&apos;" />
          <scope name="update_aliases" ilk="function" signature="update_aliases()" doc="Updates the child modules &amp; classes by replacing the ones that are aliases through a constant. &#xA; The aliased module/class is replaced in the children and in RDoc::TopLevel::all_modules_hash or RDoc::TopLevel::all_classes_hash by a copy that has RDoc::ClassModule#is_alias_for set to the aliased module/class, and this copy is added to #aliases of the aliased module/class. &#xA; Formatters can use the #non_aliases method to retrieve children that are not aliases, for instance to list the namespace content, since the aliased modules are included in the constants of the class/module, that are listed separately." />
          <scope name="update_includes" ilk="function" signature="update_includes()" doc="Deletes from #includes those whose module has been removed from the documentation." />
          <scope ilk="function" name="comment_location" />
          <scope ilk="function" name="constant_aliases" />
          <scope ilk="function" name="constant_aliases=" />
          <scope ilk="function" name="is_alias_for" />
          <scope ilk="function" name="is_alias_for=" />
          <variable name="MARSHAL_VERSION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/code_object" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="CodeObject" ilk="class" classrefs="Object">
          <import symbol="RDoc::Text" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new CodeObject that will document itself and its children" />
          <scope name="comment=" ilk="function" signature="comment=(comment)" doc="Replaces our comment with +comment+, unless it is empty." />
          <scope name="display?" ilk="function" signature="display?()" doc="Should this CodeObject be shown in documentation?" />
          <scope name="document_children=" ilk="function" signature="document_children=(document_children)" doc="Enables or disables documentation of this CodeObject&apos;s children unless it has been turned off by :enddoc:" />
          <scope name="document_self=" ilk="function" signature="document_self=(document_self)" doc="Enables or disables documentation of this CodeObject unless it has been turned off by :enddoc:.  If the argument is +nil+ it means the documentation is turned off by +:nodoc:+." />
          <scope name="documented?" ilk="function" signature="documented?()" doc="Does this object have a comment with content or is #received_nodoc true?" />
          <scope name="done_documenting=" ilk="function" signature="done_documenting=(value)" doc="Turns documentation on/off, and turns on/off #document_self and #document_children. &#xA; Once documentation has been turned off (by +:enddoc:+), the object will refuse to turn #document_self or #document_children on, so +:doc:+ and +:start_doc:+ directives will have no effect in the current file." />
          <scope name="each_parent" ilk="function" signature="each_parent()" doc="Yields each parent of this CodeObject.  See also RDoc::ClassModule#each_ancestor" />
          <scope name="file_name" ilk="function" signature="file_name()" doc="File name where this CodeObject was found. &#xA; See also RDoc::Context#in_files" />
          <scope name="force_documentation=" ilk="function" signature="force_documentation=(value)" doc="Force the documentation of this object unless documentation has been turned off by :endoc:" />
          <scope name="full_name=" ilk="function" signature="full_name=(full_name)" doc="Sets the full_name overriding any computed full name. &#xA; Set to +nil+ to clear RDoc&apos;s cached value" />
          <scope name="ignore" ilk="function" signature="ignore()" doc="Use this to ignore a CodeObject and all its children until found again (#record_location is called).  An ignored item will not be shown in documentation. &#xA; See github issue #55 &#xA; The ignored status is temporary in order to allow implementation details to be hidden.  At the end of processing a file RDoc allows all classes and modules to add new documentation to previously created classes. &#xA; If a class was ignored (via stopdoc) then reopened later with additional documentation it should be shown.  If a class was ignored and never reopened it should not be shown.  The ignore flag allows this to occur." />
          <scope name="ignored?" ilk="function" signature="ignored?()" doc="Has this class been ignored?" />
          <scope name="parent_file_name" ilk="function" signature="parent_file_name()" doc="File name of our parent" />
          <scope name="parent_name" ilk="function" signature="parent_name()" doc="Name of our parent" />
          <scope name="record_location" ilk="function" signature="record_location(top_level)" doc="Records the RDoc::TopLevel (file) where this code object was defined" />
          <scope name="start_doc" ilk="function" signature="start_doc()" doc="Enable capture of documentation unless documentation has been turned off by :endoc:" />
          <scope name="stop_doc" ilk="function" signature="stop_doc()" doc="Disable capture of documentation" />
          <scope ilk="function" name="comment" />
          <scope ilk="function" name="document_children" />
          <scope ilk="function" name="document_self" />
          <scope ilk="function" name="done_documenting" />
          <scope ilk="function" name="file" />
          <scope ilk="function" name="force_documentation" />
          <scope ilk="function" name="line" />
          <scope ilk="function" name="line=" />
          <scope ilk="function" name="metadata" />
          <scope ilk="function" name="offset" />
          <scope ilk="function" name="offset=" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="parent=" />
          <scope ilk="function" name="received_nodoc" />
          <scope ilk="function" name="section" />
          <scope ilk="function" name="section=" />
          <scope ilk="function" name="viewer" />
          <scope ilk="function" name="viewer=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/constant" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Constant" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new(name, value, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new constant with +name+, +value+ and +comment+" />
          <scope name="documented?" ilk="function" signature="documented?()" doc="A constant is documented if it has a comment, or is an alias for a documented class or module." />
          <scope name="path" ilk="function" signature="path()" doc="Path to this constant" />
          <scope ilk="function" name="is_alias_for" />
          <scope ilk="function" name="is_alias_for=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="value" />
          <scope ilk="function" name="value=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/context" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Context" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="Comparable" />
          <import symbol="RDoc::Generator::Markup" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates an unnamed empty context with public current visibility" />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias)" doc="Adds +an_alias+ that is automatically resolved" />
          <scope name="add_attribute" ilk="function" signature="add_attribute(attribute)" doc="Adds +attribute+ if not already there. If it is (as method(s) or attribute), updates the comment if it was empty. &#xA; The attribute is registered only if it defines a new method. For instance, attr_reader :foo will not be registered if method +foo+ exists, but attr_accessor :foo will be registered if method +foo+ exists, but foo= does not." />
          <scope name="add_class" ilk="function" signature="add_class(class_type, given_name, superclass = &apos;::Object&apos;)" doc="Adds a class named +given_name+ with +superclass+. &#xA; Both +given_name+ and +superclass+ may contain &apos;::&apos;, and are interpreted relative to the +self+ context. This allows handling correctly examples like these: class RDoc::Gauntlet &lt; Gauntlet&#xA;module Mod&#xA;  class Object   # implies &lt; ::Object&#xA;  class SubObject &lt; Object  # this is _not_ ::Object&#xA; Given class Container::Item RDoc assumes +Container+ is a module unless it later sees class Container.  +add_class+ automatically upgrades +given_name+ to a class in this case." />
          <scope name="add_class_or_module" ilk="function" signature="add_class_or_module(mod, self_hash, all_hash)" doc="Adds the class or module +mod+ to the modules or classes Hash +self_hash+, and to +all_hash+ (either TopLevel::modules_hash or TopLevel::classes_hash), unless #done_documenting is +true+. Sets the #parent of +mod+ to +self+, and its #section to #current_section. Returns +mod+." />
          <scope name="add_constant" ilk="function" signature="add_constant(constant)" doc="Adds +constant+ if not already there. If it is, updates the comment, value and/or is_alias_for of the known constant if they were empty/nil." />
          <scope name="add_include" ilk="function" signature="add_include(include)" doc="Adds included module +include+ which should be an RDoc::Include" />
          <scope name="add_method" ilk="function" signature="add_method(method)" doc="Adds +method+ if not already there. If it is (as method or attribute), updates the comment if it was empty." />
          <scope name="add_module" ilk="function" signature="add_module(class_type, name)" doc="Adds a module named +name+.  If RDoc already knows +name+ is a class then that class is returned instead.  See also #add_class." />
          <scope name="add_module_alias" ilk="function" signature="add_module_alias(from, name, file)" doc="Adds an alias from +from+ (a class or module) to +name+ which was defined in +file+." />
          <scope name="add_require" ilk="function" signature="add_require(require)" doc="Adds +require+ to this context&apos;s top level" />
          <scope name="add_section" ilk="function" signature="add_section(title, comment)" doc="Returns a section with +title+, creating it if it doesn&apos;t already exist. +comment+ will be appended to the section&apos;s comment. &#xA; A section with a +title+ of +nil+ will return the default section. &#xA; See also RDoc::Context::Section" />
          <scope name="add_to" ilk="function" signature="add_to(array, thing)" doc="Adds +thing+ to the collection +array+" />
          <scope name="any_content" ilk="function" signature="any_content(includes = true)" doc="Is there any content? &#xA; This means any of: comment, aliases, methods, attributes, external aliases, require, constant. &#xA; Includes are also checked unless includes == false." />
          <scope name="child_name" ilk="function" signature="child_name(name)" doc="Creates the full name for a child with +name+" />
          <scope name="class_attributes" ilk="function" signature="class_attributes()" doc="Class attributes" />
          <scope name="class_method_list" ilk="function" signature="class_method_list()" doc="Class methods" />
          <scope name="classes" ilk="function" signature="classes()" doc="Array of classes in this context" />
          <scope name="classes_and_modules" ilk="function" signature="classes_and_modules()" doc="All classes and modules in this namespace" />
          <scope name="classes_hash" ilk="function" signature="classes_hash()" doc="Hash of classes keyed by class name" />
          <scope name="current_section" ilk="function" doc="Sets the current documentation section of documentation" />
          <scope name="defined_in?" ilk="function" signature="defined_in?(file)" doc="Is part of this thing was defined in +file+?" />
          <scope name="each_attribute" ilk="function" signature="each_attribute()" doc="Iterator for attributes" />
          <scope name="each_classmodule" ilk="function" signature="each_classmodule()" doc="Iterator for classes and modules" />
          <scope name="each_constant" ilk="function" signature="each_constant()" doc="Iterator for constants" />
          <scope name="each_include" ilk="function" signature="each_include()" doc="Iterator for included modules" />
          <scope name="each_method" ilk="function" signature="each_method()" doc="Iterator for methods" />
          <scope name="each_section" ilk="function" signature="each_section()" doc="Iterator for each section&apos;s contents sorted by title.  The +section+, the section&apos;s +constants+ and the sections +attributes+ are yielded.  The +constants+ and +attributes+ collections are sorted. &#xA; To retrieve methods in a section use #methods_by_type with the optional +section+ parameter. &#xA; NOTE: Do not edit collections yielded by this method" />
          <scope name="find_attribute" ilk="function" signature="find_attribute(name, singleton)" doc="Finds an attribute +name+ with singleton value +singleton+." />
          <scope name="find_attribute_named" ilk="function" signature="find_attribute_named(name)" doc="Finds an attribute with +name+ in this context" />
          <scope name="find_class_method_named" ilk="function" signature="find_class_method_named(name)" doc="Finds a class method with +name+ in this context" />
          <scope name="find_constant_named" ilk="function" signature="find_constant_named(name)" doc="Finds a constant with +name+ in this context" />
          <scope name="find_enclosing_module_named" ilk="function" signature="find_enclosing_module_named(name)" doc="Find a module at a higher scope" />
          <scope name="find_external_alias" ilk="function" signature="find_external_alias(name, singleton)" doc="Finds an external alias +name+ with singleton value +singleton+." />
          <scope name="find_external_alias_named" ilk="function" signature="find_external_alias_named(name)" doc="Finds an external alias with +name+ in this context" />
          <scope name="find_file_named" ilk="function" signature="find_file_named(name)" doc="Finds a file with +name+ in this context" />
          <scope name="find_instance_method_named" ilk="function" signature="find_instance_method_named(name)" doc="Finds an instance method with +name+ in this context" />
          <scope name="find_local_symbol" ilk="function" signature="find_local_symbol(symbol)" doc="Finds a method, constant, attribute, external alias, module or file named +symbol+ in this context." />
          <scope name="find_method" ilk="function" signature="find_method(name, singleton)" doc="Finds a method named +name+ with singleton value +singleton+." />
          <scope name="find_method_named" ilk="function" signature="find_method_named(name)" doc="Finds a instance or module method with +name+ in this context" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" doc="Find a module with +name+ using ruby&apos;s scoping rules" />
          <scope name="find_symbol" ilk="function" signature="find_symbol(symbol)" doc="Look up +symbol+, first as a module, then as a local symbol." />
          <scope name="find_symbol_module" ilk="function" signature="find_symbol_module(symbol)" doc="Look up a module named +symbol+." />
          <scope name="full_name" ilk="function" signature="full_name()" doc="The full name for this context.  This method is overridden by subclasses." />
          <scope name="fully_documented?" ilk="function" signature="fully_documented?()" doc="Does this context and its methods and constants all have documentation? &#xA; (Yes, fully documented doesn&apos;t mean everything.)" />
          <scope name="http_url" ilk="function" signature="http_url(prefix)" doc="URL for this with a +prefix+" />
          <scope name="initialize_methods_etc" ilk="function" signature="initialize_methods_etc()" doc="Sets the defaults for methods and so-forth" />
          <scope name="instance_attributes" ilk="function" signature="instance_attributes()" doc="Instance attributes" />
          <scope name="instance_method_list" ilk="function" signature="instance_method_list()" doc="Instance methods" />
          <scope name="methods_by_type" ilk="function" signature="methods_by_type(section = nil)" doc="Breaks method_list into a nested hash by type (&apos;class&apos; or &apos;instance&apos;) and visibility (+:public+, +:protected+, +:private+). &#xA; If +section+ is provided only methods in that RDoc::Context::Section will be returned." />
          <scope name="methods_matching" ilk="function" signature="methods_matching(methods, singleton = false, &amp;block)" doc="Yields AnyMethod and Attr entries matching the list of names in +methods+." />
          <scope name="modules" ilk="function" signature="modules()" doc="Array of modules in this context" />
          <scope name="modules_hash" ilk="function" signature="modules_hash()" doc="Hash of modules keyed by module name" />
          <scope name="name_for_path" ilk="function" signature="name_for_path()" doc="Name to use to generate the url. #full_name by default." />
          <scope name="ongoing_visibility=" ilk="function" signature="ongoing_visibility=(visibility)" doc="Changes the visibility for new methods to +visibility+" />
          <scope name="record_location" ilk="function" signature="record_location(top_level)" doc="Record +top_level+ as a file +self+ is in." />
          <scope name="remove_from_documentation?" ilk="function" signature="remove_from_documentation?()" doc="Should we remove this context from the documentation? &#xA; The answer is yes if: #received_nodoc is +true+&#xA;#any_content is +false+ (not counting includes)&#xA;All #includes are modules (not a string), and their module has #remove_from_documentation? == true&#xA;All classes and modules have #remove_from_documentation? == true" />
          <scope name="remove_invisible" ilk="function" signature="remove_invisible(min_visibility)" doc="Removes methods and attributes with a visibility less than +min_visibility+." />
          <scope name="resolve_aliases" ilk="function" signature="resolve_aliases(added)" doc="Tries to resolve unmatched aliases when a method or attribute has just been added." />
          <scope name="sections" ilk="function" signature="sections()" doc="Sections in this context" />
          <scope name="set_current_section" ilk="function" signature="set_current_section(title, comment)" doc="Sets the current section to a section with +title+.  See also #add_section" />
          <scope name="set_visibility_for" ilk="function" signature="set_visibility_for(methods, visibility, singleton = false)" doc="Given an array +methods+ of method names, set the visibility of each to +visibility+" />
          <scope name="top_level" ilk="function" signature="top_level()" doc="Return the TopLevel that owns us" />
          <scope name="upgrade_to_class" ilk="function" signature="upgrade_to_class(mod, class_type, enclosing)" doc="Upgrades NormalModule +mod+ in +enclosing+ to a +class_type+" />
          <scope ilk="function" name="aliases" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="constants" />
          <scope ilk="function" name="constants_hash" />
          <scope ilk="function" name="current_section=" />
          <scope ilk="function" name="external_aliases" />
          <scope ilk="function" name="in_files" />
          <scope ilk="function" name="includes" />
          <scope ilk="function" name="method_list" />
          <scope ilk="function" name="methods_hash" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="requires" />
          <scope ilk="function" name="temporary_section" />
          <scope ilk="function" name="temporary_section=" />
          <scope ilk="function" name="unmatched_alias_lists" />
          <scope ilk="function" name="unmatched_alias_lists=" />
          <scope ilk="function" name="visibility" />
          <scope ilk="function" name="visibility=" />
          <variable name="TYPES" attributes="__const__" citdl="Object" />
          <scope name="Section" ilk="class" classrefs="Object">
            <import symbol="RDoc::Generator::Markup" />
            <import symbol="RDoc::Text" />
            <scope name="new" ilk="function" signature="new(parent, title, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new section with +title+ and +comment+" />
            <scope name="aref" ilk="function" signature="aref()" doc="Anchor reference for linking to this section" />
            <scope name="comment=" ilk="function" signature="comment=(comment)" doc="Appends +comment+ to the current comment separated by a rule." />
            <scope name="extract_comment" ilk="function" signature="extract_comment(comment)" doc="Extracts the comment for this section from the original comment block. If the first line contains :section:, strip it and use the rest. Otherwise remove lines up to the line containing :section:, and look for those lines again at the end and remove them. This lets us write &#xA; # :section: The title&#xA;# The body" />
            <scope name="sequence" ilk="function" signature="sequence()" doc="Section sequence number (deprecated)" />
            <scope ilk="function" name="comment" />
            <scope ilk="function" name="parent" />
            <scope ilk="function" name="title" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/cross_reference" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="CrossReference" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" doc="Allows cross-references to be created based on the given +context+ (RDoc::Context)." />
          <scope name="resolve" ilk="function" signature="resolve(name, text)" doc="Returns a reference to +name+. &#xA; If the reference is found and +name+ is not documented +text+ will be returned.  If +name+ is escaped +name+ is returned.  If +name+ is not found +text+ is returned." />
          <scope ilk="function" name="seen" />
          <scope ilk="function" name="seen=" />
          <variable name="CLASS_REGEXP_STR" attributes="__const__" citdl="Object" />
          <variable name="METHOD_REGEXP_STR" attributes="__const__" citdl="Object" />
          <variable name="CROSSREF_REGEXP" attributes="__const__" citdl="Object" />
          <variable name="ALL_CROSSREF_REGEXP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/encoding" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Encoding" ilk="namespace">
          <scope name="read_file" ilk="function" signature="read_file(filename, encoding, force_transcode = false)" attributes="__classmethod__" doc="Reads the contents of +filename+ and handles any encoding directives in the file. &#xA; The content will be converted to the +encoding+.  If the file cannot be converted a warning will be printed and nil will be returned. &#xA; If +force_transcode+ is true the document will be transcoded and any unknown character in the target encoding will be replaced with &apos;?&apos;" />
          <scope name="set_encoding" ilk="function" signature="set_encoding(string)" attributes="__classmethod__" doc="Sets the encoding of +string+ based on the magic comment" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/erbio" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="ERBIO" ilk="class" classrefs="ERB">
          <scope name="new" ilk="function" signature="new(str, safe_level = nil, trim_mode = nil, eoutvar = &apos;io&apos;)" attributes="__classmethod__ __ctor__" doc="Defaults +eoutvar+ to &apos;io&apos;, otherwise is identical to ERB&apos;s initialize" />
          <scope name="set_eoutvar" ilk="function" signature="set_eoutvar(compiler, io_variable)" doc="Instructs +compiler+ how to write to +io_variable+" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/darkfish" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="Darkfish" ilk="class" classrefs="Object">
            <import symbol="ERB::Util" />
            <scope name="new" ilk="function" signature="new(options)" attributes="__classmethod__ __ctor__" doc="Initialize a few instance variables before we start" />
            <scope name="class_dir" ilk="function" signature="class_dir()" doc="Directory where generated class HTML files live relative to the output dir." />
            <scope name="debug_msg" ilk="function" signature="debug_msg(*msg)" doc="Output progress information if debugging is enabled" />
            <scope name="file_dir" ilk="function" signature="file_dir()" doc="Directory where generated class HTML files live relative to the output dir." />
            <scope name="gen_sub_directories" ilk="function" signature="gen_sub_directories()" doc="Create the directories the generated docs will live in if they don&apos;t already exist." />
            <scope name="generate" ilk="function" signature="generate(top_levels)" doc="Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information." />
            <scope name="write_style_sheet" ilk="function" signature="write_style_sheet()" doc="Copy over the stylesheet into the appropriate place in the output directory." />
            <scope ilk="function" name="outputdir" />
            <variable name="GENERATOR_DIR" attributes="__const__" citdl="Object" />
            <variable name="VERSION" attributes="__const__" citdl="Object" />
            <variable name="DESCRIPTION" attributes="__const__" citdl="Object" />
            <variable name="SVNID_PATTERN" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/markup" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="Markup" ilk="namespace">
            <scope name="aref_to" ilk="function" signature="aref_to(target_path)" doc="Generates a relative URL from this object&apos;s path to +target_path+" />
            <scope name="as_href" ilk="function" signature="as_href(from_path)" doc="Generates a relative URL from +from_path+ to this object&apos;s path" />
            <scope name="cvs_url" ilk="function" signature="cvs_url(url, full_path)" doc="Build a webcvs URL starting for the given +url+ with +full_path+ appended as the destination path.  If +url+ contains &apos;%s&apos; +full_path+ will be sprintf&apos;d into +url+ instead." />
            <scope name="description" ilk="function" signature="description()" doc="Handy wrapper for marking up this object&apos;s comment" />
            <scope name="formatter" ilk="function" signature="formatter()" doc="Creates an RDoc::Markup::ToHtmlCrossref formatter" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/generator/ri" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Generator" ilk="namespace">
          <scope name="RI" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(options)" attributes="__classmethod__ __ctor__" doc="Set up a new ri generator" />
            <scope name="generate" ilk="function" signature="generate(top_levels)" doc="Build the initial indices and output objects based on an array of TopLevel objects containing the extracted information." />
            <scope name="install_siginfo_handler" ilk="function" signature="install_siginfo_handler()" doc="Installs a siginfo handler that prints the current filename." />
            <scope name="remove_siginfo_handler" ilk="function" signature="remove_siginfo_handler()" doc="Removes a siginfo handler and replaces the previous" />
            <variable name="DESCRIPTION" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ghost_method" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="GhostMethod" ilk="class" classrefs="RDoc::AnyMethod">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/include" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Include" ilk="class" classrefs="RDoc::CodeObject">
          <scope name="new" ilk="function" signature="new(name, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new Include for +name+ with +comment+" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Full name based on #module" />
          <scope name="module" ilk="function" signature="module()" doc="Attempts to locate the included module object.  Returns the name if not known. &#xA; The scoping rules of Ruby to resolve the name of an included module are: first look into the children of the current context;&#xA;if not found, look into the children of included modules, in reverse inclusion order;&#xA;if still not found, go up the hierarchy of names." />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(attribute_manager = nil)" attributes="__classmethod__ __ctor__" doc="Take a block of text and use various heuristics to determine its structure (paragraphs, lists, and so on).  Invoke an event handler as we identify significant chunks." />
          <scope name="add_html" ilk="function" signature="add_html(tag, name)" doc="Add to the sequences recognized as general markup." />
          <scope name="add_special" ilk="function" signature="add_special(pattern, name)" doc="Add to other inline sequences.  For example, we could add WikiWords using something like: &#xA; parser.add_special(/\b([A-Z][a-z]+[A-Z]\w+)/, :WIKIWORD)&#xA; Each wiki word will be presented to the output formatter via the accept_special method." />
          <scope name="add_word_pair" ilk="function" signature="add_word_pair(start, stop, name)" doc="Add to the sequences used to add formatting to an individual word (such as *bold*).  Matching entries will generate attributes that the output formatters can recognize by their +name+." />
          <scope name="convert" ilk="function" signature="convert(input, formatter)" doc="We take +input+, parse it if necessary, then invoke the output +formatter+ using a Visitor to render the result." />
          <scope ilk="function" name="attribute_manager" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/attribute_manager" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="AttributeManager" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new attribute manager that understands bold, emphasized and teletype text." />
            <scope name="add_html" ilk="function" signature="add_html(tag, name)" doc="Adds a markup class with +name+ for words surrounded by HTML tag +tag+. To process emphasis tags: &#xA; am.add_html &apos;em&apos;, :EM" />
            <scope name="add_special" ilk="function" signature="add_special(pattern, name)" doc="Adds a special handler for +pattern+ with +name+.  A simple URL handler would be: &#xA; @am.add_special(/((https?:)\S+\w)/, :HYPERLINK)" />
            <scope name="add_word_pair" ilk="function" signature="add_word_pair(start, stop, name)" doc="Adds a markup class with +name+ for words wrapped in the +start+ and +stop+ character.  To make words wrapped with &quot;*&quot; bold: &#xA; am.add_word_pair &apos;*&apos;, &apos;*&apos;, :BOLD" />
            <scope name="attribute" ilk="function" signature="attribute(turn_on, turn_off)" doc="Return an attribute object with the given turn_on and turn_off bits set" />
            <scope name="change_attribute" ilk="function" signature="change_attribute(current, new)" doc="Changes the current attribute from +current+ to +new+" />
            <scope name="changed_attribute_by_name" ilk="function" signature="changed_attribute_by_name(current_set, new_set)" doc="Used by the tests to change attributes by name from +current_set+ to +new_set+" />
            <scope name="convert_attrs" ilk="function" signature="convert_attrs(str, attrs)" doc="Map attributes like &lt;b&gt;text&lt;/b&gt;to the sequence \001\002&lt;char&gt;\001\003&lt;char&gt;, where &lt;char&gt; is a per-attribute specific character" />
            <scope name="convert_html" ilk="function" signature="convert_html(str, attrs)" doc="Converts HTML tags to RDoc attributes" />
            <scope name="convert_specials" ilk="function" signature="convert_specials(str, attrs)" doc="Converts special sequences to RDoc attributes" />
            <scope name="copy_string" ilk="function" signature="copy_string(start_pos, end_pos)" doc="Copies +start_pos+ to +end_pos+ from the current string" />
            <scope name="display_attributes" ilk="function" signature="display_attributes()" doc="Debug method that prints a string along with its attributes" />
            <scope name="flow" ilk="function" signature="flow(str)" doc="Processes +str+ converting attributes, HTML and specials" />
            <scope name="mask_protected_sequences" ilk="function" signature="mask_protected_sequences()" doc="Escapes special sequences of text to prevent conversion to RDoc" />
            <scope name="split_into_flow" ilk="function" signature="split_into_flow()" doc="Splits the string into chunks by attribute change" />
            <scope name="unmask_protected_sequences" ilk="function" signature="unmask_protected_sequences()" doc="Unescapes special sequences of text" />
            <scope ilk="function" name="html_tags" />
            <scope ilk="function" name="matching_word_pairs" />
            <scope ilk="function" name="protectable" />
            <scope ilk="function" name="special" />
            <scope ilk="function" name="word_pair_map" />
            <variable name="NULL" attributes="__const__" citdl="Object" />
            <variable name="A_PROTECT" attributes="__const__" citdl="Object" />
            <variable name="PROTECT_ATTR" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/blank_line" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="BlankLine" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="RDoc::Markup::BlankLine is a singleton" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_blank_line on +visitor+" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/document" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Document" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*parts)" attributes="__classmethod__ __ctor__" doc="Creates a new Document with +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Runs this document and all its #items through +visitor+" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Does this document have no parts?" />
            <scope name="merge" ilk="function" signature="merge(other)" doc="When this is a collection of documents (#file is not set and this document contains only other documents as its direct children) #merge replaces documents in this class with documents from +other+ when the file matches and adds documents from +other+ when the files do not. &#xA; The information in +other+ is preferred over the receiver" />
            <scope name="merged?" ilk="function" signature="merged?()" doc="Does this Document contain other Documents?" />
            <scope name="push" ilk="function" signature="push(*parts)" doc="Appends +parts+ to the document" />
            <scope ilk="function" name="file" />
            <scope ilk="function" name="file=" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/formatter" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Formatter" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Formatter" />
            <scope name="accept_document" ilk="function" signature="accept_document(document)" doc="Adds +document+ to the output" />
            <scope name="add_tag" ilk="function" signature="add_tag(name, start, stop)" doc="Add a new set of tags for an attribute. We allow separate start and end tags for flexibility" />
            <scope name="annotate" ilk="function" signature="annotate(tag)" doc="Allows +tag+ to be decorated with additional information." />
            <scope name="convert" ilk="function" signature="convert(content)" doc="Marks up +content+" />
            <scope name="convert_flow" ilk="function" signature="convert_flow(flow)" doc="Converts flow items +flow+" />
            <scope name="convert_special" ilk="function" signature="convert_special(special)" doc="Converts added specials.  See RDoc::Markup#add_special" />
            <scope name="convert_string" ilk="function" signature="convert_string(string)" doc="Converts a string to be fancier if desired" />
            <scope name="in_tt?" ilk="function" signature="in_tt?()" doc="Are we currently inside tt tags?" />
            <scope name="off_tags" ilk="function" signature="off_tags(res, item)" doc="Turns off tags for +item+ on +res+" />
            <scope name="on_tags" ilk="function" signature="on_tags(res, item)" doc="Turns on tags for +item+ on +res+" />
            <scope name="tt?" ilk="function" signature="tt?(tag)" doc="Is +tag+ a tt tag?" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/formatter_test_case" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="FormatterTestCase" ilk="class" classrefs="MiniTest::Unit::TestCase">
            <scope name="add_visitor_tests" ilk="function" signature="add_visitor_tests()" attributes="__classmethod__" doc="Call to add the visitor tests to your test case" />
            <scope name="setup" ilk="function" signature="setup()" doc="Call #setup when inheriting from this test case. &#xA; Provides the following instance variables: &#xA; RDoc::Markup.new&#xA;RDoc::Markup # to reduce typing&#xA;@RM::List.new :BULLET, # ...&#xA;@RM::List.new :LABEL, # ...&#xA;@RM::List.new :LALPHA, # ...&#xA;@RM::List.new :NOTE, # ...&#xA;@RM::List.new :NUMBER, # ...&#xA;@RM::List.new :UALPHA, # ..." />
            <scope name="test_accept_blank_line" ilk="function" signature="test_accept_blank_line()" doc="Calls accept_blank_line" />
            <scope name="test_accept_document" ilk="function" signature="test_accept_document()" doc="Test case that calls @to.accept_document" />
            <scope name="test_accept_heading" ilk="function" signature="test_accept_heading()" doc="Calls accept_heading with a level 5 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_1" ilk="function" signature="test_accept_heading_1()" doc="Calls accept_heading_1 with a level 1 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_2" ilk="function" signature="test_accept_heading_2()" doc="Calls accept_heading_2 with a level 2 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_3" ilk="function" signature="test_accept_heading_3()" doc="Calls accept_heading_3 with a level 3 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_4" ilk="function" signature="test_accept_heading_4()" doc="Calls accept_heading_4 with a level 4 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_b" ilk="function" signature="test_accept_heading_b()" doc="Calls accept_heading_b with a bold level 1 RDoc::Markup::Heading" />
            <scope name="test_accept_heading_suppressed_crossref" ilk="function" signature="test_accept_heading_suppressed_crossref()" doc="Calls accept_heading_suppressed_crossref with a level 1 RDoc::Markup::Heading containing a suppressed crossref" />
            <scope name="test_accept_list_end_bullet" ilk="function" signature="test_accept_list_end_bullet()" doc="Calls accept_list_end_bullet" />
            <scope name="test_accept_list_end_label" ilk="function" signature="test_accept_list_end_label()" doc="Calls accept_list_end_label" />
            <scope name="test_accept_list_end_lalpha" ilk="function" signature="test_accept_list_end_lalpha()" doc="Calls accept_list_end_lalpha" />
            <scope name="test_accept_list_end_note" ilk="function" signature="test_accept_list_end_note()" doc="Calls accept_list_end_note" />
            <scope name="test_accept_list_end_number" ilk="function" signature="test_accept_list_end_number()" doc="Calls accept_list_end_number" />
            <scope name="test_accept_list_end_ualpha" ilk="function" signature="test_accept_list_end_ualpha()" doc="Calls accept_list_end_ulpha" />
            <scope name="test_accept_list_item_end_bullet" ilk="function" signature="test_accept_list_item_end_bullet()" doc="Calls accept_list_item_end_bullet" />
            <scope name="test_accept_list_item_end_label" ilk="function" signature="test_accept_list_item_end_label()" doc="Calls accept_list_item_end_label" />
            <scope name="test_accept_list_item_end_lalpha" ilk="function" signature="test_accept_list_item_end_lalpha()" doc="Calls accept_list_item_end_lalpha" />
            <scope name="test_accept_list_item_end_note" ilk="function" signature="test_accept_list_item_end_note()" doc="Calls accept_list_item_end_note" />
            <scope name="test_accept_list_item_end_number" ilk="function" signature="test_accept_list_item_end_number()" doc="Calls accept_list_item_end_number" />
            <scope name="test_accept_list_item_end_ualpha" ilk="function" signature="test_accept_list_item_end_ualpha()" doc="Calls accept_list_item_end_ualpha" />
            <scope name="test_accept_list_item_start_bullet" ilk="function" signature="test_accept_list_item_start_bullet()" doc="Calls accept_list_item_start_bullet" />
            <scope name="test_accept_list_item_start_label" ilk="function" signature="test_accept_list_item_start_label()" doc="Calls accept_list_item_start_label" />
            <scope name="test_accept_list_item_start_lalpha" ilk="function" signature="test_accept_list_item_start_lalpha()" doc="Calls accept_list_item_start_lalpha" />
            <scope name="test_accept_list_item_start_note" ilk="function" signature="test_accept_list_item_start_note()" doc="Calls accept_list_item_start_note" />
            <scope name="test_accept_list_item_start_note_2" ilk="function" signature="test_accept_list_item_start_note_2()" doc="Calls accept_list_item_start_note_2" />
            <scope name="test_accept_list_item_start_number" ilk="function" signature="test_accept_list_item_start_number()" doc="Calls accept_list_item_start_number" />
            <scope name="test_accept_list_item_start_ualpha" ilk="function" signature="test_accept_list_item_start_ualpha()" doc="Calls accept_list_item_start_ualpha" />
            <scope name="test_accept_list_start_bullet" ilk="function" signature="test_accept_list_start_bullet()" doc="Calls accept_list_start_bullet" />
            <scope name="test_accept_list_start_label" ilk="function" signature="test_accept_list_start_label()" doc="Calls accept_list_start_label" />
            <scope name="test_accept_list_start_lalpha" ilk="function" signature="test_accept_list_start_lalpha()" doc="Calls accept_list_start_lalpha" />
            <scope name="test_accept_list_start_note" ilk="function" signature="test_accept_list_start_note()" doc="Calls accept_list_start_note" />
            <scope name="test_accept_list_start_number" ilk="function" signature="test_accept_list_start_number()" doc="Calls accept_list_start_number" />
            <scope name="test_accept_list_start_ualpha" ilk="function" signature="test_accept_list_start_ualpha()" doc="Calls accept_list_start_ualpha" />
            <scope name="test_accept_paragraph" ilk="function" signature="test_accept_paragraph()" doc="Calls accept_paragraph" />
            <scope name="test_accept_paragraph_b" ilk="function" signature="test_accept_paragraph_b()" doc="Calls accept_paragraph_b with a RDoc::Markup::Paragraph containing bold words" />
            <scope name="test_accept_paragraph_i" ilk="function" signature="test_accept_paragraph_i()" doc="Calls accept_paragraph_i with a RDoc::Markup::Paragraph containing emphasized words" />
            <scope name="test_accept_paragraph_plus" ilk="function" signature="test_accept_paragraph_plus()" doc="Calls accept_paragraph_plus with a RDoc::Markup::Paragraph containing teletype words" />
            <scope name="test_accept_paragraph_star" ilk="function" signature="test_accept_paragraph_star()" doc="Calls accept_paragraph_star with a RDoc::Markup::Paragraph containing bold words" />
            <scope name="test_accept_paragraph_underscore" ilk="function" signature="test_accept_paragraph_underscore()" doc="Calls accept_paragraph_underscore with a RDoc::Markup::Paragraph containing emphasized words" />
            <scope name="test_accept_raw" ilk="function" signature="test_accept_raw()" doc="Calls accept_raw with a RDoc::Markup::Raw" />
            <scope name="test_accept_rule" ilk="function" signature="test_accept_rule()" doc="Calls accept_rule with a RDoc::Markup::Rule" />
            <scope name="test_accept_verbatim" ilk="function" signature="test_accept_verbatim()" doc="Calls accept_verbatim with a RDoc::Markup::Verbatim" />
            <scope name="test_end_accepting" ilk="function" signature="test_end_accepting()" doc="Calls end_accepting on your test case which needs to call @to.end_accepting and verify document generation" />
            <scope name="test_list_nested" ilk="function" signature="test_list_nested()" doc="Calls list_nested with a two-level list" />
            <scope name="test_list_verbatim" ilk="function" signature="test_list_verbatim()" doc="Calls list_verbatim with a list containing a verbatim block" />
            <scope name="test_start_accepting" ilk="function" signature="test_start_accepting()" doc="Calls start_accepting which needs to verify startup state" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/heading" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Heading" ilk="class" classrefs="Struct.new :level, :text">
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_heading on +visitor+" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/indented_paragraph" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="IndentedParagraph" ilk="class" classrefs="RDoc::Markup::Raw">
            <scope name="new" ilk="function" signature="new(indent, *parts)" attributes="__classmethod__ __ctor__" doc="Creates a new IndentedParagraph containing +parts+ indented with +indent+ spaces" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_indented_paragraph on +visitor+" />
            <scope ilk="function" name="indent" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/inline" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="AttrChanger" ilk="class" classrefs="Object">
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="AttrSpan" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(length)" attributes="__classmethod__ __ctor__" doc="Creates a new AttrSpan for +length+ characters" />
            <scope name="set_attrs" ilk="function" signature="set_attrs(start, length, bits)" doc="Toggles +bits+ from +start+ to +length+" />
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Attribute" ilk="class" classrefs="Object">
            <scope name="as_string" ilk="function" signature="as_string(bitmap)" attributes="__classmethod__" doc="Returns a string representation of +bitmap+" />
            <scope name="bitmap_for" ilk="function" signature="bitmap_for(name)" attributes="__classmethod__" doc="Returns a unique bit for +name+" />
            <scope name="each_name_of" ilk="function" signature="each_name_of(bitmap)" attributes="__classmethod__" doc="yields each attribute name in +bitmap+" />
            <variable name="SPECIAL" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Markup" ilk="namespace">
          <scope name="Special" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(type, text)" attributes="__classmethod__ __ctor__" doc="Creates a new special sequence of +type+ with +text+" />
            <scope ilk="function" name="text" />
            <scope ilk="function" name="text=" />
            <scope ilk="function" name="type" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/list" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="List" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(type = nil, *items)" attributes="__classmethod__ __ctor__" doc="Creates a new list of +type+ with +items+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Runs this list and all its #items through +visitor+" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Is the list empty?" />
            <scope name="last" ilk="function" signature="last()" doc="Returns the last item in the list" />
            <scope name="push" ilk="function" signature="push(*items)" doc="Appends +items+ to the list" />
            <scope ilk="function" name="items" />
            <scope ilk="function" name="type" />
            <scope ilk="function" name="type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/list_item" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ListItem" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(label = nil, *parts)" attributes="__classmethod__ __ctor__" doc="Creates a new ListItem with an optional +label+ containing +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Runs this list item and all its #parts through +visitor+" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Is the ListItem empty?" />
            <scope name="length" ilk="function" signature="length()" doc="Length of parts in the ListItem" />
            <scope name="push" ilk="function" signature="push(*parts)" doc="Adds +parts+ to the ListItem" />
            <scope ilk="function" name="label" />
            <scope ilk="function" name="label=" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/paragraph" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Paragraph" ilk="class" classrefs="RDoc::Markup::Raw">
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_paragraph on +visitor+" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/parser" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Parser" ilk="class" classrefs="Object">
            <import symbol="RDoc::Text" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new Parser.  See also ::parse" />
            <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" doc="Parses +str+ into a Document" />
            <scope name="tokenize" ilk="function" signature="tokenize(str)" attributes="__classmethod__" doc="Returns a token stream for +str+, for testing" />
            <scope name="build_heading" ilk="function" signature="build_heading(level)" doc="Builds a Heading of +level+" />
            <scope name="build_list" ilk="function" signature="build_list(margin)" doc="Builds a List flush to +margin+" />
            <scope name="build_paragraph" ilk="function" signature="build_paragraph(margin)" doc="Builds a Paragraph that is flush to +margin+" />
            <scope name="build_verbatim" ilk="function" signature="build_verbatim(margin)" doc="Builds a Verbatim that is indented from +margin+. &#xA; The verbatim block is shifted left (the least indented lines start in column 0).  Each part of the verbatim is one line of text, always terminated by a newline.  Blank lines always consist of a single newline character, and there is never a single newline at the end of the verbatim." />
            <scope name="get" ilk="function" signature="get()" doc="Pulls the next token from the stream." />
            <scope name="parse" ilk="function" signature="parse(parent, indent = 0)" doc="Parses the tokens into an array of RDoc::Markup::XXX objects, and appends them to the passed +parent+ RDoc::Markup::YYY object. &#xA; Exits at the end of the token stream, or when it encounters a token in a column less than +indent+ (unless it is a NEWLINE). &#xA; Returns +parent+." />
            <scope name="peek_token" ilk="function" signature="peek_token()" doc="Returns the next token on the stream without modifying the stream" />
            <scope name="skip" ilk="function" signature="skip(token_type, error = true)" doc="Skips the next token if its type is +token_type+. &#xA; Optionally raises an error if the next token is not of the expected type." />
            <scope name="token_pos" ilk="function" signature="token_pos(offset)" doc="Calculates the column and line of the current token based on +offset+." />
            <scope name="tokenize" ilk="function" signature="tokenize(input)" doc="Turns text +input+ into a stream of tokens" />
            <scope name="unget" ilk="function" signature="unget()" doc="Returns the current token to the token stream" />
            <scope ilk="function" name="debug" />
            <scope ilk="function" name="debug=" />
            <scope ilk="function" name="tokens" />
            <variable name="LIST_TOKENS" attributes="__const__" citdl="Object" />
            <scope name="Error" ilk="class" classrefs="RuntimeError">
            </scope>
            <scope name="ParseError" ilk="class" classrefs="RDoc::Markup::Parser::Error">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/pre_process" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="PreProcess" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(input_file_name, include_path)" attributes="__classmethod__ __ctor__" doc="Creates a new pre-processor for +input_file_name+ that will look for included files in +include_path+" />
            <scope name="register" ilk="function" signature="register(directive, &amp;block)" attributes="__classmethod__" doc="Registers +directive+ as one handled by RDoc.  If a block is given the directive will be replaced by the result of the block, otherwise the directive will be removed from the processed text." />
            <scope name="registered" ilk="function" signature="registered()" attributes="__classmethod__" doc="Registered directives" />
            <scope name="find_include_file" ilk="function" signature="find_include_file(name)" doc="Look for the given file in the directory containing the current file, and then in each of the directories specified in the RDOC_INCLUDE path" />
            <scope name="handle" ilk="function" signature="handle(text, code_object = nil, &amp;block)" doc="Look for directives in a chunk of +text+. &#xA; Options that we don&apos;t handle are yielded.  If the block returns false the directive is restored to the text.  If the block returns nil or no block was given the directive is handled according to the registered directives. If a String was returned the directive is replaced with the string. &#xA; If no matching directive was registered the directive is restored to the text. &#xA; If +code_object+ is given and the param is set as metadata on the +code_object+.  See RDoc::CodeObject#metadata" />
            <scope name="handle_directive" ilk="function" signature="handle_directive(prefix, directive, param, code_object = nil, encoding = nil)" />
            <scope name="include_file" ilk="function" signature="include_file(name, indent, encoding)" doc="Handles the :include: _filename_ directive. &#xA; If the first line of the included file starts with &apos;#&apos;, and contains an encoding information in the form &apos;coding:&apos; or &apos;coding=&apos;, it is removed. &#xA; If all lines in the included file start with a &apos;#&apos;, this leading &apos;#&apos; is removed before inclusion. The included content is indented like the :include: directive." />
            <scope ilk="function" name="options" />
            <scope ilk="function" name="options=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/raw" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Raw" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(*parts)" attributes="__classmethod__ __ctor__" doc="Creates a new Raw containing +parts+" />
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_raw+ on +visitor+" />
            <scope name="merge" ilk="function" signature="merge(other)" doc="Appends +other+&apos;s parts" />
            <scope name="push" ilk="function" signature="push(*texts)" doc="Appends +texts+ onto this Paragraph" />
            <scope name="text" ilk="function" signature="text()" doc="The raw text" />
            <scope ilk="function" name="parts" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/rule" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Rule" ilk="class" classrefs="Struct.new :weight">
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_rule on +visitor+" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/text_formatter_test_case" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="TextFormatterTestCase" ilk="class" classrefs="RDoc::Markup::FormatterTestCase">
            <scope name="add_text_tests" ilk="function" signature="add_text_tests()" attributes="__classmethod__" doc="Adds test cases to the calling TestCase." />
            <scope name="test_accept_heading_indent" ilk="function" signature="test_accept_heading_indent()" doc="Test case that calls @to.accept_heading" />
            <scope name="test_accept_paragraph_indent" ilk="function" signature="test_accept_paragraph_indent()" doc="Test case that calls @to.accept_paragraph with an indent" />
            <scope name="test_accept_paragraph_wrap" ilk="function" signature="test_accept_paragraph_wrap()" doc="Test case that calls @to.accept_paragraph with a long line" />
            <scope name="test_accept_rule_indent" ilk="function" signature="test_accept_rule_indent()" doc="Test case that calls @to.accept_rule" />
            <scope name="test_accept_verbatim_big_indent" ilk="function" signature="test_accept_verbatim_big_indent()" doc="Test case that calls @to.accept_verbatim with a big indent" />
            <scope name="test_accept_verbatim_indent" ilk="function" signature="test_accept_verbatim_indent()" doc="Test case that calls @to.accept_verbatim" />
            <scope name="test_attributes" ilk="function" signature="test_attributes()" doc="Test case that calls @to.attributes with an escaped cross-reference.  If this test doesn&apos;t pass something may be very wrong." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_ansi" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToAnsi" ilk="class" classrefs="RDoc::Markup::ToRdoc">
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new ToAnsi visitor that is ready to output vibrant ANSI color!" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" doc="Overrides indent width to ensure output lines up correctly." />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" doc="Adds coloring to note and label list items" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to ANSI sequences" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" doc="Starts accepting with a reset screen" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_bs" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToBs" ilk="class" classrefs="RDoc::Markup::ToRdoc">
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Returns a new ToBs that is ready for hot backspace action!" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" doc="Makes heading text bold." />
            <scope name="annotate" ilk="function" signature="annotate(tag)" doc="Turns on or off special handling for +convert_string+" />
            <scope name="convert_special" ilk="function" signature="convert_special(special)" doc="Calls convert_string on the result of convert_special" />
            <scope name="convert_string" ilk="function" signature="convert_string(string)" doc="Adds bold or underline mixed with backspaces" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Sets a flag that is picked up by #annotate to do the right thing in #convert_string" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_html" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToHtml" ilk="class" classrefs="RDoc::Markup::Formatter">
            <import symbol="RDoc::Text" />
            <scope name="gen_relative_url" ilk="function" signature="gen_relative_url(path, target)" attributes="__classmethod__" doc="Converts a target url to one that is relative to a given path" />
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new formatter that will output HTML" />
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(blank_line)" doc="Adds +blank_line+ to the output" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" doc="Adds +heading+ to the output" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" doc="Finishes consumption of +list+" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" doc="Finishes consumption of +list_item+" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" doc="Prepares the visitor for consuming +list_item+" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" doc="Prepares the visitor for consuming +list+" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" doc="Adds +paragraph+ to the output" />
            <scope name="accept_raw" ilk="function" signature="accept_raw(raw)" doc="Adds +raw+ to the output" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(rule)" doc="Adds +rule+ to the output" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(verbatim)" doc="Adds +verbatim+ to the output" />
            <scope name="convert_string" ilk="function" signature="convert_string(text)" doc="CGI escapes +text+" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" doc="Returns the generated output" />
            <scope name="gen_url" ilk="function" signature="gen_url(url, text)" doc="Generate a link for +url+, labeled with +text+.  Handles the special cases for img: and link: described under handle_special_HYPERLINK" />
            <scope name="handle_special_HYPERLINK" ilk="function" signature="handle_special_HYPERLINK(special)" doc="+special+ is a potential link.  The following schemes are handled: &#xA; Inserted as-is.&#xA;Links are checked to see if they reference an image. If so, that image gets inserted using an &lt;img&gt; tag. Otherwise a conventional &lt;a href&gt; is used.&#xA;Reference to a local file relative to the output directory." />
            <scope name="handle_special_TIDYLINK" ilk="function" signature="handle_special_TIDYLINK(special)" doc="This +special+ is a link where the label is different from the URL label[url] or {long label}[url]" />
            <scope name="html_list_name" ilk="function" signature="html_list_name(list_type, open_tag)" doc="Determines the HTML list element for +list_type+ and +open_tag+" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to HTML tags" />
            <scope name="list_end_for" ilk="function" signature="list_end_for(list_type)" doc="Returns the HTML end-tag for +list_type+" />
            <scope name="list_item_start" ilk="function" signature="list_item_start(list_item, list_type)" doc="Returns the HTML tag for +list_type+, possible using a label from +list_item+" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" doc="Prepares the visitor for HTML generation" />
            <scope name="to_html" ilk="function" signature="to_html(item)" doc="Converts +item+ to HTML using RDoc::Text#to_html" />
            <scope ilk="function" name="from_path" />
            <scope ilk="function" name="from_path=" />
            <variable name="LIST_TYPE_TO_HTML" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_html_crossref" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToHtmlCrossref" ilk="class" classrefs="RDoc::Markup::ToHtml">
            <scope name="new" ilk="function" signature="new(from_path, context, show_hash, hyperlink_all = false, markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new crossref resolver that generates links relative to +context+ which lives at +from_path+ in the generated files.  &apos;#&apos; characters on references are removed unless +show_hash+ is true.  Only method names preceded by &apos;#&apos; or &apos;::&apos; are linked, unless +hyperlink_all+ is true." />
            <scope name="cross_reference" ilk="function" signature="cross_reference(name, text = nil)" doc="Creates a link to the reference +name+ if the name exists.  If +text+ is given it is used as the link text, otherwise +name+ is used." />
            <scope name="gen_url" ilk="function" signature="gen_url(url, text)" doc="Generates links for rdoc-ref: scheme URLs and allows RDoc::Markup::ToHtml to handle other schemes." />
            <scope name="handle_special_CROSSREF" ilk="function" signature="handle_special_CROSSREF(special)" doc="We&apos;re invoked when any text matches the CROSSREF pattern.  If we find the corresponding reference, generate a link.  If the name we&apos;re looking for contains no punctuation, we look for it up the module/class chain.  For example, ToHtml is found, even without the RDoc::Markup:: prefix, because we look for it in module Markup first." />
            <scope name="handle_special_HYPERLINK" ilk="function" signature="handle_special_HYPERLINK(special)" doc="Handles rdoc-ref: scheme links and allows RDoc::Markup::ToHtml to handle other schemes." />
            <scope name="link" ilk="function" signature="link(name, text)" doc="Creates an HTML link to +name+ with the given +text+." />
            <scope ilk="function" name="context" />
            <scope ilk="function" name="context=" />
            <scope ilk="function" name="show_hash" />
            <scope ilk="function" name="show_hash=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_rdoc" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToRdoc" ilk="class" classrefs="RDoc::Markup::Formatter">
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new formatter that will output (mostly) \RDoc markup" />
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(blank_line)" doc="Adds +blank_line+ to the output" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(heading)" doc="Adds +heading+ to the output" />
            <scope name="accept_indented_paragraph" ilk="function" signature="accept_indented_paragraph(paragraph)" doc="Adds +paragraph+ to the output" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" doc="Finishes consumption of +list+" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(list_item)" doc="Finishes consumption of +list_item+" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" doc="Prepares the visitor for consuming +list_item+" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" doc="Prepares the visitor for consuming +list+" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" doc="Adds +paragraph+ to the output" />
            <scope name="accept_raw" ilk="function" signature="accept_raw(raw)" doc="Adds +raw+ to the output" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(rule)" doc="Adds +rule+ to the output" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(verbatim)" doc="Outputs +verbatim+ indented 2 columns" />
            <scope name="attributes" ilk="function" signature="attributes(text)" doc="Applies attribute-specific markup to +text+ using RDoc::AttributeManager" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" doc="Returns the generated output" />
            <scope name="handle_special_SUPPRESSED_CROSSREF" ilk="function" signature="handle_special_SUPPRESSED_CROSSREF(special)" doc="Removes preceding \\ from the suppressed crossref +special+" />
            <scope name="init_tags" ilk="function" signature="init_tags()" doc="Maps attributes to HTML sequences" />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" doc="Prepares the visitor for text generation" />
            <scope name="use_prefix" ilk="function" signature="use_prefix()" doc="Adds the stored #prefix to the output and clears it.  Lists generate a prefix for later consumption." />
            <scope name="wrap" ilk="function" signature="wrap(text)" doc="Wraps +text+ to #width" />
            <scope ilk="function" name="indent" />
            <scope ilk="function" name="indent=" />
            <scope ilk="function" name="list_index" />
            <scope ilk="function" name="list_type" />
            <scope ilk="function" name="list_width" />
            <scope ilk="function" name="prefix" />
            <scope ilk="function" name="res" />
            <scope ilk="function" name="width" />
            <scope ilk="function" name="width=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_test" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToTest" ilk="class" classrefs="RDoc::Markup::Formatter">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/to_tt_only" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="ToTtOnly" ilk="class" classrefs="RDoc::Markup::Formatter">
            <scope name="new" ilk="function" signature="new(markup = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new tt-only formatter." />
            <scope name="accept_blank_line" ilk="function" signature="accept_blank_line(markup_item)" />
            <scope name="accept_heading" ilk="function" signature="accept_heading(markup_item)" />
            <scope name="accept_list_end" ilk="function" signature="accept_list_end(list)" doc="Pops the list type for +list+ from #list_type" />
            <scope name="accept_list_item_end" ilk="function" signature="accept_list_item_end(markup_item)" />
            <scope name="accept_list_item_start" ilk="function" signature="accept_list_item_start(list_item)" doc="Prepares the visitor for consuming +list_item+" />
            <scope name="accept_list_start" ilk="function" signature="accept_list_start(list)" doc="Pushes the list type for +list+ onto #list_type" />
            <scope name="accept_paragraph" ilk="function" signature="accept_paragraph(paragraph)" doc="Adds +paragraph+ to the output" />
            <scope name="accept_raw" ilk="function" signature="accept_raw(markup_item)" />
            <scope name="accept_rule" ilk="function" signature="accept_rule(markup_item)" />
            <scope name="accept_verbatim" ilk="function" signature="accept_verbatim(markup_item)" />
            <scope name="do_nothing" ilk="function" signature="do_nothing(markup_item)" doc="Does nothing to +markup_item+ because it doesn&apos;t have any user-built content" />
            <scope name="end_accepting" ilk="function" signature="end_accepting()" doc="Returns an Array of items that were wrapped in plus, tt or code." />
            <scope name="start_accepting" ilk="function" signature="start_accepting()" doc="Prepares the visitor for gathering tt sections" />
            <scope name="tt_sections" ilk="function" signature="tt_sections(text)" doc="Extracts tt sections from +text+" />
            <scope ilk="function" name="list_type" />
            <scope ilk="function" name="res" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/markup/verbatim" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Markup" ilk="namespace">
          <scope name="Verbatim" ilk="class" classrefs="RDoc::Markup::Raw">
            <scope name="accept" ilk="function" signature="accept(visitor)" doc="Calls #accept_verbatim on +visitor+" />
            <scope name="normalize" ilk="function" signature="normalize()" doc="Collapses 3+ newlines into two newlines" />
            <scope name="text" ilk="function" signature="text()" doc="The text of the section" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/meta_method" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="MetaMethod" ilk="class" classrefs="RDoc::AnyMethod">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/method_attr" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="MethodAttr" ilk="class" classrefs="RDoc::CodeObject">
          <import symbol="Comparable" />
          <scope name="new" ilk="function" signature="new(text, name)" attributes="__classmethod__ __ctor__" doc="Creates a new MethodAttr from token stream +text+ and method or attribute name +name+. &#xA; Usually this is called by super from a subclass." />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias, context)" doc="Abstract method. Contexts in their building phase call this to register a new alias for this known method/attribute. &#xA; creates a new AnyMethod/Attribute +newa+ named an_alias.new_name;&#xA;adds +self+ as +newa.is_alias_for+;&#xA;adds +newa+ to #aliases&#xA;adds +newa+ to the methods/attributes of +context+." />
          <scope name="aref" ilk="function" signature="aref()" doc="HTML fragment reference for this method" />
          <scope name="aref_prefix" ilk="function" signature="aref_prefix()" doc="Prefix for +aref+, defined by subclasses." />
          <scope name="block_params=" ilk="function" signature="block_params=(value)" doc="Attempts to sanitize the content passed by the ruby parser: remove outer parentheses, etc." />
          <scope name="documented?" ilk="function" signature="documented?()" doc="A method/attribute is documented if any of the following is true: it was marked with :nodoc:;&#xA;it has a comment;&#xA;it is an alias for a documented method;&#xA;it has a +#see+ method that is documented." />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Full method/attribute name including namespace" />
          <scope name="html_name" ilk="function" signature="html_name()" doc="HTML id-friendly method/attribute name" />
          <scope name="name_prefix" ilk="function" signature="name_prefix()" doc="&apos;::&apos; for a class method/attribute, &apos;#&apos; for an instance method." />
          <scope name="parent_name" ilk="function" signature="parent_name()" doc="Name of our parent with special handling for un-marshaled methods" />
          <scope name="path" ilk="function" signature="path()" doc="Path to this method" />
          <scope name="pretty_name" ilk="function" signature="pretty_name()" doc="Method/attribute name with class/instance indicator" />
          <scope name="see" ilk="function" signature="see()" doc="A method/attribute to look at, in particular if this method/attribute has no documentation. &#xA; It can be a method/attribute of the superclass or of an included module, including the Kernel module, which is always appended to the included modules. &#xA; Returns +nil+ if there is no such method/attribute. The +#is_alias_for+ method/attribute, if any, is not included. &#xA; Templates may generate a &quot;see also ...&quot; if this method/attribute has documentation, and &quot;see ...&quot; if it does not." />
          <scope name="type" ilk="function" signature="type()" doc="Type of method/attribute (class or instance)" />
          <scope ilk="function" name="aliases" />
          <scope ilk="function" name="arglists" />
          <scope ilk="function" name="block_params" />
          <scope ilk="function" name="call_seq" />
          <scope ilk="function" name="call_seq=" />
          <scope ilk="function" name="is_alias_for" />
          <scope ilk="function" name="is_alias_for=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="param_seq" />
          <scope ilk="function" name="params" />
          <scope ilk="function" name="params=" />
          <scope ilk="function" name="singleton" />
          <scope ilk="function" name="singleton=" />
          <scope ilk="function" name="text" />
          <scope ilk="function" name="visibility" />
          <scope ilk="function" name="visibility=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/normal_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="NormalClass" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="ancestors" ilk="function" signature="ancestors()" doc="Appends the superclass, if any, to the included modules." />
          <scope name="definition" ilk="function" signature="definition()" doc="The definition of this class, class MyClassName" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/normal_module" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="NormalModule" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="definition" ilk="function" signature="definition()" doc="The definition of this module, module MyModuleName" />
          <scope name="module?" ilk="function" signature="module?()" doc="This is a module, returns true" />
          <scope name="superclass" ilk="function" signature="superclass()" doc="Modules don&apos;t have one, raises NoMethodError" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/options" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Options" ilk="class" classrefs="Object">
          <scope name="check_files" ilk="function" signature="check_files()" doc="Check that the files on the command line exist" />
          <scope name="check_generator" ilk="function" signature="check_generator()" doc="Ensure only one generator is loaded" />
          <scope name="default_title=" ilk="function" signature="default_title=(string)" doc="Set the title, but only if not already set. Used to set the title from a source file, so that a title set from the command line will have the priority." />
          <scope name="finish" ilk="function" signature="finish()" doc="Completes any unfinished option setup business such as filtering for existent files, creating a regexp for #exclude and setting a default #template." />
          <scope name="generator_descriptions" ilk="function" signature="generator_descriptions()" doc="Returns a properly-space list of generators and their descriptions." />
          <scope name="parse" ilk="function" signature="parse(argv)" doc="Parses command line options." />
          <scope name="quiet" ilk="function" signature="quiet()" doc="Don&apos;t display progress as we process the files" />
          <scope name="quiet=" ilk="function" signature="quiet=(bool)" doc="Set quietness to +bool+" />
          <scope name="setup_generator" ilk="function" signature="setup_generator(generator_name = @generator_name)" doc="Set up an output generator for the named +generator_name+. &#xA; If the found generator responds to :setup_options it will be called with the options instance.  This allows generators to add custom options or set default options." />
          <scope name="template_dir_for" ilk="function" signature="template_dir_for(template)" doc="Finds the template dir for +template+" />
          <scope ilk="function" name="charset" />
          <scope ilk="function" name="charset=" />
          <scope ilk="function" name="coverage_report" />
          <scope ilk="function" name="coverage_report=" />
          <scope ilk="function" name="dry_run" />
          <scope ilk="function" name="dry_run=" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="encoding=" />
          <scope ilk="function" name="exclude" />
          <scope ilk="function" name="exclude=" />
          <scope ilk="function" name="files" />
          <scope ilk="function" name="files=" />
          <scope ilk="function" name="force_output" />
          <scope ilk="function" name="force_output=" />
          <scope ilk="function" name="force_update" />
          <scope ilk="function" name="force_update=" />
          <scope ilk="function" name="formatter" />
          <scope ilk="function" name="formatter=" />
          <scope ilk="function" name="generator" />
          <scope ilk="function" name="generator=" />
          <scope ilk="function" name="generator_options" />
          <scope ilk="function" name="generator_options=" />
          <scope ilk="function" name="hyperlink_all" />
          <scope ilk="function" name="hyperlink_all=" />
          <scope ilk="function" name="line_numbers" />
          <scope ilk="function" name="line_numbers=" />
          <scope ilk="function" name="main_page" />
          <scope ilk="function" name="main_page=" />
          <scope ilk="function" name="op_dir" />
          <scope ilk="function" name="op_dir=" />
          <scope ilk="function" name="option_parser" />
          <scope ilk="function" name="option_parser=" />
          <scope ilk="function" name="pipe" />
          <scope ilk="function" name="pipe=" />
          <scope ilk="function" name="rdoc_include" />
          <scope ilk="function" name="rdoc_include=" />
          <scope ilk="function" name="show_hash" />
          <scope ilk="function" name="show_hash=" />
          <scope ilk="function" name="tab_width" />
          <scope ilk="function" name="tab_width=" />
          <scope ilk="function" name="template" />
          <scope ilk="function" name="template=" />
          <scope ilk="function" name="template_dir" />
          <scope ilk="function" name="template_dir=" />
          <scope ilk="function" name="title" />
          <scope ilk="function" name="title=" />
          <scope ilk="function" name="update_output_dir" />
          <scope ilk="function" name="update_output_dir=" />
          <scope ilk="function" name="verbosity" />
          <scope ilk="function" name="verbosity=" />
          <scope ilk="function" name="visibility" />
          <scope ilk="function" name="visibility=" />
          <scope ilk="function" name="webcvs" />
          <scope ilk="function" name="webcvs=" />
          <variable name="DEPRECATED" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="alias_extension" ilk="function" signature="alias_extension(old_ext, new_ext)" attributes="__classmethod__" doc="Alias an extension to another extension. After this call, files ending &quot;new_ext&quot; will be parsed using the same parser as &quot;old_ext&quot;" />
          <scope name="binary?" ilk="function" signature="binary?(file)" attributes="__classmethod__" doc="Determines if the file is a &quot;binary&quot; file which basically means it has content that an RDoc parser shouldn&apos;t try to consume." />
          <scope name="can_parse" ilk="function" signature="can_parse(file_name)" attributes="__classmethod__" doc="Return a parser that can handle a particular extension" />
          <scope name="for" ilk="function" signature="for(top_level, file_name, body, options, stats)" attributes="__classmethod__" doc="Find the correct parser for a particular file name. Return a SimpleParser for ones that we don&apos;t know" />
          <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Creates a new Parser storing +top_level+, +file_name+, +content+, +options+ and +stats+ in instance variables. &#xA; Usually invoked by +super+" />
          <scope name="parse_files_matching" ilk="function" signature="parse_files_matching(regexp)" attributes="__classmethod__" doc="Record which file types this parser can understand. &#xA; It is ok to call this multiple times." />
          <scope name="process_directive" ilk="function" signature="process_directive(code_object, directive, value)" attributes="__classmethod__" doc="Processes common directives for CodeObjects for the C and Ruby parsers. &#xA; Applies +directive+&apos;s +value+ to +code_object+, if appropriate" />
          <scope name="zip?" ilk="function" signature="zip?(file)" attributes="__classmethod__" doc="Checks if +file+ is a zip file in disguise.  Signatures from http://www.garykessler.net/library/file_sigs.html" />
          <scope ilk="function" name="parsers" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/c" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="C" ilk="class" classrefs="RDoc::Parser">
            <import symbol="RDoc::Text" />
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Prepare to parse a C file" />
            <scope name="reset" ilk="function" signature="reset()" attributes="__classmethod__" doc="Resets cross-file state.  Call when parsing different projects that need separate documentation." />
            <scope name="do_aliases" ilk="function" signature="do_aliases()" doc="Scans #content for rb_define_alias" />
            <scope name="do_attrs" ilk="function" signature="do_attrs()" doc="Scans #content for rb_attr and rb_define_attr" />
            <scope name="do_classes" ilk="function" signature="do_classes()" doc="Scans #content for rb_define_module, rb_define_class, boot_defclass, rb_define_module_under, rb_define_class_under and rb_singleton_class" />
            <scope name="do_constants" ilk="function" signature="do_constants()" doc="Scans #content for rb_define_variable, rb_define_readonly_variable, rb_define_const and rb_define_global_const" />
            <scope name="do_includes" ilk="function" signature="do_includes()" doc="Scans #content for rb_include_module" />
            <scope name="do_methods" ilk="function" signature="do_methods()" doc="Scans #content for rb_define_method, rb_define_singleton_method, rb_define_module_function, rb_define_private_method, rb_define_global_function and define_filetest_function" />
            <scope name="find_alias_comment" ilk="function" signature="find_alias_comment(class_name, new_name, old_name)" doc="Finds the comment for an alias on +class_name+ from +new_name+ to +old_name+" />
            <scope name="find_attr_comment" ilk="function" signature="find_attr_comment(var_name, attr_name, read = nil, write = nil)" doc="Finds a comment for rb_define_attr, rb_attr or Document-attr. &#xA; +var_name+ is the C class variable the attribute is defined on. +attr_name+ is the attribute&apos;s name. &#xA; +read+ and +write+ are the read/write flags (&apos;1&apos; or &apos;0&apos;).  Either both or neither must be provided." />
            <scope name="find_body" ilk="function" signature="find_body(class_name, meth_name, meth_obj, file_content, quiet = false)" doc="Find the C code corresponding to a Ruby method" />
            <scope name="find_class" ilk="function" signature="find_class(raw_name, name)" doc="Finds a RDoc::NormalClass or RDoc::NormalModule for +raw_name+" />
            <scope name="find_class_comment" ilk="function" signature="find_class_comment(class_name, class_mod)" doc="Look for class or module documentation above Init_+class_name+(void), in a Document-class +class_name+ (or module) comment or above an rb_define_class (or module).  If a comment is supplied above a matching Init_ and a rb_define_class the Init_ comment is used. &#xA; /*&#xA; * This is a comment for Foo&#xA; */&#xA;Init_Foo(void) {&#xA;    VALUE cFoo = rb_define_class(&quot;Foo&quot;, rb_cObject);&#xA;}&#xA;/*&#xA; * Document-class: Foo&#xA; * This is a comment for Foo&#xA; */&#xA;Init_foo(void) {&#xA;    VALUE cFoo = rb_define_class(&quot;Foo&quot;, rb_cObject);" />
            <scope name="find_const_comment" ilk="function" signature="find_const_comment(type, const_name, class_name = nil)" doc="Finds a comment matching +type+ and +const_name+ either above the comment or in the matching Document- section." />
            <scope name="find_modifiers" ilk="function" signature="find_modifiers(comment, meth_obj)" doc="Handles modifiers in +comment+ and updates +meth_obj+ as appropriate. &#xA; If :nodoc: is found, documentation on +meth_obj+ is suppressed. &#xA; If :yields: is followed by an argument list it is used for the #block_params of +meth_obj+. &#xA; If the comment block contains a  call-seq:&#xA;   ARGF.readlines(sep=$/)     -&gt; array&#xA;   ARGF.readlines(limit)      -&gt; array&#xA;   ARGF.readlines(sep, limit) -&gt; array&#xA;&#xA;   ARGF.to_a(sep=$/)     -&gt; array&#xA;   ARGF.to_a(limit)      -&gt; array&#xA;   ARGF.to_a(sep, limit) -&gt; array&#xA; it is used for the parameters of +meth_obj+." />
            <scope name="find_override_comment" ilk="function" signature="find_override_comment(class_name, meth_obj)" doc="Finds a Document-method override for +meth_obj+ on +class_name+" />
            <scope name="handle_attr" ilk="function" signature="handle_attr(var_name, attr_name, read, write)" doc="Creates a new RDoc::Attr +attr_name+ on class +var_name+ that is either +read+, +write+ or both" />
            <scope name="handle_class_module" ilk="function" signature="handle_class_module(var_name, type, class_name, parent, in_module)" doc="Creates a new RDoc::NormalClass or RDoc::NormalModule based on +type+ named +class_name+ in +parent+ which was assigned to the C +var_name+." />
            <scope name="handle_constants" ilk="function" signature="handle_constants(type, var_name, const_name, definition)" doc="Adds constants.  By providing some_value: at the start of the comment you can override the C value of the comment to give a friendly definition. &#xA; /* 300: The perfect score in bowling */&#xA;rb_define_const(cFoo, &quot;PERFECT&quot;, INT2FIX(300);&#xA; Will override INT2FIX(300) with the value +300+ in the output RDoc.  Values may include quotes and escaped colons (\:)." />
            <scope name="handle_ifdefs_in" ilk="function" signature="handle_ifdefs_in(body)" doc="Removes #ifdefs that would otherwise confuse us" />
            <scope name="handle_method" ilk="function" signature="handle_method(type, var_name, meth_name, function, param_count, source_file = nil)" doc="Adds an RDoc::AnyMethod +meth_name+ defined on a class or module assigned to +var_name+.  +type+ is the type of method definition function used. +singleton_method+ and +module_function+ create a singleton method." />
            <scope name="handle_singleton" ilk="function" signature="handle_singleton(sclass_var, class_var)" doc="Registers a singleton class +sclass_var+ as a singleton of +class_var+" />
            <scope name="handle_tab_width" ilk="function" signature="handle_tab_width(body)" doc="Normalizes tabs in +body+" />
            <scope name="look_for_directives_in" ilk="function" signature="look_for_directives_in(context, comment)" doc="Look for directives in a normal comment block: &#xA; /*&#xA; * :title: My Awesome Project&#xA; */&#xA; This method modifies the +comment+" />
            <scope name="rb_scan_args" ilk="function" signature="rb_scan_args(method_body)" doc="Extracts parameters from the +method_body+ and returns a method parameter string.  Follows 1.9.3dev&apos;s scan-arg-spec, see README.EXT" />
            <scope name="remove_commented_out_lines" ilk="function" signature="remove_commented_out_lines()" doc="Removes lines that are commented out that might otherwise get picked up when scanning for classes and methods" />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(comment)" doc="Removes private comments from +comment+" />
            <scope name="scan" ilk="function" signature="scan()" doc="Extracts the classes, modules, methods, attributes, constants and aliases from a C file and returns an RDoc::TopLevel for this file" />
            <scope ilk="function" name="content" />
            <scope ilk="function" name="content=" />
            <scope ilk="function" name="known_classes" />
            <scope ilk="function" name="singleton_classes" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/ruby" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="Ruby" ilk="class" classrefs="RDoc::Parser">
            <import symbol="RDoc::Parser::RubyTools" />
            <import symbol="RDoc::RubyToken" />
            <import symbol="RDoc::TokenStream" />
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Creates a new Ruby parser." />
            <scope name="collect_first_comment" ilk="function" signature="collect_first_comment()" doc="Look for the first comment in a file that isn&apos;t a shebang line." />
            <scope name="error" ilk="function" signature="error(msg)" doc="Aborts with +msg+" />
            <scope name="extract_call_seq" ilk="function" signature="extract_call_seq(comment, meth)" doc="Look for a &apos;call-seq&apos; in the comment, and override the normal parameter stuff" />
            <scope name="get_bool" ilk="function" signature="get_bool()" doc="Looks for a true or false token.  Returns false if TkFALSE or TkNIL are found." />
            <scope name="get_class_or_module" ilk="function" signature="get_class_or_module(container)" doc="or&#xA;separated named) and return the ultimate name, the associated container, and the given name (with the ::)." />
            <scope name="get_class_specification" ilk="function" signature="get_class_specification()" doc="Return a superclass, which can be either a constant of an expression" />
            <scope name="get_constant" ilk="function" signature="get_constant()" doc="Parse a constant, which might be qualified by one or more class or module names" />
            <scope name="get_constant_with_optional_parens" ilk="function" signature="get_constant_with_optional_parens()" doc="Get a constant that may be surrounded by parens" />
            <scope name="get_symbol_or_name" ilk="function" signature="get_symbol_or_name()" doc="Extracts a name or symbol from the token stream." />
            <scope name="look_for_directives_in" ilk="function" signature="look_for_directives_in(context, comment)" doc="Look for directives in a normal comment block: &#xA; # :stopdoc:&#xA;# Don&apos;t display comment from this point forward&#xA; This routine modifies its +comment+ parameter." />
            <scope name="make_message" ilk="function" signature="make_message(message)" doc="Adds useful info about the parser to +message+" />
            <scope name="parse_alias" ilk="function" signature="parse_alias(context, single, tk, comment)" doc="Parses an +alias+ in +context+ with +comment+" />
            <scope name="parse_attr" ilk="function" signature="parse_attr(context, single, tk, comment)" doc="Creates an RDoc::Attr for the name following +tk+, setting the comment to +comment+." />
            <scope name="parse_attr_accessor" ilk="function" signature="parse_attr_accessor(context, single, tk, comment)" doc="Creates an RDoc::Attr for each attribute listed after +tk+, setting the comment for each to +comment+." />
            <scope name="parse_call_parameters" ilk="function" signature="parse_call_parameters(tk)" doc="Extracts call parameters from the token stream." />
            <scope name="parse_class" ilk="function" signature="parse_class(container, single, tk, comment)" doc="Parses a class in +context+ with +comment+" />
            <scope name="parse_comment" ilk="function" signature="parse_comment(container, tk, comment)" doc="Generates an RDoc::Method or RDoc::Attr from +comment+ by looking for :method: or :attr: directives in +comment+." />
            <scope name="parse_constant" ilk="function" signature="parse_constant(container, tk, comment)" doc="Parses a constant in +context+ with +comment+" />
            <scope name="parse_include" ilk="function" signature="parse_include(context, comment)" doc="Parses an +include+ in +context+ with +comment+" />
            <scope name="parse_meta_attr" ilk="function" signature="parse_meta_attr(context, single, tk, comment)" doc="Parses a meta-programmed attribute and creates an RDoc::Attr. &#xA; To create foo and bar attributes on class C with comment &quot;My attributes&quot;: &#xA; class C&#xA;  ##&#xA;  # :attr:&#xA;  #&#xA;  # My attributes&#xA;  my_attr :foo, :bar&#xA;end&#xA; To create a foo attribute on class C with comment &quot;My attribute&quot;: &#xA; class C&#xA;  ##&#xA;  # :attr: foo" />
            <scope name="parse_meta_method" ilk="function" signature="parse_meta_method(container, single, tk, comment)" doc="Parses a meta-programmed method" />
            <scope name="parse_method" ilk="function" signature="parse_method(container, single, tk, comment)" doc="Parses a normal method defined by +def+" />
            <scope name="parse_method_or_yield_parameters" ilk="function" signature="parse_method_or_yield_parameters(method = nil, modifiers = RDoc::METHOD_MODIFIERS)" doc="Extracts +yield+ parameters from +method+" />
            <scope name="parse_method_parameters" ilk="function" signature="parse_method_parameters(method)" doc="Capture the method&apos;s parameters. Along the way, look for a comment containing: &#xA; # yields: ....&#xA; and add this as the block_params for the method" />
            <scope name="parse_module" ilk="function" signature="parse_module(container, single, tk, comment)" doc="Parses an RDoc::NormalModule in +container+ with +comment+" />
            <scope name="parse_require" ilk="function" signature="parse_require(context, comment)" doc="Parses an RDoc::Require in +context+ containing +comment+" />
            <scope name="parse_statements" ilk="function" signature="parse_statements(container, single = NORMAL, current_method = nil, comment = &apos;&apos;)" doc="The core of the ruby parser." />
            <scope name="parse_symbol_arg" ilk="function" signature="parse_symbol_arg(no = nil)" doc="Parse up to +no+ symbol arguments" />
            <scope name="parse_symbol_in_arg" ilk="function" signature="parse_symbol_in_arg()" doc="Returns symbol text from the next token" />
            <scope name="parse_top_level_statements" ilk="function" signature="parse_top_level_statements(container)" doc="Parses statements in the top-level +container+" />
            <scope name="parse_visibility" ilk="function" signature="parse_visibility(container, single, tk)" doc="Determines the visibility in +container+ from +tk+" />
            <scope name="parse_yield" ilk="function" signature="parse_yield(context, single, tk, method)" doc="Determines the block parameter for +context+" />
            <scope name="read_directive" ilk="function" signature="read_directive(allowed)" doc="Directives are modifier comments that can appear after class, module, or method names. For example: &#xA; def fred # :yields: a, b&#xA; or: &#xA; class MyClass # :nodoc:&#xA; We return the directive name and any parameters as a two element array" />
            <scope name="read_documentation_modifiers" ilk="function" signature="read_documentation_modifiers(context, allow)" doc="Handles the directive for +context+ if the directive is listed in +allow+. This method is called for directives following a definition." />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(comment)" doc="Removes private comments from +comment+" />
            <scope name="scan" ilk="function" signature="scan()" doc="Scans this ruby file for ruby constructs" />
            <scope name="skip_for_variable" ilk="function" signature="skip_for_variable()" doc="skip the var [in] part of a &apos;for&apos; statement" />
            <scope name="skip_method" ilk="function" signature="skip_method(container)" doc="Skips the next method in +container+" />
            <scope name="skip_optional_do_after_expression" ilk="function" signature="skip_optional_do_after_expression()" doc="while, until, and for have an optional do" />
            <scope name="skip_tkspace_comment" ilk="function" signature="skip_tkspace_comment(skip_nl = true)" doc="Skip spaces until a comment is found" />
            <scope name="warn" ilk="function" signature="warn(msg)" doc="Prints +msg+ to +$stderr+ unless we&apos;re being quiet" />
            <variable name="NORMAL" attributes="__const__" citdl="Object" />
            <variable name="SINGLE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/ruby_tools" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="RubyTools" ilk="namespace">
            <import symbol="RDoc::RubyToken" />
            <scope name="add_token_listener" ilk="function" signature="add_token_listener(obj)" doc="Adds a token listener +obj+, but you should probably use token_listener" />
            <scope name="get_tk" ilk="function" signature="get_tk()" doc="Fetches the next token from the scanner" />
            <scope name="get_tk_until" ilk="function" signature="get_tk_until(*tokens)" doc="Reads and returns all tokens up to one of +tokens+.  Leaves the matched token in the token list." />
            <scope name="get_tkread" ilk="function" signature="get_tkread()" doc="Retrieves a String representation of the read tokens" />
            <scope name="peek_read" ilk="function" signature="peek_read()" doc="Peek equivalent for get_tkread" />
            <scope name="peek_tk" ilk="function" signature="peek_tk()" doc="Peek at the next token, but don&apos;t remove it from the stream" />
            <scope name="remove_token_listener" ilk="function" signature="remove_token_listener(obj)" doc="Removes the token listener +obj+" />
            <scope name="reset" ilk="function" signature="reset()" doc="Resets the tools" />
            <scope name="skip_tkspace" ilk="function" signature="skip_tkspace(skip_nl = true)" doc="Skips whitespace tokens including newlines if +skip_nl+ is true" />
            <scope name="token_listener" ilk="function" signature="token_listener(obj)" doc="Has +obj+ listen to tokens" />
            <scope name="unget_tk" ilk="function" signature="unget_tk(tk)" doc="Returns +tk+ to the scanner" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/parser/simple" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Parser" ilk="namespace">
          <scope name="Simple" ilk="class" classrefs="RDoc::Parser">
            <scope name="new" ilk="function" signature="new(top_level, file_name, content, options, stats)" attributes="__classmethod__ __ctor__" doc="Prepare to parse a plain file" />
            <scope name="remove_coding_comment" ilk="function" signature="remove_coding_comment(text)" doc="Removes the encoding magic comment from +text+" />
            <scope name="remove_private_comments" ilk="function" signature="remove_private_comments(text)" doc="Removes comments wrapped in --/++" />
            <scope name="scan" ilk="function" signature="scan()" doc="Extract the file contents and attach them to the TopLevel as a comment" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/rdoc" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RDoc" ilk="class" classrefs="Object">
          <scope name="add_generator" ilk="function" signature="add_generator(klass)" attributes="__classmethod__" doc="Add +klass+ that can generate output after parsing" />
          <scope name="current" ilk="function" signature="current()" attributes="__classmethod__" doc="Active RDoc::RDoc instance" />
          <scope name="current=" ilk="function" signature="current=(rdoc)" attributes="__classmethod__" doc="Sets the active RDoc::RDoc instance" />
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" doc="Creates a new RDoc::RDoc instance.  Call #document to parse files and generate documentation." />
          <scope name="reset" ilk="function" signature="reset()" attributes="__classmethod__" doc="Resets all internal state" />
          <scope name="document" ilk="function" signature="document(options)" doc="Generates documentation or a coverage report depending upon the settings in +options+. &#xA; +options+ can be either an RDoc::Options instance or an array of strings equivalent to the strings that would be passed on the command line like %w[-q -o doc -t My\ Doc\ Title].  #document will automatically call RDoc::Options#finish if an options instance was given. &#xA; For a list of options, see either RDoc::Options or rdoc --help. &#xA; By default, output will be stored in a directory called &quot;doc&quot; below the current directory, so make sure you&apos;re somewhere writable before invoking." />
          <scope name="error" ilk="function" signature="error(msg)" doc="Report an error message and exit" />
          <scope name="gather_files" ilk="function" signature="gather_files(files)" doc="Gathers a set of parseable files from the files and directories listed in +files+." />
          <scope name="generate" ilk="function" signature="generate(file_info)" doc="Generates documentation for +file_info+ (from #parse_files) into the output dir using the generator selected by the RDoc options" />
          <scope name="handle_pipe" ilk="function" signature="handle_pipe()" doc="Turns RDoc from stdin into HTML" />
          <scope name="install_siginfo_handler" ilk="function" signature="install_siginfo_handler()" doc="Installs a siginfo handler that prints the current filename." />
          <scope name="list_files_in_directory" ilk="function" signature="list_files_in_directory(dir)" doc="Return a list of the files to be processed in a directory. We know that this directory doesn&apos;t have a .document file, so we&apos;re looking for real files. However we may well contain subdirectories which must be tested for .document files." />
          <scope name="normalized_file_list" ilk="function" signature="normalized_file_list(relative_files, force_doc = false, exclude_pattern = nil)" doc="Given a list of files and directories, create a list of all the Ruby files they contain. &#xA; If +force_doc+ is true we always add the given files, if false, only add files that we guarantee we can parse.  It is true when looking at files given on the command line, false when recursing through subdirectories. &#xA; The effect of this is that if you want a file with a non-standard extension parsed, you must name it explicitly." />
          <scope name="output_flag_file" ilk="function" signature="output_flag_file(op_dir)" doc="Return the path name of the flag file in an output directory." />
          <scope name="parse_dot_doc_file" ilk="function" signature="parse_dot_doc_file(in_dir, filename)" doc="The .document file contains a list of file and directory name patterns, representing candidates for documentation. It may also contain comments (starting with &apos;#&apos;)" />
          <scope name="parse_file" ilk="function" signature="parse_file(filename)" doc="Parses +filename+ and returns an RDoc::TopLevel" />
          <scope name="parse_files" ilk="function" signature="parse_files(files)" doc="Parse each file on the command line, recursively entering directories." />
          <scope name="remove_siginfo_handler" ilk="function" signature="remove_siginfo_handler()" doc="Removes a siginfo handler and replaces the previous" />
          <scope name="remove_unparseable" ilk="function" signature="remove_unparseable(files)" doc="Removes file extensions known to be unparseable from +files+" />
          <scope name="setup_output_dir" ilk="function" signature="setup_output_dir(dir, force)" doc="Create an output dir if it doesn&apos;t exist. If it does exist, but doesn&apos;t contain the flag file created.rid then we refuse to use it, as we may clobber some manually generated documentation" />
          <scope name="update_output_dir" ilk="function" signature="update_output_dir(op_dir, time, last = {})" doc="Update the flag file in an output directory." />
          <scope ilk="function" name="exclude" />
          <scope ilk="function" name="exclude=" />
          <scope ilk="function" name="generator" />
          <scope ilk="function" name="generator=" />
          <scope ilk="function" name="last_modified" />
          <scope ilk="function" name="options" />
          <scope ilk="function" name="options=" />
          <scope ilk="function" name="stats" />
          <variable name="GENERATORS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/require" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Require" ilk="class" classrefs="RDoc::CodeObject">
          <scope name="new" ilk="function" signature="new(name, comment)" attributes="__classmethod__ __ctor__" doc="Creates a new Require that loads +name+ with +comment+" />
          <scope name="top_level" ilk="function" signature="top_level()" doc="The RDoc::TopLevel corresponding to this require, or +nil+ if not found." />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Error" ilk="class" classrefs="RDoc::Error">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/driver" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Driver" ilk="class" classrefs="Object">
            <scope name="default_options" ilk="function" signature="default_options()" attributes="__classmethod__" doc="Default options for ri" />
            <scope name="dump" ilk="function" signature="dump(data_path)" attributes="__classmethod__" doc="Dump +data_path+ using pp" />
            <scope name="new" ilk="function" signature="new(initial_options = {})" attributes="__classmethod__ __ctor__" doc="Creates a new driver using +initial_options+ from ::process_args" />
            <scope name="process_args" ilk="function" signature="process_args(argv)" attributes="__classmethod__" doc="Parses +argv+ and returns a Hash of options" />
            <scope name="run" ilk="function" signature="run(argv = ARGV)" attributes="__classmethod__" doc="Runs the ri command line executable using +argv+" />
            <scope name="add_also_in" ilk="function" signature="add_also_in(out, also_in)" doc="Adds paths for undocumented classes +also_in+ to +out+" />
            <scope name="add_class" ilk="function" signature="add_class(out, name, classes)" doc="Adds a class header to +out+ for class +name+ which is described in +classes+." />
            <scope name="add_from" ilk="function" signature="add_from(out, store)" doc="Adds &quot;(from ...)&quot; to +out+ for +store+" />
            <scope name="add_includes" ilk="function" signature="add_includes(out, includes)" doc="Adds +includes+ to +out+" />
            <scope name="add_method_list" ilk="function" signature="add_method_list(out, methods, name)" doc="Adds a list of +methods+ to +out+ with a heading of +name+" />
            <scope name="ancestors_of" ilk="function" signature="ancestors_of(klass)" doc="Returns ancestor classes of +klass+" />
            <scope name="class_document" ilk="function" signature="class_document(name, found, klasses, includes)" doc="Builds a RDoc::Markup::Document from +found+, +klasess+ and +includes+" />
            <scope name="classes" ilk="function" signature="classes()" doc="Hash mapping a known class or module to the stores it can be loaded from" />
            <scope name="classes_and_includes_for" ilk="function" signature="classes_and_includes_for(name)" doc="Returns the stores wherin +name+ is found along with the classes and includes that match it" />
            <scope name="complete" ilk="function" signature="complete(name)" doc="Completes +name+ based on the caches.  For Readline" />
            <scope name="display" ilk="function" signature="display(document)" doc="Converts +document+ to text and writes it to the pager" />
            <scope name="display_class" ilk="function" signature="display_class(name)" doc="Outputs formatted RI data for class +name+.  Groups undocumented classes" />
            <scope name="display_method" ilk="function" signature="display_method(name)" doc="Outputs formatted RI data for method +name+" />
            <scope name="display_name" ilk="function" signature="display_name(name)" doc="Outputs formatted RI data for the class or method +name+. &#xA; Returns true if +name+ was found, false if it was not an alternative could be guessed, raises an error if +name+ couldn&apos;t be guessed." />
            <scope name="display_names" ilk="function" signature="display_names(names)" doc="Displays each name in +name+" />
            <scope name="expand_class" ilk="function" signature="expand_class(klass)" doc="Expands abbreviated klass +klass+ into a fully-qualified class.  &quot;Zl::Da&quot; will be expanded to Zlib::DataError." />
            <scope name="expand_name" ilk="function" signature="expand_name(name)" doc="Expands the class portion of +name+ into a fully-qualified class.  See #expand_class." />
            <scope name="filter_methods" ilk="function" signature="filter_methods(found, name)" doc="Filters the methods in +found+ trying to find a match for +name+." />
            <scope name="find_methods" ilk="function" signature="find_methods(name)" doc="Yields items matching +name+ including the store they were found in, the class being searched for, the class they were found in (an ancestor) the types of methods to look up (from #method_type), and the method name being searched for" />
            <scope name="formatter" ilk="function" signature="formatter(io)" doc="Creates a new RDoc::Markup::Formatter.  If a formatter is given with -f, use it.  If we&apos;re outputting to a pager, use bs, otherwise ansi." />
            <scope name="in_path?" ilk="function" signature="in_path?(file)" doc="Is +file+ in ENV[&apos;PATH&apos;]?" />
            <scope name="interactive" ilk="function" signature="interactive()" doc="Runs ri interactively using Readline if it is available." />
            <scope name="list_known_classes" ilk="function" signature="list_known_classes(names = [])" doc="Lists classes known to ri starting with +names+.  If +names+ is empty all known classes are shown." />
            <scope name="list_methods_matching" ilk="function" signature="list_methods_matching(name)" doc="Returns an Array of methods matching +name+" />
            <scope name="load_method" ilk="function" signature="load_method(store, cache, klass, type, name)" doc="Loads RI data for method +name+ on +klass+ from +store+.  +type+ and +cache+ indicate if it is a class or instance method." />
            <scope name="load_methods_matching" ilk="function" signature="load_methods_matching(name)" doc="Returns an Array of RI data for methods matching +name+" />
            <scope name="method_document" ilk="function" signature="method_document(name, filtered)" doc="Builds a RDoc::Markup::Document from +found+, +klasess+ and +includes+" />
            <scope name="method_type" ilk="function" signature="method_type(selector)" doc="Returns the type of method (:both, :instance, :class) for +selector+" />
            <scope name="name_regexp" ilk="function" signature="name_regexp(name)" doc="Returns a regular expression for +name+ that will match an RDoc::AnyMethod&apos;s name." />
            <scope name="page" ilk="function" signature="page()" doc="Paginates output through a pager program." />
            <scope name="paging?" ilk="function" signature="paging?()" doc="Are we using a pager?" />
            <scope name="parse_name" ilk="function" signature="parse_name(name)" doc="Extracts the class, selector and method name parts from +name+ like Foo::Bar#baz. &#xA; NOTE: Given Foo::Bar, Bar is considered a class even though it may be a method" />
            <scope name="run" ilk="function" signature="run()" doc="Looks up and displays ri data according to the options given." />
            <scope name="setup_pager" ilk="function" signature="setup_pager()" doc="Sets up a pager program to pass output through.  Tries the RI_PAGER and PAGER environment variables followed by pager, less then more." />
            <scope ilk="function" name="stores" />
            <scope ilk="function" name="stores=" />
            <scope ilk="function" name="use_stdout" />
            <scope ilk="function" name="use_stdout=" />
            <scope name="Error" ilk="class" classrefs="RDoc::RI::Error">
            </scope>
            <scope name="NotFoundError" ilk="class" classrefs="RDoc::RI::Driver::Error">
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/paths" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Paths" ilk="namespace">
            <scope name="each" ilk="function" signature="each(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Iterates over each selected path yielding the directory and type. &#xA; Yielded types: Where Ruby&apos;s ri data is stored.  Yielded when +system+ is true&#xA;Where ri for installed libraries are stored.  Yielded when +site+ is true.  Normally no ri data is stored here.&#xA;~/.rdoc.  Yielded when +home+ is true.&#xA;ri data for an installed gem.  Yielded when +gems+ is true.&#xA;ri data directory from the command line.  Yielded for each entry in +extra_dirs+" />
            <scope name="gemdirs" ilk="function" signature="gemdirs()" attributes="__classmethod__" doc="The latest installed gems&apos; ri directories" />
            <scope name="path" ilk="function" signature="path(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Returns existing directories from the selected documentation directories as an Array. &#xA; See also ::each" />
            <scope name="raw_path" ilk="function" signature="raw_path(system, site, home, gems, *extra_dirs)" attributes="__classmethod__" doc="Returns selected documentation directories including nonexistent directories. &#xA; See also ::each" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ri/store" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RI" ilk="namespace">
          <scope name="Store" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(path, type = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new Store of +type+ that will load or save to +path+" />
            <scope name="ancestors" ilk="function" signature="ancestors()" doc="Ancestors cache accessor.  Maps a klass name to an Array of its ancestors in this store.  If Foo in this store inherits from Object, Kernel won&apos;t be listed (it will be included from ruby&apos;s ri store)." />
            <scope name="attributes" ilk="function" signature="attributes()" doc="Attributes cache accessor.  Maps a class to an Array of its attributes." />
            <scope name="cache_path" ilk="function" signature="cache_path()" doc="Path to the cache file" />
            <scope name="class_file" ilk="function" signature="class_file(klass_name)" doc="Path to the ri data for +klass_name+" />
            <scope name="class_methods" ilk="function" signature="class_methods()" doc="Class methods cache accessor.  Maps a class to an Array of its class methods (not full name)." />
            <scope name="class_path" ilk="function" signature="class_path(klass_name)" doc="Path where data for +klass_name+ will be stored (methods or class data)" />
            <scope name="friendly_path" ilk="function" signature="friendly_path()" doc="Friendly rendition of #path" />
            <scope name="instance_methods" ilk="function" signature="instance_methods()" doc="Instance methods cache accessor.  Maps a class to an Array of its instance methods (not full name)." />
            <scope name="load_cache" ilk="function" signature="load_cache()" doc="Loads cache file for this store" />
            <scope name="load_class" ilk="function" signature="load_class(klass_name)" doc="Loads ri data for +klass_name+" />
            <scope name="load_method" ilk="function" signature="load_method(klass_name, method_name)" doc="Loads ri data for +method_name+ in +klass_name+" />
            <scope name="method_file" ilk="function" signature="method_file(klass_name, method_name)" doc="Path to the ri data for +method_name+ in +klass_name+" />
            <scope name="modules" ilk="function" signature="modules()" doc="Modules cache accessor.  An Array of all the modules (and classes) in the store." />
            <scope name="save_cache" ilk="function" signature="save_cache()" doc="Writes the cache file for this store" />
            <scope name="save_class" ilk="function" signature="save_class(klass)" doc="Writes the ri data for +klass+" />
            <scope name="save_method" ilk="function" signature="save_method(klass, method)" doc="Writes the ri data for +method+ on +klass+" />
            <scope ilk="function" name="cache" />
            <scope ilk="function" name="dry_run" />
            <scope ilk="function" name="dry_run=" />
            <scope ilk="function" name="encoding" />
            <scope ilk="function" name="encoding=" />
            <scope ilk="function" name="path" />
            <scope ilk="function" name="path=" />
            <scope ilk="function" name="type" />
            <scope ilk="function" name="type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ruby_lex" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RubyLex" ilk="class" classrefs="Object">
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/ruby_token" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RubyToken" ilk="namespace">
          <scope name="TkError" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="TkId" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="TkKW" ilk="class" classrefs="RDoc::RubyToken::TkId">
          </scope>
          <scope name="TkNode" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="TkOPASGN" ilk="class" classrefs="RDoc::RubyToken::TkOp">
          </scope>
          <scope name="TkOp" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="TkSYMBOL" ilk="class" classrefs="Object">
          </scope>
          <scope name="TkUnknownChar" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="TkVal" ilk="class" classrefs="RDoc::RubyToken::Token">
          </scope>
          <scope name="Token" ilk="class" classrefs="Object">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/rubygems_hook" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="RubygemsHook" ilk="class" classrefs="Object">
          <import symbol="Gem::UserInteraction" />
          <scope name="generation_hook" ilk="function" signature="generation_hook(installer, specs)" attributes="__classmethod__" doc="Post installs hook that generates documentation for each specification in +specs+" />
          <scope name="load_rdoc" ilk="function" signature="load_rdoc()" attributes="__classmethod__" doc="Loads the RDoc generator" />
          <scope name="new" ilk="function" signature="new(spec, generate_rdoc = true, generate_ri = true)" attributes="__classmethod__ __ctor__" doc="Creates a new documentation generator for +spec+.  RDoc and ri data generation can be disabled through +generate_rdoc+ and +generate_ri+ respectively." />
          <scope name="delete_legacy_args" ilk="function" signature="delete_legacy_args(args)" doc="Removes legacy rdoc arguments from +args+" />
          <scope name="document" ilk="function" signature="document(generator, options, destination)" doc="Generates documentation using the named +generator+ (&quot;darkfish&quot; or &quot;ri&quot;) and following the given +options+. &#xA; Documentation will be generated into +destination+" />
          <scope name="generate" ilk="function" signature="generate()" doc="Generates RDoc and ri data" />
          <scope name="rdoc_installed?" ilk="function" signature="rdoc_installed?()" doc="Is rdoc documentation installed?" />
          <scope name="remove" ilk="function" signature="remove()" doc="Removes generated RDoc and ri data" />
          <scope name="ri_installed?" ilk="function" signature="ri_installed?()" doc="Is ri data installed?" />
          <scope name="setup" ilk="function" signature="setup()" doc="Prepares the spec for documentation generation" />
          <scope ilk="function" name="force" />
          <scope ilk="function" name="force=" />
          <scope ilk="function" name="generate_rdoc" />
          <scope ilk="function" name="generate_rdoc=" />
          <scope ilk="function" name="generate_ri" />
          <scope ilk="function" name="generate_ri=" />
          <scope ilk="function" name="rdoc_version" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/single_class" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="SingleClass" ilk="class" classrefs="RDoc::ClassModule">
          <scope name="ancestors" ilk="function" signature="ancestors()" doc="Adds the superclass to the included modules." />
          <scope name="definition" ilk="function" signature="definition()" doc="The definition of this singleton class, class &lt;&lt; MyClassName" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(num_files, verbosity = 1)" attributes="__classmethod__ __ctor__" doc="Creates a new Stats that will have +num_files+.  +verbosity+ defaults to 1 which will create an RDoc::Stats::Normal outputter." />
          <scope name="add_alias" ilk="function" signature="add_alias(as)" doc="Records the parsing of an alias +as+." />
          <scope name="add_attribute" ilk="function" signature="add_attribute(attribute)" doc="Records the parsing of an attribute +attribute+" />
          <scope name="add_class" ilk="function" signature="add_class(klass)" doc="Records the parsing of a class +klass+" />
          <scope name="add_constant" ilk="function" signature="add_constant(constant)" doc="Records the parsing of +constant+" />
          <scope name="add_file" ilk="function" signature="add_file(file)" doc="Records the parsing of +file+" />
          <scope name="add_method" ilk="function" signature="add_method(method)" doc="Records the parsing of +method+" />
          <scope name="add_module" ilk="function" signature="add_module(mod)" doc="Records the parsing of a module +mod+" />
          <scope name="begin_adding" ilk="function" signature="begin_adding()" doc="Call this to mark the beginning of parsing for display purposes" />
          <scope name="calculate" ilk="function" signature="calculate()" doc="Calculates documentation totals and percentages for classes, modules, constants, attributes and methods." />
          <scope name="coverage_level=" ilk="function" signature="coverage_level=(level)" doc="Sets coverage report level.  Accepted values are: &#xA; No report&#xA;Classes, modules, constants, attributes, methods&#xA;Level 0 + method parameters" />
          <scope name="doc_stats" ilk="function" signature="doc_stats(collection)" doc="Returns the length and number of undocumented items in +collection+." />
          <scope name="done_adding" ilk="function" signature="done_adding()" doc="Call this to mark the end of parsing for display purposes" />
          <scope name="fully_documented?" ilk="function" signature="fully_documented?()" doc="The documentation status of this project.  +true+ when 100%, +false+ when less than 100% and +nil+ when unknown. &#xA; Set by calling #calculate" />
          <scope name="great_job" ilk="function" signature="great_job()" doc="A report that says you did a great job!" />
          <scope name="percent_doc" ilk="function" signature="percent_doc()" doc="Calculates the percentage of items documented." />
          <scope name="report" ilk="function" signature="report()" doc="Returns a report on which items are not documented" />
          <scope name="report_attributes" ilk="function" signature="report_attributes(cm)" doc="Returns a report on undocumented attributes in ClassModule +cm+" />
          <scope name="report_class_module" ilk="function" signature="report_class_module(cm)" doc="Returns a report on undocumented items in ClassModule +cm+" />
          <scope name="report_constants" ilk="function" signature="report_constants(cm)" doc="Returns a report on undocumented constants in ClassModule +cm+" />
          <scope name="report_methods" ilk="function" signature="report_methods(cm)" doc="Returns a report on undocumented methods in ClassModule +cm+" />
          <scope name="summary" ilk="function" signature="summary()" doc="Returns a summary of the collected statistics." />
          <scope name="undoc_params" ilk="function" signature="undoc_params(method)" doc="Determines which parameters in +method+ were not documented.  Returns a total parameter count and an Array of undocumented methods." />
          <scope ilk="function" name="coverage_level" />
          <scope ilk="function" name="files_so_far" />
          <scope ilk="function" name="num_files" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats/normal" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="namespace">
          <scope name="Normal" ilk="class" classrefs="RDoc::Stats::Quiet">
            <scope name="print_file" ilk="function" signature="print_file(files_so_far, filename)" doc="Prints a file with a progress bar" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats/quiet" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="namespace">
          <scope name="Quiet" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(num_files)" attributes="__classmethod__ __ctor__" doc="Creates a new Quiet that will print nothing" />
            <scope name="begin_adding" ilk="function" signature="begin_adding(*)" doc="Prints a message at the beginning of parsing" />
            <scope name="done_adding" ilk="function" signature="done_adding(*)" doc="Prints when RDoc is done" />
            <scope name="print_alias" ilk="function" signature="print_alias(*)" doc="Prints when an alias is added" />
            <scope name="print_attribute" ilk="function" signature="print_attribute(*)" doc="Prints when an attribute is added" />
            <scope name="print_class" ilk="function" signature="print_class(*)" doc="Prints when a class is added" />
            <scope name="print_constant" ilk="function" signature="print_constant(*)" doc="Prints when a constant is added" />
            <scope name="print_file" ilk="function" signature="print_file(*)" doc="Prints when a file is added" />
            <scope name="print_method" ilk="function" signature="print_method(*)" doc="Prints when a method is added" />
            <scope name="print_module" ilk="function" signature="print_module(*)" doc="Prints when a module is added" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/stats/verbose" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Stats" ilk="namespace">
          <scope name="Verbose" ilk="class" classrefs="RDoc::Stats::Normal">
            <scope name="nodoc" ilk="function" signature="nodoc(co)" doc="Returns a marker for RDoc::CodeObject +co+ being undocumented" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/task" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Task" ilk="class" classrefs="Rake::TaskLib">
          <scope ilk="function" name="external" />
          <scope ilk="function" name="external=" />
          <scope ilk="function" name="generator" />
          <scope ilk="function" name="generator=" />
          <scope ilk="function" name="main" />
          <scope ilk="function" name="main=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="name=" />
          <scope ilk="function" name="options" />
          <scope ilk="function" name="options=" />
          <scope ilk="function" name="rdoc_dir" />
          <scope ilk="function" name="rdoc_dir=" />
          <scope ilk="function" name="rdoc_files" />
          <scope ilk="function" name="rdoc_files=" />
          <scope ilk="function" name="template" />
          <scope ilk="function" name="template=" />
          <scope ilk="function" name="title" />
          <scope ilk="function" name="title=" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/text" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="Text" ilk="namespace">
          <scope name="encode_fallback" ilk="function" signature="encode_fallback(character, encoding, fallback)" attributes="__classmethod__" doc="Transcodes +character+ to +encoding+ with a +fallback+ character." />
          <scope name="expand_tabs" ilk="function" signature="expand_tabs(text)" doc="Expands tab characters in +text+ to eight spaces" />
          <scope name="flush_left" ilk="function" signature="flush_left(text)" doc="Flush +text+ left based on the shortest line" />
          <scope name="markup" ilk="function" signature="markup(text)" doc="Convert a string in markup format into HTML. &#xA; Requires the including class to implement #formatter" />
          <scope name="normalize_comment" ilk="function" signature="normalize_comment(text)" doc="Strips hashes, expands tabs then flushes +text+ to the left" />
          <scope name="parse" ilk="function" signature="parse(text)" doc="Normalizes +text+ then builds a RDoc::Markup::Document from it" />
          <scope name="strip_hashes" ilk="function" signature="strip_hashes(text)" doc="Strips leading # characters from +text+" />
          <scope name="strip_newlines" ilk="function" signature="strip_newlines(text)" doc="Strips leading and trailing \n characters from +text+" />
          <scope name="strip_stars" ilk="function" signature="strip_stars(text)" doc="Strips /* */ style comments" />
          <scope name="to_html" ilk="function" signature="to_html(text)" doc="Converts ampersand, dashes, ellipsis, quotes, copyright and registered trademark symbols in +text+ to properly encoded characters." />
          <scope name="wrap" ilk="function" signature="wrap(txt, line_len = 76)" doc="Wraps +txt+ to +line_len+" />
          <variable name="TO_HTML_CHARACTERS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/token_stream" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="TokenStream" ilk="namespace">
          <scope name="add_token" ilk="function" signature="add_token(*tokens)" />
          <scope name="add_tokens" ilk="function" signature="add_tokens(*tokens)" doc="Adds +tokens+ to the collected tokens" />
          <scope name="collect_tokens" ilk="function" signature="collect_tokens()" doc="Starts collecting tokens" />
          <scope name="pop_token" ilk="function" signature="pop_token()" doc="Remove the last token from the collected tokens" />
          <scope name="start_collecting_tokens" ilk="function" signature="start_collecting_tokens()" />
          <scope name="token_stream" ilk="function" signature="token_stream()" doc="Current token stream" />
          <scope name="tokens_to_s" ilk="function" signature="tokens_to_s()" doc="Returns a string representation of the token stream" />
        </scope>
      </scope>
    </scope>
    <scope name="rdoc/top_level" ilk="blob" lang="Ruby">
      <scope name="RDoc" ilk="namespace">
        <scope name="TopLevel" ilk="class" classrefs="RDoc::Context">
          <scope name="all_classes" ilk="function" signature="all_classes()" attributes="__classmethod__" doc="Returns all classes discovered by RDoc" />
          <scope name="all_classes_and_modules" ilk="function" signature="all_classes_and_modules()" attributes="__classmethod__" doc="Returns all classes and modules discovered by RDoc" />
          <scope name="all_classes_hash" ilk="function" signature="all_classes_hash()" attributes="__classmethod__" doc="Hash of all classes known to RDoc" />
          <scope name="all_files" ilk="function" signature="all_files()" attributes="__classmethod__" doc="All TopLevels known to RDoc" />
          <scope name="all_files_hash" ilk="function" signature="all_files_hash()" attributes="__classmethod__" doc="Hash of all files known to RDoc" />
          <scope name="all_modules" ilk="function" signature="all_modules()" attributes="__classmethod__" doc="Returns all modules discovered by RDoc" />
          <scope name="all_modules_hash" ilk="function" signature="all_modules_hash()" attributes="__classmethod__" doc="Hash of all modules known to RDoc" />
          <scope name="classes" ilk="function" signature="classes()" attributes="__classmethod__" />
          <scope name="classes_hash" ilk="function" signature="classes_hash()" attributes="__classmethod__" />
          <scope name="complete" ilk="function" signature="complete(min_visibility)" attributes="__classmethod__" doc="Prepares the RDoc code object tree for use by a generator. &#xA; It finds unique classes/modules defined, and replaces classes/modules that are aliases for another one by a copy with RDoc::ClassModule#is_alias_for set. &#xA; It updates the RDoc::ClassModule#constant_aliases attribute of &quot;real&quot; classes or modules. &#xA; It also completely removes the classes and modules that should be removed from the documentation and the methods that have a visibility below +min_visibility+, which is the --visibility option. &#xA; See also RDoc::Context#remove_from_documentation?" />
          <scope name="files" ilk="function" signature="files()" attributes="__classmethod__" />
          <scope name="files_hash" ilk="function" signature="files_hash()" attributes="__classmethod__" />
          <scope name="find_class_named" ilk="function" signature="find_class_named(name)" attributes="__classmethod__" doc="Finds the class with +name+ in all discovered classes" />
          <scope name="find_class_named_from" ilk="function" signature="find_class_named_from(name, from)" attributes="__classmethod__" doc="Finds the class with +name+ starting in namespace +from+" />
          <scope name="find_class_or_module" ilk="function" signature="find_class_or_module(name)" attributes="__classmethod__" doc="Finds the class or module with +name+" />
          <scope name="find_file_named" ilk="function" signature="find_file_named(name)" attributes="__classmethod__" doc="Finds the file with +name+ in all discovered files" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" attributes="__classmethod__" doc="Finds the module with +name+ in all discovered modules" />
          <scope name="find_unique" ilk="function" signature="find_unique(all_hash)" attributes="__classmethod__" doc="Finds unique classes/modules defined in +all_hash+, and returns them as an array. Performs the alias updates in +all_hash+: see ::complete." />
          <scope name="fix_basic_object_inheritance" ilk="function" signature="fix_basic_object_inheritance()" attributes="__classmethod__" doc="Fixes the erroneous BasicObject &lt; Object in 1.9. &#xA; Because we assumed all classes without a stated superclass inherit from Object, we have the above wrong inheritance. &#xA; We fix BasicObject right away if we are running in a Ruby version &gt;= 1.9. If not, we may be documenting 1.9 source while running under 1.8: we search the files of BasicObject for &quot;object.c&quot;, and fix the inheritance if we find it." />
          <scope name="modules" ilk="function" signature="modules()" attributes="__classmethod__" />
          <scope name="modules_hash" ilk="function" signature="modules_hash()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(file_name)" attributes="__classmethod__ __ctor__" doc="Creates a new RDoc::TopLevel with +file_name+ only if one with the same name does not exist in all_files." />
          <scope name="remove_nodoc" ilk="function" signature="remove_nodoc(all_hash)" attributes="__classmethod__" doc="Removes from +all_hash+ the contexts that are nodoc or have no content. &#xA; See RDoc::Context#remove_from_documentation?" />
          <scope name="reset" ilk="function" signature="reset()" attributes="__classmethod__" doc="Empties RDoc of stored class, module and file information" />
          <scope name="unique_classes" ilk="function" signature="unique_classes()" attributes="__classmethod__" doc="Returns the unique classes discovered by RDoc. &#xA; ::complete must have been called prior to using this method." />
          <scope name="unique_classes_and_modules" ilk="function" signature="unique_classes_and_modules()" attributes="__classmethod__" doc="Returns the unique classes and modules discovered by RDoc. ::complete must have been called prior to using this method." />
          <scope name="unique_modules" ilk="function" signature="unique_modules()" attributes="__classmethod__" doc="Returns the unique modules discovered by RDoc. ::complete must have been called prior to using this method." />
          <scope name="add_alias" ilk="function" signature="add_alias(an_alias)" doc="Adds +an_alias+ to +Object+ instead of +self+." />
          <scope name="add_constant" ilk="function" signature="add_constant(constant)" doc="Adds +constant+ to +Object+ instead of +self+." />
          <scope name="add_include" ilk="function" signature="add_include(include)" doc="Adds +include+ to +Object+ instead of +self+." />
          <scope name="add_method" ilk="function" signature="add_method(method)" doc="Adds +method+ to +Object+ instead of +self+." />
          <scope name="add_to_classes_or_modules" ilk="function" signature="add_to_classes_or_modules(mod)" doc="Adds class or module +mod+. Used in the building phase by the ruby parser." />
          <scope name="base_name" ilk="function" signature="base_name()" doc="Base name of this file" />
          <scope name="cvs_url" ilk="function" signature="cvs_url()" doc="Returns a URL for this source file on some web repository.  Use the -W command line option to set." />
          <scope name="eql?" ilk="function" signature="eql?(other)" />
          <scope name="find_class_or_module" ilk="function" signature="find_class_or_module(name)" doc="See RDoc::TopLevel::find_class_or_module" />
          <scope name="find_local_symbol" ilk="function" signature="find_local_symbol(symbol)" doc="Finds a class or module named +symbol+" />
          <scope name="find_module_named" ilk="function" signature="find_module_named(name)" doc="Finds a module or class with +name+" />
          <scope name="full_name" ilk="function" signature="full_name()" doc="Returns the relative name of this file" />
          <scope name="hash" ilk="function" signature="hash()" doc="An RDoc::TopLevel has the same hash as another with the same absolute_name" />
          <scope name="http_url" ilk="function" signature="http_url(prefix)" doc="URL for this with a +prefix+" />
          <scope name="last_modified" ilk="function" signature="last_modified()" doc="Time this file was last modified, if known" />
          <scope name="name" ilk="function" signature="name()" />
          <scope name="object_class" ilk="function" signature="object_class()" doc="Returns the NormalClass &quot;Object&quot;, creating it if not found. &#xA; Records +self+ as a location in &quot;Object&quot;." />
          <scope name="path" ilk="function" signature="path()" doc="Path to this file" />
          <scope ilk="function" name="absolute_name" />
          <scope ilk="function" name="absolute_name=" />
          <scope ilk="function" name="classes_or_modules" />
          <scope ilk="function" name="file_stat" />
          <scope ilk="function" name="file_stat=" />
          <scope ilk="function" name="parser" />
          <scope ilk="function" name="parser=" />
          <scope ilk="function" name="relative_name" />
          <scope ilk="function" name="relative_name=" />
        </scope>
      </scope>
    </scope>
    <scope name="readline" ilk="blob" lang="Ruby">
      <scope name="Readline" ilk="namespace">
        <scope name="basic_quote_characters" ilk="function" signature="basic_quote_characters()" attributes="__classmethod__" doc="Gets a list of quote characters which can cause a word break. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_quote_characters=" ilk="function" signature="basic_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of quote characters which can cause a word break. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_word_break_characters" ilk="function" signature="basic_word_break_characters()" attributes="__classmethod__" doc="Gets the basic list of characters that signal a break between words for the completer routine. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="basic_word_break_characters=" ilk="function" signature="basic_word_break_characters=(p1)" attributes="__classmethod__" doc="Sets the basic list of characters that signal a break between words for the completer routine. The default is the characters which break words for completion in Bash: &quot;\t\n\&quot;\\&apos;`@$&gt;&lt;=;|&amp;{(&quot;. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_quote_characters" ilk="function" signature="completer_quote_characters()" attributes="__classmethod__" doc="Gets a list of characters which can be used to quote a substring of the line. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_quote_characters=" ilk="function" signature="completer_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of characters which can be used to quote a substring of the line. Completion occurs on the entire substring, and within the substring Readline.completer_word_break_characters are treated as any other character, unless they also appear within this list. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_word_break_characters" ilk="function" signature="completer_word_break_characters()" attributes="__classmethod__" doc="Gets the basic list of characters that signal a break between words for rl_complete_internal(). &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completer_word_break_characters=" ilk="function" signature="completer_word_break_characters=(p1)" attributes="__classmethod__" doc="Sets the basic list of characters that signal a break between words for rl_complete_internal(). The default is the value of Readline.basic_word_break_characters. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_append_character" ilk="function" signature="completion_append_character()" attributes="__classmethod__" doc="Returns a string containing a character to be appended on completion. The default is a space (&quot; &quot;). &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_append_character=" ilk="function" signature="completion_append_character=(p1)" attributes="__classmethod__" doc="Specifies a character to be appended on completion. Nothing will be appended if an empty string (&quot;&quot;) or nil is specified. &#xA; For example: require &quot;readline&quot;&#xA;Readline.readline(&quot;&gt; &quot;, true)&#xA;Readline.completion_append_character = &quot; &quot;&#xA; Result: &gt;&#xA;Input &quot;/var/li&quot;.&#xA;&gt; /var/li&#xA;Press TAB key.&#xA;&gt; /var/lib&#xA;Completes &quot;b&quot; and appends &quot; &quot;. So, you can continuously input &quot;/usr&quot;.&#xA;&gt; /var/lib /usr&#xA; NOTE: Only one character can be specified. When &quot;string&quot; is specified, sets only &quot;s&quot; that is the first. &#xA; require &quot;readline&quot;" />
        <scope name="completion_case_fold" ilk="function" signature="completion_case_fold()" attributes="__classmethod__" doc="Returns true if completion ignores case. If no, returns false. &#xA; NOTE: Returns the same object that is specified by Readline.completion_case_fold= method. &#xA; require &quot;readline&quot;&#xA;&#xA;Readline.completion_case_fold = &quot;This is a String.&quot;&#xA;p Readline.completion_case_fold # =&gt; &quot;This is a String.&quot;&#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_case_fold=" ilk="function" signature="completion_case_fold=(p1)" attributes="__classmethod__" doc="Sets whether or not to ignore case on completion. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_proc" ilk="function" signature="completion_proc()" attributes="__classmethod__" doc="Returns the completion Proc object. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="completion_proc=" ilk="function" signature="completion_proc=(p1)" attributes="__classmethod__" doc="Specifies a Proc object +proc+ to determine completion behavior.  It should take input string and return an array of completion candidates. &#xA; The default completion is used if +proc+ is nil. &#xA; The String that is passed to the Proc depends on the Readline.completer_word_break_characters property.  By default the word under the cursor is passed to the Proc.  For example, if the input is &quot;foo bar&quot; then only &quot;bar&quot; would be passed to the completion Proc. &#xA; Upon successful completion the Readline.completion_append_character will be appended to the input so the user can start working on their next argument. &#xA; Examples &#xA; Completion for a Static List &#xA; require &apos;readline&apos;&#xA;LIST = [&#xA;  &apos;search&apos;, &apos;download&apos;, &apos;open&apos;,&#xA;  &apos;help&apos;, &apos;history&apos;, &apos;quit&apos;,&#xA;  &apos;url&apos;, &apos;next&apos;, &apos;clear&apos;,&#xA;  &apos;prev&apos;, &apos;past&apos;&#xA;].sort" />
        <scope name="emacs_editing_mode" ilk="function" signature="emacs_editing_mode()" attributes="__classmethod__" doc="Specifies Emacs editing mode. The default is this mode. See the manual of GNU Readline for details of Emacs editing mode. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="emacs_editing_mode?" ilk="function" signature="emacs_editing_mode?()" attributes="__classmethod__" doc="Returns true if emacs mode is active. Returns false if not. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="filename_quote_characters" ilk="function" signature="filename_quote_characters()" attributes="__classmethod__" doc="Gets a list of characters that cause a filename to be quoted by the completer when they appear in a completed filename. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="filename_quote_characters=" ilk="function" signature="filename_quote_characters=(p1)" attributes="__classmethod__" doc="Sets a list of characters that cause a filename to be quoted by the completer when they appear in a completed filename. The default is nil. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="get_screen_size" ilk="function" signature="get_screen_size()" attributes="__classmethod__" doc="Returns the terminal&apos;s rows and columns. &#xA; See GNU Readline&apos;s rl_get_screen_size function. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="input=" ilk="function" signature="input=(p1)" attributes="__classmethod__" doc="Specifies a File object +input+ that is input stream for Readline.readline method. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="line_buffer" ilk="function" signature="line_buffer()" attributes="__classmethod__" doc="Returns the full line that is being edited. This is useful from within the complete_proc for determining the context of the completion request. &#xA; The length of +Readline.line_buffer+ and GNU Readline&apos;s rl_end are same." />
        <scope name="output=" ilk="function" signature="output=(p1)" attributes="__classmethod__" doc="Specifies a File object +output+ that is output stream for Readline.readline method. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="point" ilk="function" signature="point()" attributes="__classmethod__" doc="Returns the index of the current cursor position in +Readline.line_buffer+. &#xA; The index in +Readline.line_buffer+ which matches the start of input-string passed to completion_proc is computed by subtracting the length of input-string from +Readline.point+. &#xA; start = (the length of input-string) - Readline.point" />
        <scope name="readline" ilk="function" signature="readline(p1 = v1, p2 = v2)" attributes="__classmethod__" doc="Shows the +prompt+ and reads the inputted line with line editing. The inputted line is added to the history if +add_hist+ is true. &#xA; Returns nil when the inputted line is empty and user inputs EOF (Presses ^D on UNIX). &#xA; Raises IOError exception if below conditions are satisfied. stdin is not tty.&#xA;stdin was closed. (errno is EBADF after called isatty(2).) &#xA; This method supports thread. Switchs the thread context when waits inputting line. &#xA; Supports line edit when inputs line. Provides VI and Emacs editing mode. Default is Emacs editing mode. &#xA; NOTE: Terminates ruby interpreter and does not return the terminal status after user pressed &apos;^C&apos; when wait inputting line. Give 3 examples that avoid it. &#xA; Catches the Interrupt exception by pressed ^C after returns terminal status: &#xA; require &quot;readline&quot;&#xA;stty_save = `stty -g`.chomp&#xA;begin&#xA;  while buf = Readline.readline&#xA;      p buf" />
        <scope name="refresh_line" ilk="function" signature="refresh_line()" attributes="__classmethod__" doc="Clear the current input line. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="set_screen_size" ilk="function" signature="set_screen_size(p1, p2)" attributes="__classmethod__" doc="Set terminal size to +rows+ and +columns+. &#xA; See GNU Readline&apos;s rl_set_screen_size function. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="vi_editing_mode" ilk="function" signature="vi_editing_mode()" attributes="__classmethod__" doc="Specifies VI editing mode. See the manual of GNU Readline for details of VI editing mode. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <scope name="vi_editing_mode?" ilk="function" signature="vi_editing_mode?()" attributes="__classmethod__" doc="Returns true if vi mode is active. Returns false if not. &#xA; Raises NotImplementedError if the using readline library does not support. &#xA; Raises SecurityError exception if $SAFE is 4." />
        <variable name="HISTORY" attributes="__const__" citdl="Object" />
        <variable name="FILENAME_COMPLETION_PROC" attributes="__const__" citdl="Object" />
        <variable name="USERNAME_COMPLETION_PROC" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="resolv" ilk="blob" lang="Ruby">
      <scope name="Resolv" ilk="class" classrefs="Object">
        <scope name="each_address" ilk="function" signature="each_address(name, &amp;block)" attributes="__classmethod__" doc="Iterates over all IP addresses for +name+." />
        <scope name="each_name" ilk="function" signature="each_name(address, &amp;proc)" attributes="__classmethod__" doc="Iterates over all hostnames for +address+." />
        <scope name="getaddress" ilk="function" signature="getaddress(name)" attributes="__classmethod__" doc="Looks up the first IP address for +name+." />
        <scope name="getaddresses" ilk="function" signature="getaddresses(name)" attributes="__classmethod__" doc="Looks up all IP address for +name+." />
        <scope name="getname" ilk="function" signature="getname(address)" attributes="__classmethod__" doc="Looks up the hostname of +address+." />
        <scope name="getnames" ilk="function" signature="getnames(address)" attributes="__classmethod__" doc="Looks up all hostnames for +address+." />
        <scope name="new" ilk="function" signature="new(resolvers=[Hosts.new, DNS.new])" attributes="__classmethod__ __ctor__" doc="Creates a new Resolv using +resolvers+." />
        <scope name="each_address" ilk="function" signature="each_address(name)" doc="Iterates over all IP addresses for +name+." />
        <scope name="each_name" ilk="function" signature="each_name(address)" doc="Iterates over all hostnames for +address+." />
        <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Looks up the first IP address for +name+." />
        <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Looks up all IP address for +name+." />
        <scope name="getname" ilk="function" signature="getname(address)" doc="Looks up the hostname of +address+." />
        <scope name="getnames" ilk="function" signature="getnames(address)" doc="Looks up all hostnames for +address+." />
        <scope name="DNS" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config_info=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new DNS resolver. &#xA; +config_info+ can be: &#xA; Uses /etc/resolv.conf.&#xA;Path to a file using /etc/resolv.conf&apos;s format.&#xA;Must contain :nameserver, :search and :ndots keys. :nameserver_port can be used to specify port number of nameserver address. &#xA; The value of :nameserver should be an address string or an array of address strings. :nameserver =&gt; &apos;8.8.8.8&apos;&#xA;:nameserver =&gt; [&apos;8.8.8.8&apos;, &apos;8.8.4.4&apos;] &#xA; The value of :nameserver_port should be an array of pair of nameserver address and port number. :nameserver_port =&gt; [[&apos;8.8.8.8&apos;, 53], [&apos;8.8.4.4&apos;, 53]] &#xA; Example: &#xA; Resolv::DNS.new(:nameserver =&gt; [&apos;210.251.121.21&apos;],&#xA;                :search =&gt; [&apos;ruby-lang.org&apos;],&#xA;                :ndots =&gt; 1)" />
          <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Creates a new DNS resolver.  See Resolv::DNS.new for argument details. &#xA; Yields the created DNS resolver to the block, if given, otherwise returns it." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the DNS resolver." />
          <scope name="each_address" ilk="function" signature="each_address(name)" doc="Iterates over all IP addresses for +name+ retrieved from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="each_name" ilk="function" signature="each_name(address)" doc="Iterates over all hostnames for +address+ retrieved from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names will be Resolv::DNS::Name instances." />
          <scope name="each_resource" ilk="function" signature="each_resource(name, typeclass, &amp;proc)" doc="Iterates over all +typeclass+ DNS resources for +name+.  See #getresource for argument details." />
          <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Gets the IP address of +name+ from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved address will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Gets all IP addresses for +name+ from the DNS resolver. &#xA; +name+ can be a Resolv::DNS::Name or a String.  Retrieved addresses will be a Resolv::IPv4 or Resolv::IPv6" />
          <scope name="getname" ilk="function" signature="getname(address)" doc="Gets the hostname for +address+ from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved name will be a Resolv::DNS::Name." />
          <scope name="getnames" ilk="function" signature="getnames(address)" doc="Gets all hostnames for +address+ from the DNS resolver. &#xA; +address+ must be a Resolv::IPv4, Resolv::IPv6 or a String.  Retrieved names will be Resolv::DNS::Name instances." />
          <scope name="getresource" ilk="function" signature="getresource(name, typeclass)" doc="Look up the +typeclass+ DNS resource of +name+. &#xA; +name+ must be a Resolv::DNS::Name or a String. &#xA; +typeclass+ should be one of the following: &#xA; Resolv::DNS::Resource::IN::A&#xA;Resolv::DNS::Resource::IN::AAAA&#xA;Resolv::DNS::Resource::IN::ANY&#xA;Resolv::DNS::Resource::IN::CNAME&#xA;Resolv::DNS::Resource::IN::HINFO&#xA;Resolv::DNS::Resource::IN::MINFO&#xA;Resolv::DNS::Resource::IN::MX&#xA;Resolv::DNS::Resource::IN::NS&#xA;Resolv::DNS::Resource::IN::PTR&#xA;Resolv::DNS::Resource::IN::SOA" />
          <scope name="getresources" ilk="function" signature="getresources(name, typeclass)" doc="Looks up all +typeclass+ DNS resources for +name+.  See #getresource for argument details." />
          <scope name="Config" ilk="class" classrefs="Object">
            <scope name="NXDomain" ilk="class" classrefs="Resolv::ResolvError">
            </scope>
            <scope name="OtherResolvError" ilk="class" classrefs="Resolv::ResolvError">
            </scope>
          </scope>
          <scope name="DecodeError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="EncodeError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="Name" ilk="class" classrefs="Object">
            <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" doc="Creates a new DNS name from +arg+.  +arg+ can be: &#xA; returns +arg+.&#xA;Creates a new Name." />
            <scope name="absolute?" ilk="function" signature="absolute?()" doc="True if this name is absolute." />
            <scope name="subdomain_of?" ilk="function" signature="subdomain_of?(other)" doc="Returns true if +other+ is a subdomain. &#xA; Example: &#xA; domain = Resolv::DNS::Name.create(&quot;y.z&quot;)&#xA;p Resolv::DNS::Name.create(&quot;w.x.y.z&quot;).subdomain_of?(domain) =&gt; true&#xA;p Resolv::DNS::Name.create(&quot;x.y.z&quot;).subdomain_of?(domain) =&gt; true&#xA;p Resolv::DNS::Name.create(&quot;y.z&quot;).subdomain_of?(domain) =&gt; false&#xA;p Resolv::DNS::Name.create(&quot;z&quot;).subdomain_of?(domain) =&gt; false&#xA;p Resolv::DNS::Name.create(&quot;x.y.z.&quot;).subdomain_of?(domain) =&gt; false&#xA;p Resolv::DNS::Name.create(&quot;w.z&quot;).subdomain_of?(domain) =&gt; false" />
            <scope name="to_s" ilk="function" signature="to_s()" doc="returns the domain name as a string. &#xA; The domain name doesn&apos;t have a trailing dot even if the name object is absolute. &#xA; Example: &#xA; p Resolv::DNS::Name.create(&quot;x.y.z.&quot;).to_s =&gt; &quot;x.y.z&quot;&#xA;p Resolv::DNS::Name.create(&quot;x.y.z&quot;).to_s =&gt; &quot;x.y.z&quot;" />
          </scope>
          <scope name="Query" ilk="class" classrefs="Object">
          </scope>
          <scope name="Requester" ilk="class" classrefs="Object">
            <scope name="RequestError" ilk="class" classrefs="StandardError">
            </scope>
          </scope>
          <scope name="Resource" ilk="class" classrefs="Resolv::DNS::Query">
            <scope ilk="function" name="ttl" />
            <scope name="ANY" ilk="class" classrefs="Resolv::DNS::Query">
            </scope>
            <scope name="CNAME" ilk="class" classrefs="Resolv::DNS::Resource::DomainName">
            </scope>
            <scope name="DomainName" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(name)" attributes="__classmethod__ __ctor__" doc="Creates a new DomainName from +name+." />
              <scope ilk="function" name="name" />
            </scope>
            <scope name="Generic" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(data)" attributes="__classmethod__ __ctor__" doc="Creates a new generic resource." />
              <scope ilk="function" name="data" />
            </scope>
            <scope name="HINFO" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(cpu, os)" attributes="__classmethod__ __ctor__" doc="Creates a new HINFO running +os+ on +cpu+." />
              <scope ilk="function" name="cpu" />
              <scope ilk="function" name="os" />
            </scope>
            <scope name="IN" ilk="namespace">
              <scope name="A" ilk="class" classrefs="Resolv::DNS::Resource">
                <scope name="new" ilk="function" signature="new(address)" attributes="__classmethod__ __ctor__" doc="Creates a new A for +address+." />
                <scope ilk="function" name="address" />
              </scope>
              <scope name="AAAA" ilk="class" classrefs="Resolv::DNS::Resource">
                <scope name="new" ilk="function" signature="new(address)" attributes="__classmethod__ __ctor__" doc="Creates a new AAAA for +address+." />
                <scope ilk="function" name="address" />
              </scope>
              <scope name="SRV" ilk="class" classrefs="Resolv::DNS::Resource">
                <scope name="new" ilk="function" signature="new(priority, weight, port, target)" attributes="__classmethod__ __ctor__" doc="Create a SRV resource record. &#xA; See the documentation for #priority, #weight, #port and #target for +priority+, +weight+, +port and +target+ respectively." />
                <scope ilk="function" name="port" />
                <scope ilk="function" name="priority" />
                <scope ilk="function" name="target" />
                <scope ilk="function" name="weight" />
              </scope>
              <scope name="WKS" ilk="class" classrefs="Resolv::DNS::Resource">
                <scope name="new" ilk="function" signature="new(address, protocol, bitmap)" attributes="__classmethod__ __ctor__" />
                <scope ilk="function" name="address" />
                <scope ilk="function" name="bitmap" />
                <scope ilk="function" name="protocol" />
              </scope>
            </scope>
            <scope name="MINFO" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(rmailbx, emailbx)" attributes="__classmethod__ __ctor__" />
              <scope ilk="function" name="emailbx" />
              <scope ilk="function" name="rmailbx" />
            </scope>
            <scope name="MX" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(preference, exchange)" attributes="__classmethod__ __ctor__" doc="Creates a new MX record with +preference+, accepting mail at +exchange+." />
              <scope ilk="function" name="exchange" />
              <scope ilk="function" name="preference" />
            </scope>
            <scope name="NS" ilk="class" classrefs="Resolv::DNS::Resource::DomainName">
            </scope>
            <scope name="PTR" ilk="class" classrefs="Resolv::DNS::Resource::DomainName">
            </scope>
            <scope name="SOA" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(mname, rname, serial, refresh, retry_, expire, minimum)" attributes="__classmethod__ __ctor__" doc="Creates a new SOA record.  See the attr documentation for the details of each argument." />
              <scope ilk="function" name="expire" />
              <scope ilk="function" name="minimum" />
              <scope ilk="function" name="mname" />
              <scope ilk="function" name="refresh" />
              <scope ilk="function" name="retry" />
              <scope ilk="function" name="rname" />
              <scope ilk="function" name="serial" />
            </scope>
            <scope name="TXT" ilk="class" classrefs="Resolv::DNS::Resource">
              <scope name="new" ilk="function" signature="new(first_string, *rest_strings)" attributes="__classmethod__ __ctor__" />
              <scope name="data" ilk="function" signature="data()" doc="Returns the first string from +strings+." />
              <scope ilk="function" name="strings" />
            </scope>
          </scope>
        </scope>
        <scope name="Hosts" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(filename = DefaultFileName)" attributes="__classmethod__ __ctor__" doc="Creates a new Resolv::Hosts, using +filename+ for its data source." />
          <scope name="each_address" ilk="function" signature="each_address(name, &amp;proc)" doc="Iterates over all IP addresses for +name+ retrieved from the hosts file." />
          <scope name="each_name" ilk="function" signature="each_name(address, &amp;proc)" doc="Iterates over all hostnames for +address+ retrieved from the hosts file." />
          <scope name="getaddress" ilk="function" signature="getaddress(name)" doc="Gets the IP address of +name+ from the hosts file." />
          <scope name="getaddresses" ilk="function" signature="getaddresses(name)" doc="Gets all IP addresses for +name+ from the hosts file." />
          <scope name="getname" ilk="function" signature="getname(address)" doc="Gets the hostname of +address+ from the hosts file." />
          <scope name="getnames" ilk="function" signature="getnames(address)" doc="Gets all hostnames for +address+ from the hosts file." />
        </scope>
        <scope name="IPv4" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" />
          <scope name="to_name" ilk="function" signature="to_name()" doc="Turns this IPv4 address into a Resolv::DNS::Name." />
          <scope ilk="function" name="address" />
        </scope>
        <scope name="IPv6" ilk="class" classrefs="Object">
          <scope name="create" ilk="function" signature="create(arg)" attributes="__classmethod__" doc="Creates a new IPv6 address from +arg+ which may be: &#xA; returns +arg+.&#xA;+arg+ must match one of the IPv6::Regex* constants" />
          <scope name="to_name" ilk="function" signature="to_name()" doc="Turns this IPv6 address into a Resolv::DNS::Name." />
          <scope ilk="function" name="address" />
        </scope>
        <scope name="ResolvError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="ResolvTimeout" ilk="class" classrefs="Timeout::Error">
        </scope>
      </scope>
    </scope>
    <scope name="rexml/attlistdecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="AttlistDecl" ilk="class" classrefs="Child">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" doc="Create an AttlistDecl, pulling the information from a Source.  Notice that this isn&apos;t very convenient; to create an AttlistDecl, you basically have to format it yourself, and then have the initializer parse it. Sorry, but for the forseeable future, DTD support in REXML is pretty weak on convenience.  Have I mentioned how much I hate DTDs?" />
          <scope name="each" ilk="function" signature="each(&amp;block)" doc="Iterate over the key/value pairs: attlist_decl.each { |attribute_name, attribute_value| ... }" />
          <scope name="include?" ilk="function" signature="include?(key)" doc="Whether an attlist declaration includes the given attribute definition if attlist_decl.include? &quot;xmlns:foobar&quot;" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write(out, indent=-1)" doc="Write out exactly what we got in." />
          <scope ilk="function" name="element_name" />
        </scope>
        <scope name="DTD" ilk="namespace">
          <scope name="AttlistDecl" ilk="class" classrefs="Child">
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PATTERN_RE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/attribute" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Attribute" ilk="class" classrefs="Object">
          <import symbol="Namespace" />
          <import symbol="Node" />
          <scope name="new" ilk="function" signature="new( first, second=nil, parent=nil )" attributes="__classmethod__ __ctor__" doc="Constructor. FIXME: The parser doesn&apos;t catch illegal characters in attributes &#xA; Either: an Attribute, which this new attribute will become a clone of; or a String, which is the name of this attribute&#xA;If +first+ is an Attribute, then this may be an Element, or nil. If nil, then the Element parent of this attribute is the parent of the +first+ Attribute.  If the first argument is a String, then this must also be a String, and is the content of the attribute. If this is the content, it must be fully normalized (contain no illegal characters).&#xA;Ignored unless +first+ is a String; otherwise, may be the Element parent of this attribute, or nil. &#xA; Attribute.new( attribute_to_clone )&#xA;Attribute.new( attribute_to_clone, parent_element )&#xA;Attribute.new( &quot;attr&quot;, &quot;attr_value&quot; )&#xA;Attribute.new( &quot;attr&quot;, &quot;attr_value&quot;, parent_element )" />
          <scope name="clone" ilk="function" signature="clone()" doc="Returns a copy of this attribute" />
          <scope name="doctype" ilk="function" signature="doctype()" />
          <scope name="element=" ilk="function" signature="element=( element )" doc="Sets the element of which this object is an attribute.  Normally, this is not directly called. &#xA; Returns this attribute" />
          <scope name="hash" ilk="function" signature="hash()" doc="Creates (and returns) a hash from both the name and value" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="namespace" ilk="function" signature="namespace(arg=nil)" doc="Returns the namespace URL, if defined, or nil otherwise &#xA; e = Element.new(&quot;el&quot;)&#xA;e.add_attributes({&quot;xmlns:ns&quot;, &quot;http://url&quot;})&#xA;e.namespace( &quot;ns&quot; )              # -&gt; &quot;http://url&quot;" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="prefix" ilk="function" signature="prefix()" doc="Returns the namespace of the attribute. &#xA; e = Element.new( &quot;elns:myelement&quot; )&#xA;e.add_attribute( &quot;nsa:a&quot;, &quot;aval&quot; )&#xA;e.add_attribute( &quot;b&quot;, &quot;bval&quot; )&#xA;e.attributes.get_attribute( &quot;a&quot; ).prefix   # -&gt; &quot;nsa&quot;&#xA;e.attributes.get_attribute( &quot;b&quot; ).prefix   # -&gt; &quot;elns&quot;&#xA;a = Attribute.new( &quot;x&quot;, &quot;y&quot; )&#xA;a.prefix                                   # -&gt; &quot;&quot;" />
          <scope name="remove" ilk="function" signature="remove()" doc="Removes this Attribute from the tree, and returns true if successfull &#xA; This method is usually not called directly." />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the attribute value, with entities replaced" />
          <scope name="to_string" ilk="function" signature="to_string()" doc="Returns this attribute out as XML source, expanding the name &#xA; a = Attribute.new( &quot;x&quot;, &quot;y&quot; )&#xA;a.to_string     # -&gt; &quot;x=&apos;y&apos;&quot;&#xA;b = Attribute.new( &quot;ns:x&quot;, &quot;y&quot; )&#xA;b.to_string     # -&gt; &quot;ns:x=&apos;y&apos;&quot;" />
          <scope name="value" ilk="function" signature="value()" doc="Returns the UNNORMALIZED value of this attribute.  That is, entities have been expanded to their values" />
          <scope name="write" ilk="function" signature="write( output, indent=-1 )" doc="Writes this attribute (EG, puts &apos;key=&quot;value&quot;&apos; to the output)" />
          <scope name="xpath" ilk="function" signature="xpath()" />
          <scope ilk="function" name="element" />
          <scope ilk="function" name="normalized=" />
          <variable name="PATTERN" attributes="__const__" citdl="Object" />
          <variable name="NEEDS_A_SECOND_CHECK" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/cdata" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="CData" ilk="class" classrefs="Text">
          <scope name="new" ilk="function" signature="new( first, whitespace=true, parent=nil )" attributes="__classmethod__ __ctor__" doc="Constructor.  CData is data between &lt;![CDATA[ ... ]]&gt;&#xA; _Examples_ CData.new( source )&#xA;CData.new( &quot;Here is some CDATA&quot; )&#xA;CData.new( &quot;Some unprocessed data&quot;, respect_whitespace_TF, parent_element )" />
          <scope name="clone" ilk="function" signature="clone()" doc="Make a copy of this object &#xA; _Examples_ c = CData.new( &quot;Some text&quot; )&#xA;d = c.clone&#xA;d.to_s        # -&gt; &quot;Some text&quot;" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the content of this CData object &#xA; _Examples_ c = CData.new( &quot;Some text&quot; )&#xA;c.to_s        # -&gt; &quot;Some text&quot;" />
          <scope name="value" ilk="function" signature="value()" />
          <scope name="write" ilk="function" signature="write( output=$stdout, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See the rexml/formatters package &#xA; Generates XML output of this object &#xA; Where to write the string.  Defaults to $stdout&#xA;The amount to indent this node by&#xA;Ignored&#xA;Ignored &#xA; _Examples_ c = CData.new( &quot; Some text &quot; )&#xA;c.write( $stdout )     #-&gt;  &lt;![CDATA[ Some text ]]&gt;" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
          <variable name="ILLEGAL" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/child" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Child" ilk="class" classrefs="Object">
          <import symbol="Node" />
          <scope name="new" ilk="function" signature="new( parent = nil )" attributes="__classmethod__ __ctor__" doc="Constructor.  Any inheritors of this class should call super to make sure this method is called. if supplied, the parent of this child will be set to the supplied value, and self will be added to the parent" />
          <scope name="bytes" ilk="function" signature="bytes()" doc="This doesn&apos;t yet handle encodings" />
          <scope name="document" ilk="function" signature="document()" doc="the document this child belongs to, or nil if this child belongs to no document" />
          <scope name="next_sibling=" ilk="function" signature="next_sibling=( other )" doc="Sets the next sibling of this child.  This can be used to insert a child after some other child. a = Element.new(&quot;a&quot;)&#xA;b = a.add_element(&quot;b&quot;)&#xA;c = Element.new(&quot;c&quot;)&#xA;b.next_sibling = c&#xA;# =&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="parent=" ilk="function" signature="parent=( other )" doc="Sets the parent of this child to the supplied argument. &#xA; Must be a Parent object.  If this object is the same object as the existing parent of this child, no action is taken. Otherwise, this child is removed from the current parent (if one exists), and is added to the new parent.&#xA;The parent added" />
          <scope name="previous_sibling=" ilk="function" signature="previous_sibling=(other)" doc="Sets the previous sibling of this child.  This can be used to insert a child before some other child. a = Element.new(&quot;a&quot;)&#xA;b = a.add_element(&quot;b&quot;)&#xA;c = Element.new(&quot;c&quot;)&#xA;b.previous_sibling = c&#xA;# =&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="remove" ilk="function" signature="remove()" doc="Removes this child from the parent. &#xA; self" />
          <scope name="replace_with" ilk="function" signature="replace_with( child )" doc="Replaces this object with another object.  Basically, calls Parent.replace_child &#xA; self" />
          <scope ilk="function" name="parent" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/comment" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Comment" ilk="class" classrefs="Child">
          <import symbol="Comparable" />
          <scope name="new" ilk="function" signature="new( first, second = nil )" attributes="__classmethod__ __ctor__" doc="Constructor.  The first argument can be one of three types: @param first If String, the contents of this comment are set to the argument.  If Comment, the argument is duplicated.  If Source, the argument is scanned for a comment. @param second If the first argument is a Source, this argument should be nil, not supplied, or a Parent to be set as the parent of this object" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write( output, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See REXML::Formatters &#xA; Where to write the string&#xA;An integer.    If -1, no indenting will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.&#xA;Ignored by this class. The contents of comments are never modified.&#xA;Needed for conformity to the child API, but not used by this class." />
          <scope ilk="function" name="string" />
          <scope ilk="function" name="string=" />
          <scope ilk="function" name="to_s" />
          <scope ilk="function" name="to_s=" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/doctype" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="ElementDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(match)" attributes="__classmethod__ __ctor__" doc="\s*(((([&quot;&apos;]).*?\5)|[^\/&apos;&quot;&gt;]*)*?)(\/)?&gt;/um, true)" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PATTERN_RE" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="DTD" ilk="namespace">
          <scope name="NotationDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" />
            <scope name="parse_source" ilk="function" signature="parse_source(source, listener)" attributes="__classmethod__" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="write" ilk="function" signature="write( output, indent )" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Declaration" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent )" doc="DEPRECATED See REXML::Formatters" />
        </scope>
        <scope name="DocType" ilk="class" classrefs="Parent">
          <import symbol="XMLTokens" />
          <scope name="new" ilk="function" signature="new( first, parent=nil )" attributes="__classmethod__ __ctor__" doc="Constructor &#xA; dt = DocType.new( &apos;foo&apos;, &apos;-//I/Hate/External/IDs&apos; )&#xA;# &lt;!DOCTYPE foo &apos;-//I/Hate/External/IDs&apos;&gt;&#xA;dt = DocType.new( doctype_to_clone )&#xA;# Incomplete.  Shallow clone of doctype&#xA; +Note+ that the constructor: &#xA; Doctype.new( Source.new( &quot;&lt;!DOCTYPE foo &apos;bar&apos;&gt;&quot; ) )&#xA; is _deprecated_.  Do not use it.  It will probably disappear." />
          <scope name="add" ilk="function" signature="add(child)" />
          <scope name="attribute_of" ilk="function" signature="attribute_of(element, attribute)" />
          <scope name="attributes_of" ilk="function" signature="attributes_of(element)" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="context" ilk="function" signature="context()" />
          <scope name="entity" ilk="function" signature="entity( name )" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="notation" ilk="function" signature="notation(name)" doc="Retrieves a named notation. Only notations declared in the internal DTD subset can be retrieved. &#xA; Method contributed by Henrik Martensson" />
          <scope name="notations" ilk="function" signature="notations()" doc="This method returns a list of notations that have been declared in the _internal_ DTD subset. Notations in the external DTD subset are not listed. &#xA; Method contributed by Henrik Martensson" />
          <scope name="public" ilk="function" signature="public()" doc="This method retrieves the public identifier identifying the document&apos;s DTD. &#xA; Method contributed by Henrik Martensson" />
          <scope name="system" ilk="function" signature="system()" doc="This method retrieves the system identifier identifying the document&apos;s DTD &#xA; Method contributed by Henrik Martensson" />
          <scope name="write" ilk="function" signature="write( output, indent=0, transitive=false, ie_hack=false )" doc="Where to write the string&#xA;An integer.  If -1, no indentation will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.&#xA;Ignored&#xA;Ignored" />
          <scope ilk="function" name="entities" />
          <scope ilk="function" name="external_id" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="namespaces" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
          <variable name="SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="PUBLIC" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_ENTITIES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ElementDecl" ilk="class" classrefs="REXML::Declaration">
          <scope name="new" ilk="function" signature="new( src )" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="ExternalEntity" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new( src )" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent )" />
        </scope>
        <scope name="NotationDecl" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(name, middle, pub, sys)" attributes="__classmethod__ __ctor__" />
          <scope name="name" ilk="function" signature="name()" doc="This method retrieves the name of the notation. &#xA; Method contributed by Henrik Martensson" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="write" ilk="function" signature="write( output, indent=-1 )" />
          <scope ilk="function" name="public" />
          <scope ilk="function" name="public=" />
          <scope ilk="function" name="system" />
          <scope ilk="function" name="system=" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/document" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Document" ilk="class" classrefs="Element">
          <scope name="entity_expansion_limit" ilk="function" signature="entity_expansion_limit()" attributes="__classmethod__" doc="Get the entity expansion limit. By default the limit is set to 10000." />
          <scope name="entity_expansion_limit=" ilk="function" signature="entity_expansion_limit=( val )" attributes="__classmethod__" doc="Set the entity expansion limit. By default the limit is set to 10000." />
          <scope name="new" ilk="function" signature="new( source = nil, context = {} )" attributes="__classmethod__ __ctor__" doc="Constructor @param source if supplied, must be a Document, String, or IO. Documents have their context and Element attributes cloned. Strings are expected to be valid XML documents.  IOs are expected to be sources of valid XML documents. @param context if supplied, contains the context of the document; this should be a Hash." />
          <scope name="parse_stream" ilk="function" signature="parse_stream( source, listener )" attributes="__classmethod__" />
          <scope name="add" ilk="function" signature="add( child )" doc="We override this, because XMLDecls and DocTypes must go at the start of the document" />
          <scope name="add_element" ilk="function" signature="add_element(arg=nil, arg2=nil)" />
          <scope name="clone" ilk="function" signature="clone()" doc="Should be obvious" />
          <scope name="doctype" ilk="function" signature="doctype()" doc="@return the DocType child of the document, if one exists, and nil otherwise." />
          <scope name="encoding" ilk="function" signature="encoding()" doc="@return the XMLDecl encoding of this document as an Encoding object. If no XMLDecl has been set, returns the default encoding." />
          <scope name="expanded_name" ilk="function" signature="expanded_name()" doc="According to the XML spec, a root node has no expanded name" />
          <scope name="name" ilk="function" signature="name()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="record_entity_expansion" ilk="function" signature="record_entity_expansion()" />
          <scope name="root" ilk="function" signature="root()" doc="@return the root Element of the document, or nil if this document has no children." />
          <scope name="stand_alone?" ilk="function" signature="stand_alone?()" doc="@return the XMLDecl standalone value of this document as a String. If no XMLDecl has been set, returns the default setting." />
          <scope name="version" ilk="function" signature="version()" doc="@return the XMLDecl version of this document as a String. If no XMLDecl has been set, returns the default version." />
          <scope name="write" ilk="function" signature="write( output=$stdout, indent=-1, transitive=false, ie_hack=false )" doc="Write the XML tree out, optionally with indent.  This writes out the entire XML document, including XML declarations, doctype declarations, and processing instructions (if any are given). &#xA; A controversial point is whether Document should always write the XML declaration (&lt;?xml version=&apos;1.0&apos;?&gt;) whether or not one is given by the user (or source document).  REXML does not write one if one was not specified, because it adds unnecessary bandwidth to applications such as XML-RPC. &#xA; See also the classes in the rexml/formatters package for the proper way to change the default formatting of XML output &#xA; _Examples_ Document.new(&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;).serialize&#xA;&#xA;output_string = &quot;&quot;&#xA;tr = Transitive.new( output_string )&#xA;Document.new(&quot;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&quot;).serialize( tr )&#xA; output an object which supports &apos;&lt;&lt; string&apos;; this is where the document will be written.&#xA; An integer.  If -1, no indenting will be used; otherwise, the indentation will be twice this number of spaces, and children will be indented an additional amount.  For a value of 3, every item will be indented 3 more levels, or 6 more spaces (2 * 3). Defaults to -1&#xA;If transitive is true and indent is &gt;= 0, then the output will be pretty-printed in such a way that the added whitespace does not affect the absolute *value* of the document -- that is, it leaves the value and number of Text nodes in the document unchanged.&#xA;Internet Explorer is the worst piece of crap to have ever been written, with the possible exception of Windows itself.  Since IE is unable to parse proper XML, we have to provide a hack to generate XML that IE&apos;s limited abilities can handle.  This hack inserts a space before the /&gt; on empty tags.  Defaults to false" />
          <scope name="xml_decl" ilk="function" signature="xml_decl()" doc="@return the XMLDecl of this document; if no XMLDecl has been set, the default declaration is returned." />
          <scope ilk="function" name="entity_expansion_count" />
          <variable name="DECLARATION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/dtd" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="Parser" ilk="class" classrefs="Object">
            <scope name="parse" ilk="function" signature="parse( input )" attributes="__classmethod__" />
            <scope name="parse_helper" ilk="function" signature="parse_helper( input )" attributes="__classmethod__" doc="Takes a String and parses it out" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/entitydecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
          <scope name="EntityDecl" ilk="class" classrefs="Child">
            <scope name="new" ilk="function" signature="new(src)" attributes="__classmethod__ __ctor__" doc="&lt;!ENTITY name SYSTEM &quot;...&quot;&gt; &lt;!ENTITY name &quot;...&quot;&gt;" />
            <scope name="parse_source" ilk="function" signature="parse_source(source, listener)" attributes="__classmethod__" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope name="write" ilk="function" signature="write( output, indent )" />
            <variable name="START" attributes="__const__" citdl="Object" />
            <variable name="START_RE" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
            <variable name="PLAIN" attributes="__const__" citdl="Object" />
            <variable name="PERCENT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/dtd/notationdecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="DTD" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rexml/element" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Attributes" ilk="class" classrefs="Hash">
          <scope name="new" ilk="function" signature="new(element)" attributes="__classmethod__ __ctor__" doc="Constructor the Element of which this is an Attribute" />
          <scope name="add" ilk="function" signature="add( attribute )" doc="Adds an attribute, overriding any existing attribute by the same name.  Namespaces are significant. An Attribute" />
          <scope name="delete" ilk="function" signature="delete( attribute )" doc="Removes an attribute either a String, which is the name of the attribute to remove -- namespaces are significant here -- or the attribute to remove.&#xA;the owning element doc = Document.new &quot;&lt;a y:foo=&apos;0&apos; x:foo=&apos;1&apos; foo=&apos;3&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA;doc.root.attributes.delete &apos;foo&apos;   #-&gt; &lt;a y:foo=&apos;0&apos; x:foo=&apos;1&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA;doc.root.attributes.delete &apos;x:foo&apos; #-&gt; &lt;a y:foo=&apos;0&apos; z:foo=&apos;4&apos;/&gt;&quot;&#xA;attr = doc.root.attributes.get_attribute(&apos;y:foo&apos;)&#xA;doc.root.attributes.delete attr    #-&gt; &lt;a z:foo=&apos;4&apos;/&gt;&quot;" />
          <scope name="delete_all" ilk="function" signature="delete_all( name )" doc="Deletes all attributes matching a name.  Namespaces are significant. A String; all attributes that match this path will be removed&#xA;an Array of the Attributes that were removed" />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over each attribute of an Element, yielding the expanded name and value as a pair of Strings. &#xA; doc = Document.new &apos;&lt;a x=&quot;1&quot; y=&quot;2&quot;/&gt;&apos;&#xA;doc.root.attributes.each {|name, value| p name+&quot; =&gt; &quot;+value }" />
          <scope name="each_attribute" ilk="function" signature="each_attribute()" doc="Iterates over the attributes of an Element.  Yields actual Attribute nodes, not String values. &#xA; doc = Document.new &apos;&lt;a x=&quot;1&quot; y=&quot;2&quot;/&gt;&apos;&#xA;doc.root.attributes.each_attribute {|attr|&#xA;  p attr.expanded_name+&quot; =&gt; &quot;+attr.value&#xA;}" />
          <scope name="get_attribute" ilk="function" signature="get_attribute( name )" doc="Fetches an attribute the name by which to search for the attribute.  Can be a prefix:name namespace name.&#xA;The first matching attribute, or nil if there was none.  This value is an Attribute node, not the String value of the attribute. doc = Document.new &apos;&lt;a x:foo=&quot;1&quot; foo=&quot;2&quot; bar=&quot;3&quot;/&gt;&apos;&#xA;doc.root.attributes.get_attribute(&quot;foo&quot;).value    #-&gt; &quot;2&quot;&#xA;doc.root.attributes.get_attribute(&quot;x:foo&quot;).value  #-&gt; &quot;1&quot;" />
          <scope name="get_attribute_ns" ilk="function" signature="get_attribute_ns(namespace, name)" doc="The +get_attribute_ns+ method retrieves a method by its namespace and name. Thus it is possible to reliably identify an attribute even if an XML processor has changed the prefix. &#xA; Method contributed by Henrik Martensson" />
          <scope name="length" ilk="function" signature="length()" doc="Returns the number of attributes the owning Element contains. doc = Document &quot;&lt;a x=&apos;1&apos; y=&apos;2&apos; foo:x=&apos;3&apos;/&gt;&quot;&#xA;doc.root.attributes.length        #-&gt; 3" />
          <scope name="namespaces" ilk="function" signature="namespaces()" />
          <scope name="prefixes" ilk="function" signature="prefixes()" doc="Returns an array of Strings containing all of the prefixes declared by this set of # attributes.  The array does not include the default namespace declaration, if one exists. doc = Document.new(&quot;&lt;a xmlns=&apos;foo&apos; xmlns:x=&apos;bar&apos; xmlns:y=&apos;twee&apos; &quot;+&#xA;      &quot;z=&apos;glorp&apos; p:k=&apos;gru&apos;/&gt;&quot;)&#xA;prefixes = doc.root.attributes.prefixes    #-&gt; [&apos;x&apos;, &apos;y&apos;]" />
          <scope name="size" ilk="function" signature="size()" />
          <scope name="to_a" ilk="function" signature="to_a()" />
        </scope>
        <scope name="Element" ilk="class" classrefs="Parent">
          <import symbol="Namespace" />
          <scope name="new" ilk="function" signature="new( arg = UNDEFINED, parent=nil, context=nil )" attributes="__classmethod__ __ctor__" doc="Constructor if not supplied, will be set to the default value. If a String, the name of this object will be set to the argument. If an Element, the object will be shallowly cloned; name, attributes, and namespaces will be copied.  Children will +not+ be copied.&#xA;if supplied, must be a Parent, and will be used as the parent of this object.&#xA;If supplied, must be a hash containing context items.  Context items include: :respect_whitespace the value of this is :+all+ or an array of strings being the names of the elements to respect whitespace for.  Defaults to :+all+.&#xA;:compress_whitespace the value can be :+all+ or an array of strings being the names of the elements to ignore whitespace on. Overrides :+respect_whitespace+.&#xA;:ignore_whitespace_nodes the value can be :+all+ or an array of strings being the names of the elements in which to ignore whitespace-only nodes.  If this is set, Text nodes which contain only whitespace will not be added to the document tree.&#xA;:raw can be :+all+, or an array of strings being the names of the elements to process in raw mode.  In raw mode, special characters in text is not converted to or from entities." />
          <scope name="add_attribute" ilk="function" signature="add_attribute( key, value=nil )" doc="Adds an attribute to this element, overwriting any existing attribute by the same name. can be either an Attribute or a String.  If an Attribute, the attribute is added to the list of Element attributes.  If String, the argument is used as the name of the new attribute, and the value parameter must be supplied.&#xA;Required if +key+ is a String, and ignored if the first argument is an Attribute.  This is a String, and is used as the value of the new Attribute.  This should be the unnormalized value of the attribute (without entities).&#xA;the Attribute added e = Element.new &apos;e&apos;&#xA;e.add_attribute( &apos;a&apos;, &apos;b&apos; )               #-&gt; &lt;e a=&apos;b&apos;/&gt;&#xA;e.add_attribute( &apos;x:a&apos;, &apos;c&apos; )             #-&gt; &lt;e a=&apos;b&apos; x:a=&apos;c&apos;/&gt;&#xA;e.add_attribute Attribute.new(&apos;b&apos;, &apos;d&apos;)   #-&gt; &lt;e a=&apos;b&apos; x:a=&apos;c&apos; b=&apos;d&apos;/&gt;" />
          <scope name="add_attributes" ilk="function" signature="add_attributes(hash)" doc="Add multiple attributes to this element. is either a hash, or array of arrays el.add_attributes( {&quot;name1&quot;=&gt;&quot;value1&quot;, &quot;name2&quot;=&gt;&quot;value2&quot;} )&#xA;el.add_attributes( [ [&quot;name1&quot;,&quot;value1&quot;], [&quot;name2&quot;=&gt;&quot;value2&quot;] ] )" />
          <scope name="add_element" ilk="function" signature="add_element(element, attrs=nil)" doc="Adds a child to this element, optionally setting attributes in the element. optional.  If Element, the element is added. Otherwise, a new Element is constructed with the argument (see Element.initialize).&#xA;If supplied, must be a Hash containing String name,value pairs, which will be used to set the attributes of the new Element.&#xA;the Element that was added el = doc.add_element &apos;my-tag&apos;&#xA;el = doc.add_element &apos;my-tag&apos;, {&apos;attr1&apos;=&gt;&apos;val1&apos;, &apos;attr2&apos;=&gt;&apos;val2&apos;}&#xA;el = Element.new &apos;my-tag&apos;&#xA;doc.add_element el" />
          <scope name="add_namespace" ilk="function" signature="add_namespace( prefix, uri=nil )" doc="Adds a namespace to this element. the prefix string, or the namespace URI if +uri+ is not supplied&#xA;the namespace URI.  May be nil, in which +prefix+ is used as the URI Evaluates to: this Element a = Element.new(&quot;a&quot;)&#xA;a.add_namespace(&quot;xmlns:foo&quot;, &quot;bar&quot; )&#xA;a.add_namespace(&quot;foo&quot;, &quot;bar&quot;)  # shorthand for previous line&#xA;a.add_namespace(&quot;twiddle&quot;)&#xA;puts a   #-&gt; &lt;a xmlns:foo=&apos;bar&apos; xmlns=&apos;twiddle&apos;/&gt;" />
          <scope name="add_text" ilk="function" signature="add_text( text )" doc="A helper method to add a Text child.  Actual Text instances can be added with regular Parent methods, such as add() and &lt;&lt;() if a String, a new Text instance is created and added to the parent.  If Text, the object is added directly.&#xA;this Element e = Element.new(&apos;a&apos;)          #-&gt; &lt;e/&gt;&#xA;e.add_text &apos;foo&apos;              #-&gt; &lt;e&gt;foo&lt;/e&gt;&#xA;e.add_text Text.new(&apos; bar&apos;)    #-&gt; &lt;e&gt;foo bar&lt;/e&gt;&#xA; Note that at the end of this example, the branch has &lt;b&gt;3&lt;/b&gt; nodes; the &apos;e&apos; element and &lt;b&gt;2&lt;/b&gt; Text node children." />
          <scope name="attribute" ilk="function" signature="attribute( name, namespace=nil )" doc="Attributes                                    #" />
          <scope name="cdatas" ilk="function" signature="cdatas()" doc="Get an array of all CData children. IMMUTABLE" />
          <scope name="clone" ilk="function" signature="clone()" doc="Creates a shallow copy of self. d = Document.new &quot;&lt;a&gt;&lt;b/&gt;&lt;b/&gt;&lt;c&gt;&lt;d/&gt;&lt;/c&gt;&lt;/a&gt;&quot;&#xA;new_a = d.root.clone&#xA;puts new_a  # =&gt; &quot;&lt;a/&gt;&quot;" />
          <scope name="comments" ilk="function" signature="comments()" doc="Get an array of all Comment children. IMMUTABLE" />
          <scope name="delete_attribute" ilk="function" signature="delete_attribute(key)" doc="Removes an attribute either an Attribute or a String.  In either case, the attribute is found by matching the attribute name to the argument, and then removed.  If no attribute is found, no action is taken.&#xA;the attribute removed, or nil if this Element did not contain a matching attribute e = Element.new(&apos;E&apos;)&#xA;e.add_attribute( &apos;name&apos;, &apos;Sean&apos; )             #-&gt; &lt;E name=&apos;Sean&apos;/&gt;&#xA;r = e.add_attribute( &apos;sur:name&apos;, &apos;Russell&apos; )  #-&gt; &lt;E name=&apos;Sean&apos; sur:name=&apos;Russell&apos;/&gt;&#xA;e.delete_attribute( &apos;name&apos; )                  #-&gt; &lt;E sur:name=&apos;Russell&apos;/&gt;&#xA;e.delete_attribute( r )                       #-&gt; &lt;E/&gt;" />
          <scope name="delete_element" ilk="function" signature="delete_element(element)" doc="Deletes a child element. Must be an +Element+, +String+, or +Integer+.  If Element, the element is removed.  If String, the element is found (via XPath) and removed.  This means that any parent can remove any descendant.  If Integer, the Element indexed by that number will be removed.&#xA;the element that was removed. doc.delete_element &quot;/a/b/c[@id=&apos;4&apos;]&quot;&#xA;doc.delete_element doc.elements[&quot;//k&quot;]&#xA;doc.delete_element 1" />
          <scope name="delete_namespace" ilk="function" signature="delete_namespace(namespace=&quot;xmlns&quot;)" doc="Removes a namespace from this node.  This only works if the namespace is actually declared in this node.  If no argument is passed, deletes the default namespace. &#xA; Evaluates to: this element doc = Document.new &quot;&lt;a xmlns:foo=&apos;bar&apos; xmlns=&apos;twiddle&apos;/&gt;&quot;&#xA;doc.root.delete_namespace&#xA;puts doc     # -&gt; &lt;a xmlns:foo=&apos;bar&apos;/&gt;&#xA;doc.root.delete_namespace &apos;foo&apos;&#xA;puts doc     # -&gt; &lt;a/&gt;" />
          <scope name="document" ilk="function" signature="document()" doc="Evaluates to the document to which this element belongs, or nil if this element doesn&apos;t belong to a document." />
          <scope name="each_element" ilk="function" signature="each_element( xpath=nil )" doc="Synonym for Element.elements.each" />
          <scope name="each_element_with_attribute" ilk="function" signature="each_element_with_attribute( key, value=nil, max=0, name=nil )" doc="Iterates through the child elements, yielding for each Element that has a particular attribute set. the name of the attribute to search for&#xA;the value of the attribute&#xA;(optional) causes this method to return after yielding for this number of matching children&#xA;(optional) if supplied, this is an XPath that filters the children to check. &#xA; doc = Document.new &quot;&lt;a&gt;&lt;b @id=&apos;1&apos;/&gt;&lt;c @id=&apos;2&apos;/&gt;&lt;d @id=&apos;1&apos;/&gt;&lt;e/&gt;&lt;/a&gt;&quot;&#xA;# Yields b, c, d&#xA;doc.root.each_element_with_attribute( &apos;id&apos; ) {|e| p e}&#xA;# Yields b, d&#xA;doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos; ) {|e| p e}&#xA;# Yields b&#xA;doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos;, 1 ) {|e| p e}&#xA;# Yields d&#xA;doc.root.each_element_with_attribute( &apos;id&apos;, &apos;1&apos;, 0, &apos;d&apos; ) {|e| p e}" />
          <scope name="each_element_with_text" ilk="function" signature="each_element_with_text( text=nil, max=0, name=nil )" doc="Iterates through the children, yielding for each Element that has a particular text set. the text to search for.  If nil, or not supplied, will iterate over all +Element+ children that contain at least one +Text+ node.&#xA;(optional) causes this method to return after yielding for this number of matching children&#xA;(optional) if supplied, this is an XPath that filters the children to check. &#xA; doc = Document.new &apos;&lt;a&gt;&lt;b&gt;b&lt;/b&gt;&lt;c&gt;b&lt;/c&gt;&lt;d&gt;d&lt;/d&gt;&lt;e/&gt;&lt;/a&gt;&apos;&#xA;# Yields b, c, d&#xA;doc.each_element_with_text {|e|p e}&#xA;# Yields b, c&#xA;doc.each_element_with_text(&apos;b&apos;){|e|p e}&#xA;# Yields b&#xA;doc.each_element_with_text(&apos;b&apos;, 1){|e|p e}&#xA;# Yields d&#xA;doc.each_element_with_text(nil, 0, &apos;d&apos;){|e|p e}" />
          <scope name="get_elements" ilk="function" signature="get_elements( xpath )" doc="Synonym for Element.to_a This is a little slower than calling elements.each directly. any XPath by which to search for elements in the tree&#xA;an array of Elements that match the supplied path" />
          <scope name="get_text" ilk="function" signature="get_text(path = nil)" doc="Returns the first child Text node, if any, or +nil+ otherwise. This method returns the actual +Text+ node, rather than the String content. doc = Document.new &quot;&lt;p&gt;some text &lt;b&gt;this is bold!&lt;/b&gt; more text&lt;/p&gt;&quot;&#xA;# The element &apos;p&apos; has two text elements, &quot;some text &quot; and &quot; more text&quot;.&#xA;doc.root.get_text.value            #-&gt; &quot;some text &quot;" />
          <scope name="has_attributes?" ilk="function" signature="has_attributes?()" doc="Evaluates to +true+ if this element has any attributes set, false otherwise." />
          <scope name="has_elements?" ilk="function" signature="has_elements?()" doc="Evaluates to +true+ if this element has at least one child Element doc = Document.new &quot;&lt;a&gt;&lt;b/&gt;&lt;c&gt;Text&lt;/c&gt;&lt;/a&gt;&quot;&#xA;doc.root.has_elements               # -&gt; true&#xA;doc.elements[&quot;/a/b&quot;].has_elements   # -&gt; false&#xA;doc.elements[&quot;/a/c&quot;].has_elements   # -&gt; false" />
          <scope name="has_text?" ilk="function" signature="has_text?()" doc="Evaluates to +true+ if this element has at least one Text child" />
          <scope name="ignore_whitespace_nodes" ilk="function" signature="ignore_whitespace_nodes()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="instructions" ilk="function" signature="instructions()" doc="Get an array of all Instruction children. IMMUTABLE" />
          <scope name="namespace" ilk="function" signature="namespace(prefix=nil)" doc="Evalutas to the URI for a prefix, or the empty string if no such namespace is declared for this element. Evaluates recursively for ancestors.  Returns the default namespace, if there is one. the prefix to search for.  If not supplied, returns the default namespace if one exists&#xA;the namespace URI as a String, or nil if no such namespace exists.  If the namespace is undefined, returns an empty string doc = Document.new(&quot;&lt;a xmlns=&apos;1&apos; xmlns:y=&apos;2&apos;&gt;&lt;b/&gt;&lt;c xmlns:z=&apos;3&apos;/&gt;&lt;/a&gt;&quot;)&#xA;b = doc.elements[&apos;//b&apos;]&#xA;b.namespace           # -&gt; &apos;1&apos;&#xA;b.namespace(&quot;y&quot;)      # -&gt; &apos;2&apos;" />
          <scope name="namespaces" ilk="function" signature="namespaces()" />
          <scope name="next_element" ilk="function" signature="next_element()" doc="Returns the next sibling that is an element, or nil if there is no Element sibling after this one doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&apos;&#xA;doc.root.elements[&apos;b&apos;].next_element          #-&gt; &lt;c/&gt;&#xA;doc.root.elements[&apos;c&apos;].next_element          #-&gt; nil" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="prefixes" ilk="function" signature="prefixes()" doc="Evaluates to an +Array+ containing the prefixes (names) of all defined namespaces at this context node. doc = Document.new(&quot;&lt;a xmlns:x=&apos;1&apos; xmlns:y=&apos;2&apos;&gt;&lt;b/&gt;&lt;c xmlns:z=&apos;3&apos;/&gt;&lt;/a&gt;&quot;)&#xA;doc.elements[&apos;//b&apos;].prefixes # -&gt; [&apos;x&apos;, &apos;y&apos;]" />
          <scope name="previous_element" ilk="function" signature="previous_element()" doc="Returns the previous sibling that is an element, or nil if there is no Element sibling prior to this one doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;text&lt;c/&gt;&lt;/a&gt;&apos;&#xA;doc.root.elements[&apos;c&apos;].previous_element          #-&gt; &lt;b/&gt;&#xA;doc.root.elements[&apos;b&apos;].previous_element          #-&gt; nil" />
          <scope name="raw" ilk="function" signature="raw()" doc="Evaluates to +true+ if raw mode is set for this element.  This is the case if the context has :+raw+ set to :+all+ or an array containing the name of this element. &#xA; The evaluation is tested against +expanded_name+, and so is namespace sensitive." />
          <scope name="root" ilk="function" signature="root()" />
          <scope name="root_node" ilk="function" signature="root_node()" doc="Evaluates to the root node of the document that this element belongs to. If this element doesn&apos;t belong to a document, but does belong to another Element, the parent&apos;s root will be returned, until the earliest ancestor is found. &#xA; Note that this is not the same as the document element. In the following example, &lt;a&gt; is the document element, and the root node is the parent node of the document element.  You may ask yourself why the root node is useful: consider the doctype and XML declaration, and any processing instructions before the document element... they are children of the root node, or siblings of the document element. The only time this isn&apos;t true is when an Element is created that is not part of any Document.  In this case, the ancestor that has no parent acts as the root node. d = Document.new &apos;&lt;a&gt;&lt;b&gt;&lt;c/&gt;&lt;/b&gt;&lt;/a&gt;&apos;&#xA;a = d[1] ; c = a[1][1]&#xA;d.root_node == d   # TRUE&#xA;a.root_node        # namely, d&#xA;c.root_node        # again, d" />
          <scope name="text" ilk="function" signature="text( path = nil )" doc="A convenience method which returns the String value of the _first_ child text element, if one exists, and +nil+ otherwise. &#xA; Note that an element may have multiple Text elements, perhaps separated by other children.  Be aware that this method only returns the first Text node. &#xA; This method returns the +value+ of the first text child node, which ignores the +raw+ setting, so always returns normalized text. See the Text::value documentation. &#xA; doc = Document.new &quot;&lt;p&gt;some text &lt;b&gt;this is bold!&lt;/b&gt; more text&lt;/p&gt;&quot;&#xA;# The element &apos;p&apos; has two text elements, &quot;some text &quot; and &quot; more text&quot;.&#xA;doc.root.text              #-&gt; &quot;some text &quot;" />
          <scope name="text=" ilk="function" signature="text=( text )" doc="Sets the first Text child of this object.  See text() for a discussion about Text children. &#xA; If a Text child already exists, the child is replaced by this content.  This means that Text content can be deleted by calling this method with a nil argument.  In this case, the next Text child becomes the first Text child.  In no case is the order of any siblings disturbed. If a String, a new Text child is created and added to this Element as the first Text child.  If Text, the text is set as the first Child element.  If nil, then any existing first Text child is removed.&#xA;this Element. doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&apos;&#xA;doc.root.text = &apos;Sean&apos;      #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Sean&lt;/a&gt;&apos;&#xA;doc.root.text = &apos;Elliott&apos;   #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Elliott&lt;/a&gt;&apos;&#xA;doc.root.add_element &apos;c&apos;    #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Elliott&lt;c/&gt;&lt;/a&gt;&apos;&#xA;doc.root.text = &apos;Russell&apos;   #-&gt; &apos;&lt;a&gt;&lt;b/&gt;Russell&lt;c/&gt;&lt;/a&gt;&apos;&#xA;doc.root.text = nil         #-&gt; &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;&apos;" />
          <scope name="texts" ilk="function" signature="texts()" doc="Get an array of all Text children. IMMUTABLE" />
          <scope name="whitespace" ilk="function" signature="whitespace()" doc="Evaluates to +true+ if whitespace is respected for this element.  This is the case if: Neither :+respect_whitespace+ nor :+compress_whitespace+ has any value&#xA;The context has :+respect_whitespace+ set to :+all+ or an array containing the name of this element, and :+compress_whitespace+ isn&apos;t set to :+all+ or an array containing the name of this element. The evaluation is tested against +expanded_name+, and so is namespace sensitive." />
          <scope name="write" ilk="function" signature="write(output=$stdout, indent=-1, transitive=false, ie_hack=false)" doc="DEPRECATED See REXML::Formatters &#xA; Writes out this element, and recursively, all children. output an object which supports &apos;&lt;&lt; string&apos;; this is where the document will be written.&#xA; An integer.  If -1, no indenting will be used; otherwise, the indentation will be this number of spaces, and children will be indented an additional amount.  Defaults to -1&#xA;If transitive is true and indent is &gt;= 0, then the output will be pretty-printed in such a way that the added whitespace does not affect the parse tree of the document&#xA;Internet Explorer is the worst piece of crap to have ever been written, with the possible exception of Windows itself.  Since IE is unable to parse proper XML, we have to provide a hack to generate XML that IE&apos;s limited abilities can handle.  This hack inserts a space before the /&gt; on empty tags.  Defaults to false &#xA; out = &apos;&apos;&#xA;doc.write( out )     #-&gt; doc is written to the string &apos;out&apos;&#xA;doc.write( $stdout ) #-&gt; doc written to the console" />
          <scope name="xpath" ilk="function" signature="xpath()" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="context" />
          <scope ilk="function" name="context=" />
          <scope ilk="function" name="elements" />
          <variable name="UNDEFINED" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Elements" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(parent)" attributes="__classmethod__ __ctor__" doc="Constructor the parent Element" />
          <scope name="add" ilk="function" signature="add(element=nil)" doc="Adds an element if supplied, is either an Element, String, or Source (see Element.initialize).  If not supplied or nil, a new, default Element will be constructed&#xA;the added Element a = Element.new(&apos;a&apos;)&#xA;a.elements.add(Element.new(&apos;b&apos;))  #-&gt; &lt;a&gt;&lt;b/&gt;&lt;/a&gt;&#xA;a.elements.add(&apos;c&apos;)               #-&gt; &lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;/a&gt;" />
          <scope name="collect" ilk="function" signature="collect( xpath=nil, &amp;block )" />
          <scope name="delete" ilk="function" signature="delete(element)" doc="Deletes a child Element Either an Element, which is removed directly; an xpath, where the first matching child is removed; or an Integer, where the n&apos;th Element is removed.&#xA;the removed child doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;c id=&quot;1&quot;/&gt;&lt;/a&gt;&apos;&#xA;b = doc.root.elements[1]&#xA;doc.root.elements.delete b           #-&gt; &lt;a&gt;&lt;c/&gt;&lt;c id=&quot;1&quot;/&gt;&lt;/a&gt;&#xA;doc.elements.delete(&quot;a/c[@id=&apos;1&apos;]&quot;)  #-&gt; &lt;a&gt;&lt;c/&gt;&lt;/a&gt;&#xA;doc.root.elements.delete 1           #-&gt; &lt;a/&gt;" />
          <scope name="delete_all" ilk="function" signature="delete_all( xpath )" doc="Removes multiple elements.  Filters for Element children, regardless of XPath matching. all elements matching this String path are removed.&#xA;an Array of Elements that have been removed doc = Document.new &apos;&lt;a&gt;&lt;c/&gt;&lt;c/&gt;&lt;c/&gt;&lt;c/&gt;&lt;/a&gt;&apos;&#xA;deleted = doc.elements.delete_all &apos;a/c&apos; #-&gt; [&lt;c/&gt;, &lt;c/&gt;, &lt;c/&gt;, &lt;c/&gt;]" />
          <scope name="each" ilk="function" signature="each( xpath=nil, &amp;block)" doc="Iterates through all of the child Elements, optionally filtering them by a given XPath optional.  If supplied, this is a String XPath, and is used to filter the children, so that only matching children are yielded.  Note that XPaths are automatically filtered for Elements, so that non-Element children will not be yielded doc = Document.new &apos;&lt;a&gt;&lt;b/&gt;&lt;c/&gt;&lt;d/&gt;sean&lt;b/&gt;&lt;c/&gt;&lt;d/&gt;&lt;/a&gt;&apos;&#xA;doc.root.each {|e|p e}       #-&gt; Yields b, c, d, b, c, d elements&#xA;doc.root.each(&apos;b&apos;) {|e|p e}  #-&gt; Yields b, b elements&#xA;doc.root.each(&apos;child::node()&apos;)  {|e|p e}&#xA;#-&gt; Yields &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;, &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;&#xA;XPath.each(doc.root, &apos;child::node()&apos;, &amp;block)&#xA;#-&gt; Yields &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;, sean, &lt;b/&gt;, &lt;c/&gt;, &lt;d/&gt;" />
          <scope name="empty?" ilk="function" signature="empty?()" doc="Returns +true+ if there are no +Element+ children, +false+ otherwise" />
          <scope name="index" ilk="function" signature="index(element)" doc="Returns the index of the supplied child (starting at 1), or -1 if the element is not a child an +Element+ child" />
          <scope name="inject" ilk="function" signature="inject( xpath=nil, initial=nil, &amp;block )" />
          <scope name="size" ilk="function" signature="size()" doc="Returns the number of +Element+ children of the parent object. doc = Document.new &apos;&lt;a&gt;sean&lt;b/&gt;elliott&lt;b/&gt;russell&lt;b/&gt;&lt;/a&gt;&apos;&#xA;doc.root.size            #-&gt; 6, 3 element and 3 text nodes&#xA;doc.root.elements.size   #-&gt; 3" />
          <scope name="to_a" ilk="function" signature="to_a( xpath=nil )" doc="Returns an Array of Element children.  An XPath may be supplied to filter the children.  Only Element children are returned, even if the supplied XPath matches non-Element children. doc = Document.new &apos;&lt;a&gt;sean&lt;b/&gt;elliott&lt;c/&gt;&lt;/a&gt;&apos;&#xA;doc.root.elements.to_a                  #-&gt; [ &lt;b/&gt;, &lt;c/&gt; ]&#xA;doc.root.elements.to_a(&quot;child::node()&quot;) #-&gt; [ &lt;b/&gt;, &lt;c/&gt; ]&#xA;XPath.match(doc.root, &quot;child::node()&quot;)  #-&gt; [ sean, &lt;b/&gt;, elliott, &lt;c/&gt; ]" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/encoding" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Encoding" ilk="namespace">
          <scope name="check_encoding" ilk="function" signature="check_encoding(xml)" />
          <scope name="decode" ilk="function" signature="decode(string)" />
          <scope name="encode" ilk="function" signature="encode(string)" />
          <scope name="encoding=" ilk="function" signature="encoding=(encoding)" />
          <scope ilk="function" name="encoding" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/entity" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Entity" ilk="class" classrefs="Child">
          <import symbol="XMLTokens" />
          <scope name="matches?" ilk="function" signature="matches?(string)" attributes="__classmethod__" doc="Evaluates whether the given string matchs an entity definition, returning true if so, and false otherwise." />
          <scope name="new" ilk="function" signature="new(stream, value=nil, parent=nil, reference=false)" attributes="__classmethod__ __ctor__" doc="Create a new entity.  Simple entities can be constructed by passing a name, value to the constructor; this creates a generic, plain entity reference. For anything more complicated, you have to pass a Source to the constructor with the entity definition, or use the accessor methods. +WARNING+: There is no validation of entity state except when the entity is read from a stream.  If you start poking around with the accessors, you can easily create a non-conformant Entity.  The best thing to do is dump the stupid DTDs and use XMLSchema instead. &#xA; e = Entity.new( &apos;amp&apos;, &apos;&amp;&apos; )" />
          <scope name="normalized" ilk="function" signature="normalized()" doc="Returns the value of this entity unprocessed -- raw.  This is the normalized value; that is, with all %ent; and &amp;ent; entities intact" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns this entity as a string.  See write()." />
          <scope name="unnormalized" ilk="function" signature="unnormalized()" doc="Evaluates to the unnormalized value of this entity; that is, replacing all entities -- both %ent; and &amp;ent; entities.  This differs from +value()+ in that +value+ only replaces %ent; entities." />
          <scope name="value" ilk="function" signature="value()" doc="Returns the value of this entity.  At the moment, only internal entities are processed.  If the value contains internal references (IE, %blah;), those are replaced with their values.  IE, if the doctype contains: &lt;!ENTITY % foo &quot;bar&quot;&gt;&#xA;&lt;!ENTITY yada &quot;nanoo %foo; nanoo&gt;&#xA; then: doctype.entity(&apos;yada&apos;).value   #-&gt; &quot;nanoo bar nanoo&quot;" />
          <scope name="write" ilk="function" signature="write(out, indent=-1)" doc="Write out a fully formed, correct entity definition (assuming the Entity object itself is valid.) &#xA; An object implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;TT&gt; to which the entity will be output&#xA;*DEPRECATED* and ignored" />
          <scope ilk="function" name="external" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="ndata" />
          <scope ilk="function" name="pubid" />
          <scope ilk="function" name="ref" />
          <variable name="PUBIDCHAR" attributes="__const__" citdl="Object" />
          <variable name="SYSTEMLITERAL" attributes="__const__" citdl="Object" />
          <variable name="PUBIDLITERAL" attributes="__const__" citdl="Object" />
          <variable name="EXTERNALID" attributes="__const__" citdl="Object" />
          <variable name="NDATADECL" attributes="__const__" citdl="Object" />
          <variable name="PEREFERENCE" attributes="__const__" citdl="Object" />
          <variable name="ENTITYVALUE" attributes="__const__" citdl="Object" />
          <variable name="PEDEF" attributes="__const__" citdl="Object" />
          <variable name="ENTITYDEF" attributes="__const__" citdl="Object" />
          <variable name="PEDECL" attributes="__const__" citdl="Object" />
          <variable name="GEDECL" attributes="__const__" citdl="Object" />
          <variable name="ENTITYDECL" attributes="__const__" citdl="Object" />
          <variable name="PEREFERENCE_RE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="EntityConst" ilk="namespace">
          <variable name="GT" attributes="__const__" citdl="Object" />
          <variable name="LT" attributes="__const__" citdl="Object" />
          <variable name="AMP" attributes="__const__" citdl="Object" />
          <variable name="QUOT" attributes="__const__" citdl="Object" />
          <variable name="APOS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/default" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Default" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( ie_hack=false )" attributes="__classmethod__ __ctor__" doc="Prints out the XML document with no formatting -- except if id_hack is set. &#xA; If set to true, then inserts whitespace before the close of an empty tag, so that IE&apos;s bad XML parser doesn&apos;t choke." />
            <scope name="write" ilk="function" signature="write( node, output )" doc="Writes the node to some output. &#xA; The node to write&#xA;A class implementing &lt;TT&gt;&amp;lt;&amp;lt;&lt;/TT&gt;.  Pass in an Output object to change the output encoding." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/pretty" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Pretty" ilk="class" classrefs="Default">
            <scope name="new" ilk="function" signature="new( indentation=2, ie_hack=false )" attributes="__classmethod__ __ctor__" doc="Create a new pretty printer. &#xA; An object implementing &apos;&lt;&lt;(String)&apos;, to which the output will be written.&#xA;An integer greater than 0.  The indentation of each level will be this number of spaces.  If this is &lt; 1, the behavior of this object is undefined.  Defaults to 2.&#xA;If true, the printer will insert whitespace before closing empty tags, thereby allowing Internet Explorer&apos;s feeble XML parser to function. Defaults to false." />
            <scope ilk="function" name="compact" />
            <scope ilk="function" name="compact=" />
            <scope ilk="function" name="width" />
            <scope ilk="function" name="width=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/formatters/transitive" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Formatters" ilk="namespace">
          <scope name="Transitive" ilk="class" classrefs="Default">
            <scope name="new" ilk="function" signature="new( indentation=2, ie_hack=false )" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/functions" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Functions" ilk="namespace">
          <scope name="boolean" ilk="function" signature="boolean( object=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="ceiling" ilk="function" signature="ceiling( number )" attributes="__classmethod__" />
          <scope name="compare_language" ilk="function" signature="compare_language(lang1, lang2)" attributes="__classmethod__" />
          <scope name="concat" ilk="function" signature="concat( *objects )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="contains" ilk="function" signature="contains( string, test )" attributes="__classmethod__" doc="Fixed by Mike Stok" />
          <scope name="context=" ilk="function" signature="context=(value)" attributes="__classmethod__" />
          <scope name="count" ilk="function" signature="count( node_set )" attributes="__classmethod__" doc="Returns the size of the given list of nodes." />
          <scope name="false" ilk="function" signature="false( )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="floor" ilk="function" signature="floor( number )" attributes="__classmethod__" />
          <scope name="get_namespace" ilk="function" signature="get_namespace( node_set = nil )" attributes="__classmethod__" doc="Helper method." />
          <scope name="id" ilk="function" signature="id( object )" attributes="__classmethod__" doc="Since REXML is non-validating, this method is not implemented as it requires a DTD" />
          <scope name="lang" ilk="function" signature="lang( language )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="last" ilk="function" signature="last( )" attributes="__classmethod__" doc="Returns the last node of the given list of nodes." />
          <scope name="local_name" ilk="function" signature="local_name( node_set=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="method_missing" ilk="function" signature="method_missing( id )" attributes="__classmethod__" />
          <scope name="name" ilk="function" signature="name( node_set=nil )" attributes="__classmethod__" />
          <scope name="namespace_context" ilk="function" signature="namespace_context()" attributes="__classmethod__" />
          <scope name="namespace_context=" ilk="function" signature="namespace_context=(x)" attributes="__classmethod__" />
          <scope name="namespace_uri" ilk="function" signature="namespace_uri( node_set=nil )" attributes="__classmethod__" />
          <scope name="normalize_space" ilk="function" signature="normalize_space( string=nil )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="not" ilk="function" signature="not( object )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="number" ilk="function" signature="number( object=nil )" attributes="__classmethod__" doc="a string that consists of optional whitespace followed by an optional minus sign followed by a Number followed by whitespace is converted to the IEEE 754 number that is nearest (according to the IEEE 754 round-to-nearest rule) to the mathematical value represented by the string; any other string is converted to NaN &#xA; boolean true is converted to 1; boolean false is converted to 0 &#xA; a node-set is first converted to a string as if by a call to the string function and then converted in the same way as a string argument &#xA; an object of a type other than the four basic types is converted to a number in a way that is dependent on that type" />
          <scope name="position" ilk="function" signature="position( )" attributes="__classmethod__" />
          <scope name="processing_instruction" ilk="function" signature="processing_instruction( node )" attributes="__classmethod__" />
          <scope name="round" ilk="function" signature="round( number )" attributes="__classmethod__" />
          <scope name="starts_with" ilk="function" signature="starts_with( string, test )" attributes="__classmethod__" doc="Fixed by Mike Stok" />
          <scope name="string" ilk="function" signature="string( object=nil )" attributes="__classmethod__" doc="A node-set is converted to a string by returning the string-value of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned. &#xA; A number is converted to a string as follows &#xA; NaN is converted to the string NaN &#xA; positive zero is converted to the string 0 &#xA; negative zero is converted to the string 0 &#xA; positive infinity is converted to the string Infinity &#xA; negative infinity is converted to the string -Infinity &#xA; if the number is an integer, the number is represented in decimal form as a Number with no decimal point and no leading zeros, preceded by a minus sign (-) if the number is negative &#xA; otherwise, the number is represented in decimal form as a Number including a decimal point with at least one digit before the decimal point and at least one digit after the decimal point, preceded by a minus sign (-) if the number is negative; there must be no leading zeros before the decimal point apart possibly from the one required digit immediately before the decimal point; beyond the one required digit after the decimal point there must be as many, but only as many, more digits as are needed to uniquely distinguish the number from all other IEEE 754 numeric values. &#xA; The boolean false value is converted to the string false. The boolean true value is converted to the string true. &#xA; An object of a type other than the four basic types is converted to a string in a way that is dependent on that type." />
          <scope name="string_length" ilk="function" signature="string_length( string )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="string_value" ilk="function" signature="string_value( o )" attributes="__classmethod__" doc="A node-set is converted to a string by returning the concatenation of the string-value of each of the children of the node in the node-set that is first in document order. If the node-set is empty, an empty string is returned." />
          <scope name="substring" ilk="function" signature="substring( string, start, length=nil )" attributes="__classmethod__" doc="Take equal portions of Mike Stok and Sean Russell; mix vigorously, and pour into a tall, chilled glass.  Serves 10,000." />
          <scope name="substring_after" ilk="function" signature="substring_after( string, test )" attributes="__classmethod__" doc="Kouhei fixed this too" />
          <scope name="substring_before" ilk="function" signature="substring_before( string, test )" attributes="__classmethod__" doc="Kouhei fixed this" />
          <scope name="sum" ilk="function" signature="sum( nodes )" attributes="__classmethod__" />
          <scope name="text" ilk="function" signature="text( )" attributes="__classmethod__" />
          <scope name="translate" ilk="function" signature="translate( string, tr1, tr2 )" attributes="__classmethod__" doc="This is entirely Mike Stok&apos;s beast" />
          <scope name="true" ilk="function" signature="true( )" attributes="__classmethod__" doc="UNTESTED" />
          <scope name="variables" ilk="function" signature="variables()" attributes="__classmethod__" />
          <scope name="variables=" ilk="function" signature="variables=(x)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/instruction" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Instruction" ilk="class" classrefs="Child">
          <scope name="new" ilk="function" signature="new(target, content=nil)" attributes="__classmethod__ __ctor__" doc="Constructs a new Instruction @param target can be one of a number of things.  If String, then the target of this instruction is set to this.  If an Instruction, then the Instruction is shallowly cloned (target and content are copied).  If a Source, then the source is scanned and parsed for an Instruction declaration. @param content Must be either a String, or a Parent.  Can only be a Parent if the target argument is a Source.  Otherwise, this String is set as the content of this instruction." />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="write" ilk="function" signature="write(writer, indent=-1, transitive=false, ie_hack=false)" doc="DEPRECATED See the rexml/formatters package" />
          <scope ilk="function" name="content" />
          <scope ilk="function" name="content=" />
          <scope ilk="function" name="target" />
          <scope ilk="function" name="target=" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/light/node" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <variable name="COPYRIGHT" attributes="__const__" citdl="Object" />
        <variable name="DATE" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="REVISION" attributes="__const__" citdl="Object" />
        <scope name="Light" ilk="namespace">
          <scope name="Node" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(node=nil)" attributes="__classmethod__ __ctor__" doc="Create a new element." />
            <scope name="children" ilk="function" signature="children()" />
            <scope name="each" ilk="function" signature="each( &amp;block )" />
            <scope name="has_name?" ilk="function" signature="has_name?( name, namespace = &apos;&apos; )" />
            <scope name="local_name" ilk="function" signature="local_name()" />
            <scope name="local_name=" ilk="function" signature="local_name=( name_str )" />
            <scope name="name" ilk="function" signature="name()" />
            <scope name="name=" ilk="function" signature="name=( name_str, ns=nil )" />
            <scope name="namespace" ilk="function" signature="namespace( prefix=prefix() )" />
            <scope name="namespace=" ilk="function" signature="namespace=( namespace )" />
            <scope name="node_type" ilk="function" signature="node_type()" />
            <scope name="parent" ilk="function" signature="parent()" />
            <scope name="parent=" ilk="function" signature="parent=( node )" />
            <scope name="prefix" ilk="function" signature="prefix( namespace=nil )" />
            <scope name="root" ilk="function" signature="root()" />
            <scope name="size" ilk="function" signature="size()" />
            <scope name="text=" ilk="function" signature="text=( foo )" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
            <variable name="PARENTS" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/namespace" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Namespace" ilk="namespace">
          <import symbol="XMLTokens" />
          <scope name="fully_expanded_name" ilk="function" signature="fully_expanded_name()" doc="Fully expand the name, even if the prefix wasn&apos;t specified in the source file." />
          <scope name="has_name?" ilk="function" signature="has_name?( other, ns=nil )" doc="Compares names optionally WITH namespaces" />
          <scope name="name=" ilk="function" signature="name=( name )" doc="Sets the name and the expanded name" />
          <scope ilk="function" name="expanded_name" />
          <scope ilk="function" name="local_name" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="prefix" />
          <scope ilk="function" name="prefix=" />
          <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/node" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Node" ilk="namespace">
          <scope name="each_recursive" ilk="function" signature="each_recursive()" doc="Visit all subnodes of +self+ recursively" />
          <scope name="find_first_recursive" ilk="function" signature="find_first_recursive()" doc="Find (and return) first subnode (recursively) for which the block evaluates to true. Returns +nil+ if none was found." />
          <scope name="indent" ilk="function" signature="indent(to, ind)" />
          <scope name="index_in_parent" ilk="function" signature="index_in_parent()" doc="Returns the position that +self+ holds in its parent&apos;s array, indexed from 1." />
          <scope name="next_sibling_node" ilk="function" signature="next_sibling_node()" doc="@return the next sibling (nil if unset)" />
          <scope name="parent?" ilk="function" signature="parent?()" />
          <scope name="previous_sibling_node" ilk="function" signature="previous_sibling_node()" doc="@return the previous sibling (nil if unset)" />
          <scope name="to_s" ilk="function" signature="to_s(indent=nil)" doc="*DEPRECATED* This parameter is now ignored.  See the formatters in the REXML::Formatters package for changing the output style." />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/output" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Output" ilk="class" classrefs="Object">
          <import symbol="Encoding" />
          <scope name="new" ilk="function" signature="new(real_IO, encd=&quot;iso-8859-1&quot;)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="encoding" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parent" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parent" ilk="class" classrefs="Child">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(parent=nil)" attributes="__classmethod__ __ctor__" doc="Constructor @param parent if supplied, will be set as the parent of this object" />
          <scope name="add" ilk="function" signature="add( object )" />
          <scope name="children" ilk="function" signature="children()" />
          <scope name="deep_clone" ilk="function" signature="deep_clone()" doc="Deeply clones this object.  This creates a complete duplicate of this Parent, including all descendants." />
          <scope name="delete" ilk="function" signature="delete( object )" />
          <scope name="delete_at" ilk="function" signature="delete_at( index )" />
          <scope name="delete_if" ilk="function" signature="delete_if( &amp;block )" />
          <scope name="each" ilk="function" signature="each(&amp;block)" />
          <scope name="each_child" ilk="function" signature="each_child(&amp;block)" />
          <scope name="each_index" ilk="function" signature="each_index( &amp;block )" />
          <scope name="index" ilk="function" signature="index( child )" doc="Fetches the index of a given child @param child the child to get the index of @return the index of the child, or nil if the object is not a child of this parent." />
          <scope name="insert_after" ilk="function" signature="insert_after( child1, child2 )" doc="Inserts an child after another child @param child1 this is either an xpath or an Element.  If an Element, child2 will be inserted after child1 in the child list of the parent. If an xpath, child2 will be inserted after the first child to match the xpath. @param child2 the child to insert @return the parent (self)" />
          <scope name="insert_before" ilk="function" signature="insert_before( child1, child2 )" doc="Inserts an child before another child @param child1 this is either an xpath or an Element.  If an Element, child2 will be inserted before child1 in the child list of the parent. If an xpath, child2 will be inserted before the first child to match the xpath. @param child2 the child to insert @return the parent (self)" />
          <scope name="length" ilk="function" signature="length()" />
          <scope name="parent?" ilk="function" signature="parent?()" />
          <scope name="push" ilk="function" signature="push( object )" />
          <scope name="replace_child" ilk="function" signature="replace_child( to_replace, replacement )" doc="Replaces one child with another, making sure the nodelist is correct @param to_replace the child to replace (must be a Child) @param replacement the child to insert into the nodelist (must be a Child)" />
          <scope name="size" ilk="function" signature="size()" doc="@return the number of children of this parent" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="unshift" ilk="function" signature="unshift( object )" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parseexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="ParseException" ilk="class" classrefs="RuntimeError">
          <scope name="new" ilk="function" signature="new( message, source=nil, parser=nil, exception=nil )" attributes="__classmethod__ __ctor__" />
          <scope name="context" ilk="function" signature="context()" />
          <scope name="line" ilk="function" signature="line()" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="continued_exception" />
          <scope ilk="function" name="continued_exception=" />
          <scope ilk="function" name="parser" />
          <scope ilk="function" name="parser=" />
          <scope ilk="function" name="source" />
          <scope ilk="function" name="source=" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/baseparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="BaseParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( source )" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if there are no more events" />
            <scope name="entity" ilk="function" signature="entity( reference, entities )" />
            <scope name="has_next?" ilk="function" signature="has_next?()" doc="Returns true if there are more events.  Synonymous with !empty?" />
            <scope name="normalize" ilk="function" signature="normalize( input, entities=nil, entity_filter=nil )" doc="Escapes all possible entities" />
            <scope name="peek" ilk="function" signature="peek(depth=0)" doc="Peek at the +depth+ event in the stack.  The first element on the stack is at depth 0.  If +depth+ is -1, will parse to the end of the input stream and return the last event, which is always :end_document. Be aware that this causes the stream to be parsed up to the +depth+ event, so you can effectively pre-parse the entire document (pull the entire thing into memory) using this method." />
            <scope name="position" ilk="function" signature="position()" />
            <scope name="pull" ilk="function" signature="pull()" doc="Returns the next event.  This is a +PullEvent+ object." />
            <scope name="stream=" ilk="function" signature="stream=( source )" />
            <scope name="unnormalize" ilk="function" signature="unnormalize( string, entities=nil, filter=nil )" doc="Unescapes all possible entities" />
            <scope name="unshift" ilk="function" signature="unshift(token)" doc="Push an event back on the head of the stream.  This method has (theoretically) infinite depth." />
            <scope ilk="function" name="source" />
            <variable name="LETTER" attributes="__const__" citdl="Object" />
            <variable name="DIGIT" attributes="__const__" citdl="Object" />
            <variable name="COMBININGCHAR" attributes="__const__" citdl="Object" />
            <variable name="EXTENDER" attributes="__const__" citdl="Object" />
            <variable name="NCNAME_STR" attributes="__const__" citdl="Object" />
            <variable name="NAME_STR" attributes="__const__" citdl="Object" />
            <variable name="UNAME_STR" attributes="__const__" citdl="Object" />
            <variable name="NAMECHAR" attributes="__const__" citdl="Object" />
            <variable name="NAME" attributes="__const__" citdl="Object" />
            <variable name="NMTOKEN" attributes="__const__" citdl="Object" />
            <variable name="NMTOKENS" attributes="__const__" citdl="Object" />
            <variable name="REFERENCE" attributes="__const__" citdl="Object" />
            <variable name="REFERENCE_RE" attributes="__const__" citdl="Object" />
            <variable name="DOCTYPE_START" attributes="__const__" citdl="Object" />
            <variable name="DOCTYPE_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="ATTRIBUTE_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="COMMENT_START" attributes="__const__" citdl="Object" />
            <variable name="COMMENT_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="CDATA_START" attributes="__const__" citdl="Object" />
            <variable name="CDATA_END" attributes="__const__" citdl="Object" />
            <variable name="CDATA_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="XMLDECL_START" attributes="__const__" citdl="Object" />
            <variable name="XMLDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="INSTRUCTION_START" attributes="__const__" citdl="Object" />
            <variable name="INSTRUCTION_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="TAG_MATCH" attributes="__const__" citdl="Object" />
            <variable name="CLOSE_MATCH" attributes="__const__" citdl="Object" />
            <variable name="VERSION" attributes="__const__" citdl="Object" />
            <variable name="ENCODING" attributes="__const__" citdl="Object" />
            <variable name="STANDALONE" attributes="__const__" citdl="Object" />
            <variable name="ENTITY_START" attributes="__const__" citdl="Object" />
            <variable name="IDENTITY" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTDECL_START" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="SYSTEMENTITY" attributes="__const__" citdl="Object" />
            <variable name="ENUMERATION" attributes="__const__" citdl="Object" />
            <variable name="NOTATIONTYPE" attributes="__const__" citdl="Object" />
            <variable name="ENUMERATEDTYPE" attributes="__const__" citdl="Object" />
            <variable name="ATTTYPE" attributes="__const__" citdl="Object" />
            <variable name="ATTVALUE" attributes="__const__" citdl="Object" />
            <variable name="DEFAULTDECL" attributes="__const__" citdl="Object" />
            <variable name="ATTDEF" attributes="__const__" citdl="Object" />
            <variable name="ATTDEF_RE" attributes="__const__" citdl="Object" />
            <variable name="ATTLISTDECL_START" attributes="__const__" citdl="Object" />
            <variable name="ATTLISTDECL_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="NOTATIONDECL_START" attributes="__const__" citdl="Object" />
            <variable name="PUBLIC" attributes="__const__" citdl="Object" />
            <variable name="SYSTEM" attributes="__const__" citdl="Object" />
            <variable name="TEXT_PATTERN" attributes="__const__" citdl="Object" />
            <variable name="PUBIDCHAR" attributes="__const__" citdl="Object" />
            <variable name="SYSTEMLITERAL" attributes="__const__" citdl="Object" />
            <variable name="PUBIDLITERAL" attributes="__const__" citdl="Object" />
            <variable name="EXTERNALID" attributes="__const__" citdl="Object" />
            <variable name="NDATADECL" attributes="__const__" citdl="Object" />
            <variable name="PEREFERENCE" attributes="__const__" citdl="Object" />
            <variable name="ENTITYVALUE" attributes="__const__" citdl="Object" />
            <variable name="PEDEF" attributes="__const__" citdl="Object" />
            <variable name="ENTITYDEF" attributes="__const__" citdl="Object" />
            <variable name="PEDECL" attributes="__const__" citdl="Object" />
            <variable name="GEDECL" attributes="__const__" citdl="Object" />
            <variable name="ENTITYDECL" attributes="__const__" citdl="Object" />
            <variable name="EREFERENCE" attributes="__const__" citdl="Object" />
            <variable name="DEFAULT_ENTITIES" attributes="__const__" citdl="Object" />
            <variable name="MISSING_ATTRIBUTE_QUOTES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/lightparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="LightParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="rewind" ilk="function" signature="rewind()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/pullparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="PullEvent" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(arg)" attributes="__classmethod__ __ctor__" doc="The type of this event.  Will be one of :tag_start, :tag_end, :text, :processing_instruction, :comment, :doctype, :attlistdecl, :entitydecl, :notationdecl, :entity, :cdata, :xmldecl, or :error." />
            <scope name="attlistdecl?" ilk="function" signature="attlistdecl?()" doc="Content: [ String text ]" />
            <scope name="cdata?" ilk="function" signature="cdata?()" doc="Content: [ String text ]" />
            <scope name="comment?" ilk="function" signature="comment?()" doc="Content: [ String text ]" />
            <scope name="doctype?" ilk="function" signature="doctype?()" doc="Content: [ String name, String pub_sys, String long_name, String uri ]" />
            <scope name="elementdecl?" ilk="function" signature="elementdecl?()" doc="Content: [ String text ]" />
            <scope name="end_element?" ilk="function" signature="end_element?()" doc="Content: [ String tag_name ]" />
            <scope name="entity?" ilk="function" signature="entity?()" doc="Content: [ String text ]" />
            <scope name="entitydecl?" ilk="function" signature="entitydecl?()" doc="Due to the wonders of DTDs, an entity declaration can be just about anything.  There&apos;s no way to normalize it; you&apos;ll have to interpret the content yourself.  However, the following is true: &#xA; If the entity declaration is an internal entity: &#xA; Content: [ String text ]" />
            <scope name="error?" ilk="function" signature="error?()" />
            <scope name="event_type" ilk="function" signature="event_type()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="instruction?" ilk="function" signature="instruction?()" doc="Content: [ String text ]" />
            <scope name="notationdecl?" ilk="function" signature="notationdecl?()" doc="Content: [ String text ]" />
            <scope name="start_element?" ilk="function" signature="start_element?()" doc="Content: [ String tag_name, Hash attributes ]" />
            <scope name="text?" ilk="function" signature="text?()" doc="Content: [ String raw_text, String unnormalized_text ]" />
            <scope name="xmldecl?" ilk="function" signature="xmldecl?()" doc="Content: [ String version, String encoding, String standalone ]" />
          </scope>
        </scope>
        <scope name="Parsers" ilk="namespace">
          <scope name="PullParser" ilk="class" classrefs="Object">
            <import symbol="XMLTokens" />
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="peek" ilk="function" signature="peek(depth=0)" />
            <scope name="pull" ilk="function" signature="pull()" />
            <scope name="unshift" ilk="function" signature="unshift(token)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/sax2parser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="SAX2Parser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="deafen" ilk="function" signature="deafen( listener=nil, &amp;blok )" />
            <scope name="listen" ilk="function" signature="listen( *args, &amp;blok )" doc="Listen arguments: &#xA; Symbol, Array, Block Listen to Symbol events on Array elements&#xA; Symbol, Block Listen to Symbol events&#xA; Array, Listener Listen to all events on Array elements&#xA; Array, Block Listen to :start_element events on Array elements&#xA; Listener Listen to All events&#xA; Symbol can be one of: :start_element, :end_element, :start_prefix_mapping, :end_prefix_mapping, :characters, :processing_instruction, :doctype, :attlistdecl, :elementdecl, :entitydecl, :notationdecl, :cdata, :xmldecl, :comment &#xA; There is an additional symbol that can be listened for: :progress. This will be called for every event generated, passing in the current stream position. &#xA; Array contains regular expressions or strings which will be matched against fully qualified element names. &#xA; Listener must implement the methods in SAX2Listener &#xA; Block will be passed the same arguments as a SAX2Listener method would be, where the method name is the same as the matched Symbol. See the SAX2Listener for more information." />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="source" ilk="function" signature="source()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/streamparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="StreamParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(source, listener)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/treeparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="TreeParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( source, build_context = Document.new )" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/ultralightparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="UltraLightParser" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(stream)" attributes="__classmethod__ __ctor__" />
            <scope name="add_listener" ilk="function" signature="add_listener( listener )" />
            <scope name="parse" ilk="function" signature="parse()" />
            <scope name="rewind" ilk="function" signature="rewind()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/parsers/xpathparser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Parsers" ilk="namespace">
          <scope name="XPathParser" ilk="class" classrefs="Object">
            <import symbol="XMLTokens" />
            <scope name="abbreviate" ilk="function" signature="abbreviate( path )" />
            <scope name="expand" ilk="function" signature="expand( path )" />
            <scope name="namespaces=" ilk="function" signature="namespaces=( namespaces )" />
            <scope name="parse" ilk="function" signature="parse(path)" />
            <scope name="predicate" ilk="function" signature="predicate(path)" />
            <scope name="predicate_to_string" ilk="function" signature="predicate_to_string( path, &amp;block )" />
            <variable name="LITERAL" attributes="__const__" citdl="Object" />
            <variable name="AXIS" attributes="__const__" citdl="Object" />
            <variable name="NCNAMETEST" attributes="__const__" citdl="Object" />
            <variable name="QNAME" attributes="__const__" citdl="Object" />
            <variable name="NODE_TYPE" attributes="__const__" citdl="Object" />
            <variable name="PI" attributes="__const__" citdl="Object" />
            <variable name="VARIABLE_REFERENCE" attributes="__const__" citdl="Object" />
            <variable name="NUMBER" attributes="__const__" citdl="Object" />
            <variable name="NT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/quickpath" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="QuickPath" ilk="class" classrefs="Object">
          <import symbol="Functions" />
          <import symbol="XMLTokens" />
          <scope name="attribute" ilk="function" signature="attribute( name )" attributes="__classmethod__" />
          <scope name="axe" ilk="function" signature="axe( elements, axe_name, rest )" attributes="__classmethod__" />
          <scope name="each" ilk="function" signature="each(element, path, namespaces=EMPTY_HASH, &amp;block)" attributes="__classmethod__" />
          <scope name="filter" ilk="function" signature="filter(elements, path)" attributes="__classmethod__" doc="Given an array of nodes it filters the array based on the path. The result is that when this method returns, the array will contain elements which match the path" />
          <scope name="first" ilk="function" signature="first(element, path, namespaces=EMPTY_HASH)" attributes="__classmethod__" />
          <scope name="function" ilk="function" signature="function( elements, fname, rest )" attributes="__classmethod__" />
          <scope name="match" ilk="function" signature="match(element, path, namespaces=EMPTY_HASH)" attributes="__classmethod__" />
          <scope name="method_missing" ilk="function" signature="method_missing( id, *args )" attributes="__classmethod__" />
          <scope name="name" ilk="function" signature="name()" attributes="__classmethod__" />
          <scope name="parse_args" ilk="function" signature="parse_args( element, string )" attributes="__classmethod__" />
          <scope name="predicate" ilk="function" signature="predicate( elements, path )" attributes="__classmethod__" doc="A predicate filters a node-set with respect to an axis to produce a new node-set. For each node in the node-set to be filtered, the PredicateExpr is evaluated with that node as the context node, with the number of nodes in the node-set as the context size, and with the proximity position of the node in the node-set with respect to the axis as the context position; if PredicateExpr evaluates to true for that node, the node is included in the new node-set; otherwise, it is not included. &#xA; A PredicateExpr is evaluated by evaluating the Expr and converting the result to a boolean. If the result is a number, the result will be converted to true if the number is equal to the context position and will be converted to false otherwise; if the result is not a number, then the result will be converted as if by a call to the boolean function. Thus a location path para[3] is equivalent to para[position()=3]." />
          <variable name="EMPTY_HASH" attributes="__const__" citdl="Object" />
          <variable name="OPERAND_" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/sax2listener" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="SAX2Listener" ilk="namespace">
          <scope name="attlistdecl" ilk="function" signature="attlistdecl(element, pairs, contents)" doc="If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;.  This is the same for all of the .*decl methods." />
          <scope name="cdata" ilk="function" signature="cdata(content)" doc="Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;" />
          <scope name="characters" ilk="function" signature="characters(text)" />
          <scope name="comment" ilk="function" signature="comment(comment)" doc="Called when a comment is encountered. @p comment The content of the comment" />
          <scope name="doctype" ilk="function" signature="doctype(name, pub_sys, long_name, uri)" doc="Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil.  EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil.  EG, &quot;foo&quot; @p uri the uri of the doctype, or nil.  EG, &quot;bar&quot;" />
          <scope name="elementdecl" ilk="function" signature="elementdecl(content)" doc="&lt;!ELEMENT ...&gt;" />
          <scope name="end_document" ilk="function" signature="end_document()" />
          <scope name="end_element" ilk="function" signature="end_element(uri, localname, qname)" />
          <scope name="end_prefix_mapping" ilk="function" signature="end_prefix_mapping(prefix)" />
          <scope name="entitydecl" ilk="function" signature="entitydecl(name, decl)" doc="&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration.  It can be in a number of formats, but in general it returns (example, result): &lt;!ENTITY % YN &apos;&quot;Yes&quot;&apos;&gt;&#xA;[&quot;%&quot;, &quot;YN&quot;, &quot;&apos;\&quot;Yes\&quot;&apos;&quot;, &quot;\&quot;&quot;]&#xA;&lt;!ENTITY % YN &apos;Yes&apos;&gt;&#xA;[&quot;%&quot;, &quot;YN&quot;, &quot;&apos;Yes&apos;&quot;, &quot;s&quot;]&#xA;&lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot;&gt;&#xA;[&quot;WhatHeSaid&quot;, &quot;\&quot;He said %YN;\&quot;&quot;, &quot;YN&quot;]&#xA;&lt;!ENTITY open-hatch SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA;[&quot;open-hatch&quot;, &quot;SYSTEM&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA;&lt;!ENTITY open-hatch PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot; &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA;[&quot;open-hatch&quot;, &quot;PUBLIC&quot;, &quot;\&quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN\&quot;&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA;&lt;!ENTITY hatch-pic SYSTEM &quot;../grafix/OpenHatch.gif&quot; NDATA gif&gt;&#xA;[&quot;hatch-pic&quot;, &quot;SYSTEM&quot;, &quot;\&quot;../grafix/OpenHatch.gif\&quot;&quot;, &quot;\n\t\t\t\t\t\t\tNDATA gif&quot;, &quot;gif&quot;]" />
          <scope name="notationdecl" ilk="function" signature="notationdecl(content)" doc="&lt;!NOTATION ...&gt;" />
          <scope name="processing_instruction" ilk="function" signature="processing_instruction(target, data)" />
          <scope name="progress" ilk="function" signature="progress(position)" />
          <scope name="start_document" ilk="function" signature="start_document()" />
          <scope name="start_element" ilk="function" signature="start_element(uri, localname, qname, attributes)" />
          <scope name="start_prefix_mapping" ilk="function" signature="start_prefix_mapping(prefix, uri)" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value.  EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil.  EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil.  EG, nil @p spaced the declaration is followed by a line break" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/source" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="IOSource" ilk="class" classrefs="REXML::Source">
          <scope name="new" ilk="function" signature="new(arg, block_size=500, encoding=nil)" attributes="__classmethod__ __ctor__" doc="block_size has been deprecated" />
          <scope name="consume" ilk="function" signature="consume( pattern )" />
          <scope name="current_line" ilk="function" signature="current_line()" doc="@return the current line in the source" />
          <scope name="empty?" ilk="function" signature="empty?()" />
          <scope name="match" ilk="function" signature="match( pattern, cons=false )" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="read" ilk="function" signature="read()" />
          <scope name="scan" ilk="function" signature="scan(pattern, cons=false)" />
        </scope>
        <scope name="Source" ilk="class" classrefs="Object">
          <import symbol="Encoding" />
          <scope name="new" ilk="function" signature="new(arg, encoding=nil)" attributes="__classmethod__ __ctor__" doc="Constructor @param arg must be a String, and should be a valid XML document @param encoding if non-null, sets the encoding of the source to this value, overriding all encoding detection" />
          <scope name="consume" ilk="function" signature="consume( pattern )" />
          <scope name="current_line" ilk="function" signature="current_line()" doc="@return the current line in the source" />
          <scope name="empty?" ilk="function" signature="empty?()" doc="@return true if the Source is exhausted" />
          <scope name="encoding=" ilk="function" signature="encoding=(enc)" doc="Inherited from Encoding Overridden to support optimized en/decoding" />
          <scope name="match" ilk="function" signature="match(pattern, cons=false)" />
          <scope name="match_to" ilk="function" signature="match_to( char, pattern )" />
          <scope name="match_to_consume" ilk="function" signature="match_to_consume( char, pattern )" />
          <scope name="position" ilk="function" signature="position()" />
          <scope name="read" ilk="function" signature="read()" />
          <scope name="scan" ilk="function" signature="scan(pattern, cons=false)" doc="Scans the source for a given pattern.  Note, that this is not your usual scan() method.  For one thing, the pattern argument has some requirements; for another, the source can be consumed.  You can easily confuse this method.  Originally, the patterns were easier to construct and this method more robust, because this method generated search regexes on the fly; however, this was computationally expensive and slowed down the entire REXML package considerably, since this is by far the most commonly called method. @param pattern must be a Regexp, and must be in the form of /^\s*(#{your pattern, with no groups})(.*)/.  The first group will be returned; the second group is used if the consume flag is set. @param consume if true, the pattern returned will be consumed, leaving everything after it in the Source. @return the pattern, if found, or nil if the Source is empty or the pattern is not found." />
          <scope ilk="function" name="buffer" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="line" />
        </scope>
        <scope name="SourceFactory" ilk="class" classrefs="Object">
          <scope name="create_from" ilk="function" signature="create_from(arg)" attributes="__classmethod__" doc="Generates a Source object @param arg Either a String, or an IO @return a Source, or nil if a bad argument was given" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/streamlistener" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="StreamListener" ilk="namespace">
          <scope name="attlistdecl" ilk="function" signature="attlistdecl(element_name, attributes, raw_content)" doc="If a doctype includes an ATTLIST declaration, it will cause this method to be called.  The content is the declaration itself, unparsed. EG, &lt;!ATTLIST el attr CDATA #REQUIRED&gt; will come to this method as &quot;el attr CDATA #REQUIRED&quot;.  This is the same for all of the .*decl methods." />
          <scope name="cdata" ilk="function" signature="cdata(content)" doc="Called when &lt;![CDATA[ ... ]]&gt; is encountered in a document. @p content &quot;...&quot;" />
          <scope name="comment" ilk="function" signature="comment(comment)" doc="Called when a comment is encountered. @p comment The content of the comment" />
          <scope name="doctype" ilk="function" signature="doctype(name, pub_sys, long_name, uri)" doc="Handles a doctype declaration. Any attributes of the doctype which are not supplied will be nil.  # EG, &lt;!DOCTYPE me PUBLIC &quot;foo&quot; &quot;bar&quot;&gt; @p name the name of the doctype; EG, &quot;me&quot; @p pub_sys &quot;PUBLIC&quot;, &quot;SYSTEM&quot;, or nil.  EG, &quot;PUBLIC&quot; @p long_name the supplied long name, or nil.  EG, &quot;foo&quot; @p uri the uri of the doctype, or nil.  EG, &quot;bar&quot;" />
          <scope name="doctype_end" ilk="function" signature="doctype_end()" doc="Called when the doctype is done" />
          <scope name="elementdecl" ilk="function" signature="elementdecl(content)" doc="&lt;!ELEMENT ...&gt;" />
          <scope name="entity" ilk="function" signature="entity(content)" doc="Called when %foo; is encountered in a doctype declaration. @p content &quot;foo&quot;" />
          <scope name="entitydecl" ilk="function" signature="entitydecl(content)" doc="&lt;!ENTITY ...&gt; The argument passed to this method is an array of the entity declaration.  It can be in a number of formats, but in general it returns (example, result): &lt;!ENTITY % YN &apos;&quot;Yes&quot;&apos;&gt;&#xA;[&quot;%&quot;, &quot;YN&quot;, &quot;&apos;\&quot;Yes\&quot;&apos;&quot;, &quot;\&quot;&quot;]&#xA;&lt;!ENTITY % YN &apos;Yes&apos;&gt;&#xA;[&quot;%&quot;, &quot;YN&quot;, &quot;&apos;Yes&apos;&quot;, &quot;s&quot;]&#xA;&lt;!ENTITY WhatHeSaid &quot;He said %YN;&quot;&gt;&#xA;[&quot;WhatHeSaid&quot;, &quot;\&quot;He said %YN;\&quot;&quot;, &quot;YN&quot;]&#xA;&lt;!ENTITY open-hatch SYSTEM &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA;[&quot;open-hatch&quot;, &quot;SYSTEM&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA;&lt;!ENTITY open-hatch PUBLIC &quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN&quot; &quot;http://www.textuality.com/boilerplate/OpenHatch.xml&quot;&gt;&#xA;[&quot;open-hatch&quot;, &quot;PUBLIC&quot;, &quot;\&quot;-//Textuality//TEXT Standard open-hatch boilerplate//EN\&quot;&quot;, &quot;\&quot;http://www.textuality.com/boilerplate/OpenHatch.xml\&quot;&quot;]&#xA;&lt;!ENTITY hatch-pic SYSTEM &quot;../grafix/OpenHatch.gif&quot; NDATA gif&gt;&#xA;[&quot;hatch-pic&quot;, &quot;SYSTEM&quot;, &quot;\&quot;../grafix/OpenHatch.gif\&quot;&quot;, &quot;\n\t\t\t\t\t\t\tNDATA gif&quot;, &quot;gif&quot;]" />
          <scope name="instruction" ilk="function" signature="instruction(name, instruction)" doc="Called when an instruction is encountered.  EG: &lt;?xsl sheet=&apos;foo&apos;?&gt; @p name the instruction name; in the example, &quot;xsl&quot; @p instruction the rest of the instruction.  In the example, &quot;sheet=&apos;foo&apos;&quot;" />
          <scope name="notationdecl" ilk="function" signature="notationdecl(content)" doc="&lt;!NOTATION ...&gt;" />
          <scope name="tag_end" ilk="function" signature="tag_end(name)" doc="Called when the end tag is reached.  In the case of &lt;tag/&gt;, tag_end will be called immidiately after tag_start @p the name of the tag" />
          <scope name="tag_start" ilk="function" signature="tag_start(name, attrs)" doc="Called when a tag is encountered. @p name the tag name @p attrs an array of arrays of attribute/value pairs, suitable for use with assoc or rassoc.  IE, &lt;tag attr1=&quot;value1&quot; attr2=&quot;value2&quot;&gt; will result in tag_start( &quot;tag&quot;, # [[&quot;attr1&quot;,&quot;value1&quot;],[&quot;attr2&quot;,&quot;value2&quot;]])" />
          <scope name="text" ilk="function" signature="text(text)" doc="Called when text is encountered in the document @p text the text content." />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="Called when an XML PI is encountered in the document. EG: &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf&quot;?&gt; @p version the version attribute value.  EG, &quot;1.0&quot; @p encoding the encoding attribute value, or nil.  EG, &quot;utf&quot; @p standalone the standalone attribute value, or nil.  EG, nil" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/syncenumerator" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="SyncEnumerator" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(*enums)" attributes="__classmethod__ __ctor__" doc="Creates a new SyncEnumerator which enumerates rows of given Enumerable objects." />
          <scope name="each" ilk="function" signature="each()" doc="Enumerates rows of the Enumerable objects." />
          <scope name="length" ilk="function" signature="length()" doc="Returns the number of enumerated Enumerable objects, i.e. the size of each row." />
          <scope name="size" ilk="function" signature="size()" doc="Returns the number of enumerated Enumerable objects, i.e. the size of each row." />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/text" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Text" ilk="class" classrefs="Child">
          <import symbol="Comparable" />
          <scope name="check" ilk="function" signature="check(string, pattern, doctype)" attributes="__classmethod__" doc="check for illegal characters" />
          <scope name="new" ilk="function" signature="new(arg, respect_whitespace=false, parent=nil, raw=nil, entity_filter=nil, illegal=NEEDS_A_SECOND_CHECK )" attributes="__classmethod__ __ctor__" doc="Constructor +arg+ if a String, the content is set to the String.  If a Text, the object is shallowly cloned. &#xA; +respect_whitespace+ (boolean, false) if true, whitespace is respected &#xA; +parent+ (nil) if this is a Parent object, the parent will be set to this. &#xA; +raw+ (nil) This argument can be given three values. If true, then the value of used to construct this object is expected to contain no unescaped XML markup, and REXML will not change the text. If this value is false, the string may contain any characters, and REXML will escape any and all defined entities whose values are contained in the text.  If this value is nil (the default), then the raw value of the parent will be used as the raw value for this node.  If there is no raw value for the parent, and no value is supplied, the default is false. Use this field if you have entities defined for some text, and you don&apos;t want REXML to escape that text in output. Text.new( &quot;&lt;&amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;lt;&amp;amp;&quot;&#xA;Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, false ) #-&gt; &quot;&amp;amp;lt;&amp;amp;amp;&quot;&#xA;Text.new( &quot;&lt;&amp;&quot;, false, nil, true )  #-&gt; Parse exception&#xA;Text.new( &quot;&amp;lt;&amp;amp;&quot;, false, nil, true )  #-&gt; &quot;&amp;lt;&amp;amp;&quot;&#xA;# Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;&#xA;# and that the entity    &quot;r&quot; is defined to be &quot;russell&quot;&#xA;Text.new( &quot;sean russell&quot; )          #-&gt; &quot;&amp;s; &amp;r;&quot;&#xA;Text.new( &quot;sean russell&quot;, false, nil, true ) #-&gt; &quot;sean russell&quot;&#xA; +entity_filter+ (nil) This can be an array of entities to match in the supplied text.  This argument is only useful if +raw+ is set to false. Text.new( &quot;sean russell&quot;, false, nil, false, [&quot;s&quot;] ) #-&gt; &quot;&amp;s; russell&quot;&#xA;Text.new( &quot;sean russell&quot;, false, nil, true, [&quot;s&quot;] ) #-&gt; &quot;sean russell&quot;" />
          <scope name="normalize" ilk="function" signature="normalize( input, doctype=nil, entity_filter=nil )" attributes="__classmethod__" doc="Escapes all possible entities" />
          <scope name="read_with_substitution" ilk="function" signature="read_with_substitution( input, illegal=nil )" attributes="__classmethod__" doc="Reads text, substituting entities" />
          <scope name="unnormalize" ilk="function" signature="unnormalize( string, doctype=nil, filter=nil, illegal=nil )" attributes="__classmethod__" doc="Unescapes all possible entities" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="doctype" ilk="function" signature="doctype()" />
          <scope name="empty?" ilk="function" signature="empty?()" />
          <scope name="indent_text" ilk="function" signature="indent_text(string, level=1, style=&quot;\t&quot;, indentfirstline=true)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="parent=" ilk="function" signature="parent=(parent)" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Returns the string value of this text node.  This string is always escaped, meaning that it is a valid XML text node string, and all entities that can be escaped, have been inserted.  This method respects the entity filter set in the constructor. &#xA; # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the&#xA;# entity &quot;r&quot; is defined to be &quot;russell&quot;&#xA;t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, [&apos;s&apos;] )&#xA;t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;&#xA;t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false )&#xA;t.to_s   #-&gt; &quot;&amp;lt; &amp;amp; &amp;s; russell&quot;&#xA;u = Text.new( &quot;sean russell&quot;, false, nil, true )&#xA;u.to_s   #-&gt; &quot;sean russell&quot;" />
          <scope name="value" ilk="function" signature="value()" doc="Returns the string value of this text.  This is the text without entities, as it might be used programmatically, or printed to the console.  This ignores the &apos;raw&apos; attribute setting, and any entity_filter. &#xA; # Assume that the entity &quot;s&quot; is defined to be &quot;sean&quot;, and that the&#xA;# entity &quot;r&quot; is defined to be &quot;russell&quot;&#xA;t = Text.new( &quot;&lt; &amp; sean russell&quot;, false, nil, false, [&apos;s&apos;] )&#xA;t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;&#xA;t = Text.new( &quot;&lt; &amp; &amp;s; russell&quot;, false, nil, false )&#xA;t.value   #-&gt; &quot;&lt; &amp; sean russell&quot;&#xA;u = Text.new( &quot;sean russell&quot;, false, nil, true )&#xA;u.value   #-&gt; &quot;sean russell&quot;" />
          <scope name="value=" ilk="function" signature="value=( val )" doc="Sets the contents of this text node.  This expects the text to be unnormalized.  It returns self. &#xA; e = Element.new( &quot;a&quot; )&#xA;e.add_text( &quot;foo&quot; )   # &lt;a&gt;foo&lt;/a&gt;&#xA;e[0].value = &quot;bar&quot;    # &lt;a&gt;bar&lt;/a&gt;&#xA;e[0].value = &quot;&lt;a&gt;&quot;    # &lt;a&gt;&amp;lt;a&amp;gt;&lt;/a&gt;" />
          <scope name="wrap" ilk="function" signature="wrap(string, width, addnewline=false)" />
          <scope name="write" ilk="function" signature="write( writer, indent=-1, transitive=false, ie_hack=false )" doc="DEPRECATED See REXML::Formatters" />
          <scope name="write_with_substitution" ilk="function" signature="write_with_substitution(out, input)" doc="Writes out text, substituting special characters beforehand. +out+ A String, IO, or any other object supporting &lt;&lt;( String ) +input+ the text to substitute and the write out &#xA; z=utf8.unpack(&quot;U*&quot;)&#xA;ascOut=&quot;&quot;&#xA;z.each{|r|&#xA;  if r &lt;  0x100&#xA;    ascOut.concat(r.chr)&#xA;  else&#xA;    ascOut.concat(sprintf(&quot;&amp;#x%x;&quot;, r))&#xA;  end&#xA;}&#xA;puts ascOut" />
          <scope name="xpath" ilk="function" signature="xpath()" doc="FIXME This probably won&apos;t work properly" />
          <scope ilk="function" name="raw" />
          <scope ilk="function" name="raw=" />
          <variable name="SPECIALS" attributes="__const__" citdl="Object" />
          <variable name="SUBSTITUTES" attributes="__const__" citdl="Object" />
          <variable name="SLAICEPS" attributes="__const__" citdl="Object" />
          <variable name="SETUTITSBUS" attributes="__const__" citdl="Object" />
          <variable name="NEEDS_A_SECOND_CHECK" attributes="__const__" citdl="Object" />
          <variable name="NUMERICENTITY" attributes="__const__" citdl="Object" />
          <variable name="VALID_CHAR" attributes="__const__" citdl="Object" />
          <variable name="VALID_XML_CHARS" attributes="__const__" citdl="Object" />
          <variable name="REFERENCE" attributes="__const__" citdl="Object" />
          <variable name="EREFERENCE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/undefinednamespaceexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="UndefinedNamespaceException" ilk="class" classrefs="REXML::ParseException">
          <scope name="new" ilk="function" signature="new( prefix, source, parser )" attributes="__classmethod__ __ctor__" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/relaxng" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="Choice" ilk="class" classrefs="REXML::Validation::State">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Interleave" ilk="class" classrefs="REXML::Validation::Choice">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="next_current" ilk="function" signature="next_current( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="OneOrMore" ilk="class" classrefs="REXML::Validation::State">
            <scope name="new" ilk="function" signature="new(context)" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="reset" ilk="function" signature="reset()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Optional" ilk="class" classrefs="REXML::Validation::State">
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="matches?" ilk="function" signature="matches?(event)" />
            <scope name="next" ilk="function" signature="next( event )" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Ref" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(value)" attributes="__classmethod__ __ctor__" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="RelaxNG" ilk="class" classrefs="Object">
            <import symbol="Validator" />
            <scope name="new" ilk="function" signature="new(source)" attributes="__classmethod__ __ctor__" doc="FIXME: Namespaces" />
            <scope name="receive" ilk="function" signature="receive(event)" />
            <scope ilk="function" name="count" />
            <scope ilk="function" name="count=" />
            <scope ilk="function" name="current" />
            <scope ilk="function" name="current=" />
            <scope ilk="function" name="references" />
            <variable name="INFINITY" attributes="__const__" citdl="Object" />
            <variable name="EMPTY" attributes="__const__" citdl="Object" />
            <variable name="TEXT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="Sequence" ilk="class" classrefs="REXML::Validation::State">
            <scope name="matches?" ilk="function" signature="matches?(event)" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="State" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new( context )" attributes="__classmethod__ __ctor__" />
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="next" ilk="function" signature="next( event )" />
            <scope name="previous=" ilk="function" signature="previous=( previous )" />
            <scope name="reset" ilk="function" signature="reset()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
          </scope>
        </scope>
        <scope name="Validation" ilk="namespace">
          <scope name="ZeroOrMore" ilk="class" classrefs="REXML::Validation::Optional">
            <scope name="expected" ilk="function" signature="expected()" />
            <scope name="next" ilk="function" signature="next( event )" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/validation" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="Event" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(event_type, event_arg=nil )" attributes="__classmethod__ __ctor__" />
            <scope name="done?" ilk="function" signature="done?()" />
            <scope name="inspect" ilk="function" signature="inspect()" />
            <scope name="matches?" ilk="function" signature="matches?( event )" />
            <scope name="single?" ilk="function" signature="single?()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="event_arg" />
            <scope ilk="function" name="event_arg=" />
            <scope ilk="function" name="event_type" />
          </scope>
          <scope name="Validator" ilk="namespace">
            <scope name="dump" ilk="function" signature="dump()" />
            <scope name="reset" ilk="function" signature="reset()" />
            <scope name="validate" ilk="function" signature="validate( event )" />
            <variable name="NILEVENT" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/validation/validationexception" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="Validation" ilk="namespace">
          <scope name="ValidationException" ilk="class" classrefs="RuntimeError">
            <scope name="new" ilk="function" signature="new(msg)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xmldecl" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XMLDecl" ilk="class" classrefs="Child">
          <import symbol="Encoding" />
          <scope name="default" ilk="function" signature="default()" attributes="__classmethod__" doc="Only use this if you do not want the XML declaration to be written; this object is ignored by the XML writer.  Otherwise, instantiate your own XMLDecl and add it to the document. &#xA; Note that XML 1.1 documents *must* include an XML declaration" />
          <scope name="new" ilk="function" signature="new(version=DEFAULT_VERSION, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="clone" ilk="function" signature="clone()" />
          <scope name="dowrite" ilk="function" signature="dowrite()" />
          <scope name="encoding=" ilk="function" signature="encoding=( enc )" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="node_type" ilk="function" signature="node_type()" />
          <scope name="nowrite" ilk="function" signature="nowrite()" />
          <scope name="old_enc=" ilk="function" signature="old_enc=( enc )" />
          <scope name="write" ilk="function" signature="write(writer, indent=-1, transitive=false, ie_hack=false)" doc="Ignored.  There must be no whitespace before an XML declaration&#xA;Ignored&#xA;Ignored" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
          <scope ilk="function" name="stand_alone?" />
          <scope ilk="function" name="stand_alone?=" />
          <scope ilk="function" name="standalone" />
          <scope ilk="function" name="standalone=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
          <scope ilk="function" name="writeencoding" />
          <scope ilk="function" name="writethis" />
          <variable name="DEFAULT_VERSION" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_ENCODING" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_STANDALONE" attributes="__const__" citdl="Object" />
          <variable name="START" attributes="__const__" citdl="Object" />
          <variable name="STOP" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xmltokens" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XMLTokens" ilk="namespace">
          <variable name="NCNAME_STR" attributes="__const__" citdl="Object" />
          <variable name="NAME_STR" attributes="__const__" citdl="Object" />
          <variable name="NAMECHAR" attributes="__const__" citdl="Object" />
          <variable name="NAME" attributes="__const__" citdl="Object" />
          <variable name="NMTOKEN" attributes="__const__" citdl="Object" />
          <variable name="NMTOKENS" attributes="__const__" citdl="Object" />
          <variable name="REFERENCE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xpath" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XPath" ilk="class" classrefs="Object">
          <import symbol="Functions" />
          <scope name="each" ilk="function" signature="each(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Iterates over nodes that match the given path, calling the supplied block with the match. The context element&#xA;The xpath to search for.  If not supplied or nil, defaults to &apos;*&apos;&#xA;If supplied, a Hash which defines a namespace mapping&#xA;If supplied, a Hash which maps $variables in the query to values. This can be used to avoid XPath injection attacks or to automatically handle escaping string values. &#xA; XPath.each( node ) { |el| ... }&#xA;XPath.each( node, &apos;/*[@attr=&apos;v&apos;]&apos; ) { |el| ... }&#xA;XPath.each( node, &apos;ancestor::x&apos; ) { |el| ... }&#xA;XPath.each( node, &apos;/book/publisher/text()=$publisher&apos;, {}, {&quot;publisher&quot;=&gt;&quot;O&apos;Reilly&quot;}) \&#xA;  {|el| ... }" />
          <scope name="first" ilk="function" signature="first(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Finds and returns the first node that matches the supplied xpath. The context element&#xA;The xpath to search for.  If not supplied or nil, returns the first node matching &apos;*&apos;.&#xA;If supplied, a Hash which defines a namespace mapping.&#xA;If supplied, a Hash which maps $variables in the query to values. This can be used to avoid XPath injection attacks or to automatically handle escaping string values. &#xA; XPath.first( node )&#xA;XPath.first( doc, &quot;//b&quot;} )&#xA;XPath.first( node, &quot;a/x:b&quot;, { &quot;x&quot;=&gt;&quot;http://doofus&quot; } )&#xA;XPath.first( node, &apos;/book/publisher/text()=$publisher&apos;, {}, {&quot;publisher&quot;=&gt;&quot;O&apos;Reilly&quot;})" />
          <scope name="match" ilk="function" signature="match(element, path=nil, namespaces=nil, variables={})" attributes="__classmethod__" doc="Returns an array of nodes matching a given XPath." />
          <variable name="EMPTY_HASH" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rexml/xpath_parser" ilk="blob" lang="Ruby">
      <scope name="REXML" ilk="namespace">
        <scope name="XPathParser" ilk="class" classrefs="Object">
          <import symbol="XMLTokens" />
          <scope name="new" ilk="function" signature="new( )" attributes="__classmethod__ __ctor__" />
          <scope name="first" ilk="function" signature="first( path_stack, node )" doc="Performs a depth-first (document order) XPath search, and returns the first match.  This is the fastest, lightest way to return a single result. &#xA; FIXME: This method is incomplete!" />
          <scope name="get_first" ilk="function" signature="get_first(path, nodeset)" />
          <scope name="match" ilk="function" signature="match( path_stack, nodeset )" />
          <scope name="namespaces=" ilk="function" signature="namespaces=( namespaces={} )" />
          <scope name="parse" ilk="function" signature="parse(path, nodeset)" />
          <scope name="predicate" ilk="function" signature="predicate(path, nodeset)" />
          <scope name="variables=" ilk="function" signature="variables=( vars={} )" />
          <variable name="LITERAL" attributes="__const__" citdl="Object" />
          <variable name="ALL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/rinda" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="DRbObjectTemplate" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(uri=nil, ref=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new DRbObjectTemplate that will match against +uri+ and +ref+." />
        </scope>
        <scope name="InvalidHashTupleKey" ilk="class" classrefs="Rinda::RindaError">
        </scope>
        <scope name="RequestCanceledError" ilk="class" classrefs="ThreadError">
        </scope>
        <scope name="RequestExpiredError" ilk="class" classrefs="ThreadError">
        </scope>
        <scope name="RindaError" ilk="class" classrefs="RuntimeError">
        </scope>
        <scope name="SimpleRenewer" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(sec=180)" attributes="__classmethod__ __ctor__" doc="Creates a new SimpleRenewer that keeps an object alive for another +sec+ seconds." />
          <scope name="renew" ilk="function" signature="renew()" doc="Called by the TupleSpace to check if the object is still alive." />
        </scope>
        <scope name="Template" ilk="class" classrefs="Rinda::Tuple">
          <scope name="match" ilk="function" signature="match(tuple)" doc="Matches this template against +tuple+.  The +tuple+ must be the same size as the template.  An element with a +nil+ value in a template acts as a wildcard, matching any value in the corresponding position in the tuple.  Elements of the template match the +tuple+ if the are == or ===. &#xA; Template.new([:foo, 5]).match   Tuple.new([:foo, 5]) # =&gt; true&#xA;Template.new([:foo, nil]).match Tuple.new([:foo, 5]) # =&gt; true&#xA;Template.new([String]).match    Tuple.new([&apos;hello&apos;]) # =&gt; true&#xA;&#xA;Template.new([:foo]).match      Tuple.new([:foo, 5]) # =&gt; false&#xA;Template.new([:foo, 6]).match   Tuple.new([:foo, 5]) # =&gt; false&#xA;Template.new([:foo, nil]).match Tuple.new([:foo])    # =&gt; false&#xA;Template.new([:foo, 6]).match   Tuple.new([:foo])    # =&gt; false" />
        </scope>
        <scope name="Tuple" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(ary_or_hash)" attributes="__classmethod__ __ctor__" doc="Creates a new Tuple from +ary_or_hash+ which must be an Array or Hash." />
          <scope name="each" ilk="function" signature="each()" doc="Iterate through the tuple, yielding the index or key, and the value, thus ensuring arrays are iterated similarly to hashes." />
          <scope name="fetch" ilk="function" signature="fetch(k)" doc="Fetches item +k+ from the tuple." />
          <scope name="size" ilk="function" signature="size()" doc="The number of elements in the tuple." />
          <scope name="value" ilk="function" signature="value()" doc="Return the tuple itself" />
        </scope>
        <scope name="TupleSpaceProxy" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(ts)" attributes="__classmethod__ __ctor__" doc="Creates a new TupleSpaceProxy to wrap +ts+." />
          <scope name="notify" ilk="function" signature="notify(ev, tuple, sec=nil)" doc="Registers for notifications of event +ev+ on the proxied TupleSpace. See TupleSpace#notify" />
          <scope name="read" ilk="function" signature="read(tuple, sec=nil, &amp;block)" doc="Reads +tuple+ from the proxied TupleSpace.  See TupleSpace#read." />
          <scope name="read_all" ilk="function" signature="read_all(tuple)" doc="Reads all tuples matching +tuple+ from the proxied TupleSpace.  See TupleSpace#read_all." />
          <scope name="take" ilk="function" signature="take(tuple, sec=nil, &amp;block)" doc="Takes +tuple+ from the proxied TupleSpace.  See TupleSpace#take." />
          <scope name="write" ilk="function" signature="write(tuple, sec=nil)" doc="Adds +tuple+ to the proxied TupleSpace.  See TupleSpace#write." />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/ring" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="RingFinger" ilk="class" classrefs="Object">
          <scope name="finger" ilk="function" signature="finger()" attributes="__classmethod__" doc="Creates a singleton RingFinger and looks for a RingServer.  Returns the created RingFinger." />
          <scope name="new" ilk="function" signature="new(broadcast_list=@@broadcast_list, port=Ring_PORT)" attributes="__classmethod__ __ctor__" doc="Creates a new RingFinger that will look for RingServers at +port+ on the addresses in +broadcast_list+." />
          <scope name="primary" ilk="function" signature="primary()" attributes="__classmethod__" doc="Returns the first advertised TupleSpace." />
          <scope name="to_a" ilk="function" signature="to_a()" attributes="__classmethod__" doc="Contains all discovered TupleSpaces except for the primary." />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over all discovered TupleSpaces starting with the primary." />
          <scope name="lookup_ring" ilk="function" signature="lookup_ring(timeout=5, &amp;block)" doc="Looks up RingServers waiting +timeout+ seconds.  RingServers will be given +block+ as a callback, which will be called with the remote TupleSpace." />
          <scope name="lookup_ring_any" ilk="function" signature="lookup_ring_any(timeout=5)" doc="Returns the first found remote TupleSpace.  Any further recovered TupleSpaces can be found by calling +to_a+." />
          <scope name="to_a" ilk="function" signature="to_a()" doc="Contains all discovered TupleSpaces except for the primary." />
          <scope ilk="function" name="broadcast_list" />
          <scope ilk="function" name="broadcast_list=" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="port=" />
          <scope ilk="function" name="primary" />
          <scope ilk="function" name="primary=" />
        </scope>
        <scope name="RingProvider" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(klass, front, desc, renewer = nil)" attributes="__classmethod__ __ctor__" doc="Creates a RingProvider that will provide a +klass+ service running on +front+, with a +description+.  +renewer+ is optional." />
          <scope name="provide" ilk="function" signature="provide()" doc="Advertises this service on the primary remote TupleSpace." />
        </scope>
        <scope name="RingServer" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(ts, port=Ring_PORT)" attributes="__classmethod__ __ctor__" doc="Advertises +ts+ on the UDP broadcast address at +port+." />
          <scope name="do_reply" ilk="function" signature="do_reply()" doc="Pulls lookup tuples out of the TupleSpace and sends their DRb object the address of the local TupleSpace." />
          <scope name="do_write" ilk="function" signature="do_write(msg)" doc="Extracts the response URI from +msg+ and adds it to TupleSpace where it will be picked up by +reply_service+ for notification." />
          <scope name="reply_service" ilk="function" signature="reply_service()" doc="Creates a thread that notifies waiting clients from the TupleSpace." />
          <scope name="write_service" ilk="function" signature="write_service()" doc="Creates a thread that picks up UDP packets and passes them to do_write for decoding." />
        </scope>
      </scope>
    </scope>
    <scope name="rinda/tuplespace" ilk="blob" lang="Ruby">
      <scope name="Rinda" ilk="namespace">
        <scope name="NotifyTemplateEntry" ilk="class" classrefs="Rinda::TemplateEntry">
          <scope name="new" ilk="function" signature="new(place, event, tuple, expires=nil)" attributes="__classmethod__ __ctor__" doc="Creates a new NotifyTemplateEntry that watches +place+ for +event+s that match +tuple+." />
          <scope name="each" ilk="function" signature="each()" doc="Yields event/tuple pairs until this NotifyTemplateEntry expires." />
          <scope name="notify" ilk="function" signature="notify(ev)" doc="Called by TupleSpace to notify this NotifyTemplateEntry of a new event." />
          <scope name="pop" ilk="function" signature="pop()" doc="Retrieves a notification.  Raises RequestExpiredError when this NotifyTemplateEntry expires." />
        </scope>
        <scope name="TemplateEntry" ilk="class" classrefs="Rinda::TupleEntry">
          <scope name="match" ilk="function" signature="match(tuple)" doc="Matches this TemplateEntry against +tuple+.  See Template#match for details on how a Template matches a Tuple." />
        </scope>
        <scope name="TupleBag" ilk="class" classrefs="Object">
          <scope name="delete" ilk="function" signature="delete(tuple)" doc="Removes +tuple+ from the TupleBag." />
          <scope name="delete_unless_alive" ilk="function" signature="delete_unless_alive()" doc="Delete tuples which dead tuples from the TupleBag, returning the deleted tuples." />
          <scope name="find" ilk="function" signature="find(template)" doc="Finds a live tuple that matches +template+." />
          <scope name="find_all" ilk="function" signature="find_all(template)" doc="Finds all live tuples that match +template+." />
          <scope name="find_all_template" ilk="function" signature="find_all_template(tuple)" doc="Finds all tuples in the TupleBag which when treated as templates, match +tuple+ and are alive." />
          <scope name="has_expires?" ilk="function" signature="has_expires?()" doc="+true+ if the TupleBag to see if it has any expired entries." />
          <scope name="push" ilk="function" signature="push(tuple)" doc="Add +tuple+ to the TupleBag." />
          <scope name="TupleBin" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="add" ilk="function" signature="add(tuple)" />
            <scope name="delete" ilk="function" signature="delete(tuple)" />
            <scope name="find" ilk="function" signature="find(&amp;blk)" />
          </scope>
        </scope>
        <scope name="TupleEntry" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <scope name="new" ilk="function" signature="new(ary, sec=nil)" attributes="__classmethod__ __ctor__" doc="Creates a TupleEntry based on +ary+ with an optional renewer or expiry time +sec+. &#xA; A renewer must implement the +renew+ method which returns a Numeric, nil, or true to indicate when the tuple has expired." />
          <scope name="alive?" ilk="function" signature="alive?()" doc="A TupleEntry is dead when it is canceled or expired." />
          <scope name="cancel" ilk="function" signature="cancel()" doc="Marks this TupleEntry as canceled." />
          <scope name="canceled?" ilk="function" signature="canceled?()" doc="Returns the canceled status." />
          <scope name="expired?" ilk="function" signature="expired?()" doc="Has this tuple expired? (true/false). &#xA; A tuple has expired when its expiry timer based on the +sec+ argument to #initialize runs out." />
          <scope name="fetch" ilk="function" signature="fetch(key)" doc="Fetches +key+ from the tuple." />
          <scope name="make_expires" ilk="function" signature="make_expires(sec=nil)" doc="Returns an expiry Time based on +sec+ which can be one of: +sec+ seconds into the future&#xA;the expiry time is the start of 1970 (i.e. expired)&#xA;it is  Tue Jan 19 03:14:07 GMT Standard Time 2038 (i.e. when UNIX clocks will die)" />
          <scope name="make_tuple" ilk="function" signature="make_tuple(ary)" doc="Creates a Rinda::Tuple for +ary+." />
          <scope name="renew" ilk="function" signature="renew(sec_or_renewer)" doc="Reset the expiry time according to +sec_or_renewer+. &#xA; it is set to expire in the far future.&#xA;it has expired.&#xA;it will expire in that many seconds. &#xA; Otherwise the argument refers to some kind of renewer object which will reset its expiry time." />
          <scope name="size" ilk="function" signature="size()" doc="The size of the tuple." />
          <scope name="value" ilk="function" signature="value()" doc="Return the object which makes up the tuple itself: the Array or Hash." />
          <scope ilk="function" name="expires" />
          <scope ilk="function" name="expires=" />
        </scope>
        <scope name="TupleSpace" ilk="class" classrefs="Object">
          <import symbol="DRbUndumped" />
          <import symbol="MonitorMixin" />
          <scope name="new" ilk="function" signature="new(period=60)" attributes="__classmethod__ __ctor__" doc="Creates a new TupleSpace.  +period+ is used to control how often to look for dead tuples after modifications to the TupleSpace. &#xA; If no dead tuples are found +period+ seconds after the last modification, the TupleSpace will stop looking for dead tuples." />
          <scope name="move" ilk="function" signature="move(port, tuple, sec=nil)" doc="Moves +tuple+ to +port+." />
          <scope name="notify" ilk="function" signature="notify(event, tuple, sec=nil)" doc="Registers for notifications of +event+.  Returns a NotifyTemplateEntry. See NotifyTemplateEntry for examples of how to listen for notifications. &#xA; +event+ can be: A tuple was added&#xA;A tuple was taken or moved&#xA;A tuple was lost after being overwritten or expiring &#xA; The TupleSpace will also notify you of the &apos;close&apos; event when the NotifyTemplateEntry has expired." />
          <scope name="read" ilk="function" signature="read(tuple, sec=nil)" doc="Reads +tuple+, but does not remove it." />
          <scope name="read_all" ilk="function" signature="read_all(tuple)" doc="Returns all tuples matching +tuple+.  Does not remove the found tuples." />
          <scope name="take" ilk="function" signature="take(tuple, sec=nil, &amp;block)" doc="Removes +tuple+" />
          <scope name="write" ilk="function" signature="write(tuple, sec=nil)" doc="Adds +tuple+" />
        </scope>
        <scope name="WaitTemplateEntry" ilk="class" classrefs="Rinda::TemplateEntry">
          <scope name="new" ilk="function" signature="new(place, ary, expires=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="cancel" ilk="function" signature="cancel()" />
          <scope name="read" ilk="function" signature="read(tuple)" />
          <scope name="signal" ilk="function" signature="signal()" />
          <scope name="wait" ilk="function" signature="wait()" />
          <scope ilk="function" name="found" />
        </scope>
      </scope>
    </scope>
    <scope name="ripper" ilk="blob" lang="Ruby">
      <scope name="Ripper" ilk="class" classrefs="Object">
        <scope name="lex" ilk="function" signature="lex(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Tokenizes Ruby program and returns an Array of Array, which is formatted like [[lineno, column], type, token]. &#xA; require &apos;ripper&apos;&#xA;require &apos;pp&apos;&#xA;p Ripper.lex(&quot;def m(a) nil end&quot;)&#xA;  =&gt; [[[1,  0], :on_kw,     &quot;def&quot;],&#xA;       [[1,  3], :on_sp,     &quot; &quot;  ],&#xA;       [[1,  4], :on_ident,  &quot;m&quot;  ],&#xA;       [[1,  5], :on_lparen, &quot;(&quot;  ],&#xA;       [[1,  6], :on_ident,  &quot;a&quot;  ],&#xA;       [[1,  7], :on_rparen, &quot;)&quot;  ],&#xA;       [[1,  8], :on_sp,     &quot; &quot;  ],&#xA;       [[1,  9], :on_kw,     &quot;nil&quot;],&#xA;       [[1, 12], :on_sp,     &quot; &quot;  ]," />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Create a new Ripper object. _src_ must be a String, an IO, or an Object which has #gets method. &#xA; This method does not starts parsing. See also Ripper#parse and Ripper.parse." />
        <scope name="parse" ilk="function" signature="parse(src, filename = &apos;(ripper)&apos;, lineno = 1)" attributes="__classmethod__" doc="Parses Ruby program read from _src_. _src_ must be a String or a IO or a object which has #gets method." />
        <scope name="sexp" ilk="function" signature="sexp(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Parses +src+ and create S-exp tree. Returns more readable tree rather than Ripper.sexp_raw. This method is for mainly developper use. &#xA; require &apos;ripper&apos;&#xA;require &apos;pp&apos;&#xA;&#xA;pp Ripper.sexp(&quot;def m(a) nil end&quot;)&#xA;  =&gt; [:program,&#xA;       [[:def,&#xA;        [:@ident, &quot;m&quot;, [1, 4]],&#xA;        [:paren, [:params, [[:@ident, &quot;a&quot;, [1, 6]]], nil, nil, nil, nil]],&#xA;        [:bodystmt, [[:var_ref, [:@kw, &quot;nil&quot;, [1, 9]]]], nil, nil, nil]]]]" />
        <scope name="sexp_raw" ilk="function" signature="sexp_raw(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Parses +src+ and create S-exp tree. This method is for mainly developper use. &#xA; require &apos;ripper&apos;&#xA;require &apos;pp&apos;&#xA;pp Ripper.sexp_raw(&quot;def m(a) nil end&quot;)&#xA;  =&gt; [:program,&#xA;       [:stmts_add,&#xA;        [:stmts_new],&#xA;        [:def,&#xA;         [:@ident, &quot;m&quot;, [1, 4]],&#xA;         [:paren, [:params, [[:@ident, &quot;a&quot;, [1, 6]]], nil, nil, nil]],&#xA;         [:bodystmt,&#xA;          [:stmts_add, [:stmts_new], [:var_ref, [:@kw, &quot;nil&quot;, [1, 9]]]],&#xA;          nil," />
        <scope name="slice" ilk="function" signature="slice(src, pattern, n = 0)" attributes="__classmethod__" doc="Parses +src+ and return a string which was matched to +pattern+. +pattern+ should be described as Regexp. &#xA; require &apos;ripper&apos;&#xA;&#xA;p Ripper.slice(&apos;def m(a) nil end&apos;, &apos;ident&apos;)                   =&gt; &quot;m&quot;&#xA;p Ripper.slice(&apos;def m(a) nil end&apos;, &apos;[ident lparen rparen]+&apos;)  =&gt; &quot;m(a)&quot;&#xA;p Ripper.slice(&quot;&lt;&lt;EOS\nstring\nEOS&quot;,&#xA;               &apos;heredoc_beg nl $(tstring_content*) heredoc_end&apos;, 1)&#xA;    =&gt; &quot;string\n&quot;" />
        <scope name="tokenize" ilk="function" signature="tokenize(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__" doc="Tokenizes Ruby program and returns an Array of String." />
        <scope name="column" ilk="function" signature="column()" doc="Return column number of current parsing line. This number starts from 0." />
        <scope name="encoding" ilk="function" signature="encoding()" doc="Return encoding of the source." />
        <scope name="end_seen?" ilk="function" signature="end_seen?()" doc="Return true if parsed source ended by +\_\_END\_\_+." />
        <scope name="filename" ilk="function" signature="filename()" doc="Return current parsing filename." />
        <scope name="lineno" ilk="function" signature="lineno()" doc="Return line number of current parsing line. This number starts from 1." />
        <scope name="parse" ilk="function" signature="parse()" doc="Start parsing and returns the value of the root action." />
        <scope name="yydebug" ilk="function" signature="yydebug()" doc="Get yydebug." />
        <scope name="yydebug=" ilk="function" signature="yydebug=(p1)" doc="Set yydebug." />
        <variable name="PARSER_EVENTS" attributes="__const__" citdl="Object" />
        <variable name="SCANNER_EVENTS" attributes="__const__" citdl="Object" />
        <variable name="EVENTS" attributes="__const__" citdl="Object" />
        <scope name="TokenPattern" ilk="class" classrefs="Object">
          <scope name="CompileError" ilk="class" classrefs="Ripper::TokenPattern::Error">
          </scope>
          <scope name="Error" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="MatchData" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(tokens, match)" attributes="__classmethod__ __ctor__" />
            <scope name="string" ilk="function" signature="string(n = 0)" />
          </scope>
          <scope name="MatchError" ilk="class" classrefs="Ripper::TokenPattern::Error">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="ripper/filter" ilk="blob" lang="Ruby">
      <scope name="Ripper" ilk="namespace">
        <scope name="Filter" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(src, filename = &apos;-&apos;, lineno = 1)" attributes="__classmethod__ __ctor__" />
          <scope name="column" ilk="function" signature="column()" doc="The column number of the current token. This value starts from 0. This method is valid only in event handlers." />
          <scope name="filename" ilk="function" signature="filename()" doc="The file name of the input." />
          <scope name="lineno" ilk="function" signature="lineno()" doc="The line number of the current token. This value starts from 1. This method is valid only in event handlers." />
          <scope name="parse" ilk="function" signature="parse(init = nil)" doc="Starts parsing.  _init_ is a data accumulator. It is passed to the next event handler (as of Enumerable#inject)." />
        </scope>
      </scope>
    </scope>
    <scope name="rss" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <variable name="ITUNES_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="ITUNES_URI" attributes="__const__" citdl="Object" />
        <variable name="SY_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="SY_URI" attributes="__const__" citdl="Object" />
        <variable name="AVAILABLE_PARSER_LIBRARIES" attributes="__const__" citdl="Object" />
        <variable name="AVAILABLE_PARSERS" attributes="__const__" citdl="Object" />
        <variable name="TRACKBACK_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="TRACKBACK_URI" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="URI" attributes="__const__" citdl="Object" />
        <variable name="DEBUG" attributes="__const__" citdl="Object" />
        <variable name="DC_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="DC_URI" attributes="__const__" citdl="Object" />
        <variable name="CONTENT_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="CONTENT_URI" attributes="__const__" citdl="Object" />
        <variable name="SLASH_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="SLASH_URI" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_URI" attributes="__const__" citdl="Object" />
        <variable name="IMAGE_ELEMENTS" attributes="__const__" citdl="Object" />
        <variable name="TAXO_PREFIX" attributes="__const__" citdl="Object" />
        <variable name="TAXO_URI" attributes="__const__" citdl="Object" />
        <variable name="TAXO_ELEMENTS" attributes="__const__" citdl="Object" />
        <scope name="DublincoreModel" ilk="namespace">
          <variable name="TEXT_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="DATE_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_NAME_INFOS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="RSS09" ilk="class">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="NSPOOL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/0.9" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="CloudBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="SkipDaysBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                <scope name="Day" ilk="class" classrefs="DayBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, days)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="SkipHoursBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                <scope name="Hour" ilk="class" classrefs="HourBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, hours)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="EnclosureBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="CloudBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="SkipDaysBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                <scope name="Day" ilk="class" classrefs="DayBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="SkipHoursBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                <scope name="Hour" ilk="class" classrefs="HourBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="EnclosureBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Cloud" ilk="class" classrefs="RSS::RSS09::Channel::Cloud">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipDays" ilk="class" classrefs="RSS::RSS09::Channel::SkipDays">
                <scope name="Day" ilk="class" classrefs="RSS::RSS09::Channel::SkipDays::Day">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="SkipHours" ilk="class" classrefs="RSS::RSS09::Channel::SkipHours">
                <scope name="Hour" ilk="class" classrefs="RSS::RSS09::Channel::SkipHours::Hour">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Enclosure" ilk="class" classrefs="RSS::RSS09::Items::Item::Enclosure">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/1.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS::Maker::ItemsBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="TextinputBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS::Maker::RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS::Maker::RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS::Maker::RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS::Maker::RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS::Maker::ItemsBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="TextinputBase">
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="class" classrefs="RSS::RSS09::Items">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Textinput" ilk="class" classrefs="RSS::RSS09::Textinput">
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Bag" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="setup_maker" ilk="function" signature="setup_maker(target)" />
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Seq" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="setup_maker" ilk="function" signature="setup_maker(target)" />
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Textinput" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="RSS10" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="NSPOOL" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/2.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="GuidBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="GuidBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Guid" ilk="class" classrefs="RSS::RSS09::Items::Item::Guid">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/atom" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Atom" ilk="namespace">
          <variable name="URI" attributes="__const__" citdl="Object" />
          <variable name="XHTML_URI" attributes="__const__" citdl="Object" />
          <scope name="CommonModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="need_parent?" ilk="function" signature="need_parent?()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <variable name="NSPOOL" attributes="__const__" citdl="Object" />
            <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="DateConstruct" ilk="namespace">
            <import symbol="ContentModel" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
          </scope>
          <scope name="DuplicateLinkChecker" ilk="namespace">
            <scope name="validate_duplicate_links" ilk="function" signature="validate_duplicate_links(links)" />
          </scope>
          <scope name="Entry" ilk="class" classrefs="RSS::Element">
            <import symbol="CommonModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="DuplicateLinkChecker" />
            <import symbol="RootElementMixin" />
            <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
            <scope name="have_author?" ilk="function" signature="have_author?()" />
            <scope name="items" ilk="function" signature="items()" />
            <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          </scope>
          <scope name="Feed" ilk="class" classrefs="RSS::Element">
            <import symbol="CommonModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="DuplicateLinkChecker" />
            <import symbol="RootElementMixin" />
            <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
            <scope name="have_author?" ilk="function" signature="have_author?()" />
            <scope name="Author" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="PersonConstruct" />
            </scope>
            <scope name="Category" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
            </scope>
            <scope name="Contributor" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="PersonConstruct" />
            </scope>
            <scope name="Entry" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="DuplicateLinkChecker" />
              <scope name="have_author?" ilk="function" signature="have_author?(check_parent=true)" />
              <scope name="Content" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <scope name="xml_getter" ilk="function" signature="xml_getter()" attributes="__classmethod__" />
                <scope name="xml_setter" ilk="function" signature="xml_setter()" attributes="__classmethod__" />
                <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
                <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
                <scope name="inline_html?" ilk="function" signature="inline_html?()" />
                <scope name="inline_other?" ilk="function" signature="inline_other?()" />
                <scope name="inline_other_base64?" ilk="function" signature="inline_other_base64?()" />
                <scope name="inline_other_text?" ilk="function" signature="inline_other_text?()" />
                <scope name="inline_other_xml?" ilk="function" signature="inline_other_xml?()" />
                <scope name="inline_text?" ilk="function" signature="inline_text?()" />
                <scope name="inline_xhtml?" ilk="function" signature="inline_xhtml?()" />
                <scope name="mime_split" ilk="function" signature="mime_split()" />
                <scope name="need_base64_encode?" ilk="function" signature="need_base64_encode?()" />
                <scope name="out_of_line?" ilk="function" signature="out_of_line?()" />
                <scope name="xhtml" ilk="function" signature="xhtml()" />
                <scope name="xml" ilk="function" />
                <scope ilk="function" name="xml=" />
              </scope>
              <scope name="Published" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <import symbol="DateConstruct" />
              </scope>
              <scope name="Source" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <scope name="have_author?" ilk="function" signature="have_author?()" />
              </scope>
              <scope name="Summary" ilk="class" classrefs="RSS::Element">
                <import symbol="CommonModel" />
                <import symbol="TextConstruct" />
              </scope>
            </scope>
            <scope name="Generator" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Icon" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
            <scope name="Id" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
            <scope name="Link" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
            </scope>
            <scope name="Logo" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
              <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            </scope>
            <scope name="Rights" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Subtitle" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Title" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="TextConstruct" />
            </scope>
            <scope name="Updated" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="DateConstruct" />
            </scope>
          </scope>
          <scope name="PersonConstruct" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            <scope name="Email" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Name" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="ContentModel" />
            </scope>
            <scope name="Uri" ilk="class" classrefs="RSS::Element">
              <import symbol="CommonModel" />
              <import symbol="URIContentModel" />
            </scope>
          </scope>
          <scope name="TextConstruct" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="xml_getter" ilk="function" signature="xml_getter()" attributes="__classmethod__" />
            <scope name="xml_setter" ilk="function" signature="xml_setter()" attributes="__classmethod__" />
            <scope name="atom_validate" ilk="function" signature="atom_validate(ignore_unknown_element, tags, uri)" />
            <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
            <scope name="xhtml" ilk="function" />
            <scope ilk="function" name="xhtml=" />
          </scope>
          <scope name="URIContentModel" ilk="namespace">
            <import symbol="ContentModel" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Atom" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="ClassMethods" ilk="namespace">
              <scope name="content_type" ilk="function" signature="content_type()" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Atom" ilk="namespace">
            <scope name="Entry" ilk="class" classrefs="RSS::Maker::RSSBase">
              <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
            </scope>
            <scope name="Feed" ilk="class" classrefs="RSSBase">
              <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="namespace">
                <scope name="Author" ilk="class" classrefs="AuthorBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="CategoryBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="namespace">
                <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="namespace">
                <scope name="Link" ilk="class" classrefs="LinkBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Title" ilk="class" classrefs="TitleBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="AuthorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="CategoryBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Content" ilk="class" classrefs="ContentBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="namespace">
                  <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="namespace">
                  <scope name="Link" ilk="class" classrefs="LinkBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Rights" ilk="class" classrefs="RightsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="SourceBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Icon" ilk="class" classrefs="IconBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Logo" ilk="class" classrefs="LogoBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Rights" ilk="class" classrefs="RightsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Subtitle" ilk="class" classrefs="SubtitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Title" ilk="class" classrefs="TitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="namespace">
                    <scope name="Author" ilk="class" classrefs="AuthorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="namespace">
                    <scope name="Category" ilk="class" classrefs="CategoryBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="namespace">
                    <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="LinkBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Title" ilk="class" classrefs="TitleBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="namespace">
                <scope name="Author" ilk="class" classrefs="AuthorBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="CategoryBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="namespace">
                <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="namespace">
                <scope name="Link" ilk="class" classrefs="LinkBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Title" ilk="class" classrefs="TitleBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="AuthorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="CategoryBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Content" ilk="class" classrefs="ContentBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="namespace">
                  <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="namespace">
                  <scope name="Link" ilk="class" classrefs="LinkBase">
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Rights" ilk="class" classrefs="RightsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="SourceBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Icon" ilk="class" classrefs="IconBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Logo" ilk="class" classrefs="LogoBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Rights" ilk="class" classrefs="RightsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Subtitle" ilk="class" classrefs="SubtitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                  <scope name="Title" ilk="class" classrefs="TitleBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="namespace">
                    <scope name="Author" ilk="class" classrefs="AuthorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="namespace">
                    <scope name="Category" ilk="class" classrefs="CategoryBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="namespace">
                    <scope name="Contributor" ilk="class" classrefs="ContributorBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="LinkBase">
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Title" ilk="class" classrefs="TitleBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="namespace">
                <scope name="Category" ilk="class" classrefs="RSS::RSS09::Channel::Categories::Category">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Generator" ilk="class" classrefs="GeneratorBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="namespace">
                  <scope name="Author" ilk="class" classrefs="RSS::RSS09::Items::Item::Authors::Author">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="namespace">
                  <scope name="Category" ilk="class" classrefs="RSS::RSS09::Items::Item::Categories::Category">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="class" classrefs="RSS::RSS09::Items::Item::Source">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="namespace">
                    <scope name="Link" ilk="class" classrefs="RSS::RSS09::Items::Item::Source::Links::Link">
                      <scope name="to_feed" ilk="function" signature="to_feed(rss, source)" />
                    </scope>
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Bag" ilk="namespace">
            <scope name="Li" ilk="class" classrefs="Element">
              <import symbol="RSS10" />
              <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
              <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
              <scope name="full_name" ilk="function" signature="full_name()" />
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Li" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Seq" ilk="namespace">
            <scope name="Li" ilk="class" classrefs="Element">
              <import symbol="RSS10" />
              <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
              <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
              <scope name="full_name" ilk="function" signature="full_name()" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/content" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Atom" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
          </scope>
        </scope>
        <scope name="ContentModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ContentModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/converter" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Converter" ilk="class" classrefs="Object">
          <import symbol="Utils" />
          <scope name="new" ilk="function" signature="new(to_enc, from_enc=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="convert" ilk="function" signature="convert(value)" />
          <scope name="def_convert" ilk="function" signature="def_convert(depth=0)" />
          <scope name="def_else_enc" ilk="function" signature="def_else_enc(to_enc, from_enc)" />
          <scope name="def_iconv_convert" ilk="function" signature="def_iconv_convert(to_enc, from_enc, depth=0)" />
          <scope name="def_same_enc" ilk="function" signature="def_same_enc()" />
          <scope name="def_to_euc_jp_from_iso_2022_jp" ilk="function" signature="def_to_euc_jp_from_iso_2022_jp()" />
          <scope name="def_to_euc_jp_from_shift_jis" ilk="function" signature="def_to_euc_jp_from_shift_jis()" />
          <scope name="def_to_euc_jp_from_utf_8" ilk="function" signature="def_to_euc_jp_from_utf_8()" />
          <scope name="def_to_iso_2022_jp_from_euc_jp" ilk="function" signature="def_to_iso_2022_jp_from_euc_jp()" />
          <scope name="def_to_iso_8859_1_from_utf_8" ilk="function" signature="def_to_iso_8859_1_from_utf_8()" />
          <scope name="def_to_shift_jis_from_euc_jp" ilk="function" signature="def_to_shift_jis_from_euc_jp()" />
          <scope name="def_to_shift_jis_from_utf_8" ilk="function" signature="def_to_shift_jis_from_utf_8()" />
          <scope name="def_to_utf_8_from_euc_jp" ilk="function" signature="def_to_utf_8_from_euc_jp()" />
          <scope name="def_to_utf_8_from_iso_8859_1" ilk="function" signature="def_to_utf_8_from_iso_8859_1()" />
          <scope name="def_to_utf_8_from_shift_jis" ilk="function" signature="def_to_utf_8_from_shift_jis()" />
          <scope name="def_uconv_convert_if_can" ilk="function" signature="def_uconv_convert_if_can(meth, to_enc, from_enc, nkf_arg)" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/dublincore" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseDublinCoreModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" />
        </scope>
        <scope name="DublinCoreModel" ilk="namespace">
          <variable name="TEXT_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="DATE_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_NAME_INFOS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="DublinCoreModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_dublin_core" ilk="function" signature="install_dublin_core(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/image" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="ImageFaviconModel" ilk="namespace">
          <import symbol="ImageModelUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="ImageFavicon" ilk="class" classrefs="RSS::Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="image_size=" ilk="function" signature="image_size=(new_value)" />
            <scope name="set_size" ilk="function" signature="set_size(new_value)" />
            <scope name="size=" ilk="function" signature="size=(new_value)" />
            <variable name="AVAILABLE_SIZES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="ImageItemModel" ilk="namespace">
          <import symbol="ImageModelUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="ImageItem" ilk="class" classrefs="RSS::Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="ImageModelUtils" ilk="namespace">
          <scope name="validate_one_tag_name" ilk="function" signature="validate_one_tag_name(ignore_unknown_element, name, tags)" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageFaviconModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_image_favicon" ilk="function" signature="install_image_favicon(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageItemModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_image_item" ilk="function" signature="install_image_item(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="ImageBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS::Maker::RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS::Maker::RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="ImageBase">
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Image" ilk="class" classrefs="RSS::RSS09::Image">
            </scope>
          </scope>
        </scope>
        <scope name="RDF" ilk="namespace">
          <scope name="Image" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/itunes" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="ITunesBaseModel" ilk="namespace">
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="ITunesChannelModel" ilk="namespace">
          <import symbol="ITunesBaseModel" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
          <scope name="ITunesCategory" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="ITunesImage" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="ITunesOwner" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="ITunesItemModel" ilk="namespace">
          <import symbol="ITunesBaseModel" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
          <scope name="ITunesDuration" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="construct" ilk="function" signature="construct(hour, minute, second)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="parse" ilk="function" signature="parse(duration, do_validate=true)" attributes="__classmethod__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="content=" ilk="function" signature="content=(value)" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="hour=" ilk="function" signature="hour=(hour)" />
            <scope name="minute=" ilk="function" signature="minute=(minute)" />
            <scope name="second=" ilk="function" signature="second=(second)" />
            <scope name="value=" ilk="function" signature="value=(value)" />
            <scope ilk="function" name="hour" />
            <scope ilk="function" name="minute" />
            <scope ilk="function" name="second" />
          </scope>
        </scope>
        <scope name="ITunesModelUtils" ilk="namespace">
          <import symbol="Utils" />
          <scope name="def_class_accessor" ilk="function" signature="def_class_accessor(klass, name, type, *args)" />
          <scope name="def_element_class_accessor" ilk="function" signature="def_element_class_accessor(klass, name, full_name, klass_name, recommended_attribute_name=nil)" />
          <scope name="def_elements_class_accessor" ilk="function" signature="def_elements_class_accessor(klass, name, full_name, klass_name, plural_name, recommended_attribute_name=nil)" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesCategories" ilk="namespace">
              <scope name="ITunesCategory" ilk="class" classrefs="ITunesCategoryBase">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesImage" ilk="class" classrefs="ITunesImageBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesOwner" ilk="class" classrefs="ITunesOwnerBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesBaseModel" ilk="namespace">
            <scope name="def_class_accessor" ilk="function" signature="def_class_accessor(klass, name, type, *args)" />
            <scope name="def_csv_accessor" ilk="function" signature="def_csv_accessor(klass, full_name)" />
            <scope name="def_elements_class_accessor" ilk="function" signature="def_elements_class_accessor(klass, name, full_name, full_plural_name, klass_name, plural_klass_name, recommended_attribute_name=nil)" />
            <scope name="def_yes_clean_other_accessor" ilk="function" signature="def_yes_clean_other_accessor(klass, full_name)" />
            <scope name="def_yes_other_accessor" ilk="function" signature="def_yes_other_accessor(klass, full_name)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesItemModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="add_maker" ilk="function" signature="add_maker(version, normalized_version, maker)" attributes="__classmethod__" />
          <scope name="make" ilk="function" signature="make(version, &amp;block)" attributes="__classmethod__" />
          <scope name="makers" ilk="function" signature="makers()" attributes="__classmethod__" />
          <scope name="supported?" ilk="function" signature="supported?(version)" attributes="__classmethod__" />
          <scope name="versions" ilk="function" signature="versions()" attributes="__classmethod__" />
          <variable name="MAKERS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/0.9" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="class" classrefs="RSSBase">
            <scope name="new" ilk="function" signature="new(feed_version)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="class" classrefs="RSS::Maker::RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;0.91&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="class" classrefs="RSS::Maker::RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;0.92&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/1.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="class" classrefs="RSSBase">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;1.0&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/2.0" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="class" classrefs="RSS::RSS09">
            <scope name="new" ilk="function" signature="new(feed_version=&quot;2.0&quot;)" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/atom" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="AtomCategory" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomGenerator" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomLink" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomLogo" ilk="namespace">
            <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomPersons" ilk="namespace">
            <scope name="def_atom_persons" ilk="function" signature="def_atom_persons(klass, name, maker_name, plural=nil)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/base" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="AtomPersonConstructBase" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomTextConstruct" ilk="namespace">
            <scope name="def_atom_text_construct" ilk="function" signature="def_atom_text_construct(klass, name, maker_name, klass_name=nil, atom_klass_name=nil)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="AtomTextConstructBase" ilk="namespace">
            <import symbol="EnsureXMLContent" />
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="EnsureXMLContent" ilk="namespace">
              <scope name="included" ilk="function" signature="included(base)" attributes="__classmethod__" />
              <scope name="ensure_xml_content" ilk="function" signature="ensure_xml_content(content)" />
              <scope name="xhtml=" ilk="function" signature="xhtml=(content)" />
              <scope name="xml_content=" ilk="function" signature="xml_content=(content)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="AuthorsBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="AuthorBase" ilk="class" classrefs="RSS::Maker::Base">
                <import symbol="AtomPersonConstructBase" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CategoriesBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="CategoryBase" ilk="class" classrefs="RSS::Maker::Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CloudBase" ilk="class" classrefs="RSS::Maker::Base">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ContributorsBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="ContributorBase" ilk="class" classrefs="RSS::Maker::Base">
                <import symbol="AtomPersonConstructBase" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="CopyrightBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="DescriptionBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="GeneratorBase" ilk="class" classrefs="RSS::Maker::Base">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="LinksBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="LinkBase" ilk="class" classrefs="RSS::Maker::Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="SkipDaysBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="DayBase" ilk="class" classrefs="RSS::Maker::Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="SkipHoursBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="HourBase" ilk="class" classrefs="RSS::Maker::Base">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="TitleBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="AtomTextConstructBase" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Copyright" ilk="class" classrefs="CopyrightBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Copyright" ilk="class" classrefs="CopyrightBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Authors" ilk="class" classrefs="AuthorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Contributors" ilk="class" classrefs="ContributorsBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Authors" ilk="class" classrefs="RSS::RSS09::Items::Item::Authors">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="SetupDefaultDate" ilk="namespace">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="SetupDefaultLanguage" ilk="namespace">
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="XMLStyleSheets" ilk="class" classrefs="RSS::Maker::Base">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/dublincore" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ImageBase" ilk="class" classrefs="RSS::Maker::Base">
            <import symbol="DublinCoreModel" />
            <scope name="link" ilk="function" signature="link()" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TextinputBase" ilk="class" classrefs="RSS::Maker::Base">
            <import symbol="DublinCoreModel" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/entry" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Description" ilk="class" classrefs="DescriptionBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Description" ilk="class" classrefs="DescriptionBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Description" ilk="class" classrefs="DescriptionBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Description" ilk="class" classrefs="DescriptionBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/feed" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="class" classrefs="LinksBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="class" classrefs="LinksBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="LinksBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Links" ilk="class" classrefs="LinksBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Links" ilk="class" classrefs="LinksBase">
                  <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Categories" ilk="class" classrefs="CategoriesBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="LinksBase">
                    <scope name="to_feed" ilk="function" signature="to_feed(*args)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="namespace">
              <scope name="Categories" ilk="class" classrefs="RSS::RSS09::Channel::Categories">
                <scope name="to_feed" ilk="function" signature="to_feed(rss, channel)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Categories" ilk="class" classrefs="RSS::RSS09::Items::Item::Categories">
                  <scope name="to_feed" ilk="function" signature="to_feed(rss, item)" />
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="namespace">
                <scope name="Source" ilk="namespace">
                  <scope name="Links" ilk="class" classrefs="RSS::RSS09::Items::Item::Source::Links">
                    <scope name="to_feed" ilk="function" signature="to_feed(rss, source)" />
                  </scope>
                </scope>
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/image" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ImageFaviconModel" ilk="namespace">
            <scope name="ImageFaviconBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="Maker::DublinCoreModel" />
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="about" />
              <scope ilk="function" name="about=" />
              <scope ilk="function" name="image_size" />
              <scope ilk="function" name="image_size=" />
              <scope ilk="function" name="size" />
              <scope ilk="function" name="size=" />
              <scope ilk="function" name="size=" />
              <scope ilk="function" name="size==" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ImageItemModel" ilk="namespace">
            <scope name="ImageItemBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="Maker::DublinCoreModel" />
              <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="about" />
              <scope ilk="function" name="about=" />
              <scope ilk="function" name="height=" />
              <scope ilk="function" name="height==" />
              <scope ilk="function" name="image_height" />
              <scope ilk="function" name="image_height=" />
              <scope ilk="function" name="image_width" />
              <scope ilk="function" name="image_width=" />
              <scope ilk="function" name="resource" />
              <scope ilk="function" name="resource=" />
              <scope ilk="function" name="width=" />
              <scope ilk="function" name="width==" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/itunes" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="namespace">
            <scope name="ITunesCategories" ilk="class" classrefs="ITunesCategoriesBase">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesCategoriesBase" ilk="class" classrefs="Base">
              <scope name="ITunesCategoryBase" ilk="class" classrefs="Base">
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                <scope name="to_feed_for_categories" ilk="function" signature="to_feed_for_categories(feed, current)" />
                <scope ilk="function" name="text" />
                <scope ilk="function" name="text=" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesImageBase" ilk="class" classrefs="Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="href" />
              <scope ilk="function" name="href=" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesChannelModel" ilk="namespace">
            <scope name="ITunesOwnerBase" ilk="class" classrefs="Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="ITunesItemModel" ilk="namespace">
            <scope name="ITunesDurationBase" ilk="class" classrefs="Base">
              <scope name="content=" ilk="function" signature="content=(content)" />
              <scope name="hour=" ilk="function" signature="hour=(hour)" />
              <scope name="minute=" ilk="function" signature="minute=(minute)" />
              <scope name="second=" ilk="function" signature="second=(second)" />
              <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
              <scope ilk="function" name="content" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/taxonomy" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ChannelBase" ilk="class" classrefs="RSS::Maker::Base">
            <import symbol="DublinCoreModel" />
            <import symbol="Maker::ITunesChannelModel" />
            <import symbol="Maker::ImageFaviconModel" />
            <import symbol="SetupDefaultDate" />
            <import symbol="SyndicationModel" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="date=" ilk="function" signature="date=(_date)" />
            <scope name="icon" ilk="function" signature="icon()" />
            <scope name="icon=" ilk="function" signature="icon=(url)" />
            <scope name="lastBuildDate=" ilk="function" signature="lastBuildDate=(_date)" />
            <scope name="logo" ilk="function" signature="logo()" />
            <scope name="logo=" ilk="function" signature="logo=(url)" />
            <scope name="pubDate" ilk="function" signature="pubDate()" />
            <scope name="pubDate=" ilk="function" signature="pubDate=(date)" />
            <scope name="updated" ilk="function" signature="updated()" />
            <scope name="updated=" ilk="function" signature="updated=(date)" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSSBase" ilk="class" classrefs="RSS::Maker::Base">
            <import symbol="TaxonomyTopicModel" />
            <scope name="make" ilk="function" signature="make(*args, &amp;block)" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(feed_version)" attributes="__classmethod__ __ctor__" />
            <scope name="make" ilk="function" signature="make()" />
            <scope name="to_feed" ilk="function" signature="to_feed()" />
            <scope ilk="function" name="encoding" />
            <scope ilk="function" name="encoding=" />
            <scope ilk="function" name="feed_version" />
            <scope ilk="function" name="rss_version" />
            <scope ilk="function" name="standalone" />
            <scope ilk="function" name="standalone=" />
            <scope ilk="function" name="version" />
            <scope ilk="function" name="version=" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicModel" ilk="namespace">
            <scope name="TaxonomyTopicsBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="TaxonomyTopicBase" ilk="class" classrefs="RSS::Maker::Base">
                <import symbol="DublinCoreModel" />
                <import symbol="TaxonomyTopicsModel" />
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope ilk="function" name="taxo_link" />
                <scope ilk="function" name="taxo_link=" />
                <scope ilk="function" name="taxo_link=" />
                <scope ilk="function" name="taxo_link==" />
                <scope ilk="function" name="value" />
                <scope ilk="function" name="value=" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicsModel" ilk="namespace">
            <scope name="TaxonomyTopicsBase" ilk="class" classrefs="RSS::Maker::Base">
              <scope ilk="function" name="resources" />
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/maker/trackback" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="ItemsBase" ilk="class" classrefs="RSS::Maker::Base">
            <scope name="new" ilk="function" signature="new(maker)" attributes="__classmethod__ __ctor__" />
            <scope name="normalize" ilk="function" signature="normalize()" />
            <scope ilk="function" name="do_sort" />
            <scope ilk="function" name="do_sort=" />
            <scope ilk="function" name="max_size" />
            <scope ilk="function" name="max_size=" />
            <scope name="ItemBase" ilk="class" classrefs="RSS::Maker::Base">
              <import symbol="ContentModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="Maker::ITunesItemModel" />
              <import symbol="Maker::ImageItemModel" />
              <import symbol="SetupDefaultDate" />
              <import symbol="SlashModel" />
              <import symbol="TaxonomyTopicsModel" />
              <import symbol="TrackBackModel" />
              <scope name="date=" ilk="function" signature="date=(_date)" />
              <scope name="pubDate" ilk="function" signature="pubDate()" />
              <scope name="pubDate=" ilk="function" signature="pubDate=(date)" />
              <scope name="updated" ilk="function" signature="updated()" />
              <scope name="updated=" ilk="function" signature="updated=(date)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TrackBackModel" ilk="namespace">
            <scope name="TrackBackAboutsBase" ilk="class" classrefs="Base">
              <scope name="TrackBackAboutBase" ilk="class" classrefs="Base">
                <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
                <scope name="to_feed" ilk="function" signature="to_feed(feed, current)" />
                <scope ilk="function" name="content" />
                <scope ilk="function" name="content=" />
                <scope ilk="function" name="content=" />
                <scope ilk="function" name="content==" />
                <scope ilk="function" name="resource" />
                <scope ilk="function" name="resource=" />
                <scope ilk="function" name="resource=" />
                <scope ilk="function" name="resource==" />
                <scope ilk="function" name="value" />
                <scope ilk="function" name="value=" />
              </scope>
            </scope>
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/parser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseListener" ilk="class" classrefs="Object">
          <scope name="available_tags" ilk="function" signature="available_tags(uri)" attributes="__classmethod__" doc="return the tag_names for setters associated with uri" />
          <scope name="class_name" ilk="function" signature="class_name(uri, tag_name)" attributes="__classmethod__" doc="retrieve class_name for the supplied uri and tag_name If it doesn&apos;t exist, capitalize the tag_name" />
          <scope name="getter" ilk="function" signature="getter(uri, tag_name)" attributes="__classmethod__" />
          <scope name="install_class_name" ilk="function" signature="install_class_name(uri, tag_name, class_name)" attributes="__classmethod__" doc="record class_name for the supplied uri and tag_name" />
          <scope name="install_get_text_element" ilk="function" signature="install_get_text_element(uri, name, accessor_base)" attributes="__classmethod__" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="register_uri" ilk="function" signature="register_uri(uri, name)" attributes="__classmethod__" doc="register uri against this name." />
          <scope name="setter" ilk="function" signature="setter(uri, tag_name)" attributes="__classmethod__" doc="return the setter for the uri, tag_name pair, or nil." />
          <scope name="uri_registered?" ilk="function" signature="uri_registered?(uri, name)" attributes="__classmethod__" doc="test if this uri is registered against this name" />
        </scope>
        <scope name="BaseParser" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(rss)" attributes="__classmethod__ __ctor__" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="do_validate" ilk="function" signature="do_validate()" />
          <scope name="do_validate=" ilk="function" signature="do_validate=(new_value)" />
          <scope name="ignore_unknown_element" ilk="function" signature="ignore_unknown_element()" />
          <scope name="ignore_unknown_element=" ilk="function" signature="ignore_unknown_element=(new_value)" />
          <scope name="parse" ilk="function" signature="parse()" />
          <scope name="rss" ilk="function" signature="rss()" />
        </scope>
        <scope name="ListenerMixin" ilk="namespace">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          <scope name="instruction" ilk="function" signature="instruction(name, content)" />
          <scope name="tag_end" ilk="function" signature="tag_end(name)" />
          <scope name="tag_start" ilk="function" signature="tag_start(name, attributes)" />
          <scope name="text" ilk="function" signature="text(data)" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" doc="set instance vars for version, encoding, standalone" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <scope ilk="function" name="ignore_unknown_element" />
          <scope ilk="function" name="ignore_unknown_element=" />
          <scope ilk="function" name="rss" />
          <variable name="CONTENT_PATTERN" attributes="__const__" citdl="Object" />
          <variable name="NAMESPLIT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="Base" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="add_need_initialize_variable" ilk="function" signature="add_need_initialize_variable(variable_name, init_value=nil, &amp;init_block)" attributes="__classmethod__" />
            <scope name="add_other_element" ilk="function" signature="add_other_element(variable_name)" attributes="__classmethod__" />
            <scope name="def_array_element" ilk="function" signature="def_array_element(name, plural=nil, klass_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_element" ilk="function" signature="def_classed_element(name, class_name=nil, attribute_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_element_without_accessor" ilk="function" signature="def_classed_element_without_accessor(name, class_name=nil)" attributes="__classmethod__" />
            <scope name="def_classed_elements" ilk="function" signature="def_classed_elements(name, attribute, plural_class_name=nil, plural_name=nil, new_name=nil)" attributes="__classmethod__" />
            <scope name="def_csv_element" ilk="function" signature="def_csv_element(name, type=nil)" attributes="__classmethod__" />
            <scope name="def_other_element" ilk="function" signature="def_other_element(name)" attributes="__classmethod__" />
            <scope name="def_other_element_without_accessor" ilk="function" signature="def_other_element_without_accessor(name)" attributes="__classmethod__" />
            <scope name="inherited" ilk="function" signature="inherited(subclass)" attributes="__classmethod__" />
            <scope name="inherited_base" ilk="function" signature="inherited_base()" attributes="__classmethod__" />
            <scope name="need_initialize_variables" ilk="function" signature="need_initialize_variables()" attributes="__classmethod__" />
            <scope name="new" ilk="function" signature="new(maker)" attributes="__classmethod__ __ctor__" />
            <scope name="other_elements" ilk="function" signature="other_elements()" attributes="__classmethod__" />
            <scope name="have_required_values?" ilk="function" signature="have_required_values?()" />
            <scope name="variable_is_set?" ilk="function" signature="variable_is_set?()" />
            <scope ilk="function" name="maker" />
            <variable name="OTHER_ELEMENTS" attributes="__const__" citdl="Object" />
            <variable name="NEED_INITIALIZE_VARIABLES" attributes="__const__" citdl="Object" />
          </scope>
        </scope>
        <scope name="NSError" ilk="class" classrefs="InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, prefix, require_uri)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="prefix" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="NotValidXMLParser" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(parser)" attributes="__classmethod__ __ctor__" />
        </scope>
        <scope name="NotWellFormedError" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new(line=nil, element=nil)" attributes="__classmethod__ __ctor__" doc="Create a new NotWellFormedError for an error at +line+ in +element+.  If a block is given the return value of the block ends up in the error message." />
          <scope ilk="function" name="element" />
          <scope ilk="function" name="line" />
        </scope>
        <scope name="XMLParserNotFound" ilk="class" classrefs="Error">
          <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/rexmlparser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="REXMLListener" ilk="class" classrefs="BaseListener">
          <import symbol="ListenerMixin" />
          <import symbol="REXML::StreamListener" />
          <scope name="raise_for_undefined_entity?" ilk="function" signature="raise_for_undefined_entity?()" attributes="__classmethod__" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
        </scope>
        <scope name="REXMLParser" ilk="class" classrefs="BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/rss" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseModel" ilk="namespace">
          <import symbol="Utils" />
          <scope name="install_date_element" ilk="function" signature="install_date_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)" />
          <scope name="install_have_attribute_element" ilk="function" signature="install_have_attribute_element(tag_name, uri, occurs, name=nil, type=nil)" />
          <scope name="install_have_child_element" ilk="function" signature="install_have_child_element(tag_name, uri, occurs, name=nil, type=nil)" />
          <scope name="install_have_children_element" ilk="function" signature="install_have_children_element(tag_name, uri, occurs, name=nil, plural_name=nil)" />
          <scope name="install_text_element" ilk="function" signature="install_text_element(tag_name, uri, occurs, name=nil, type=nil, disp_name=nil)" />
        </scope>
        <scope name="ConversionError" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(string, to, from)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="from" />
          <scope ilk="function" name="string" />
          <scope ilk="function" name="to" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="InvalidRSSError" ilk="class" classrefs="RSS::Error">
        </scope>
        <scope name="MissingAttributeError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, attribute)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="attribute" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="MissingTagError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="NotAvailableValueError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, value, attribute=nil)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="attribute" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="value" />
        </scope>
        <scope name="NotExceptedTagError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, uri, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="NotExpectedTagError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, uri, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="NotSetError" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(name, variables)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="variables" />
        </scope>
        <scope name="OverlappedPrefixError" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(prefix)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="prefix" />
        </scope>
        <scope name="RootElementMixin" ilk="namespace">
          <import symbol="XMLStyleSheetMixin" />
          <scope name="new" ilk="function" signature="new(feed_version, version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="feed_info" ilk="function" signature="feed_info()" />
          <scope name="output_encoding=" ilk="function" signature="output_encoding=(enc)" />
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          <scope name="to_atom" ilk="function" signature="to_atom(type, &amp;block)" />
          <scope name="to_feed" ilk="function" signature="to_feed(type, &amp;block)" />
          <scope name="to_rss" ilk="function" signature="to_rss(type, &amp;block)" />
          <scope name="to_xml" ilk="function" signature="to_xml(type=nil, &amp;block)" />
          <scope ilk="function" name="encoding" />
          <scope ilk="function" name="encoding=" />
          <scope ilk="function" name="feed_subtype" />
          <scope ilk="function" name="feed_type" />
          <scope ilk="function" name="feed_version" />
          <scope ilk="function" name="output_encoding" />
          <scope ilk="function" name="standalone" />
          <scope ilk="function" name="standalone=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
        </scope>
        <scope name="SetupMaker" ilk="namespace">
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
        </scope>
        <scope name="TooMuchTagError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, parent)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="tag" />
        </scope>
        <scope name="UnknownConversionMethodError" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(to, from)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="from" />
          <scope ilk="function" name="to" />
        </scope>
        <scope name="UnknownConvertMethod" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(to, from)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="from" />
          <scope ilk="function" name="to" />
        </scope>
        <scope name="UnknownTagError" ilk="class" classrefs="RSS::InvalidRSSError">
          <scope name="new" ilk="function" signature="new(tag, uri)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="tag" />
          <scope ilk="function" name="uri" />
        </scope>
        <scope name="UnsupportedMakerVersionError" ilk="class" classrefs="RSS::Error">
          <scope name="new" ilk="function" signature="new(version)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="version" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/slash" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="SlashModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="SlashModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENT_INFOS" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/syndication" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="SyndicationModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="SyndicationModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="SY_UPDATEPERIOD_AVAILABLE_VALUES" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/taxonomy" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_taxo_topic" ilk="function" signature="install_taxo_topic(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TaxonomyTopicsModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
            <scope name="install_taxo_topics" ilk="function" signature="install_taxo_topics(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="TaxonomyTopicModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="TaxonomyTopic" ilk="class" classrefs="RSS::Element">
            <import symbol="DublinCoreModel" />
            <import symbol="RSS10" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
          </scope>
        </scope>
        <scope name="TaxonomyTopicsModel" ilk="namespace">
          <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          <scope name="TaxonomyTopics" ilk="class" classrefs="RSS::Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="maker_target" ilk="function" signature="maker_target(target)" />
            <scope name="resources" ilk="function" signature="resources()" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/trackback" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="BaseTrackBackModel" ilk="namespace">
          <import symbol="TrackBackUtils" />
          <scope name="append_features" ilk="function" signature="append_features(klass)" />
          <variable name="ELEMENTS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS::Maker::ChannelBase">
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS09" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="ItemBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS::Maker::RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS091" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS::Maker::RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS::Maker::RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS092" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS::Maker::RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS::Maker::ChannelBase">
              <import symbol="SetupDefaultLanguage" />
              <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS10" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="ItemBase">
                <scope name="to_feed" ilk="function" signature="to_feed(rss)" />
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Channel" ilk="class" classrefs="RSS::RSS09::Channel">
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="RSS20" ilk="namespace">
            <scope name="Items" ilk="namespace">
              <scope name="Item" ilk="class" classrefs="RSS::RSS09::Items::Item">
              </scope>
            </scope>
          </scope>
        </scope>
        <scope name="Maker" ilk="namespace">
          <scope name="TrackBackModel" ilk="namespace">
            <scope name="append_features" ilk="function" signature="append_features(klass)" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="RDF" ilk="class" classrefs="Element">
          <import symbol="RSS10" />
          <import symbol="RootElementMixin" />
          <import symbol="TaxonomyTopicModel" />
          <scope name="new" ilk="function" signature="new(version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          <scope name="full_name" ilk="function" signature="full_name()" />
          <variable name="PREFIX" attributes="__const__" citdl="Object" />
          <variable name="URI" attributes="__const__" citdl="Object" />
          <scope name="Channel" ilk="class" classrefs="Element">
            <import symbol="DublinCoreModel" />
            <import symbol="ImageFaviconModel" />
            <import symbol="RSS10" />
            <import symbol="SyndicationModel" />
            <import symbol="TaxonomyTopicsModel" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
          <scope name="Item" ilk="class" classrefs="Element">
            <import symbol="ContentModel" />
            <import symbol="DublinCoreModel" />
            <import symbol="ImageItemModel" />
            <import symbol="RSS10" />
            <import symbol="SlashModel" />
            <import symbol="TaxonomyTopicsModel" />
            <import symbol="TrackBackModel10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          </scope>
        </scope>
        <scope name="Rss" ilk="class" classrefs="RSS::Element">
          <import symbol="RootElementMixin" />
          <scope name="new" ilk="function" signature="new(feed_version, version=nil, encoding=nil, standalone=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="image" ilk="function" signature="image()" />
          <scope name="items" ilk="function" signature="items()" />
          <scope name="setup_maker_elements" ilk="function" signature="setup_maker_elements(maker)" />
          <scope name="textinput" ilk="function" signature="textinput()" />
          <scope ilk="function" name="feed_version=" />
          <scope ilk="function" name="rss_version" />
          <scope ilk="function" name="rss_version=" />
          <scope name="Channel" ilk="class" classrefs="RSS::Element">
            <import symbol="DublinCoreModel" />
            <import symbol="ITunesChannelModel" />
            <scope name="Item" ilk="class" classrefs="RSS::Element">
              <import symbol="ContentModel" />
              <import symbol="DublinCoreModel" />
              <import symbol="ITunesItemModel" />
              <import symbol="TrackBackModel20" />
            </scope>
          </scope>
        </scope>
        <scope name="TrackBackModel10" ilk="namespace">
          <scope name="TrackBackAbout" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="TrackBackPing" ilk="class" classrefs="Element">
            <import symbol="RSS10" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="TrackBackModel20" ilk="namespace">
          <scope name="TrackBackAbout" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
          <scope name="TrackBackPing" ilk="class" classrefs="Element">
            <import symbol="RSS09" />
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
            <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
            <scope name="full_name" ilk="function" signature="full_name()" />
          </scope>
        </scope>
        <scope name="TrackBackUtils" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="rss/utils" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Utils" ilk="namespace">
          <scope name="element_initialize_arguments?" ilk="function" signature="element_initialize_arguments?(args)" />
          <scope name="get_file_and_line_from_caller" ilk="function" signature="get_file_and_line_from_caller(i=0)" />
          <scope name="h" ilk="function" signature="h(s)" />
          <scope name="html_escape" ilk="function" signature="html_escape(s)" doc="escape &apos;&amp;&apos;, &apos;&quot;&apos;, &apos;&lt;&apos; and &apos;&gt;&apos; for use in HTML." />
          <scope name="new_with_value_if_need" ilk="function" signature="new_with_value_if_need(klass, value)" doc="If +value+ is an instance of class +klass+, return it, else create a new instance of +klass+ with value +value+." />
          <scope name="to_class_name" ilk="function" signature="to_class_name(name)" doc="Convert a name_with_underscores to CamelCase." />
          <scope name="CSV" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value, &amp;block)" />
          </scope>
          <scope name="InheritedReader" ilk="namespace">
            <scope name="inherited_array_reader" ilk="function" signature="inherited_array_reader(constant_name)" />
            <scope name="inherited_hash_reader" ilk="function" signature="inherited_hash_reader(constant_name)" />
            <scope name="inherited_reader" ilk="function" signature="inherited_reader(constant_name)" />
          </scope>
          <scope name="YesCleanOther" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value)" />
          </scope>
          <scope name="YesOther" ilk="namespace">
            <scope name="parse" ilk="function" signature="parse(value)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/xml" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Element" ilk="class" classrefs="Object">
          <import symbol="SetupMaker" />
          <import symbol="Utils" />
          <scope name="add_have_children_element" ilk="function" signature="add_have_children_element(variable_name, plural_name)" attributes="__classmethod__" />
          <scope name="add_need_initialize_variable" ilk="function" signature="add_need_initialize_variable(variable_name)" attributes="__classmethod__" />
          <scope name="add_plural_form" ilk="function" signature="add_plural_form(singular, plural)" attributes="__classmethod__" />
          <scope name="add_to_element_method" ilk="function" signature="add_to_element_method(method_name)" attributes="__classmethod__" />
          <scope name="content_setup" ilk="function" signature="content_setup(type=nil, disp_name=nil)" attributes="__classmethod__" />
          <scope name="def_corresponded_attr_reader" ilk="function" signature="def_corresponded_attr_reader(name, type=nil)" attributes="__classmethod__" />
          <scope name="def_corresponded_attr_writer" ilk="function" signature="def_corresponded_attr_writer(name, type=nil, disp_name=nil)" attributes="__classmethod__" />
          <scope name="get_attributes" ilk="function" signature="get_attributes()" attributes="__classmethod__" />
          <scope name="have_children_elements" ilk="function" signature="have_children_elements()" attributes="__classmethod__" />
          <scope name="have_content?" ilk="function" signature="have_content?()" attributes="__classmethod__" />
          <scope name="inherited" ilk="function" signature="inherited(klass)" attributes="__classmethod__" />
          <scope name="inherited_base" ilk="function" signature="inherited_base()" attributes="__classmethod__" />
          <scope name="install_get_attribute" ilk="function" signature="install_get_attribute(name, uri, required=true, type=nil, disp_name=nil, element_name=nil)" attributes="__classmethod__" />
          <scope name="install_model" ilk="function" signature="install_model(tag, uri, occurs=nil, getter=nil, plural=false)" attributes="__classmethod__" />
          <scope name="install_must_call_validator" ilk="function" signature="install_must_call_validator(prefix, uri)" attributes="__classmethod__" />
          <scope name="install_ns" ilk="function" signature="install_ns(prefix, uri)" attributes="__classmethod__" />
          <scope name="models" ilk="function" signature="models()" attributes="__classmethod__" />
          <scope name="must_call_validators" ilk="function" signature="must_call_validators()" attributes="__classmethod__" />
          <scope name="need_initialize_variables" ilk="function" signature="need_initialize_variables()" attributes="__classmethod__" />
          <scope name="need_parent?" ilk="function" signature="need_parent?()" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(do_validate=true, attrs=nil)" attributes="__classmethod__ __ctor__" />
          <scope name="plural_forms" ilk="function" signature="plural_forms()" attributes="__classmethod__" />
          <scope name="required_prefix" ilk="function" signature="required_prefix()" attributes="__classmethod__" />
          <scope name="required_uri" ilk="function" signature="required_uri()" attributes="__classmethod__" />
          <scope name="tag_name" ilk="function" signature="tag_name()" attributes="__classmethod__" />
          <scope name="to_element_methods" ilk="function" signature="to_element_methods()" attributes="__classmethod__" />
          <scope name="convert" ilk="function" signature="convert(value)" />
          <scope name="converter=" ilk="function" signature="converter=(converter)" />
          <scope name="full_name" ilk="function" signature="full_name()" />
          <scope name="have_xml_content?" ilk="function" signature="have_xml_content?()" />
          <scope name="need_base64_encode?" ilk="function" signature="need_base64_encode?()" />
          <scope name="set_next_element" ilk="function" signature="set_next_element(tag_name, next_element)" />
          <scope name="tag_name" ilk="function" signature="tag_name()" />
          <scope name="to_s" ilk="function" signature="to_s(need_convert=true, indent=&apos;&apos;)" />
          <scope name="valid?" ilk="function" signature="valid?(ignore_unknown_element=true)" />
          <scope name="validate" ilk="function" signature="validate(ignore_unknown_element=true)" />
          <scope name="validate_for_stream" ilk="function" signature="validate_for_stream(tags, ignore_unknown_element=true)" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <scope ilk="function" name="parent" />
          <scope ilk="function" name="parent=" />
          <variable name="INDENT" attributes="__const__" citdl="Object" />
          <variable name="MUST_CALL_VALIDATORS" attributes="__const__" citdl="Object" />
          <variable name="MODELS" attributes="__const__" citdl="Object" />
          <variable name="GET_ATTRIBUTES" attributes="__const__" citdl="Object" />
          <variable name="HAVE_CHILDREN_ELEMENTS" attributes="__const__" citdl="Object" />
          <variable name="TO_ELEMENT_METHODS" attributes="__const__" citdl="Object" />
          <variable name="NEED_INITIALIZE_VARIABLES" attributes="__const__" citdl="Object" />
          <variable name="PLURAL_FORMS" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XML" ilk="namespace">
          <scope name="Element" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="new" ilk="function" signature="new(name, prefix=nil, uri=nil, attributes={}, children=[])" attributes="__classmethod__ __ctor__" />
            <scope name="each" ilk="function" signature="each(&amp;block)" />
            <scope name="full_name" ilk="function" signature="full_name()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="attributes" />
            <scope ilk="function" name="children" />
            <scope ilk="function" name="name" />
            <scope ilk="function" name="prefix" />
            <scope ilk="function" name="uri" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="rss/xml-stylesheet" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Maker" ilk="namespace">
          <scope name="XMLStyleSheets" ilk="namespace">
            <scope name="XMLStyleSheet" ilk="class" classrefs="RSS::Maker::Base">
              <scope name="to_feed" ilk="function" signature="to_feed(feed)" />
            </scope>
          </scope>
        </scope>
        <scope name="XML" ilk="namespace">
        </scope>
        <scope name="XMLStyleSheet" ilk="class" classrefs="Object">
          <import symbol="Utils" />
          <scope name="new" ilk="function" signature="new(*attrs)" attributes="__classmethod__ __ctor__" />
          <scope name="alternate=" ilk="function" signature="alternate=(value)" />
          <scope name="href=" ilk="function" signature="href=(value)" />
          <scope name="setup_maker" ilk="function" signature="setup_maker(maker)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="do_validate" />
          <scope ilk="function" name="do_validate=" />
          <variable name="ATTRIBUTES" attributes="__const__" citdl="Object" />
          <variable name="GUESS_TABLE" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XMLStyleSheetMixin" ilk="namespace">
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope ilk="function" name="xml_stylesheets" />
          <scope ilk="function" name="xml_stylesheets=" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/xmlparser" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="Parser" ilk="class" classrefs="Object">
          <scope name="default_parser" ilk="function" signature="default_parser()" attributes="__classmethod__" />
          <scope name="default_parser=" ilk="function" signature="default_parser=(new_value)" attributes="__classmethod__" doc="Set @@default_parser to new_value if it is one of the available parsers. Else raise NotValidXMLParser error." />
          <scope name="new" ilk="function" signature="new(rss, parser_class=self.class.default_parser)" attributes="__classmethod__ __ctor__" />
          <scope name="parse" ilk="function" signature="parse(rss, do_validate=true, ignore_unknown_element=true, parser_class=default_parser)" attributes="__classmethod__" />
        </scope>
        <scope name="REXMLLikeXMLParser" ilk="class" classrefs="XML::Parser">
          <import symbol="::XML::Encoding_ja" />
          <scope name="character" ilk="function" signature="character(data)" />
          <scope name="endElement" ilk="function" signature="endElement(name)" />
          <scope name="listener=" ilk="function" signature="listener=(listener)" />
          <scope name="processingInstruction" ilk="function" signature="processingInstruction(target, content)" />
          <scope name="startElement" ilk="function" signature="startElement(name, attrs)" />
          <scope name="xmlDecl" ilk="function" signature="xmlDecl(version, encoding, standalone)" />
        </scope>
        <scope name="XMLParserListener" ilk="class" classrefs="RSS::BaseListener">
          <import symbol="ListenerMixin" />
          <scope name="xmldecl" ilk="function" signature="xmldecl(version, encoding, standalone)" />
        </scope>
        <scope name="XMLParserParser" ilk="class" classrefs="RSS::BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rss/xmlscanner" ilk="blob" lang="Ruby">
      <scope name="RSS" ilk="namespace">
        <scope name="XMLScanListener" ilk="class" classrefs="RSS::BaseListener">
          <import symbol="ListenerMixin" />
          <import symbol="XMLScan::Visitor" />
          <scope name="on_attr_charref" ilk="function" signature="on_attr_charref(code)" />
          <scope name="on_attr_charref_hex" ilk="function" signature="on_attr_charref_hex(code)" />
          <scope name="on_attr_entityref" ilk="function" signature="on_attr_entityref(ref)" />
          <scope name="on_attr_value" ilk="function" signature="on_attr_value(str)" />
          <scope name="on_attribute" ilk="function" signature="on_attribute(name)" />
          <scope name="on_charref" ilk="function" signature="on_charref(code)" />
          <scope name="on_charref_hex" ilk="function" signature="on_charref_hex(code)" />
          <scope name="on_entityref" ilk="function" signature="on_entityref(ref)" />
          <scope name="on_etag" ilk="function" signature="on_etag(name)" />
          <scope name="on_stag" ilk="function" signature="on_stag(name)" />
          <scope name="on_stag_end" ilk="function" signature="on_stag_end(name)" />
          <scope name="on_stag_end_empty" ilk="function" signature="on_stag_end_empty(name)" />
          <scope name="on_xmldecl_encoding" ilk="function" signature="on_xmldecl_encoding(str)" />
          <scope name="on_xmldecl_end" ilk="function" signature="on_xmldecl_end()" />
          <scope name="on_xmldecl_standalone" ilk="function" signature="on_xmldecl_standalone(str)" />
          <scope name="on_xmldecl_version" ilk="function" signature="on_xmldecl_version(str)" />
          <variable name="ENTITIES" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="XMLScanParser" ilk="class" classrefs="RSS::BaseParser">
          <scope name="listener" ilk="function" signature="listener()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="rubygems/test_utilities" ilk="blob" lang="Ruby">
      <scope name="TempIO" ilk="class" classrefs="Tempfile">
        <scope name="new" ilk="function" signature="new(string = &apos;&apos;)" attributes="__classmethod__ __ctor__" />
        <scope name="string" ilk="function" signature="string()" />
      </scope>
    </scope>
    <scope name="scanf" ilk="blob" lang="Ruby">
      <scope name="Scanf" ilk="namespace">
        <scope name="FormatSpecifier" ilk="class" classrefs="Object">
        </scope>
        <scope name="FormatString" ilk="class" classrefs="Object">
        </scope>
      </scope>
    </scope>
    <scope name="sdbm" ilk="blob" lang="Ruby">
      <scope name="SDBM" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2)" attributes="__classmethod__ __ctor__" />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" />
        <scope name="clear" ilk="function" signature="clear()" />
        <scope name="close" ilk="function" signature="close()" />
        <scope name="closed?" ilk="function" signature="closed?()" />
        <scope name="delete" ilk="function" signature="delete(p1)" />
        <scope name="delete_if" ilk="function" signature="delete_if()" />
        <scope name="each" ilk="function" signature="each()" />
        <scope name="each_key" ilk="function" signature="each_key()" />
        <scope name="each_pair" ilk="function" signature="each_pair()" />
        <scope name="each_value" ilk="function" signature="each_value()" />
        <scope name="empty?" ilk="function" signature="empty?()" />
        <scope name="fetch" ilk="function" signature="fetch(p1, p2 = v2)" />
        <scope name="has_key?" ilk="function" signature="has_key?(p1)" />
        <scope name="has_value?" ilk="function" signature="has_value?(p1)" />
        <scope name="include?" ilk="function" signature="include?(p1)" />
        <scope name="index" ilk="function" signature="index(p1)" />
        <scope name="invert" ilk="function" signature="invert()" />
        <scope name="key" ilk="function" signature="key(p1)" />
        <scope name="key?" ilk="function" signature="key?(p1)" />
        <scope name="keys" ilk="function" signature="keys()" />
        <scope name="length" ilk="function" signature="length()" />
        <scope name="member?" ilk="function" signature="member?(p1)" />
        <scope name="reject" ilk="function" signature="reject()" />
        <scope name="reject!" ilk="function" signature="reject!()" />
        <scope name="replace" ilk="function" signature="replace(p1)" />
        <scope name="select" ilk="function" signature="select()" />
        <scope name="shift" ilk="function" signature="shift()" />
        <scope name="size" ilk="function" signature="size()" />
        <scope name="store" ilk="function" signature="store(p1, p2)" />
        <scope name="to_a" ilk="function" signature="to_a()" />
        <scope name="to_hash" ilk="function" signature="to_hash()" />
        <scope name="update" ilk="function" signature="update(p1)" />
        <scope name="value?" ilk="function" signature="value?(p1)" />
        <scope name="values" ilk="function" signature="values()" />
        <scope name="values_at" ilk="function" signature="values_at(*args)" />
      </scope>
    </scope>
    <scope name="securerandom" ilk="blob" lang="Ruby">
      <scope name="SecureRandom" ilk="namespace">
        <scope name="base64" ilk="function" signature="base64(n=nil)" attributes="__classmethod__" doc="SecureRandom.base64 generates a random base64 string. &#xA; The argument _n_ specifies the length of the random length. The length of the result string is about 4/3 of _n_. &#xA; If _n_ is not specified, 16 is assumed. It may be larger in future. &#xA; The result may contain A-Z, a-z, 0-9, &quot;+&quot;, &quot;/&quot; and &quot;=&quot;. &#xA; p SecureRandom.base64 =&gt; &quot;/2BuBuLf3+WfSKyQbRcc/A==&quot;&#xA;p SecureRandom.base64 =&gt; &quot;6BbW0pxO0YENxn38HMUbcQ==&quot;&#xA; If secure random number generator is not available, NotImplementedError is raised. &#xA; See RFC 3548 for the definition of base64." />
        <scope name="hex" ilk="function" signature="hex(n=nil)" attributes="__classmethod__" doc="SecureRandom.hex generates a random hex string. &#xA; The argument _n_ specifies the length of the random length. The length of the result string is twice of _n_. &#xA; If _n_ is not specified, 16 is assumed. It may be larger in future. &#xA; The result may contain 0-9 and a-f. &#xA; p SecureRandom.hex =&gt; &quot;eb693ec8252cd630102fd0d0fb7c3485&quot;&#xA;p SecureRandom.hex =&gt; &quot;91dc3bfb4de5b11d029d376634589b61&quot;&#xA; If secure random number generator is not available, NotImplementedError is raised." />
        <scope name="random_bytes" ilk="function" signature="random_bytes(n=nil)" attributes="__classmethod__" doc="SecureRandom.random_bytes generates a random binary string. &#xA; The argument _n_ specifies the length of the result string. &#xA; If _n_ is not specified, 16 is assumed. It may be larger in future. &#xA; The result may contain any byte: &quot;\x00&quot; - &quot;\xff&quot;. &#xA; p SecureRandom.random_bytes =&gt; &quot;\xD8\\\xE0\xF4\r\xB2\xFC*WM\xFF\x83\x18\xF45\xB6&quot;&#xA;p SecureRandom.random_bytes =&gt; &quot;m\xDC\xFC/\a\x00Uf\xB2\xB2P\xBD\xFF6S\x97&quot;&#xA; If secure random number generator is not available, NotImplementedError is raised." />
        <scope name="random_number" ilk="function" signature="random_number(n=0)" attributes="__classmethod__" doc="SecureRandom.random_number generates a random number. &#xA; If a positive integer is given as _n_, SecureRandom.random_number returns an integer: 0 &lt;= SecureRandom.random_number(n) &lt; n. &#xA; p SecureRandom.random_number(100) =&gt; 15&#xA;p SecureRandom.random_number(100) =&gt; 88&#xA; If 0 is given or an argument is not given, SecureRandom.random_number returns a float: 0.0 &lt;= SecureRandom.random_number() &lt; 1.0. &#xA; p SecureRandom.random_number =&gt; 0.596506046187744&#xA;p SecureRandom.random_number =&gt; 0.350621695741409" />
        <scope name="urlsafe_base64" ilk="function" signature="urlsafe_base64(n=nil, padding=false)" attributes="__classmethod__" doc="SecureRandom.urlsafe_base64 generates a random URL-safe base64 string. &#xA; The argument _n_ specifies the length of the random length. The length of the result string is about 4/3 of _n_. &#xA; If _n_ is not specified, 16 is assumed. It may be larger in future. &#xA; The boolean argument _padding_ specifies the padding. If it is false or nil, padding is not generated. Otherwise padding is generated. By default, padding is not generated because &quot;=&quot; may be used as a URL delimiter. &#xA; The result may contain A-Z, a-z, 0-9, &quot;-&quot; and &quot;_&quot;. &quot;=&quot; is also used if _padding_ is true. &#xA; p SecureRandom.urlsafe_base64 =&gt; &quot;b4GOKm4pOYU_-BOXcrUGDg&quot;&#xA;p SecureRandom.urlsafe_base64 =&gt; &quot;UZLdOkzop70Ddx-IJR0ABg&quot;&#xA;&#xA;p SecureRandom.urlsafe_base64(nil, true) =&gt; &quot;i0XQ-7gglIsHGV2_BNPrdQ==&quot;&#xA;p SecureRandom.urlsafe_base64(nil, true) =&gt; &quot;-M8rLhr7JEpJlqFGUMmOxg==&quot;&#xA; If secure random number generator is not available, NotImplementedError is raised. &#xA; See RFC 3548 for the definition of URL-safe base64." />
        <scope name="uuid" ilk="function" signature="uuid()" attributes="__classmethod__" doc="SecureRandom.uuid generates a v4 random UUID (Universally Unique IDentifier). &#xA; p SecureRandom.uuid =&gt; &quot;2d931510-d99f-494a-8c67-87feb05e1594&quot;&#xA;p SecureRandom.uuid =&gt; &quot;bad85eb9-0713-4da7-8d36-07a8e4b00eab&quot;&#xA;p SecureRandom.uuid =&gt; &quot;62936e70-1815-439b-bf89-8492855a7e6b&quot;&#xA; The version 4 UUID is purely random (except the version). It doesn&apos;t contain meaningful information such as MAC address, time, etc. &#xA; See RFC 4122 for details of UUID." />
      </scope>
    </scope>
    <scope name="set" ilk="blob" lang="Ruby">
      <scope name="Set" ilk="class" classrefs="Object">
        <import symbol="Enumerable" />
        <scope name="new" ilk="function" signature="new(enum = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new set containing the elements of the given enumerable object. &#xA; If a block is given, the elements of enum are preprocessed by the given block." />
        <scope name="add" ilk="function" signature="add(o)" doc="Adds the given object to the set and returns self.  Use +merge+ to add many elements at once." />
        <scope name="add?" ilk="function" signature="add?(o)" doc="Adds the given object to the set and returns self.  If the object is already in the set, returns nil." />
        <scope name="classify" ilk="function" signature="classify()" doc="Classifies the set by the return value of the given block and returns a hash of {value =&gt; set of elements} pairs.  The block is called once for each element of the set, passing the element as parameter. &#xA; e.g.: &#xA; require &apos;set&apos;&#xA;files = Set.new(Dir.glob(&quot;*.rb&quot;))&#xA;hash = files.classify { |f| File.mtime(f).year }&#xA;p hash    # =&gt; {2000=&gt;#&lt;Set: {&quot;a.rb&quot;, &quot;b.rb&quot;}&gt;,&#xA;          #     2001=&gt;#&lt;Set: {&quot;c.rb&quot;, &quot;d.rb&quot;, &quot;e.rb&quot;}&gt;,&#xA;          #     2002=&gt;#&lt;Set: {&quot;f.rb&quot;}&gt;}" />
        <scope name="clear" ilk="function" signature="clear()" doc="Removes all elements and returns self." />
        <scope name="collect!" ilk="function" signature="collect!()" doc="Replaces the elements with ones returned by collect()." />
        <scope name="delete" ilk="function" signature="delete(o)" doc="Deletes the given object from the set and returns self.  Use +subtract+ to delete many items at once." />
        <scope name="delete?" ilk="function" signature="delete?(o)" doc="Deletes the given object from the set and returns self.  If the object is not in the set, returns nil." />
        <scope name="delete_if" ilk="function" signature="delete_if()" doc="Deletes every element of the set for which block evaluates to true, and returns self." />
        <scope name="difference" ilk="function" signature="difference(enum)" />
        <scope name="divide" ilk="function" signature="divide(&amp;func)" doc="Divides the set into a set of subsets according to the commonality defined by the given block. &#xA; If the arity of the block is 2, elements o1 and o2 are in common if block.call(o1, o2) is true.  Otherwise, elements o1 and o2 are in common if block.call(o1) == block.call(o2). &#xA; e.g.: &#xA; require &apos;set&apos;&#xA;numbers = Set[1, 3, 4, 6, 9, 10, 11]&#xA;set = numbers.divide { |i,j| (i - j).abs == 1 }&#xA;p set     # =&gt; #&lt;Set: {#&lt;Set: {1}&gt;,&#xA;          #            #&lt;Set: {11, 9, 10}&gt;,&#xA;          #            #&lt;Set: {3, 4}&gt;,&#xA;          #            #&lt;Set: {6}&gt;}&gt;" />
        <scope name="each" ilk="function" signature="each()" doc="Calls the given block once for each element in the set, passing the element as parameter.  Returns an enumerator if no block is given." />
        <scope name="empty?" ilk="function" signature="empty?()" doc="Returns true if the set contains no elements." />
        <scope name="flatten" ilk="function" signature="flatten()" doc="Returns a new set that is a copy of the set, flattening each containing set recursively." />
        <scope name="flatten!" ilk="function" signature="flatten!()" doc="Equivalent to Set#flatten, but replaces the receiver with the result in place.  Returns nil if no modifications were made." />
        <scope name="include?" ilk="function" signature="include?(o)" doc="Returns true if the set contains the given object." />
        <scope name="initialize_copy" ilk="function" signature="initialize_copy(orig)" doc="Copy internal hash." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string containing a human-readable representation of the set. (&quot;#&lt;Set: {element1, element2, ...}&gt;&quot;)" />
        <scope name="intersection" ilk="function" signature="intersection(enum)" />
        <scope name="keep_if" ilk="function" signature="keep_if()" doc="Deletes every element of the set for which block evaluates to false, and returns self." />
        <scope name="length" ilk="function" signature="length()" />
        <scope name="map!" ilk="function" signature="map!()" />
        <scope name="member?" ilk="function" signature="member?(o)" />
        <scope name="merge" ilk="function" signature="merge(enum)" doc="Merges the elements of the given enumerable object to the set and returns self." />
        <scope name="proper_subset?" ilk="function" signature="proper_subset?(set)" doc="Returns true if the set is a proper subset of the given set." />
        <scope name="proper_superset?" ilk="function" signature="proper_superset?(set)" doc="Returns true if the set is a proper superset of the given set." />
        <scope name="reject!" ilk="function" signature="reject!()" doc="Equivalent to Set#delete_if, but returns nil if no changes were made." />
        <scope name="replace" ilk="function" signature="replace(enum)" doc="Replaces the contents of the set with the contents of the given enumerable object and returns self." />
        <scope name="select!" ilk="function" signature="select!()" doc="Equivalent to Set#keep_if, but returns nil if no changes were made." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the number of elements." />
        <scope name="subset?" ilk="function" signature="subset?(set)" doc="Returns true if the set is a subset of the given set." />
        <scope name="subtract" ilk="function" signature="subtract(enum)" doc="Deletes every element that appears in the given enumerable object and returns self." />
        <scope name="superset?" ilk="function" signature="superset?(set)" doc="Returns true if the set is a superset of the given set." />
        <scope name="to_a" ilk="function" signature="to_a()" doc="Converts the set to an array.  The order of elements is uncertain." />
        <scope name="union" ilk="function" signature="union(enum)" />
      </scope>
      <scope name="SortedSet" ilk="class" classrefs="Set">
      </scope>
    </scope>
    <scope name="shell/builtin-command" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="AppendFile" ilk="class" classrefs="Shell::AppendIO">
          <scope name="new" ilk="function" signature="new(sh, to_filename, filter)" attributes="__classmethod__ __ctor__" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
        </scope>
        <scope name="AppendIO" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, io, filter)" attributes="__classmethod__ __ctor__" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
        </scope>
        <scope name="BuiltInCommand" ilk="class" classrefs="Shell::Filter">
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="wait?" ilk="function" signature="wait?()" />
        </scope>
        <scope name="Cat" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *filenames)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Concat" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *jobs)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Echo" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *strings)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Glob" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, pattern)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Tee" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, filename)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
        <scope name="Void" ilk="class" classrefs="Shell::BuiltInCommand">
          <scope name="new" ilk="function" signature="new(sh, *opts)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/command-processor" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="CommandProcessor" ilk="class" classrefs="Object">
          <scope name="add_delegate_command_to_shell" ilk="function" signature="add_delegate_command_to_shell(id)" attributes="__classmethod__" />
          <scope name="alias_command" ilk="function" signature="alias_command(ali, command, *opts, &amp;block)" attributes="__classmethod__" />
          <scope name="alias_map" ilk="function" signature="alias_map()" attributes="__classmethod__" />
          <scope name="def_builtin_commands" ilk="function" signature="def_builtin_commands(delegation_class, command_specs)" attributes="__classmethod__" doc="CommandProcessor.def_builtin_commands(delegation_class, command_specs)   delegation_class: Class or Module&#xA;  command_specs: [[command_name, [argument,...]],...]&#xA;     command_name: String&#xA;     arguments:    String&#xA;        FILENAME?? -&gt; expand_path(filename??)&#xA;        *FILENAME?? -&gt; filename??.collect{|f|expand_path(f)}.join(&quot;, &quot;)&#xA;define command_name(argument,...) as&#xA;    delegation_class.command_name(argument,...)" />
          <scope name="def_system_command" ilk="function" signature="def_system_command(command, path = command)" attributes="__classmethod__" doc="CommandProcessor.def_system_command(command, path)   command:  String&#xA;  path:     String&#xA;define &apos;command()&apos; method as method." />
          <scope name="initialize" ilk="function" signature="initialize()" attributes="__classmethod__" />
          <scope name="install_builtin_commands" ilk="function" signature="install_builtin_commands()" attributes="__classmethod__" doc="define default builtin commands" />
          <scope name="install_system_commands" ilk="function" signature="install_system_commands(pre = &quot;sys_&quot;)" attributes="__classmethod__" doc="CommandProcessor.install_system_commands(pre) pre: String - command name prefix&#xA; defines every command which belongs in default_system_path via CommandProcessor.command().  It doesn&apos;t define already defined methods twice.  By default, &quot;pre_&quot; is prefixes to each method name.  Characters that may not be used in a method name are all converted to &apos;_&apos;.  Definition errors are just ignored." />
          <scope name="method_added" ilk="function" signature="method_added(id)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(shell)" attributes="__classmethod__ __ctor__" />
          <scope name="run_config" ilk="function" signature="run_config()" attributes="__classmethod__" doc="include run file." />
          <scope name="unalias_command" ilk="function" signature="unalias_command(ali)" attributes="__classmethod__" />
          <scope name="undef_system_command" ilk="function" signature="undef_system_command(command)" attributes="__classmethod__" />
          <scope name="append" ilk="function" signature="append(to, filter)" />
          <scope name="cat" ilk="function" signature="cat(*filenames)" />
          <scope name="check_point" ilk="function" signature="check_point()" doc="ProcessCommand#transact" />
          <scope name="concat" ilk="function" signature="concat(*jobs)" />
          <scope name="echo" ilk="function" signature="echo(*strings)" />
          <scope name="expand_path" ilk="function" signature="expand_path(path)" doc="CommandProcessor#expand_path(path)   path:   String&#xA;  return: String&#xA;returns the absolute path for &lt;path&gt;" />
          <scope name="find_system_command" ilk="function" signature="find_system_command(command)" doc="private functions" />
          <scope name="finish_all_jobs" ilk="function" signature="finish_all_jobs()" />
          <scope name="foreach" ilk="function" signature="foreach(path = nil, *rs)" doc="File related commands Shell#foreach Shell#open Shell#unlink Shell#test &#xA; - &#xA; CommandProcessor#foreach(path, rs)   path: String&#xA;  rs:   String - record separator&#xA;  iterator&#xA;Same as:&#xA;  File#foreach (when path is file)&#xA;  Dir#foreach (when path is directory)&#xA;path is relative to pwd" />
          <scope name="glob" ilk="function" signature="glob(pattern)" doc="def sort(*filenames) Sort.new(self, *filenames)&#xA; end" />
          <scope name="mkdir" ilk="function" signature="mkdir(*path)" doc="Dir related methods &#xA; Shell#mkdir Shell#rmdir" />
          <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" doc="%pwd, %cwd -&gt; @pwd" />
          <scope name="open" ilk="function" signature="open(path, mode = nil, perm = 0666, &amp;b)" doc="CommandProcessor#open(path, mode)   path:   String&#xA;  mode:   String&#xA;  return: File or Dir&#xA;Same as:&#xA;  File#open (when path is file)&#xA;  Dir#open  (when path is directory)&#xA;mode has an effect only when path is a file" />
          <scope name="out" ilk="function" signature="out(dev = STDOUT, &amp;block)" doc="internal commands" />
          <scope name="rehash" ilk="function" signature="rehash()" doc="ProcessCommand#rehash clear command hash table." />
          <scope name="rmdir" ilk="function" signature="rmdir(*path)" doc="CommandProcessor#rmdir(*path)   path: String&#xA;same as Dir.rmdir()" />
          <scope name="system" ilk="function" signature="system(command, *opts)" doc="CommandProcessor#system(command, *opts)   command: String&#xA;  opts:    String&#xA;  return:  SystemCommand&#xA;Same as system() function&#xA;example:&#xA;  print sh.system(&quot;ls&quot;, &quot;-l&quot;)&#xA;  sh.system(&quot;ls&quot;, &quot;-l&quot;) | sh.head &gt; STDOUT" />
          <scope name="tee" ilk="function" signature="tee(file)" />
          <scope name="test" ilk="function" signature="test(command, file1, file2=nil)" />
          <scope name="top_level_test" ilk="function" signature="top_level_test(command, file1, file2=nil)" doc="CommandProcessor#test(command, file1, file2) CommandProcessor#[command, file1, file2]   command: char or String or Symbol&#xA;  file1:   String&#xA;  file2:   String(optional)&#xA;  return: Boolean&#xA;same as:&#xA;  test()           (when command is char or length 1 string or symbol)&#xA;  FileTest.command (others)&#xA;example:&#xA;  sh[?e, &quot;foo&quot;]&#xA;  sh[:e, &quot;foo&quot;]&#xA;  sh[&quot;e&quot;, &quot;foo&quot;]&#xA;  sh[:exists?, &quot;foo&quot;]&#xA;  sh[&quot;exists?&quot;, &quot;foo&quot;]" />
          <scope name="transact" ilk="function" signature="transact(&amp;block)" />
          <scope name="unlink" ilk="function" signature="unlink(path)" doc="CommandProcessor#unlink(path) same as:&#xA;  Dir#unlink  (when path is directory)&#xA;  File#unlink (when path is file)" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/error" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="Error" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="shell/filter" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="class" classrefs="Object">
        <import symbol="Error" />
        <scope name="alias_command" ilk="function" signature="alias_command(ali, command, *opts, &amp;block)" attributes="__classmethod__" />
        <scope name="cd" ilk="function" signature="cd(path)" attributes="__classmethod__" />
        <scope name="debug=" ilk="function" signature="debug=(val)" attributes="__classmethod__" />
        <scope name="def_system_command" ilk="function" signature="def_system_command(command, path = command)" attributes="__classmethod__" doc="command definitions" />
        <scope name="default_record_separator" ilk="function" signature="default_record_separator()" attributes="__classmethod__" />
        <scope name="default_record_separator=" ilk="function" signature="default_record_separator=(rs)" attributes="__classmethod__" />
        <scope name="default_system_path" ilk="function" signature="default_system_path()" attributes="__classmethod__" />
        <scope name="default_system_path=" ilk="function" signature="default_system_path=(path)" attributes="__classmethod__" />
        <scope name="install_system_commands" ilk="function" signature="install_system_commands(pre = &quot;sys_&quot;)" attributes="__classmethod__" />
        <scope name="new" ilk="function" signature="new(pwd = Dir.pwd, umask = nil)" attributes="__classmethod__ __ctor__" />
        <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" attributes="__classmethod__" />
        <scope name="unalias_command" ilk="function" signature="unalias_command(ali)" attributes="__classmethod__" />
        <scope name="undef_system_command" ilk="function" signature="undef_system_command(command)" attributes="__classmethod__" />
        <scope name="cd" ilk="function" signature="cd(path = nil, verbose = @verbose)" />
        <scope name="chdir" ilk="function" signature="chdir(path = nil, verbose = @verbose)" doc="If called as iterator, it restores the current directory when the block ends." />
        <scope name="debug=" ilk="function" signature="debug=(val)" />
        <scope name="expand_path" ilk="function" signature="expand_path(path)" />
        <scope name="inspect" ilk="function" signature="inspect()" />
        <scope name="jobs" ilk="function" signature="jobs()" doc="process management" />
        <scope name="kill" ilk="function" signature="kill(sig, command)" />
        <scope name="popd" ilk="function" signature="popd()" />
        <scope name="popdir" ilk="function" signature="popdir()" />
        <scope name="pushd" ilk="function" signature="pushd(path = nil, verbose = @verbose)" />
        <scope name="pushdir" ilk="function" signature="pushdir(path = nil, verbose = @verbose)" />
        <scope name="system_path=" ilk="function" signature="system_path=(path)" />
        <scope ilk="function" name="cascade" />
        <scope ilk="function" name="cascade=" />
        <scope ilk="function" name="command_processor" />
        <scope ilk="function" name="cwd" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="debug" />
        <scope ilk="function" name="debug=" />
        <scope ilk="function" name="debug?" />
        <scope ilk="function" name="debug?=" />
        <scope ilk="function" name="debug?" />
        <scope ilk="function" name="debug?=" />
        <scope ilk="function" name="dir" />
        <scope ilk="function" name="dir_stack" />
        <scope ilk="function" name="dirs" />
        <scope ilk="function" name="getwd" />
        <scope ilk="function" name="process_controller" />
        <scope ilk="function" name="pwd" />
        <scope ilk="function" name="record_separator" />
        <scope ilk="function" name="record_separator=" />
        <scope ilk="function" name="system_path" />
        <scope ilk="function" name="umask" />
        <scope ilk="function" name="umask=" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
        <scope ilk="function" name="verbose?" />
        <scope ilk="function" name="verbose?=" />
        <scope ilk="function" name="verbose?" />
        <scope ilk="function" name="verbose?=" />
        <scope name="Filter" ilk="class" classrefs="Object">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(sh)" attributes="__classmethod__ __ctor__" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
          <scope name="input=" ilk="function" signature="input=(filter)" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="input" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/process-controller" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="ProcessController" ilk="class" classrefs="Object">
          <scope name="activate" ilk="function" signature="activate(pc)" attributes="__classmethod__" />
          <scope name="active_process_controllers" ilk="function" signature="active_process_controllers()" attributes="__classmethod__" />
          <scope name="block_output_synchronize" ilk="function" signature="block_output_synchronize(&amp;b)" attributes="__classmethod__" />
          <scope name="each_active_object" ilk="function" signature="each_active_object()" attributes="__classmethod__" />
          <scope name="inactivate" ilk="function" signature="inactivate(pc)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(shell)" attributes="__classmethod__ __ctor__" />
          <scope name="wait_to_finish_all_process_controllers" ilk="function" signature="wait_to_finish_all_process_controllers()" attributes="__classmethod__" />
          <scope name="active_job?" ilk="function" signature="active_job?(job)" />
          <scope name="active_jobs" ilk="function" signature="active_jobs()" />
          <scope name="active_jobs_exist?" ilk="function" signature="active_jobs_exist?()" />
          <scope name="add_schedule" ilk="function" signature="add_schedule(command)" doc="schedule a command" />
          <scope name="jobs" ilk="function" signature="jobs()" />
          <scope name="jobs_exist?" ilk="function" signature="jobs_exist?()" />
          <scope name="kill_job" ilk="function" signature="kill_job(sig, command)" doc="kill a job" />
          <scope name="sfork" ilk="function" signature="sfork(command, &amp;block)" doc="simple fork" />
          <scope name="start_job" ilk="function" signature="start_job(command = nil)" doc="start a job" />
          <scope name="terminate_job" ilk="function" signature="terminate_job(command)" doc="terminate a job" />
          <scope name="wait_all_jobs_execution" ilk="function" signature="wait_all_jobs_execution()" doc="wait for all jobs to terminate" />
          <scope name="waiting_job?" ilk="function" signature="waiting_job?(job)" />
          <scope name="waiting_jobs" ilk="function" signature="waiting_jobs()" />
          <scope name="waiting_jobs_exist?" ilk="function" signature="waiting_jobs_exist?()" />
          <scope ilk="function" name="shell" />
          <variable name="USING_AT_EXIT_WHEN_PROCESS_EXIT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="shell/system-command" ilk="blob" lang="Ruby">
      <scope name="Shell" ilk="namespace">
        <scope name="SystemCommand" ilk="class" classrefs="Filter">
          <scope name="new" ilk="function" signature="new(sh, command, *opts)" attributes="__classmethod__ __ctor__" />
          <scope name="active?" ilk="function" signature="active?()" />
          <scope name="each" ilk="function" signature="each(rs = nil)" />
          <scope name="flush" ilk="function" signature="flush()" />
          <scope name="input=" ilk="function" signature="input=(inp)" />
          <scope name="kill" ilk="function" signature="kill(sig)" />
          <scope name="notify" ilk="function" signature="notify(*opts, &amp;block)" doc="ex) if you wish to output:&#xA;   &quot;shell: job(#{@command}:#{@pid}) close pipe-out.&quot;&#xA;then&#xA;   mes: &quot;job(%id) close pipe-out.&quot;&#xA;yorn: Boolean(@shell.debug? or @shell.verbose?)" />
          <scope name="start" ilk="function" signature="start()" />
          <scope name="start_export" ilk="function" signature="start_export()" />
          <scope name="start_import" ilk="function" signature="start_import()" />
          <scope name="super_each" ilk="function" signature="super_each(rs = nil)" />
          <scope name="terminate" ilk="function" signature="terminate()" />
          <scope name="wait?" ilk="function" signature="wait?()" />
          <scope ilk="function" name="command" />
          <scope ilk="function" name="name" />
        </scope>
      </scope>
    </scope>
    <scope name="shellwords" ilk="blob" lang="Ruby">
      <scope name="Shellwords" ilk="namespace">
        <scope name="escape" ilk="function" signature="escape(str)" attributes="__classmethod__" />
        <scope name="join" ilk="function" signature="join(array)" attributes="__classmethod__" />
        <scope name="shellescape" ilk="function" signature="shellescape(str)" attributes="__classmethod__" doc="Escapes a string so that it can be safely used in a Bourne shell command line. &#xA; Note that a resulted string should be used unquoted and is not intended for use in double quotes nor in single quotes. &#xA; open(&quot;| grep #{Shellwords.escape(pattern)} file&quot;) { |pipe|&#xA;  # ...&#xA;}&#xA; String#shellescape is a shorthand for this function. &#xA; open(&quot;| grep #{pattern.shellescape} file&quot;) { |pipe|&#xA;  # ...&#xA;}&#xA; It is caller&apos;s responsibility to encode the string in the right encoding for the shell environment where this string is used. Multibyte characters are treated as multibyte characters, not bytes." />
        <scope name="shelljoin" ilk="function" signature="shelljoin(array)" attributes="__classmethod__" doc="Builds a command line string from an argument list +array+ joining all elements escaped for Bourne shell and separated by a space. &#xA; open(&apos;|&apos; + Shellwords.join([&apos;grep&apos;, pattern, *files])) { |pipe|&#xA;  # ...&#xA;}&#xA; Array#shelljoin is a shorthand for this function. &#xA; open(&apos;|&apos; + [&apos;grep&apos;, pattern, *files].shelljoin) { |pipe|&#xA;  # ...&#xA;}" />
        <scope name="shellsplit" ilk="function" signature="shellsplit(line)" attributes="__classmethod__" doc="Splits a string into an array of tokens in the same way the UNIX Bourne shell does. &#xA; argv = Shellwords.split(&apos;here are &quot;two words&quot;&apos;)&#xA;argv =&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]&#xA; String#shellsplit is a shorthand for this function. &#xA; argv = &apos;here are &quot;two words&quot;&apos;.shellsplit&#xA;argv =&gt; [&quot;here&quot;, &quot;are&quot;, &quot;two words&quot;]" />
        <scope name="shellwords" ilk="function" signature="shellwords(line)" attributes="__classmethod__" />
        <scope name="split" ilk="function" signature="split(line)" attributes="__classmethod__" />
      </scope>
    </scope>
    <scope name="singleton" ilk="blob" lang="Ruby">
      <scope name="Singleton" ilk="namespace">
        <scope name="_load" ilk="function" signature="_load" attributes="__classmethod__" doc="By default calls instance(). Override to retain singleton state." />
        <scope name="_dump" ilk="function" signature="_dump(depth = -1)" doc="By default, do not retain any state when marshalling." />
        <scope name="clone" ilk="function" signature="clone()" doc="Raises a TypeError to prevent cloning." />
        <scope name="dup" ilk="function" signature="dup()" doc="Raises a TypeError to prevent duping." />
      </scope>
    </scope>
    <scope name="socket" ilk="blob" lang="Ruby">
      <scope name="Addrinfo" ilk="class" classrefs="Data">
        <scope name="foreach" ilk="function" signature="foreach(nodename, service, family=nil, socktype=nil, protocol=nil, flags=nil, &amp;block)" attributes="__classmethod__" doc="iterates over the list of Addrinfo objects obtained by Addrinfo.getaddrinfo. &#xA; Addrinfo.foreach(nil, 80) {|x| p x }&#xA;=&gt; #&lt;Addrinfo: 127.0.0.1:80 TCP (:80)&gt;&#xA;#   #&lt;Addrinfo: 127.0.0.1:80 UDP (:80)&gt;&#xA;#   #&lt;Addrinfo: [::1]:80 TCP (:80)&gt;&#xA;#   #&lt;Addrinfo: [::1]:80 UDP (:80)&gt;" />
        <scope name="getaddrinfo" ilk="function" signature="getaddrinfo(p1, p2, p3 = v3, p4 = v4, p5 = v5, p6 = v6)" attributes="__classmethod__" doc="returns a list of addrinfo objects as an array. &#xA; This method converts nodename (hostname) and service (port) to addrinfo. Since the conversion is not unique, the result is a list of addrinfo objects. &#xA; nodename or service can be nil if no conversion intended. &#xA; family, socktype and protocol are hint for preferred protocol. If the result will be used for a socket with SOCK_STREAM, SOCK_STREAM should be specified as socktype. If so, Addrinfo.getaddrinfo returns addrinfo list appropriate for SOCK_STREAM. If they are omitted or nil is given, the result is not restricted. &#xA; Similarly, PF_INET6 as family restricts for IPv6. &#xA; flags should be bitwise OR of Socket::AI_??? constants. &#xA; Note that socktype should be specified whenever application knows the usage of the address. Some platform causes an error when socktype is omitted and servname is specified as an integer because some port numbers, 512 for example, are ambiguous without socktype. &#xA; Addrinfo.getaddrinfo(&quot;www.kame.net&quot;, 80, nil, :STREAM)&#xA;=&gt; [#&lt;Addrinfo: 203.178.141.194:80 TCP (www.kame.net:80)&gt;,&#xA;#    #&lt;Addrinfo: [2001:200:0:8002:203:47ff:fea5:3085]:80 TCP (www.kame.net:80)&gt;]" />
        <scope name="ip" ilk="function" signature="ip(p1)" attributes="__classmethod__" doc="returns an addrinfo object for IP address. &#xA; The port, socktype, protocol of the result is filled by zero. So, it is not appropriate to create a socket. &#xA; Addrinfo.ip(&quot;localhost&quot;) =&gt; #&lt;Addrinfo: 127.0.0.1 (localhost)&gt;" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="returns a new instance of Addrinfo. The instance contains sockaddr, family, socktype, protocol. sockaddr means struct sockaddr which can be used for connect(2), etc. family, socktype and protocol are integers which is used for arguments of socket(2). &#xA; sockaddr is specified as an array or a string. The array should be compatible to the value of IPSocket#addr or UNIXSocket#addr. The string should be struct sockaddr as generated by Socket.sockaddr_in or Socket.unpack_sockaddr_un. &#xA; sockaddr examples: &#xA;&#xA;&#xA;&#xA;&#xA;&#xA;Socket.sockaddr_in(&quot;smtp&quot;, &quot;2001:DB8::1&quot;)&#xA;Socket.sockaddr_in(80, &quot;172.18.22.42&quot;)&#xA;Socket.sockaddr_in(80, &quot;www.ruby-lang.org&quot;)&#xA;Socket.sockaddr_un(&quot;/tmp/sock&quot;) &#xA; In an AF_INET/AF_INET6 sockaddr array, the 4th element, numeric IP address, is used to construct socket address in the Addrinfo instance. If the 3rd element, textual host name, is non-nil, it is also recorded but used only for Addrinfo#inspect. &#xA; family is specified as an integer to specify the protocol family such as Socket::PF_INET. It can be a symbol or a string which is the constant name with or without PF_ prefix such as :INET, :INET6, :UNIX, &quot;PF_INET&quot;, etc. If omitted, PF_UNSPEC is assumed. &#xA; socktype is specified as an integer to specify the socket type such as Socket::SOCK_STREAM. It can be a symbol or a string which is the constant name with or without SOCK_ prefix such as :STREAM, :DGRAM, :RAW, &quot;SOCK_STREAM&quot;, etc. If omitted, 0 is assumed. &#xA; protocol is specified as an integer to specify the protocol such as Socket::IPPROTO_TCP. It must be an integer, unlike family and socktype. If omitted, 0 is assumed. Note that 0 is reasonable value for most protocols, except raw socket." />
        <scope name="tcp" ilk="function" signature="tcp(p1, p2)" attributes="__classmethod__" doc="returns an addrinfo object for TCP address. &#xA; Addrinfo.tcp(&quot;localhost&quot;, &quot;smtp&quot;) =&gt; #&lt;Addrinfo: 127.0.0.1:25 TCP (localhost:smtp)&gt;" />
        <scope name="udp" ilk="function" signature="udp(p1, p2)" attributes="__classmethod__" doc="returns an addrinfo object for UDP address. &#xA; Addrinfo.udp(&quot;localhost&quot;, &quot;daytime&quot;) =&gt; #&lt;Addrinfo: 127.0.0.1:13 UDP (localhost:daytime)&gt;" />
        <scope name="unix" ilk="function" signature="unix(p1, p2 = v2)" attributes="__classmethod__" doc="returns an addrinfo object for UNIX socket address. &#xA; _socktype_ specifies the socket type. If it is omitted, :STREAM is used. &#xA; Addrinfo.unix(&quot;/tmp/sock&quot;)         =&gt; #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;, :DGRAM) =&gt; #&lt;Addrinfo: /tmp/sock SOCK_DGRAM&gt;" />
        <scope name="afamily" ilk="function" signature="afamily()" doc="returns the address family as an integer. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).afamily == Socket::AF_INET =&gt; true" />
        <scope name="bind" ilk="function" signature="bind()" doc="creates a socket bound to self. &#xA; If a block is given, it is called with the socket and the value of the block is returned. The socket is returned otherwise. &#xA; Addrinfo.udp(&quot;0.0.0.0&quot;, 9981).bind {|s|&#xA;  s.local_address.connect {|s| s.send &quot;hello&quot;, 0 }&#xA;  p s.recv(10) =&gt; &quot;hello&quot;&#xA;}" />
        <scope name="canonname" ilk="function" signature="canonname()" doc="returns the canonical name as an string. &#xA; nil is returned if no canonical name. &#xA; The canonical name is set by Addrinfo.getaddrinfo when AI_CANONNAME is specified. &#xA; list = Addrinfo.getaddrinfo(&quot;www.ruby-lang.org&quot;, 80, :INET, :STREAM, nil, Socket::AI_CANONNAME)&#xA;p list[0] =&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP carbon.ruby-lang.org (www.ruby-lang.org:80)&gt;&#xA;p list[0].canonname =&gt; &quot;carbon.ruby-lang.org&quot;" />
        <scope name="connect" ilk="function" signature="connect(&amp;block)" doc="creates a socket connected to the address of self. &#xA; If a block is given, it is called with the socket and the value of the block is returned. The socket is returned otherwise. &#xA; Addrinfo.tcp(&quot;www.ruby-lang.org&quot;, 80).connect {|s|&#xA;  s.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;  puts s.read&#xA;}" />
        <scope name="connect_from" ilk="function" signature="connect_from(*local_addr_args, &amp;block)" doc="creates a socket connected to the address of self. &#xA; If one or more arguments given as _local_addr_args_, it is used as the local address of the socket. _local_addr_args_ is given for family_addrinfo to obtain actual address. &#xA; If no arguments given, the local address of the socket is not bound. &#xA; If a block is given, it is called with the socket and the value of the block is returned. The socket is returned otherwise. &#xA; Addrinfo.tcp(&quot;www.ruby-lang.org&quot;, 80).connect_from(&quot;0.0.0.0&quot;, 4649) {|s|&#xA;  s.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;  puts s.read&#xA;}&#xA;# Addrinfo object can be taken for the argument.&#xA;Addrinfo.tcp(&quot;www.ruby-lang.org&quot;, 80).connect_from(Addrinfo.tcp(&quot;0.0.0.0&quot;, 4649)) {|s|&#xA;  s.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;  puts s.read&#xA;}" />
        <scope name="connect_to" ilk="function" signature="connect_to(*remote_addr_args, &amp;block)" doc="creates a socket connected to _remote_addr_args_ and bound to self. &#xA; If a block is given, it is called with the socket and the value of the block is returned. The socket is returned otherwise. &#xA; Addrinfo.tcp(&quot;0.0.0.0&quot;, 4649).connect_to(&quot;www.ruby-lang.org&quot;, 80) {|s|&#xA;  s.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;  puts s.read&#xA;}" />
        <scope name="family_addrinfo" ilk="function" signature="family_addrinfo(*args)" doc="creates an Addrinfo object from the arguments. &#xA; The arguments are interpreted as similar to self. &#xA; Addrinfo.tcp(&quot;0.0.0.0&quot;, 4649).family_addrinfo(&quot;www.ruby-lang.org&quot;, 80)&#xA;=&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP (www.ruby-lang.org:80)&gt;&#xA;&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).family_addrinfo(&quot;/tmp/sock2&quot;)&#xA;=&gt; #&lt;Addrinfo: /tmp/sock2 SOCK_STREAM&gt;" />
        <scope name="getnameinfo" ilk="function" signature="getnameinfo(p1 = v1)" doc="returns nodename and service as a pair of strings. This converts struct sockaddr in addrinfo to textual representation. &#xA; flags should be bitwise OR of Socket::NI_??? constants. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA;&#xA;Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).getnameinfo(Socket::NI_NUMERICSERV)&#xA;=&gt; [&quot;localhost&quot;, &quot;80&quot;]" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="returns a string which shows addrinfo in human-readable form. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).inspect =&gt; &quot;#&lt;Addrinfo: 127.0.0.1:80 TCP (localhost:80)&gt;&quot;&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).inspect    =&gt; &quot;#&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&quot;" />
        <scope name="inspect_sockaddr" ilk="function" signature="inspect_sockaddr()" doc="returns a string which shows the sockaddr in _addrinfo_ with human-readable form. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).inspect_sockaddr     =&gt; &quot;127.0.0.1:80&quot;&#xA;Addrinfo.tcp(&quot;ip6-localhost&quot;, 80).inspect_sockaddr =&gt; &quot;[::1]:80&quot;&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).inspect_sockaddr        =&gt; &quot;/tmp/sock&quot;" />
        <scope name="ip?" ilk="function" signature="ip?()" doc="returns true if addrinfo is internet (IPv4/IPv6) address. returns false otherwise. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip? =&gt; true&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ip?       =&gt; true&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).ip?    =&gt; false" />
        <scope name="ip_address" ilk="function" signature="ip_address()" doc="Returns the IP address as a string. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_address    =&gt; &quot;127.0.0.1&quot;&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ip_address          =&gt; &quot;::1&quot;" />
        <scope name="ip_port" ilk="function" signature="ip_port()" doc="Returns the port number as an integer. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_port    =&gt; 80&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ip_port          =&gt; 80" />
        <scope name="ip_unpack" ilk="function" signature="ip_unpack()" doc="Returns the IP address and port number as 2-element array. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ip_unpack    =&gt; [&quot;127.0.0.1&quot;, 80]&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ip_unpack          =&gt; [&quot;::1&quot;, 80]" />
        <scope name="ipv4?" ilk="function" signature="ipv4?()" doc="returns true if addrinfo is IPv4 address. returns false otherwise. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv4? =&gt; true&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ipv4?       =&gt; false&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).ipv4?    =&gt; false" />
        <scope name="ipv4_loopback?" ilk="function" signature="ipv4_loopback?()" doc="Returns true for IPv4 loopback address (127.0.0.0/8). It returns false otherwise." />
        <scope name="ipv4_multicast?" ilk="function" signature="ipv4_multicast?()" doc="Returns true for IPv4 multicast address (224.0.0.0/4). It returns false otherwise." />
        <scope name="ipv4_private?" ilk="function" signature="ipv4_private?()" doc="Returns true for IPv4 private address (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16). It returns false otherwise." />
        <scope name="ipv6?" ilk="function" signature="ipv6?()" doc="returns true if addrinfo is IPv6 address. returns false otherwise. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).ipv6? =&gt; false&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).ipv6?       =&gt; true&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6?    =&gt; false" />
        <scope name="ipv6_linklocal?" ilk="function" signature="ipv6_linklocal?()" doc="Returns true for IPv6 link local address (ff80::/10). It returns false otherwise." />
        <scope name="ipv6_loopback?" ilk="function" signature="ipv6_loopback?()" doc="Returns true for IPv6 loopback address (::1). It returns false otherwise." />
        <scope name="ipv6_mc_global?" ilk="function" signature="ipv6_mc_global?()" doc="Returns true for IPv6 multicast global scope address. It returns false otherwise." />
        <scope name="ipv6_mc_linklocal?" ilk="function" signature="ipv6_mc_linklocal?()" doc="Returns true for IPv6 multicast link-local scope address. It returns false otherwise." />
        <scope name="ipv6_mc_nodelocal?" ilk="function" signature="ipv6_mc_nodelocal?()" doc="Returns true for IPv6 multicast node-local scope address. It returns false otherwise." />
        <scope name="ipv6_mc_orglocal?" ilk="function" signature="ipv6_mc_orglocal?()" doc="Returns true for IPv6 multicast organization-local scope address. It returns false otherwise." />
        <scope name="ipv6_mc_sitelocal?" ilk="function" signature="ipv6_mc_sitelocal?()" doc="Returns true for IPv6 multicast site-local scope address. It returns false otherwise." />
        <scope name="ipv6_multicast?" ilk="function" signature="ipv6_multicast?()" doc="Returns true for IPv6 multicast address (ff00::/8). It returns false otherwise." />
        <scope name="ipv6_sitelocal?" ilk="function" signature="ipv6_sitelocal?()" doc="Returns true for IPv6 site local address (ffc0::/10). It returns false otherwise." />
        <scope name="ipv6_to_ipv4" ilk="function" signature="ipv6_to_ipv4()" doc="Returns IPv4 address of IPv4 mapped/compatible IPv6 address. It returns nil if +self+ is not IPv4 mapped/compatible IPv6 address. &#xA; Addrinfo.ip(&quot;::192.0.2.3&quot;).ipv6_to_ipv4      =&gt; #&lt;Addrinfo: 192.0.2.3&gt;&#xA;Addrinfo.ip(&quot;::ffff:192.0.2.3&quot;).ipv6_to_ipv4 =&gt; #&lt;Addrinfo: 192.0.2.3&gt;&#xA;Addrinfo.ip(&quot;::1&quot;).ipv6_to_ipv4              =&gt; nil&#xA;Addrinfo.ip(&quot;192.0.2.3&quot;).ipv6_to_ipv4        =&gt; nil&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).ipv6_to_ipv4      =&gt; nil" />
        <scope name="ipv6_unspecified?" ilk="function" signature="ipv6_unspecified?()" doc="Returns true for IPv6 unspecified address (::). It returns false otherwise." />
        <scope name="ipv6_v4compat?" ilk="function" signature="ipv6_v4compat?()" doc="Returns true for IPv4-compatible IPv6 address (::/80). It returns false otherwise." />
        <scope name="ipv6_v4mapped?" ilk="function" signature="ipv6_v4mapped?()" doc="Returns true for IPv4-mapped IPv6 address (::ffff:0:0/80). It returns false otherwise." />
        <scope name="listen" ilk="function" signature="listen(backlog=5)" doc="creates a listening socket bound to self." />
        <scope name="pfamily" ilk="function" signature="pfamily()" doc="returns the protocol family as an integer. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).pfamily == Socket::PF_INET =&gt; true" />
        <scope name="protocol" ilk="function" signature="protocol()" doc="returns the socket type as an integer. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).protocol == Socket::IPPROTO_TCP =&gt; true" />
        <scope name="socktype" ilk="function" signature="socktype()" doc="returns the socket type as an integer. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).socktype == Socket::SOCK_STREAM =&gt; true" />
        <scope name="to_s" ilk="function" signature="to_s()" doc="returns the socket address as packed struct sockaddr string. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr&#xA;=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;" />
        <scope name="to_sockaddr" ilk="function" signature="to_sockaddr()" doc="returns the socket address as packed struct sockaddr string. &#xA; Addrinfo.tcp(&quot;localhost&quot;, 80).to_sockaddr&#xA;=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;" />
        <scope name="unix?" ilk="function" signature="unix?()" doc="returns true if addrinfo is UNIX address. returns false otherwise. &#xA; Addrinfo.tcp(&quot;127.0.0.1&quot;, 80).unix? =&gt; false&#xA;Addrinfo.tcp(&quot;::1&quot;, 80).unix?       =&gt; false&#xA;Addrinfo.unix(&quot;/tmp/sock&quot;).unix?    =&gt; true" />
        <scope name="unix_path" ilk="function" signature="unix_path()" doc="Returns the socket path as a string. &#xA; Addrinfo.unix(&quot;/tmp/sock&quot;).unix_path       =&gt; &quot;/tmp/sock&quot;" />
      </scope>
      <scope name="BasicSocket" ilk="class" classrefs="IO">
        <scope name="do_not_reverse_lookup" ilk="function" signature="do_not_reverse_lookup()" attributes="__classmethod__" doc="Gets the global do_not_reverse_lookup flag. &#xA; BasicSocket.do_not_reverse_lookup  =&gt; false" />
        <scope name="do_not_reverse_lookup=" ilk="function" signature="do_not_reverse_lookup=(p1)" attributes="__classmethod__" doc="Sets the global do_not_reverse_lookup flag. &#xA; The flag is used for initial value of do_not_reverse_lookup for each socket. &#xA; s1 = TCPSocket.new(&quot;localhost&quot;, 80)&#xA;p s1.do_not_reverse_lookup                 =&gt; true&#xA;BasicSocket.do_not_reverse_lookup = false&#xA;s2 = TCPSocket.new(&quot;localhost&quot;, 80)&#xA;p s2.do_not_reverse_lookup                 =&gt; false&#xA;p s1.do_not_reverse_lookup                 =&gt; true" />
        <scope name="for_fd" ilk="function" signature="for_fd(p1)" attributes="__classmethod__" doc="Returns a socket object which contains the file descriptor, _fd_. &#xA; # If invoked by inetd, STDIN/STDOUT/STDERR is a socket.&#xA;STDIN_SOCK = Socket.for_fd(STDIN.fileno)&#xA;p STDIN_SOCK.remote_address" />
        <scope name="close_read" ilk="function" signature="close_read()" doc="Disallows further read using shutdown system call. &#xA; s1, s2 = UNIXSocket.pair&#xA;s1.close_read&#xA;s2.puts =&gt; Broken pipe (Errno::EPIPE)" />
        <scope name="close_write" ilk="function" signature="close_write()" doc="Disallows further write using shutdown system call. &#xA; UNIXSocket.pair {|s1, s2|&#xA;  s1.print &quot;ping&quot;&#xA;  s1.close_write&#xA;  p s2.read        =&gt; &quot;ping&quot;&#xA;  s2.print &quot;pong&quot;&#xA;  s2.close&#xA;  p s1.read        =&gt; &quot;pong&quot;&#xA;}" />
        <scope name="connect_address" ilk="function" signature="connect_address()" doc="Returns an address of the socket suitable for connect in the local machine. &#xA; This method returns _self_.local_address, except following condition. &#xA; IPv4 unspecified address (0.0.0.0) is replaced by IPv4 loopback address (127.0.0.1).&#xA;IPv6 unspecified address (::) is replaced by IPv6 loopback address (::1). &#xA; If the local address is not suitable for connect, SocketError is raised. IPv4 and IPv6 address which port is 0 is not suitable for connect. Unix domain socket which has no path is not suitable for connect. &#xA; Addrinfo.tcp(&quot;0.0.0.0&quot;, 0).listen {|serv|&#xA;  p serv.connect_address =&gt; #&lt;Addrinfo: 127.0.0.1:53660 TCP&gt;&#xA;  serv.connect_address.connect {|c|&#xA;    s, _ = serv.accept&#xA;    p [c, s] =&gt; [#&lt;Socket:fd 4&gt;, #&lt;Socket:fd 6&gt;]&#xA;  }&#xA;}" />
        <scope name="do_not_reverse_lookup" ilk="function" signature="do_not_reverse_lookup()" doc="Gets the do_not_reverse_lookup flag of _basicsocket_. &#xA; TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|sock|&#xA;  p sock.do_not_reverse_lookup      =&gt; false&#xA;  p sock.peeraddr                   =&gt; [&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;]&#xA;  sock.do_not_reverse_lookup = true&#xA;  p sock.peeraddr                   =&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]&#xA;}" />
        <scope name="do_not_reverse_lookup=" ilk="function" signature="do_not_reverse_lookup=(p1)" doc="Sets the do_not_reverse_lookup flag of _basicsocket_. &#xA; BasicSocket.do_not_reverse_lookup = false&#xA;p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup =&gt; false&#xA;BasicSocket.do_not_reverse_lookup = true&#xA;p TCPSocket.new(&quot;127.0.0.1&quot;, 80).do_not_reverse_lookup =&gt; true" />
        <scope name="getpeereid" ilk="function" signature="getpeereid()" doc="Returns the user and group on the peer of the UNIX socket. The result is a two element array which contains the effective uid and the effective gid. &#xA; Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|s|&#xA;  begin&#xA;    euid, egid = s.getpeereid&#xA;&#xA;    # Check the connected client is myself or not.&#xA;    next if euid != Process.uid&#xA;&#xA;    # do something about my resource.&#xA;&#xA;  ensure&#xA;    s.close&#xA;  end&#xA;}" />
        <scope name="getpeername" ilk="function" signature="getpeername()" doc="Returns the remote address of the socket as a sockaddr string. &#xA; TCPServer.open(&quot;127.0.0.1&quot;, 1440) {|serv|&#xA;  c = TCPSocket.new(&quot;127.0.0.1&quot;, 1440)&#xA;  s = serv.accept&#xA;  p s.getpeername =&gt; &quot;\x02\x00\x82u\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;}&#xA; If Addrinfo object is preferred over the binary string, use BasicSocket#remote_address." />
        <scope name="getsockname" ilk="function" signature="getsockname()" doc="Returns the local address of the socket as a sockaddr string. &#xA; TCPServer.open(&quot;127.0.0.1&quot;, 15120) {|serv|&#xA;  p serv.getsockname =&gt; &quot;\x02\x00;\x10\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;}&#xA; If Addrinfo object is preferred over the binary string, use BasicSocket#local_address." />
        <scope name="getsockopt" ilk="function" signature="getsockopt(p1, p2)" doc="Gets a socket option. These are protocol and system specific, see your local system documentation for details. The option is returned as a Socket::Option object. &#xA; Parameters +level+ is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.&#xA;+optname+ is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted. &#xA; Examples &#xA; Some socket options are integers with boolean values, in this case #getsockopt could be called like this: &#xA; reuseaddr = sock.getsockopt(:SOCKET, :REUSEADDR).bool&#xA;optval = sock.getsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR)&#xA;optval = optval.unpack &quot;i&quot;&#xA;reuseaddr = optval[0] == 0 ? false : true&#xA; Some socket options are integers with numeric values, in this case #getsockopt could be called like this: &#xA; ipttl = sock.getsockopt(:IP, :TTL).int&#xA;optval = sock.getsockopt(Socket::IPPROTO_IP, Socket::IP_TTL)&#xA;ipttl = optval.unpack(&quot;i&quot;)[0]" />
        <scope name="local_address" ilk="function" signature="local_address()" doc="Returns an Addrinfo object for local address obtained by getsockname. &#xA; Note that addrinfo.protocol is filled by 0. &#xA; TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|&#xA;  p s.local_address =&gt; #&lt;Addrinfo: 192.168.0.129:36873 TCP&gt;&#xA;}&#xA;&#xA;TCPServer.open(&quot;127.0.0.1&quot;, 1512) {|serv|&#xA;  p serv.local_address =&gt; #&lt;Addrinfo: 127.0.0.1:1512 TCP&gt;&#xA;}" />
        <scope name="recv" ilk="function" signature="recv(*args)" doc="Receives a message. &#xA; _maxlen_ is the maximum number of bytes to receive. &#xA; _flags_ should be a bitwise OR of Socket::MSG_* constants. &#xA; UNIXSocket.pair {|s1, s2|&#xA;  s1.puts &quot;Hello World&quot;&#xA;  p s2.recv(4)                     =&gt; &quot;Hell&quot;&#xA;  p s2.recv(4, Socket::MSG_PEEK)   =&gt; &quot;o Wo&quot;&#xA;  p s2.recv(4)                     =&gt; &quot;o Wo&quot;&#xA;  p s2.recv(10)                    =&gt; &quot;rld\n&quot;&#xA;}" />
        <scope name="recv_nonblock" ilk="function" signature="recv_nonblock(*args)" doc="Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. _flags_ is zero or more of the +MSG_+ options. The result, _mesg_, is the data received. &#xA; When recvfrom(2) returns 0, Socket#recv_nonblock returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc. &#xA; Parameters +maxlen+ - the number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example serv = TCPServer.new(&quot;127.0.0.1&quot;, 0)&#xA;af, port, host, addr = serv.addr&#xA;c = TCPSocket.new(addr, port)&#xA;s = serv.accept&#xA;c.send &quot;aaa&quot;, 0&#xA;begin # emulate blocking recv.&#xA;  p s.recv_nonblock(10) =&gt; &quot;aaa&quot;&#xA;rescue IO::WaitReadable&#xA;  IO.select([s])" />
        <scope name="recvmsg" ilk="function" signature="recvmsg(*args)" doc="recvmsg receives a message using recvmsg(2) system call in blocking manner. &#xA; _maxmesglen_ is the maximum length of mesg to receive. &#xA; _flags_ is bitwise OR of MSG_* constants such as Socket::MSG_PEEK. &#xA; _maxcontrollen_ is the maximum length of controls (ancillary data) to receive. &#xA; _opts_ is option hash. Currently :scm_rights=&gt;bool is the only option. &#xA; :scm_rights option specifies that application expects SCM_RIGHTS control message. If the value is nil or false, application don&apos;t expects SCM_RIGHTS control message. In this case, recvmsg closes the passed file descriptors immediately. This is the default behavior. &#xA; If :scm_rights value is neither nil nor false, application expects SCM_RIGHTS control message. In this case, recvmsg creates IO objects for each file descriptors for Socket::AncillaryData#unix_rights method. &#xA; The return value is 4-elements array. &#xA; _mesg_ is a string of the received message. &#xA; _sender_addrinfo_ is a sender socket address for connection-less socket. It is an Addrinfo object. For connection-oriented socket such as TCP, sender_addrinfo is platform dependent. &#xA; _rflags_ is a flags on the received message which is bitwise OR of MSG_* constants such as Socket::MSG_TRUNC. It will be nil if the system uses 4.3BSD style old recvmsg system call. &#xA; _controls_ is ancillary data which is an array of Socket::AncillaryData objects such as: &#xA; #&lt;Socket::AncillaryData: AF_UNIX SOCKET RIGHTS 7&gt;" />
        <scope name="recvmsg_nonblock" ilk="function" signature="recvmsg_nonblock(*args)" doc="recvmsg receives a message using recvmsg(2) system call in non-blocking manner. &#xA; It is similar to BasicSocket#recvmsg but non-blocking flag is set before the system call and it doesn&apos;t retry the system call." />
        <scope name="remote_address" ilk="function" signature="remote_address()" doc="Returns an Addrinfo object for remote address obtained by getpeername. &#xA; Note that addrinfo.protocol is filled by 0. &#xA; TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|s|&#xA;  p s.remote_address =&gt; #&lt;Addrinfo: 221.186.184.68:80 TCP&gt;&#xA;}&#xA;&#xA;TCPServer.open(&quot;127.0.0.1&quot;, 1728) {|serv|&#xA;  c = TCPSocket.new(&quot;127.0.0.1&quot;, 1728)&#xA;  s = serv.accept&#xA;  p s.remote_address =&gt; #&lt;Addrinfo: 127.0.0.1:36504 TCP&gt;&#xA;}" />
        <scope name="send" ilk="function" signature="send(p1, p2, p3 = v3)" doc="send _mesg_ via _basicsocket_. &#xA; _mesg_ should be a string. &#xA; _flags_ should be a bitwise OR of Socket::MSG_* constants. &#xA; _dest_sockaddr_ should be a packed sockaddr string or an addrinfo. &#xA; TCPSocket.open(&quot;localhost&quot;, 80) {|s|&#xA;  s.send &quot;GET / HTTP/1.0\r\n\r\n&quot;, 0&#xA;  p s.read&#xA;}" />
        <scope name="sendmsg" ilk="function" signature="sendmsg(*args)" doc="sendmsg sends a message using sendmsg(2) system call in blocking manner. &#xA; _mesg_ is a string to send. &#xA; _flags_ is bitwise OR of MSG_* constants such as Socket::MSG_OOB. &#xA; _dest_sockaddr_ is a destination socket address for connection-less socket. It should be a sockaddr such as a result of Socket.sockaddr_in. An Addrinfo object can be used too. &#xA; _controls_ is a list of ancillary data. The element of _controls_ should be Socket::AncillaryData or 3-elements array. The 3-element array should contains cmsg_level, cmsg_type and data. &#xA; The return value, _numbytes_sent_ is an integer which is the number of bytes sent. &#xA; sendmsg can be used to implement send_io as follows: &#xA; # use Socket::AncillaryData.&#xA;ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, io.fileno)&#xA;sock.sendmsg(&quot;a&quot;, 0, nil, ancdata)&#xA;# use 3-element array.&#xA;ancdata = [:SOCKET, :RIGHTS, [io.fileno].pack(&quot;i!&quot;)]&#xA;sock.sendmsg(&quot;\0&quot;, 0, nil, ancdata)" />
        <scope name="sendmsg_nonblock" ilk="function" signature="sendmsg_nonblock(*args)" doc="sendmsg_nonblock sends a message using sendmsg(2) system call in non-blocking manner. &#xA; It is similar to BasicSocket#sendmsg but the non-blocking flag is set before the system call and it doesn&apos;t retry the system call." />
        <scope name="setsockopt" ilk="function" signature="setsockopt(p1, p2, p3)" doc="Sets a socket option. These are protocol and system specific, see your local system documentation for details. &#xA; Parameters +level+ is an integer, usually one of the SOL_ constants such as Socket::SOL_SOCKET, or a protocol level. A string or symbol of the name, possibly without prefix, is also accepted.&#xA;+optname+ is an integer, usually one of the SO_ constants, such as Socket::SO_REUSEADDR. A string or symbol of the name, possibly without prefix, is also accepted.&#xA;+optval+ is the value of the option, it is passed to the underlying setsockopt() as a pointer to a certain number of bytes. How this is done depends on the type: Fixnum: value is assigned to an int, and a pointer to the int is passed, with length of sizeof(int).&#xA;true or false: 1 or 0 (respectively) is assigned to an int, and the int is passed as for a Fixnum. Note that +false+ must be passed, not +nil+.&#xA;String: the string&apos;s data and length is passed to the socket.&#xA;+socketoption+ is an instance of Socket::Option &#xA; Examples &#xA; Some socket options are integers with boolean values, in this case #setsockopt could be called like this: sock.setsockopt(:SOCKET, :REUSEADDR, true)&#xA;sock.setsockopt(Socket::SOL_SOCKET,Socket::SO_REUSEADDR, true)&#xA;sock.setsockopt(Socket::Option.bool(:INET, :SOCKET, :REUSEADDR, true))&#xA; Some socket options are integers with numeric values, in this case #setsockopt could be called like this: sock.setsockopt(:IP, :TTL, 255)&#xA;sock.setsockopt(Socket::IPPROTO_IP, Socket::IP_TTL, 255)" />
        <scope name="shutdown" ilk="function" signature="shutdown(p1 = v1)" doc="Calls shutdown(2) system call. &#xA; s.shutdown(Socket::SHUT_RD) disallows further read. &#xA; s.shutdown(Socket::SHUT_WR) disallows further write. &#xA; s.shutdown(Socket::SHUT_RDWR) disallows further read and write. &#xA; _how_ can be symbol or string: :RD, :SHUT_RD, &quot;RD&quot; and &quot;SHUT_RD&quot; are accepted as Socket::SHUT_RD.&#xA;:WR, :SHUT_WR, &quot;WR&quot; and &quot;SHUT_WR&quot; are accepted as Socket::SHUT_WR.&#xA;:RDWR, :SHUT_RDWR, &quot;RDWR&quot; and &quot;SHUT_RDWR&quot; are accepted as Socket::SHUT_RDWR. &#xA; UNIXSocket.pair {|s1, s2| s1.puts &quot;ping&quot;&#xA;s1.shutdown(:WR)&#xA;p s2.read          =&gt; &quot;ping\n&quot;&#xA;s2.puts &quot;pong&quot;&#xA;s2.close&#xA;p s1.read          =&gt; &quot;pong\n&quot;" />
      </scope>
      <scope name="IPSocket" ilk="class" classrefs="BasicSocket">
        <scope name="getaddress" ilk="function" signature="getaddress(s)" attributes="__classmethod__" doc="Returns a +String+ based representation of a valid DNS hostname, IPv4 or IPv6 address. &#xA; IPSocket.getaddress &apos;localhost&apos;         =&gt; &quot;::1&quot;&#xA;IPSocket.getaddress &apos;broadcasthost&apos;     =&gt; &quot;255.255.255.255&quot;&#xA;IPSocket.getaddress &apos;www.ruby-lang.org&apos; =&gt; &quot;221.186.184.68&quot;&#xA;IPSocket.getaddress &apos;www.ccc.de&apos;        =&gt; &quot;2a00:1328:e102:ccc0::122&quot;" />
        <scope name="getaddress_orig" ilk="function" signature="getaddress_orig(s)" attributes="__classmethod__" />
        <scope name="valid?" ilk="function" signature="valid?(addr)" attributes="__classmethod__" doc="Returns +true+ if +addr+ is either a valid IPv4 or IPv6 address." />
        <scope name="valid_v4?" ilk="function" signature="valid_v4?(addr)" attributes="__classmethod__" doc="Returns +true+ if +addr+ is a valid IPv4 address." />
        <scope name="valid_v6?" ilk="function" signature="valid_v6?(addr)" attributes="__classmethod__" doc="Returns +true+ if +addr+ is a valid IPv6 address." />
        <scope name="addr" ilk="function" signature="addr(*args)" doc="Returns the local address as an array which contains address_family, port, hostname and numeric_address. &#xA; If +reverse_lookup+ is +true+ or +:hostname+, hostname is obtained from numeric_address using reverse lookup. Or if it is +false+, or +:numeric+, hostname is same as numeric_address. Or if it is +nil+ or ommitted, obeys to +ipsocket.do_not_reverse_lookup+. See +Socket.getaddrinfo+ also. &#xA; TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|sock|&#xA;  p sock.addr =&gt; [&quot;AF_INET&quot;, 49429, &quot;hal&quot;, &quot;192.168.0.128&quot;]&#xA;  p sock.addr(true)  =&gt; [&quot;AF_INET&quot;, 49429, &quot;hal&quot;, &quot;192.168.0.128&quot;]&#xA;  p sock.addr(false) =&gt; [&quot;AF_INET&quot;, 49429, &quot;192.168.0.128&quot;, &quot;192.168.0.128&quot;]&#xA;  p sock.addr(:hostname)  =&gt; [&quot;AF_INET&quot;, 49429, &quot;hal&quot;, &quot;192.168.0.128&quot;]&#xA;  p sock.addr(:numeric)   =&gt; [&quot;AF_INET&quot;, 49429, &quot;192.168.0.128&quot;, &quot;192.168.0.128&quot;]&#xA;}" />
        <scope name="peeraddr" ilk="function" signature="peeraddr(*args)" doc="Returns the remote address as an array which contains address_family, port, hostname and numeric_address. It is defined for connection oriented socket such as TCPSocket. &#xA; If +reverse_lookup+ is +true+ or +:hostname+, hostname is obtained from numeric_address using reverse lookup. Or if it is +false+, or +:numeric+, hostname is same as numeric_address. Or if it is +nil+ or ommitted, obeys to +ipsocket.do_not_reverse_lookup+. See +Socket.getaddrinfo+ also. &#xA; TCPSocket.open(&quot;www.ruby-lang.org&quot;, 80) {|sock|&#xA;  p sock.peeraddr =&gt; [&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;]&#xA;  p sock.peeraddr(true)  =&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]&#xA;  p sock.peeraddr(false) =&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]&#xA;  p sock.peeraddr(:hostname) =&gt; [&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;]&#xA;  p sock.peeraddr(:numeric)  =&gt; [&quot;AF_INET&quot;, 80, &quot;221.186.184.68&quot;, &quot;221.186.184.68&quot;]&#xA;}" />
        <scope name="recvfrom" ilk="function" signature="recvfrom(*args)" doc="Receives a message and return the message as a string and an address which the message come from. &#xA; _maxlen_ is the maximum number of bytes to receive. &#xA; _flags_ should be a bitwise OR of Socket::MSG_* constants. &#xA; ipaddr is same as IPSocket#{peeraddr,addr}. &#xA; u1 = UDPSocket.new&#xA;u1.bind(&quot;127.0.0.1&quot;, 4913)&#xA;u2 = UDPSocket.new&#xA;u2.send &quot;uuuu&quot;, 0, &quot;127.0.0.1&quot;, 4913&#xA;p u1.recvfrom(10) =&gt; [&quot;uuuu&quot;, [&quot;AF_INET&quot;, 33230, &quot;localhost&quot;, &quot;127.0.0.1&quot;]]" />
      </scope>
      <scope name="SOCKSSocket" ilk="class" classrefs="TCPSocket">
        <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" doc="Opens a SOCKS connection to +host+ via the SOCKS server +serv+." />
        <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" doc="Opens a SOCKS connection to +host+ via the SOCKS server +serv+." />
        <scope name="close" ilk="function" signature="close()" doc="Closes the SOCKS connection." />
      </scope>
      <scope name="Socket" ilk="class" classrefs="BasicSocket">
        <scope name="accept_loop" ilk="function" signature="accept_loop(*sockets)" attributes="__classmethod__" doc="yield socket and client address for each a connection accepted via given sockets. &#xA; The arguments are a list of sockets. The individual argument should be a socket or an array of sockets. &#xA; This method yields the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time." />
        <scope name="getaddrinfo" ilk="function" signature="getaddrinfo(p1, p2, p3 = v3, p4 = v4, p5 = v5, p6 = v6, p7 = v7)" attributes="__classmethod__" doc="Obtains address information for _nodename_:_servname_. &#xA; _family_ should be an address family such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the family. 0 is default protocol for the family. &#xA; _flags_ should be bitwise OR of Socket::AI_* constants. &#xA; Socket.getaddrinfo(&quot;www.ruby-lang.org&quot;, &quot;http&quot;, nil, :STREAM)&#xA;=&gt; [[&quot;AF_INET&quot;, 80, &quot;carbon.ruby-lang.org&quot;, &quot;221.186.184.68&quot;, 2, 1, 6]] # PF_INET/SOCK_STREAM/IPPROTO_TCP&#xA;Socket.getaddrinfo(&quot;localhost&quot;, nil)&#xA;=&gt; [[&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 1, 6],  # PF_INET/SOCK_STREAM/IPPROTO_TCP&#xA;#    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 2, 17], # PF_INET/SOCK_DGRAM/IPPROTO_UDP&#xA;#    [&quot;AF_INET&quot;, 0, &quot;localhost&quot;, &quot;127.0.0.1&quot;, 2, 3, 0]]  # PF_INET/SOCK_RAW/IPPROTO_IP&#xA; _reverse_lookup_ directs the form of the third element, and has to be one of below. If it is ommitted, the default value is +nil+. &#xA; +true+, +:hostname+:  hostname is obtained from numeric address using reverse lookup, which may take a time." />
        <scope name="gethostbyaddr" ilk="function" signature="gethostbyaddr(p1, p2 = v2)" attributes="__classmethod__" doc="Obtains the host information for _address_. &#xA; p Socket.gethostbyaddr([221,186,184,68].pack(&quot;CCCC&quot;))&#xA;=&gt; [&quot;carbon.ruby-lang.org&quot;, [], 2, &quot;\xDD\xBA\xB8D&quot;]" />
        <scope name="gethostbyname" ilk="function" signature="gethostbyname(p1)" attributes="__classmethod__" doc="Obtains the host information for _hostname_. &#xA; p Socket.gethostbyname(&quot;hal&quot;) =&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;\x7F\x00\x00\x01&quot;]" />
        <scope name="gethostname" ilk="function" signature="gethostname()" attributes="__classmethod__" doc="Returns the hostname. &#xA; p Socket.gethostname =&gt; &quot;hal&quot;&#xA; Note that it is not guaranteed to be able to convert to IP address using gethostbyname, getaddrinfo, etc. If you need local IP address, use Socket.ip_address_list." />
        <scope name="getnameinfo" ilk="function" signature="getnameinfo(p1, p2 = v2)" attributes="__classmethod__" doc="Obtains name information for _sockaddr_. &#xA; _sockaddr_ should be one of follows. packed sockaddr string such as Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;3-elements array such as [&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;]&#xA;4-elements array such as [&quot;AF_INET&quot;, 80, ignored, &quot;127.0.0.1&quot;] &#xA; _flags_ should be bitwise OR of Socket::NI_* constants. &#xA; Note that the last form is compatible with IPSocket#{addr,peeraddr}. &#xA; Socket.getnameinfo(Socket.sockaddr_in(80, &quot;127.0.0.1&quot;))       =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA;Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;127.0.0.1&quot;])              =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA;Socket.getnameinfo([&quot;AF_INET&quot;, 80, &quot;localhost&quot;, &quot;127.0.0.1&quot;]) =&gt; [&quot;localhost&quot;, &quot;www&quot;]&#xA; If Addrinfo object is preferred, use Addrinfo#getnameinfo." />
        <scope name="getservbyname" ilk="function" signature="getservbyname(p1, p2 = v2)" attributes="__classmethod__" doc="Obtains the port number for _service_name_. &#xA; If _protocol_name_ is not given, &quot;tcp&quot; is assumed. &#xA; Socket.getservbyname(&quot;smtp&quot;)          =&gt; 25&#xA;Socket.getservbyname(&quot;shell&quot;)         =&gt; 514&#xA;Socket.getservbyname(&quot;syslog&quot;, &quot;udp&quot;) =&gt; 514" />
        <scope name="getservbyport" ilk="function" signature="getservbyport(p1, p2 = v2)" attributes="__classmethod__" doc="Obtains the port number for _port_. &#xA; If _protocol_name_ is not given, &quot;tcp&quot; is assumed. &#xA; Socket.getservbyport(80)         =&gt; &quot;www&quot;&#xA;Socket.getservbyport(514, &quot;tcp&quot;) =&gt; &quot;shell&quot;&#xA;Socket.getservbyport(514, &quot;udp&quot;) =&gt; &quot;syslog&quot;" />
        <scope name="ip_address_list" ilk="function" signature="ip_address_list()" attributes="__classmethod__" doc="Returns local IP addresses as an array. &#xA; The array contains Addrinfo objects. &#xA; pp Socket.ip_address_list&#xA;=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;,&#xA;     #&lt;Addrinfo: 192.168.0.128&gt;,&#xA;     #&lt;Addrinfo: ::1&gt;,&#xA;     ...]" />
        <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Creates a new socket object. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. This is optional. If it is not given, 0 is used internally. &#xA; Socket.new(:INET, :STREAM) # TCP socket&#xA;Socket.new(:INET, :DGRAM)  # UDP socket&#xA;Socket.new(:UNIX, :STREAM) # UNIX stream socket&#xA;Socket.new(:UNIX, :DGRAM)  # UNIX datagram socket" />
        <scope name="pack_sockaddr_in" ilk="function" signature="pack_sockaddr_in(p1, p2)" attributes="__classmethod__" doc="Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string. &#xA; Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;&#xA;Socket.sockaddr_in(80, &quot;::1&quot;)&#xA;=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;" />
        <scope name="pack_sockaddr_un" ilk="function" signature="pack_sockaddr_un(p1)" attributes="__classmethod__" doc="Packs _path_ as an AF_UNIX sockaddr string. &#xA; Socket.sockaddr_un(&quot;/tmp/sock&quot;) =&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;" />
        <scope name="pair" ilk="function" signature="pair(p1, p2, p3 = v3)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA; s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)&#xA;s1.send &quot;a&quot;, 0&#xA;s1.send &quot;b&quot;, 0&#xA;p s2.recv(10) =&gt; &quot;a&quot;&#xA;p s2.recv(10) =&gt; &quot;b&quot;" />
        <scope name="sockaddr_in" ilk="function" signature="sockaddr_in(p1, p2)" attributes="__classmethod__" doc="Packs _port_ and _host_ as an AF_INET/AF_INET6 sockaddr string. &#xA; Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;=&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;&#xA;Socket.sockaddr_in(80, &quot;::1&quot;)&#xA;=&gt; &quot;\n\x00\x00P\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00&quot;" />
        <scope name="sockaddr_un" ilk="function" signature="sockaddr_un(p1)" attributes="__classmethod__" doc="Packs _path_ as an AF_UNIX sockaddr string. &#xA; Socket.sockaddr_un(&quot;/tmp/sock&quot;) =&gt; &quot;\x01\x00/tmp/sock\x00\x00...&quot;" />
        <scope name="socketpair" ilk="function" signature="socketpair(p1, p2, p3 = v3)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _domain_ should be a communications domain such as: :INET, :INET6, :UNIX, etc. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA; s1, s2 = Socket.pair(:UNIX, :DGRAM, 0)&#xA;s1.send &quot;a&quot;, 0&#xA;s1.send &quot;b&quot;, 0&#xA;p s2.recv(10) =&gt; &quot;a&quot;&#xA;p s2.recv(10) =&gt; &quot;b&quot;" />
        <scope name="tcp" ilk="function" signature="tcp(host, port, local_host=nil, local_port=nil)" attributes="__classmethod__" doc="creates a new socket object connected to host:port using TCP/IP. &#xA; If local_host:local_port is given, the socket is bound to it. &#xA; If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns. &#xA; If no block is given, the socket is returned. &#xA; Socket.tcp(&quot;www.ruby-lang.org&quot;, 80) {|sock|&#xA;  sock.print &quot;GET / HTTP/1.0\r\nHost: www.ruby-lang.org\r\n\r\n&quot;&#xA;  sock.close_write&#xA;  puts sock.read&#xA;}" />
        <scope name="tcp_server_loop" ilk="function" signature="tcp_server_loop(host=nil, port)" attributes="__classmethod__" doc="creates a TCP/IP server on _port_ and calls the block for each connection accepted. The block is called with a socket and a client_address as an Addrinfo object. &#xA; If _host_ is specified, it is used with _port_ to determine the server addresses. &#xA; The socket is *not* closed when the block returns. So application should close it explicitly. &#xA; This method calls the block sequentially. It means that the next connection is not accepted until the block returns. So concurrent mechanism, thread for example, should be used to service multiple clients at a time. &#xA; Note that Addrinfo.getaddrinfo is used to determine the server socket addresses. When Addrinfo.getaddrinfo returns two or more addresses, IPv4 and IPv6 address for example, all of them are used. Socket.tcp_server_loop succeeds if one socket can be used at least. &#xA; # Sequential echo server.&#xA;# It services only one client at a time.&#xA;Socket.tcp_server_loop(16807) {|sock, client_addrinfo|&#xA;  begin&#xA;    IO.copy_stream(sock, sock)&#xA;  ensure&#xA;    sock.close&#xA;  end" />
        <scope name="tcp_server_sockets" ilk="function" signature="tcp_server_sockets(host=nil, port)" attributes="__classmethod__" doc="creates TCP/IP server sockets for _host_ and _port_. _host_ is optional. &#xA; If no block given, it returns an array of listening sockets. &#xA; If a block is given, the block is called with the sockets. The value of the block is returned. The socket is closed when this method returns. &#xA; If _port_ is 0, actual port number is choosen dynamically. However all sockets in the result has same port number. &#xA; # tcp_server_sockets returns two sockets.&#xA;sockets = Socket.tcp_server_sockets(1296)&#xA;p sockets =&gt; [#&lt;Socket:fd 3&gt;, #&lt;Socket:fd 4&gt;]&#xA;# The sockets contains IPv6 and IPv4 sockets.&#xA;sockets.each {|s| p s.local_address }&#xA;=&gt; #&lt;Addrinfo: [::]:1296 TCP&gt;&#xA;#   #&lt;Addrinfo: 0.0.0.0:1296 TCP&gt;&#xA;# IPv6 and IPv4 socket has same port number, 53114, even if it is choosen dynamically.&#xA;sockets = Socket.tcp_server_sockets(0)" />
        <scope name="udp_server_loop" ilk="function" signature="udp_server_loop(host=nil, port)" attributes="__classmethod__" doc="creates a UDP/IP server on _port_ and calls the block for each message arrived. The block is called with the message and its source information. &#xA; This method allocates sockets internally using _port_. If _host_ is specified, it is used conjunction with _port_ to determine the server addresses. &#xA; The _msg_ is a string. &#xA; The _msg_src_ is a Socket::UDPSource object. It is used for reply. &#xA; # UDP/IP echo server.&#xA;Socket.udp_server_loop(9261) {|msg, msg_src|&#xA;  msg_src.reply msg&#xA;}" />
        <scope name="udp_server_loop_on" ilk="function" signature="udp_server_loop_on(sockets)" attributes="__classmethod__" doc="Run UDP/IP server loop on the given sockets. &#xA; The return value of Socket.udp_server_sockets is appropriate for the argument. &#xA; It calls the block for each message received." />
        <scope name="udp_server_recv" ilk="function" signature="udp_server_recv(sockets)" attributes="__classmethod__" doc="Receive UDP/IP packets from the given _sockets_. For each packet received, the block is called. &#xA; The block receives _msg_ and _msg_src_. _msg_ is a string which is the payload of the received packet. _msg_src_ is a Socket::UDPSource object which is used for reply. &#xA; Socket.udp_server_loop can be implemented using this method as follows. &#xA; udp_server_sockets(host, port) {|sockets|&#xA;  loop {&#xA;    readable, _, _ = IO.select(sockets)&#xA;    udp_server_recv(readable) {|msg, msg_src| ... }&#xA;  }&#xA;}" />
        <scope name="udp_server_sockets" ilk="function" signature="udp_server_sockets(host=nil, port)" attributes="__classmethod__" doc="Creates UDP/IP sockets for a UDP server. &#xA; If no block given, it returns an array of sockets. &#xA; If a block is given, the block is called with the sockets. The value of the block is returned. The sockets are closed when this method returns. &#xA; If _port_ is zero, some port is choosen. But the choosen port is used for the all sockets. &#xA; # UDP/IP echo server&#xA;Socket.udp_server_sockets(0) {|sockets|&#xA;  p sockets.first.local_address.ip_port     =&gt; 32963&#xA;  Socket.udp_server_loop_on(sockets) {|msg, msg_src|&#xA;    msg_src.reply msg&#xA;  }&#xA;}" />
        <scope name="unix" ilk="function" signature="unix(path)" attributes="__classmethod__" doc="creates a new socket connected to path using UNIX socket socket. &#xA; If a block is given, the block is called with the socket. The value of the block is returned. The socket is closed when this method returns. &#xA; If no block is given, the socket is returned. &#xA; # talk to /tmp/sock socket.&#xA;Socket.unix(&quot;/tmp/sock&quot;) {|sock|&#xA;  t = Thread.new { IO.copy_stream(sock, STDOUT) }&#xA;  IO.copy_stream(STDIN, sock)&#xA;  t.join&#xA;}" />
        <scope name="unix_server_loop" ilk="function" signature="unix_server_loop(path)" attributes="__classmethod__" doc="creates a UNIX socket server on _path_. It calls the block for each socket accepted. &#xA; If _host_ is specified, it is used with _port_ to determine the server ports. &#xA; The socket is *not* closed when the block returns. So application should close it. &#xA; This method deletes the socket file pointed by _path_ at first if the file is a socket file and it is owned by the user of the application. This is safe only if the directory of _path_ is not changed by a malicious user. So don&apos;t use /tmp/malicious-users-directory/socket. Note that /tmp/socket and /tmp/your-private-directory/socket is safe assuming that /tmp has sticky bit. &#xA; # Sequential echo server.&#xA;# It services only one client at a time.&#xA;Socket.unix_server_loop(&quot;/tmp/sock&quot;) {|sock, client_addrinfo|&#xA;  begin&#xA;    IO.copy_stream(sock, sock)&#xA;  ensure&#xA;    sock.close&#xA;  end&#xA;}" />
        <scope name="unix_server_socket" ilk="function" signature="unix_server_socket(path)" attributes="__classmethod__" doc="creates a UNIX server socket on _path_ &#xA; If no block given, it returns a listening socket. &#xA; If a block is given, it is called with the socket and the block value is returned. When the block exits, the socket is closed and the socket file is removed. &#xA; socket = Socket.unix_server_socket(&quot;/tmp/s&quot;)&#xA;p socket                  =&gt; #&lt;Socket:fd 3&gt;&#xA;p socket.local_address    =&gt; #&lt;Addrinfo: /tmp/s SOCK_STREAM&gt;&#xA;&#xA;Socket.unix_server_socket(&quot;/tmp/sock&quot;) {|s|&#xA;  p s                     =&gt; #&lt;Socket:fd 3&gt;&#xA;  p s.local_address       =&gt; # #&lt;Addrinfo: /tmp/sock SOCK_STREAM&gt;&#xA;}" />
        <scope name="unpack_sockaddr_in" ilk="function" signature="unpack_sockaddr_in(p1)" attributes="__classmethod__" doc="Unpacks _sockaddr_ into port and ip_address. &#xA; _sockaddr_ should be a string or an addrinfo for AF_INET/AF_INET6. &#xA; sockaddr = Socket.sockaddr_in(80, &quot;127.0.0.1&quot;)&#xA;p sockaddr =&gt; &quot;\x02\x00\x00P\x7F\x00\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00&quot;&#xA;p Socket.unpack_sockaddr_in(sockaddr) =&gt; [80, &quot;127.0.0.1&quot;]" />
        <scope name="unpack_sockaddr_un" ilk="function" signature="unpack_sockaddr_un(p1)" attributes="__classmethod__" doc="Unpacks _sockaddr_ into path. &#xA; _sockaddr_ should be a string or an addrinfo for AF_UNIX. &#xA; sockaddr = Socket.sockaddr_un(&quot;/tmp/sock&quot;)&#xA;p Socket.unpack_sockaddr_un(sockaddr) =&gt; &quot;/tmp/sock&quot;" />
        <scope name="accept" ilk="function" signature="accept()" doc="Accepts a next connection. Returns a new Socket object and Addrinfo object. &#xA; serv = Socket.new(:INET, :STREAM, 0)&#xA;serv.listen(5)&#xA;c = Socket.new(:INET, :STREAM, 0)&#xA;c.connect(serv.connect_address)&#xA;p serv.accept =&gt; [#&lt;Socket:fd 6&gt;, #&lt;Addrinfo: 127.0.0.1:48555 TCP&gt;]" />
        <scope name="accept_nonblock" ilk="function" signature="accept_nonblock()" doc="Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an array containing the accepted socket for the incoming connection, _client_socket_, and an Addrinfo, _client_addrinfo_. &#xA; Example # In one script, start this first&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)&#xA;socket.bind(sockaddr)&#xA;socket.listen(5)&#xA;begin # emulate blocking accept&#xA;  client_socket, client_addrinfo = socket.accept_nonblock&#xA;rescue IO::WaitReadable, Errno::EINTR&#xA;  IO.select([socket])&#xA;  retry" />
        <scope name="bind" ilk="function" signature="bind(p1)" doc="Binds to the given local address. &#xA; Parameter +local_sockaddr+ - the +struct+ sockaddr contained in a string or an Addrinfo object &#xA; Example require &apos;socket&apos;&#xA;# use Addrinfo&#xA;socket = Socket.new(:INET, :STREAM, 0)&#xA;socket.bind(Addrinfo.tcp(&quot;127.0.0.1&quot;, 2222))&#xA;p socket.local_address =&gt; #&lt;Addrinfo: 127.0.0.1:2222 TCP&gt;&#xA;# use struct sockaddr&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA; Unix-based Exceptions On unix-based based systems the following system exceptions may be raised if the call to _bind_ fails: Errno::EACCES - the specified _sockaddr_ is protected and the current user does not have permission to bind to it" />
        <scope name="connect" ilk="function" signature="connect(p1)" doc="Requests a connection to be made on the given +remote_sockaddr+. Returns 0 if successful, otherwise an exception is raised. &#xA; Parameter +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object &#xA; Example: # Pull down Google&apos;s web page&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 80, &apos;www.google.com&apos; )&#xA;socket.connect( sockaddr )&#xA;socket.write( &quot;GET / HTTP/1.0\r\n\r\n&quot; )&#xA;results = socket.read&#xA; Unix-based Exceptions On unix-based systems the following system exceptions may be raised if the call to _connect_ fails: Errno::EACCES - search permission is denied for a component of the prefix path or write access to the +socket+ is denied&#xA;Errno::EADDRINUSE - the _sockaddr_ is already in use&#xA;Errno::EADDRNOTAVAIL - the specified _sockaddr_ is not available from the local machine" />
        <scope name="connect_nonblock" ilk="function" signature="connect_nonblock(p1)" doc="Requests a connection to be made on the given +remote_sockaddr+ after O_NONBLOCK is set for the underlying file descriptor. Returns 0 if successful, otherwise an exception is raised. &#xA; Parameter +remote_sockaddr+ - the +struct+ sockaddr contained in a string or Addrinfo object &#xA; Example: # Pull down Google&apos;s web page&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;sockaddr = Socket.sockaddr_in(80, &apos;www.google.com&apos;)&#xA;begin # emulate blocking connect&#xA;  socket.connect_nonblock(sockaddr)&#xA;rescue IO::WaitWritable&#xA;  IO.select(nil, [socket]) # wait 3-way handshake completion&#xA;  begin&#xA;    socket.connect_nonblock(sockaddr) # check connection failure" />
        <scope name="ipv6only!" ilk="function" signature="ipv6only!()" doc="enable the socket option IPV6_V6ONLY if IPV6_V6ONLY is available." />
        <scope name="listen" ilk="function" signature="listen(p1)" doc="Listens for connections, using the specified +int+ as the backlog. A call to _listen_ only applies if the +socket+ is of type SOCK_STREAM or SOCK_SEQPACKET. &#xA; Parameter +backlog+ - the maximum length of the queue for pending connections. &#xA; Example 1 require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA;socket.listen( 5 )&#xA; Example 2 (listening on an arbitrary port, unix-based systems only): require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;socket.listen( 1 )&#xA; Unix-based Exceptions On unix based systems the above will work because a new +sockaddr+ struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the +socket+ is bound by calling _bind_ before it can _listen_. " />
        <scope name="recvfrom" ilk="function" signature="recvfrom(*args)" doc="Receives up to _maxlen_ bytes from +socket+. _flags_ is zero or more of the +MSG_+ options. The first element of the results, _mesg_, is the data received. The second element, _sender_addrinfo_, contains protocol-specific address information of the sender. &#xA; Parameters +maxlen+ - the maximum number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example # In one file, start this first&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA;socket.listen( 5 )&#xA;client, client_addrinfo = socket.accept&#xA;data = client.recvfrom( 20 )[0].chomp&#xA;puts &quot;I only received 20 bytes &apos;#{data}&apos;&quot;" />
        <scope name="recvfrom_nonblock" ilk="function" signature="recvfrom_nonblock(*args)" doc="Receives up to _maxlen_ bytes from +socket+ using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. _flags_ is zero or more of the +MSG_+ options. The first element of the results, _mesg_, is the data received. The second element, _sender_addrinfo_, contains protocol-specific address information of the sender. &#xA; When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string as data. The meaning depends on the socket: EOF on TCP, empty packet on UDP, etc. &#xA; Parameters +maxlen+ - the maximum number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example # In one file, start this first&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new(AF_INET, SOCK_STREAM, 0)&#xA;sockaddr = Socket.sockaddr_in(2200, &apos;localhost&apos;)&#xA;socket.bind(sockaddr)&#xA;socket.listen(5)&#xA;client, client_addrinfo = socket.accept&#xA;begin # emulate blocking recvfrom" />
        <scope name="sysaccept" ilk="function" signature="sysaccept()" doc="Accepts an incoming connection returning an array containing the (integer) file descriptor for the incoming connection, _client_socket_fd_, and an Addrinfo, _client_addrinfo_. &#xA; Example # In one script, start this first&#xA;require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA;socket.listen( 5 )&#xA;client_fd, client_addrinfo = socket.sysaccept&#xA;client_socket = Socket.for_fd( client_fd )&#xA;puts &quot;The client said, &apos;#{client_socket.readline.chomp}&apos;&quot;&#xA;client_socket.puts &quot;Hello from script one!&quot;&#xA;socket.close" />
        <variable name="SOCK_STREAM" attributes="__const__" citdl="Object" />
        <variable name="SOCK_DGRAM" attributes="__const__" citdl="Object" />
        <variable name="SOCK_RAW" attributes="__const__" citdl="Object" />
        <variable name="SOCK_RDM" attributes="__const__" citdl="Object" />
        <variable name="SOCK_SEQPACKET" attributes="__const__" citdl="Object" />
        <variable name="SOCK_PACKET" attributes="__const__" citdl="Object" />
        <variable name="AF_UNSPEC" attributes="__const__" citdl="Object" />
        <variable name="PF_UNSPEC" attributes="__const__" citdl="Object" />
        <variable name="AF_INET" attributes="__const__" citdl="Object" />
        <variable name="PF_INET" attributes="__const__" citdl="Object" />
        <variable name="AF_UNIX" attributes="__const__" citdl="Object" />
        <variable name="PF_UNIX" attributes="__const__" citdl="Object" />
        <variable name="AF_IPX" attributes="__const__" citdl="Object" />
        <variable name="PF_IPX" attributes="__const__" citdl="Object" />
        <variable name="AF_APPLETALK" attributes="__const__" citdl="Object" />
        <variable name="PF_APPLETALK" attributes="__const__" citdl="Object" />
        <variable name="AF_LOCAL" attributes="__const__" citdl="Object" />
        <variable name="PF_LOCAL" attributes="__const__" citdl="Object" />
        <variable name="AF_IMPLINK" attributes="__const__" citdl="Object" />
        <variable name="PF_IMPLINK" attributes="__const__" citdl="Object" />
        <variable name="AF_PUP" attributes="__const__" citdl="Object" />
        <variable name="PF_PUP" attributes="__const__" citdl="Object" />
        <variable name="AF_CHAOS" attributes="__const__" citdl="Object" />
        <variable name="PF_CHAOS" attributes="__const__" citdl="Object" />
        <variable name="AF_NS" attributes="__const__" citdl="Object" />
        <variable name="PF_NS" attributes="__const__" citdl="Object" />
        <variable name="AF_ISO" attributes="__const__" citdl="Object" />
        <variable name="PF_ISO" attributes="__const__" citdl="Object" />
        <variable name="AF_OSI" attributes="__const__" citdl="Object" />
        <variable name="PF_OSI" attributes="__const__" citdl="Object" />
        <variable name="AF_ECMA" attributes="__const__" citdl="Object" />
        <variable name="PF_ECMA" attributes="__const__" citdl="Object" />
        <variable name="AF_DATAKIT" attributes="__const__" citdl="Object" />
        <variable name="PF_DATAKIT" attributes="__const__" citdl="Object" />
        <variable name="AF_CCITT" attributes="__const__" citdl="Object" />
        <variable name="PF_CCITT" attributes="__const__" citdl="Object" />
        <variable name="AF_SNA" attributes="__const__" citdl="Object" />
        <variable name="PF_SNA" attributes="__const__" citdl="Object" />
        <variable name="AF_DEC" attributes="__const__" citdl="Object" />
        <variable name="PF_DEC" attributes="__const__" citdl="Object" />
        <variable name="AF_DLI" attributes="__const__" citdl="Object" />
        <variable name="PF_DLI" attributes="__const__" citdl="Object" />
        <variable name="AF_LAT" attributes="__const__" citdl="Object" />
        <variable name="PF_LAT" attributes="__const__" citdl="Object" />
        <variable name="AF_HYLINK" attributes="__const__" citdl="Object" />
        <variable name="PF_HYLINK" attributes="__const__" citdl="Object" />
        <variable name="AF_ROUTE" attributes="__const__" citdl="Object" />
        <variable name="PF_ROUTE" attributes="__const__" citdl="Object" />
        <variable name="AF_LINK" attributes="__const__" citdl="Object" />
        <variable name="PF_LINK" attributes="__const__" citdl="Object" />
        <variable name="AF_COIP" attributes="__const__" citdl="Object" />
        <variable name="PF_COIP" attributes="__const__" citdl="Object" />
        <variable name="AF_CNT" attributes="__const__" citdl="Object" />
        <variable name="PF_CNT" attributes="__const__" citdl="Object" />
        <variable name="AF_SIP" attributes="__const__" citdl="Object" />
        <variable name="PF_SIP" attributes="__const__" citdl="Object" />
        <variable name="AF_NDRV" attributes="__const__" citdl="Object" />
        <variable name="PF_NDRV" attributes="__const__" citdl="Object" />
        <variable name="AF_ISDN" attributes="__const__" citdl="Object" />
        <variable name="PF_ISDN" attributes="__const__" citdl="Object" />
        <variable name="AF_NATM" attributes="__const__" citdl="Object" />
        <variable name="PF_NATM" attributes="__const__" citdl="Object" />
        <variable name="AF_SYSTEM" attributes="__const__" citdl="Object" />
        <variable name="PF_SYSTEM" attributes="__const__" citdl="Object" />
        <variable name="AF_NETBIOS" attributes="__const__" citdl="Object" />
        <variable name="PF_NETBIOS" attributes="__const__" citdl="Object" />
        <variable name="AF_PPP" attributes="__const__" citdl="Object" />
        <variable name="PF_PPP" attributes="__const__" citdl="Object" />
        <variable name="AF_ATM" attributes="__const__" citdl="Object" />
        <variable name="PF_ATM" attributes="__const__" citdl="Object" />
        <variable name="AF_NETGRAPH" attributes="__const__" citdl="Object" />
        <variable name="PF_NETGRAPH" attributes="__const__" citdl="Object" />
        <variable name="AF_MAX" attributes="__const__" citdl="Object" />
        <variable name="PF_MAX" attributes="__const__" citdl="Object" />
        <variable name="AF_PACKET" attributes="__const__" citdl="Object" />
        <variable name="PF_PACKET" attributes="__const__" citdl="Object" />
        <variable name="PF_XTP" attributes="__const__" citdl="Object" />
        <variable name="PF_RTIP" attributes="__const__" citdl="Object" />
        <variable name="PF_PIP" attributes="__const__" citdl="Object" />
        <variable name="PF_KEY" attributes="__const__" citdl="Object" />
        <variable name="MSG_OOB" attributes="__const__" citdl="Object" />
        <variable name="MSG_PEEK" attributes="__const__" citdl="Object" />
        <variable name="MSG_DONTROUTE" attributes="__const__" citdl="Object" />
        <variable name="MSG_EOR" attributes="__const__" citdl="Object" />
        <variable name="MSG_TRUNC" attributes="__const__" citdl="Object" />
        <variable name="MSG_CTRUNC" attributes="__const__" citdl="Object" />
        <variable name="MSG_WAITALL" attributes="__const__" citdl="Object" />
        <variable name="MSG_DONTWAIT" attributes="__const__" citdl="Object" />
        <variable name="MSG_EOF" attributes="__const__" citdl="Object" />
        <variable name="MSG_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="MSG_HOLD" attributes="__const__" citdl="Object" />
        <variable name="MSG_SEND" attributes="__const__" citdl="Object" />
        <variable name="MSG_HAVEMORE" attributes="__const__" citdl="Object" />
        <variable name="MSG_RCVMORE" attributes="__const__" citdl="Object" />
        <variable name="MSG_COMPAT" attributes="__const__" citdl="Object" />
        <variable name="MSG_PROXY" attributes="__const__" citdl="Object" />
        <variable name="MSG_FIN" attributes="__const__" citdl="Object" />
        <variable name="MSG_SYN" attributes="__const__" citdl="Object" />
        <variable name="MSG_CONFIRM" attributes="__const__" citdl="Object" />
        <variable name="MSG_RST" attributes="__const__" citdl="Object" />
        <variable name="MSG_ERRQUEUE" attributes="__const__" citdl="Object" />
        <variable name="MSG_NOSIGNAL" attributes="__const__" citdl="Object" />
        <variable name="MSG_MORE" attributes="__const__" citdl="Object" />
        <variable name="SOL_SOCKET" attributes="__const__" citdl="Object" />
        <variable name="SOL_IP" attributes="__const__" citdl="Object" />
        <variable name="SOL_IPX" attributes="__const__" citdl="Object" />
        <variable name="SOL_ATALK" attributes="__const__" citdl="Object" />
        <variable name="SOL_TCP" attributes="__const__" citdl="Object" />
        <variable name="SOL_UDP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_IP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_ICMP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_IGMP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_GGP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_TCP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_EGP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_PUP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_UDP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_IDP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_HELLO" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_ND" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_TP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_XTP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_EON" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_BIP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_AH" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_DSTOPTS" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_ESP" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_FRAGMENT" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_HOPOPTS" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_NONE" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_ROUTING" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_RAW" attributes="__const__" citdl="Object" />
        <variable name="IPPROTO_MAX" attributes="__const__" citdl="Object" />
        <variable name="IPPORT_RESERVED" attributes="__const__" citdl="Object" />
        <variable name="IPPORT_USERRESERVED" attributes="__const__" citdl="Object" />
        <variable name="INADDR_ANY" attributes="__const__" citdl="Object" />
        <variable name="INADDR_BROADCAST" attributes="__const__" citdl="Object" />
        <variable name="INADDR_LOOPBACK" attributes="__const__" citdl="Object" />
        <variable name="INADDR_UNSPEC_GROUP" attributes="__const__" citdl="Object" />
        <variable name="INADDR_ALLHOSTS_GROUP" attributes="__const__" citdl="Object" />
        <variable name="INADDR_MAX_LOCAL_GROUP" attributes="__const__" citdl="Object" />
        <variable name="INADDR_NONE" attributes="__const__" citdl="Object" />
        <variable name="IP_OPTIONS" attributes="__const__" citdl="Object" />
        <variable name="IP_HDRINCL" attributes="__const__" citdl="Object" />
        <variable name="IP_TOS" attributes="__const__" citdl="Object" />
        <variable name="IP_TTL" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVOPTS" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVRETOPTS" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVDSTADDR" attributes="__const__" citdl="Object" />
        <variable name="IP_RETOPTS" attributes="__const__" citdl="Object" />
        <variable name="IP_MINTTL" attributes="__const__" citdl="Object" />
        <variable name="IP_DONTFRAG" attributes="__const__" citdl="Object" />
        <variable name="IP_SENDSRCADDR" attributes="__const__" citdl="Object" />
        <variable name="IP_ONESBCAST" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVTTL" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVIF" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVSLLA" attributes="__const__" citdl="Object" />
        <variable name="IP_PORTRANGE" attributes="__const__" citdl="Object" />
        <variable name="IP_MULTICAST_IF" attributes="__const__" citdl="Object" />
        <variable name="IP_MULTICAST_TTL" attributes="__const__" citdl="Object" />
        <variable name="IP_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
        <variable name="IP_ADD_MEMBERSHIP" attributes="__const__" citdl="Object" />
        <variable name="IP_DROP_MEMBERSHIP" attributes="__const__" citdl="Object" />
        <variable name="IP_DEFAULT_MULTICAST_TTL" attributes="__const__" citdl="Object" />
        <variable name="IP_DEFAULT_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
        <variable name="IP_MAX_MEMBERSHIPS" attributes="__const__" citdl="Object" />
        <variable name="IP_ROUTER_ALERT" attributes="__const__" citdl="Object" />
        <variable name="IP_PKTINFO" attributes="__const__" citdl="Object" />
        <variable name="IP_PKTOPTIONS" attributes="__const__" citdl="Object" />
        <variable name="IP_MTU_DISCOVER" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVERR" attributes="__const__" citdl="Object" />
        <variable name="IP_RECVTOS" attributes="__const__" citdl="Object" />
        <variable name="IP_MTU" attributes="__const__" citdl="Object" />
        <variable name="IP_FREEBIND" attributes="__const__" citdl="Object" />
        <variable name="IP_IPSEC_POLICY" attributes="__const__" citdl="Object" />
        <variable name="IP_XFRM_POLICY" attributes="__const__" citdl="Object" />
        <variable name="IP_PASSSEC" attributes="__const__" citdl="Object" />
        <variable name="IP_PMTUDISC_DONT" attributes="__const__" citdl="Object" />
        <variable name="IP_PMTUDISC_WANT" attributes="__const__" citdl="Object" />
        <variable name="IP_PMTUDISC_DO" attributes="__const__" citdl="Object" />
        <variable name="IP_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
        <variable name="IP_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
        <variable name="IP_ADD_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
        <variable name="IP_DROP_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
        <variable name="IP_MSFILTER" attributes="__const__" citdl="Object" />
        <variable name="MCAST_JOIN_GROUP" attributes="__const__" citdl="Object" />
        <variable name="MCAST_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
        <variable name="MCAST_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
        <variable name="MCAST_LEAVE_GROUP" attributes="__const__" citdl="Object" />
        <variable name="MCAST_JOIN_SOURCE_GROUP" attributes="__const__" citdl="Object" />
        <variable name="MCAST_LEAVE_SOURCE_GROUP" attributes="__const__" citdl="Object" />
        <variable name="MCAST_MSFILTER" attributes="__const__" citdl="Object" />
        <variable name="MCAST_EXCLUDE" attributes="__const__" citdl="Object" />
        <variable name="MCAST_INCLUDE" attributes="__const__" citdl="Object" />
        <variable name="SO_DEBUG" attributes="__const__" citdl="Object" />
        <variable name="SO_REUSEADDR" attributes="__const__" citdl="Object" />
        <variable name="SO_REUSEPORT" attributes="__const__" citdl="Object" />
        <variable name="SO_TYPE" attributes="__const__" citdl="Object" />
        <variable name="SO_ERROR" attributes="__const__" citdl="Object" />
        <variable name="SO_DONTROUTE" attributes="__const__" citdl="Object" />
        <variable name="SO_BROADCAST" attributes="__const__" citdl="Object" />
        <variable name="SO_SNDBUF" attributes="__const__" citdl="Object" />
        <variable name="SO_RCVBUF" attributes="__const__" citdl="Object" />
        <variable name="SO_KEEPALIVE" attributes="__const__" citdl="Object" />
        <variable name="SO_OOBINLINE" attributes="__const__" citdl="Object" />
        <variable name="SO_NO_CHECK" attributes="__const__" citdl="Object" />
        <variable name="SO_PRIORITY" attributes="__const__" citdl="Object" />
        <variable name="SO_LINGER" attributes="__const__" citdl="Object" />
        <variable name="SO_PASSCRED" attributes="__const__" citdl="Object" />
        <variable name="SO_PEERCRED" attributes="__const__" citdl="Object" />
        <variable name="SO_RCVLOWAT" attributes="__const__" citdl="Object" />
        <variable name="SO_SNDLOWAT" attributes="__const__" citdl="Object" />
        <variable name="SO_RCVTIMEO" attributes="__const__" citdl="Object" />
        <variable name="SO_SNDTIMEO" attributes="__const__" citdl="Object" />
        <variable name="SO_ACCEPTCONN" attributes="__const__" citdl="Object" />
        <variable name="SO_USELOOPBACK" attributes="__const__" citdl="Object" />
        <variable name="SO_ACCEPTFILTER" attributes="__const__" citdl="Object" />
        <variable name="SO_DONTTRUNC" attributes="__const__" citdl="Object" />
        <variable name="SO_WANTMORE" attributes="__const__" citdl="Object" />
        <variable name="SO_WANTOOBFLAG" attributes="__const__" citdl="Object" />
        <variable name="SO_NREAD" attributes="__const__" citdl="Object" />
        <variable name="SO_NKE" attributes="__const__" citdl="Object" />
        <variable name="SO_NOSIGPIPE" attributes="__const__" citdl="Object" />
        <variable name="SO_SECURITY_AUTHENTICATION" attributes="__const__" citdl="Object" />
        <variable name="SO_SECURITY_ENCRYPTION_TRANSPORT" attributes="__const__" citdl="Object" />
        <variable name="SO_SECURITY_ENCRYPTION_NETWORK" attributes="__const__" citdl="Object" />
        <variable name="SO_BINDTODEVICE" attributes="__const__" citdl="Object" />
        <variable name="SO_ATTACH_FILTER" attributes="__const__" citdl="Object" />
        <variable name="SO_DETACH_FILTER" attributes="__const__" citdl="Object" />
        <variable name="SO_PEERNAME" attributes="__const__" citdl="Object" />
        <variable name="SO_TIMESTAMP" attributes="__const__" citdl="Object" />
        <variable name="SO_TIMESTAMPNS" attributes="__const__" citdl="Object" />
        <variable name="SO_BINTIME" attributes="__const__" citdl="Object" />
        <variable name="SO_RECVUCRED" attributes="__const__" citdl="Object" />
        <variable name="SO_MAC_EXEMPT" attributes="__const__" citdl="Object" />
        <variable name="SO_ALLZONES" attributes="__const__" citdl="Object" />
        <variable name="SOPRI_INTERACTIVE" attributes="__const__" citdl="Object" />
        <variable name="SOPRI_NORMAL" attributes="__const__" citdl="Object" />
        <variable name="SOPRI_BACKGROUND" attributes="__const__" citdl="Object" />
        <variable name="IPX_TYPE" attributes="__const__" citdl="Object" />
        <variable name="TCP_NODELAY" attributes="__const__" citdl="Object" />
        <variable name="TCP_MAXSEG" attributes="__const__" citdl="Object" />
        <variable name="TCP_CORK" attributes="__const__" citdl="Object" />
        <variable name="TCP_DEFER_ACCEPT" attributes="__const__" citdl="Object" />
        <variable name="TCP_INFO" attributes="__const__" citdl="Object" />
        <variable name="TCP_KEEPCNT" attributes="__const__" citdl="Object" />
        <variable name="TCP_KEEPIDLE" attributes="__const__" citdl="Object" />
        <variable name="TCP_KEEPINTVL" attributes="__const__" citdl="Object" />
        <variable name="TCP_NOOPT" attributes="__const__" citdl="Object" />
        <variable name="TCP_NOPUSH" attributes="__const__" citdl="Object" />
        <variable name="TCP_QUICKACK" attributes="__const__" citdl="Object" />
        <variable name="TCP_SYNCNT" attributes="__const__" citdl="Object" />
        <variable name="TCP_WINDOW_CLAMP" attributes="__const__" citdl="Object" />
        <variable name="UDP_CORK" attributes="__const__" citdl="Object" />
        <variable name="EAI_ADDRFAMILY" attributes="__const__" citdl="Object" />
        <variable name="EAI_AGAIN" attributes="__const__" citdl="Object" />
        <variable name="EAI_BADFLAGS" attributes="__const__" citdl="Object" />
        <variable name="EAI_FAIL" attributes="__const__" citdl="Object" />
        <variable name="EAI_FAMILY" attributes="__const__" citdl="Object" />
        <variable name="EAI_MEMORY" attributes="__const__" citdl="Object" />
        <variable name="EAI_NODATA" attributes="__const__" citdl="Object" />
        <variable name="EAI_NONAME" attributes="__const__" citdl="Object" />
        <variable name="EAI_OVERFLOW" attributes="__const__" citdl="Object" />
        <variable name="EAI_SERVICE" attributes="__const__" citdl="Object" />
        <variable name="EAI_SOCKTYPE" attributes="__const__" citdl="Object" />
        <variable name="EAI_SYSTEM" attributes="__const__" citdl="Object" />
        <variable name="EAI_BADHINTS" attributes="__const__" citdl="Object" />
        <variable name="EAI_PROTOCOL" attributes="__const__" citdl="Object" />
        <variable name="EAI_MAX" attributes="__const__" citdl="Object" />
        <variable name="AI_PASSIVE" attributes="__const__" citdl="Object" />
        <variable name="AI_CANONNAME" attributes="__const__" citdl="Object" />
        <variable name="AI_NUMERICHOST" attributes="__const__" citdl="Object" />
        <variable name="AI_NUMERICSERV" attributes="__const__" citdl="Object" />
        <variable name="AI_MASK" attributes="__const__" citdl="Object" />
        <variable name="AI_ALL" attributes="__const__" citdl="Object" />
        <variable name="AI_ADDRCONFIG" attributes="__const__" citdl="Object" />
        <variable name="AI_DEFAULT" attributes="__const__" citdl="Object" />
        <variable name="NI_MAXHOST" attributes="__const__" citdl="Object" />
        <variable name="NI_MAXSERV" attributes="__const__" citdl="Object" />
        <variable name="NI_NOFQDN" attributes="__const__" citdl="Object" />
        <variable name="NI_NUMERICHOST" attributes="__const__" citdl="Object" />
        <variable name="NI_NAMEREQD" attributes="__const__" citdl="Object" />
        <variable name="NI_NUMERICSERV" attributes="__const__" citdl="Object" />
        <variable name="NI_DGRAM" attributes="__const__" citdl="Object" />
        <variable name="SHUT_RD" attributes="__const__" citdl="Object" />
        <variable name="SHUT_WR" attributes="__const__" citdl="Object" />
        <variable name="SHUT_RDWR" attributes="__const__" citdl="Object" />
        <variable name="INET_ADDRSTRLEN" attributes="__const__" citdl="Object" />
        <variable name="IFNAMSIZ" attributes="__const__" citdl="Object" />
        <variable name="IF_NAMESIZE" attributes="__const__" citdl="Object" />
        <variable name="SOMAXCONN" attributes="__const__" citdl="Object" />
        <variable name="SCM_RIGHTS" attributes="__const__" citdl="Object" />
        <variable name="SCM_TIMESTAMP" attributes="__const__" citdl="Object" />
        <variable name="SCM_TIMESTAMPNS" attributes="__const__" citdl="Object" />
        <variable name="SCM_BINTIME" attributes="__const__" citdl="Object" />
        <variable name="SCM_CREDENTIALS" attributes="__const__" citdl="Object" />
        <variable name="SCM_CREDS" attributes="__const__" citdl="Object" />
        <variable name="SCM_UCRED" attributes="__const__" citdl="Object" />
        <variable name="LOCAL_PEERCRED" attributes="__const__" citdl="Object" />
        <variable name="LOCAL_CREDS" attributes="__const__" citdl="Object" />
        <variable name="LOCAL_CONNWAIT" attributes="__const__" citdl="Object" />
      </scope>
      <scope name="Socket" ilk="namespace">
        <scope name="AncillaryData" ilk="class" classrefs="Object">
          <scope name="int" ilk="function" signature="int(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::AncillaryData object which contains a int as data. &#xA; The size and endian is dependent on the host. &#xA; p Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)&#xA;=&gt; #&lt;Socket::AncillaryData: UNIX SOCKET RIGHTS 2&gt;" />
          <scope name="ip_pktinfo" ilk="function" signature="ip_pktinfo(p1, p2, p3 = v3)" attributes="__classmethod__" doc="Returns new ancillary data for IP_PKTINFO. &#xA; If spec_dst is not given, addr is used. &#xA; IP_PKTINFO is not standard. &#xA; Supported platform: GNU/Linux &#xA; addr = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;ifindex = 0&#xA;spec_dst = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;p Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dst)&#xA;=&gt; #&lt;Socket::AncillaryData: INET IP PKTINFO 127.0.0.1 ifindex:0 spec_dst:127.0.0.1&gt;" />
          <scope name="ipv6_pktinfo" ilk="function" signature="ipv6_pktinfo(p1, p2)" attributes="__classmethod__" doc="Returns new ancillary data for IPV6_PKTINFO. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA; addr = Addrinfo.ip(&quot;::1&quot;)&#xA;ifindex = 0&#xA;p Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;=&gt; #&lt;Socket::AncillaryData: INET6 IPV6 PKTINFO ::1 ifindex:0&gt;" />
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4)" attributes="__classmethod__ __ctor__" doc="_family_ should be an integer, a string or a symbol. Socket::AF_INET, &quot;AF_INET&quot;, &quot;INET&quot;, :AF_INET, :INET&#xA;Socket::AF_UNIX, &quot;AF_UNIX&quot;, &quot;UNIX&quot;, :AF_UNIX, :UNIX&#xA;etc. &#xA; _cmsg_level_ should be an integer, a string or a symbol. Socket::SOL_SOCKET, &quot;SOL_SOCKET&quot;, &quot;SOCKET&quot;, :SOL_SOCKET and :SOCKET&#xA;Socket::IPPROTO_IP, &quot;IP&quot; and :IP&#xA;Socket::IPPROTO_IPV6, &quot;IPV6&quot; and :IPV6&#xA;Socket::IPPROTO_TCP, &quot;TCP&quot; and :TCP&#xA;etc. &#xA; _cmsg_type_ should be an integer, a string or a symbol. If a string/symbol is specified, it is interpreted depend on _cmsg_level_. Socket::SCM_RIGHTS, &quot;SCM_RIGHTS&quot;, &quot;RIGHTS&quot;, :SCM_RIGHTS, :RIGHTS for SOL_SOCKET&#xA;Socket::IP_RECVTTL, &quot;RECVTTL&quot; and :RECVTTL for IPPROTO_IP&#xA;Socket::IPV6_PKTINFO, &quot;PKTINFO&quot; and :PKTINFO for IPPROTO_IPV6&#xA;etc. &#xA; _cmsg_data_ should be a string. " />
          <scope name="unix_rights" ilk="function" signature="unix_rights(*args)" attributes="__classmethod__" doc="Creates a new Socket::AncillaryData object which contains file descriptors as data. &#xA; p Socket::AncillaryData.unix_rights(STDERR)&#xA;=&gt; #&lt;Socket::AncillaryData: UNIX SOCKET RIGHTS 2&gt;" />
          <scope name="cmsg_is?" ilk="function" signature="cmsg_is?(p1, p2)" doc="tests the level and type of _ancillarydata_. &#xA; ancdata = Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;)&#xA;ancdata.cmsg_is?(Socket::IPPROTO_IPV6, Socket::IPV6_PKTINFO) =&gt; true&#xA;ancdata.cmsg_is?(:IPV6, :PKTINFO)       =&gt; true&#xA;ancdata.cmsg_is?(:IP, :PKTINFO)         =&gt; false&#xA;ancdata.cmsg_is?(:SOCKET, :RIGHTS)      =&gt; false" />
          <scope name="data" ilk="function" signature="data()" doc="returns the cmsg data as a string. &#xA; p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).data&#xA;=&gt; &quot;&quot;" />
          <scope name="family" ilk="function" signature="family()" doc="returns the socket family as an integer. &#xA; p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).family&#xA;=&gt; 10" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="returns a string which shows ancillarydata in human-readable form. &#xA; p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).inspect&#xA;=&gt; &quot;#&lt;Socket::AncillaryData: INET6 IPV6 PKTINFO \&quot;\&quot;&gt;&quot;" />
          <scope name="int" ilk="function" signature="int()" doc="Returns the data in _ancillarydata_ as an int. &#xA; The size and endian is dependent on the host. &#xA; ancdata = Socket::AncillaryData.int(:UNIX, :SOCKET, :RIGHTS, STDERR.fileno)&#xA;p ancdata.int =&gt; 2" />
          <scope name="ip_pktinfo" ilk="function" signature="ip_pktinfo()" doc="Extracts addr, ifindex and spec_dst from IP_PKTINFO ancillary data. &#xA; IP_PKTINFO is not standard. &#xA; Supported platform: GNU/Linux &#xA; addr = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;ifindex = 0&#xA;spec_dest = Addrinfo.ip(&quot;127.0.0.1&quot;)&#xA;ancdata = Socket::AncillaryData.ip_pktinfo(addr, ifindex, spec_dest)&#xA;p ancdata.ip_pktinfo&#xA;=&gt; [#&lt;Addrinfo: 127.0.0.1&gt;, 0, #&lt;Addrinfo: 127.0.0.1&gt;]" />
          <scope name="ipv6_pktinfo" ilk="function" signature="ipv6_pktinfo()" doc="Extracts addr and ifindex from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA; addr = Addrinfo.ip(&quot;::1&quot;)&#xA;ifindex = 0&#xA;ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;p ancdata.ipv6_pktinfo =&gt; [#&lt;Addrinfo: ::1&gt;, 0]" />
          <scope name="ipv6_pktinfo_addr" ilk="function" signature="ipv6_pktinfo_addr()" doc="Extracts addr from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA; addr = Addrinfo.ip(&quot;::1&quot;)&#xA;ifindex = 0&#xA;ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;p ancdata.ipv6_pktinfo_addr =&gt; #&lt;Addrinfo: ::1&gt;" />
          <scope name="ipv6_pktinfo_ifindex" ilk="function" signature="ipv6_pktinfo_ifindex()" doc="Extracts ifindex from IPV6_PKTINFO ancillary data. &#xA; IPV6_PKTINFO is defined by RFC 3542. &#xA; addr = Addrinfo.ip(&quot;::1&quot;)&#xA;ifindex = 0&#xA;ancdata = Socket::AncillaryData.ipv6_pktinfo(addr, ifindex)&#xA;p ancdata.ipv6_pktinfo_ifindex =&gt; 0" />
          <scope name="level" ilk="function" signature="level()" doc="returns the cmsg level as an integer. &#xA; p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).level&#xA;=&gt; 41" />
          <scope name="timestamp" ilk="function" signature="timestamp()" doc="returns the timestamp as a time object. &#xA; _ancillarydata_ should be one of following type: SOL_SOCKET/SCM_TIMESTAMP (micro second) GNU/Linux, FreeBSD, NetBSD, OpenBSD, Solaris, MacOS X&#xA;SOL_SOCKET/SCM_TIMESTAMPNS (nano second) GNU/Linux&#xA;SOL_SOCKET/SCM_BINTIME (2**(-64) second) FreeBSD &#xA; Addrinfo.udp(&quot;127.0.0.1&quot;, 0).bind {|s1| Addrinfo.udp(&quot;127.0.0.1&quot;, 0).bind {|s2|&#xA;  s1.setsockopt(:SOCKET, :TIMESTAMP, true)&#xA;  s2.send &quot;a&quot;, 0, s1.local_address&#xA;  ctl = s1.recvmsg.last&#xA;  p ctl    =&gt; #&lt;Socket::AncillaryData: INET SOCKET TIMESTAMP 2009-02-24 17:35:46.775581&gt;&#xA;  t = ctl.timestamp&#xA;  p t      =&gt; 2009-02-24 17:35:46 +0900&#xA;  p t.usec =&gt; 775581&#xA;  p t.nsec =&gt; 775581000" />
          <scope name="type" ilk="function" signature="type()" doc="returns the cmsg type as an integer. &#xA; p Socket::AncillaryData.new(:INET6, :IPV6, :PKTINFO, &quot;&quot;).type&#xA;=&gt; 2" />
          <scope name="unix_rights" ilk="function" signature="unix_rights()" doc="returns the array of IO objects for SCM_RIGHTS control message in UNIX domain socket. &#xA; The class of the IO objects in the array is IO or Socket. &#xA; The array is attached to _ancillarydata_ when it is instantiated. For example, BasicSocket#recvmsg attach the array when receives a SCM_RIGHTS control message and :scm_rights=&gt;true option is given. &#xA; # recvmsg needs :scm_rights=&gt;true for unix_rights&#xA;s1, s2 = UNIXSocket.pair&#xA;p s1                                         =&gt; #&lt;UNIXSocket:fd 3&gt;&#xA;s1.sendmsg &quot;stdin and a socket&quot;, 0, nil, Socket::AncillaryData.unix_rights(STDIN, s1)&#xA;_, _, _, ctl = s2.recvmsg(:scm_rights=&gt;true)&#xA;p ctl                                        =&gt; #&lt;Socket::AncillaryData: UNIX SOCKET RIGHTS 6 7&gt;&#xA;p ctl.unix_rights                            =&gt; [#&lt;IO:fd 6&gt;, #&lt;Socket:fd 7&gt;]&#xA;p File.identical?(STDIN, ctl.unix_rights[0]) =&gt; true&#xA;p File.identical?(s1, ctl.unix_rights[1])    =&gt; true&#xA;# If :scm_rights=&gt;true is not given, unix_rights returns nil" />
        </scope>
        <scope name="Constants" ilk="namespace">
          <variable name="SOCK_STREAM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_DGRAM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_RAW" attributes="__const__" citdl="Object" />
          <variable name="SOCK_RDM" attributes="__const__" citdl="Object" />
          <variable name="SOCK_SEQPACKET" attributes="__const__" citdl="Object" />
          <variable name="SOCK_PACKET" attributes="__const__" citdl="Object" />
          <variable name="AF_UNSPEC" attributes="__const__" citdl="Object" />
          <variable name="PF_UNSPEC" attributes="__const__" citdl="Object" />
          <variable name="AF_INET" attributes="__const__" citdl="Object" />
          <variable name="PF_INET" attributes="__const__" citdl="Object" />
          <variable name="AF_UNIX" attributes="__const__" citdl="Object" />
          <variable name="PF_UNIX" attributes="__const__" citdl="Object" />
          <variable name="AF_IPX" attributes="__const__" citdl="Object" />
          <variable name="PF_IPX" attributes="__const__" citdl="Object" />
          <variable name="AF_APPLETALK" attributes="__const__" citdl="Object" />
          <variable name="PF_APPLETALK" attributes="__const__" citdl="Object" />
          <variable name="AF_LOCAL" attributes="__const__" citdl="Object" />
          <variable name="PF_LOCAL" attributes="__const__" citdl="Object" />
          <variable name="AF_IMPLINK" attributes="__const__" citdl="Object" />
          <variable name="PF_IMPLINK" attributes="__const__" citdl="Object" />
          <variable name="AF_PUP" attributes="__const__" citdl="Object" />
          <variable name="PF_PUP" attributes="__const__" citdl="Object" />
          <variable name="AF_CHAOS" attributes="__const__" citdl="Object" />
          <variable name="PF_CHAOS" attributes="__const__" citdl="Object" />
          <variable name="AF_NS" attributes="__const__" citdl="Object" />
          <variable name="PF_NS" attributes="__const__" citdl="Object" />
          <variable name="AF_ISO" attributes="__const__" citdl="Object" />
          <variable name="PF_ISO" attributes="__const__" citdl="Object" />
          <variable name="AF_OSI" attributes="__const__" citdl="Object" />
          <variable name="PF_OSI" attributes="__const__" citdl="Object" />
          <variable name="AF_ECMA" attributes="__const__" citdl="Object" />
          <variable name="PF_ECMA" attributes="__const__" citdl="Object" />
          <variable name="AF_DATAKIT" attributes="__const__" citdl="Object" />
          <variable name="PF_DATAKIT" attributes="__const__" citdl="Object" />
          <variable name="AF_CCITT" attributes="__const__" citdl="Object" />
          <variable name="PF_CCITT" attributes="__const__" citdl="Object" />
          <variable name="AF_SNA" attributes="__const__" citdl="Object" />
          <variable name="PF_SNA" attributes="__const__" citdl="Object" />
          <variable name="AF_DEC" attributes="__const__" citdl="Object" />
          <variable name="PF_DEC" attributes="__const__" citdl="Object" />
          <variable name="AF_DLI" attributes="__const__" citdl="Object" />
          <variable name="PF_DLI" attributes="__const__" citdl="Object" />
          <variable name="AF_LAT" attributes="__const__" citdl="Object" />
          <variable name="PF_LAT" attributes="__const__" citdl="Object" />
          <variable name="AF_HYLINK" attributes="__const__" citdl="Object" />
          <variable name="PF_HYLINK" attributes="__const__" citdl="Object" />
          <variable name="AF_ROUTE" attributes="__const__" citdl="Object" />
          <variable name="PF_ROUTE" attributes="__const__" citdl="Object" />
          <variable name="AF_LINK" attributes="__const__" citdl="Object" />
          <variable name="PF_LINK" attributes="__const__" citdl="Object" />
          <variable name="AF_COIP" attributes="__const__" citdl="Object" />
          <variable name="PF_COIP" attributes="__const__" citdl="Object" />
          <variable name="AF_CNT" attributes="__const__" citdl="Object" />
          <variable name="PF_CNT" attributes="__const__" citdl="Object" />
          <variable name="AF_SIP" attributes="__const__" citdl="Object" />
          <variable name="PF_SIP" attributes="__const__" citdl="Object" />
          <variable name="AF_NDRV" attributes="__const__" citdl="Object" />
          <variable name="PF_NDRV" attributes="__const__" citdl="Object" />
          <variable name="AF_ISDN" attributes="__const__" citdl="Object" />
          <variable name="PF_ISDN" attributes="__const__" citdl="Object" />
          <variable name="AF_NATM" attributes="__const__" citdl="Object" />
          <variable name="PF_NATM" attributes="__const__" citdl="Object" />
          <variable name="AF_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="PF_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="AF_NETBIOS" attributes="__const__" citdl="Object" />
          <variable name="PF_NETBIOS" attributes="__const__" citdl="Object" />
          <variable name="AF_PPP" attributes="__const__" citdl="Object" />
          <variable name="PF_PPP" attributes="__const__" citdl="Object" />
          <variable name="AF_ATM" attributes="__const__" citdl="Object" />
          <variable name="PF_ATM" attributes="__const__" citdl="Object" />
          <variable name="AF_NETGRAPH" attributes="__const__" citdl="Object" />
          <variable name="PF_NETGRAPH" attributes="__const__" citdl="Object" />
          <variable name="AF_MAX" attributes="__const__" citdl="Object" />
          <variable name="PF_MAX" attributes="__const__" citdl="Object" />
          <variable name="AF_PACKET" attributes="__const__" citdl="Object" />
          <variable name="PF_PACKET" attributes="__const__" citdl="Object" />
          <variable name="PF_XTP" attributes="__const__" citdl="Object" />
          <variable name="PF_RTIP" attributes="__const__" citdl="Object" />
          <variable name="PF_PIP" attributes="__const__" citdl="Object" />
          <variable name="PF_KEY" attributes="__const__" citdl="Object" />
          <variable name="MSG_OOB" attributes="__const__" citdl="Object" />
          <variable name="MSG_PEEK" attributes="__const__" citdl="Object" />
          <variable name="MSG_DONTROUTE" attributes="__const__" citdl="Object" />
          <variable name="MSG_EOR" attributes="__const__" citdl="Object" />
          <variable name="MSG_TRUNC" attributes="__const__" citdl="Object" />
          <variable name="MSG_CTRUNC" attributes="__const__" citdl="Object" />
          <variable name="MSG_WAITALL" attributes="__const__" citdl="Object" />
          <variable name="MSG_DONTWAIT" attributes="__const__" citdl="Object" />
          <variable name="MSG_EOF" attributes="__const__" citdl="Object" />
          <variable name="MSG_FLUSH" attributes="__const__" citdl="Object" />
          <variable name="MSG_HOLD" attributes="__const__" citdl="Object" />
          <variable name="MSG_SEND" attributes="__const__" citdl="Object" />
          <variable name="MSG_HAVEMORE" attributes="__const__" citdl="Object" />
          <variable name="MSG_RCVMORE" attributes="__const__" citdl="Object" />
          <variable name="MSG_COMPAT" attributes="__const__" citdl="Object" />
          <variable name="MSG_PROXY" attributes="__const__" citdl="Object" />
          <variable name="MSG_FIN" attributes="__const__" citdl="Object" />
          <variable name="MSG_SYN" attributes="__const__" citdl="Object" />
          <variable name="MSG_CONFIRM" attributes="__const__" citdl="Object" />
          <variable name="MSG_RST" attributes="__const__" citdl="Object" />
          <variable name="MSG_ERRQUEUE" attributes="__const__" citdl="Object" />
          <variable name="MSG_NOSIGNAL" attributes="__const__" citdl="Object" />
          <variable name="MSG_MORE" attributes="__const__" citdl="Object" />
          <variable name="SOL_SOCKET" attributes="__const__" citdl="Object" />
          <variable name="SOL_IP" attributes="__const__" citdl="Object" />
          <variable name="SOL_IPX" attributes="__const__" citdl="Object" />
          <variable name="SOL_ATALK" attributes="__const__" citdl="Object" />
          <variable name="SOL_TCP" attributes="__const__" citdl="Object" />
          <variable name="SOL_UDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ICMP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IGMP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_GGP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_TCP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_EGP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_PUP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_UDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_IDP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_HELLO" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ND" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_TP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_XTP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_EON" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_BIP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_AH" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_DSTOPTS" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ESP" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_FRAGMENT" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_HOPOPTS" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_NONE" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_ROUTING" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_RAW" attributes="__const__" citdl="Object" />
          <variable name="IPPROTO_MAX" attributes="__const__" citdl="Object" />
          <variable name="IPPORT_RESERVED" attributes="__const__" citdl="Object" />
          <variable name="IPPORT_USERRESERVED" attributes="__const__" citdl="Object" />
          <variable name="INADDR_ANY" attributes="__const__" citdl="Object" />
          <variable name="INADDR_BROADCAST" attributes="__const__" citdl="Object" />
          <variable name="INADDR_LOOPBACK" attributes="__const__" citdl="Object" />
          <variable name="INADDR_UNSPEC_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_ALLHOSTS_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_MAX_LOCAL_GROUP" attributes="__const__" citdl="Object" />
          <variable name="INADDR_NONE" attributes="__const__" citdl="Object" />
          <variable name="IP_OPTIONS" attributes="__const__" citdl="Object" />
          <variable name="IP_HDRINCL" attributes="__const__" citdl="Object" />
          <variable name="IP_TOS" attributes="__const__" citdl="Object" />
          <variable name="IP_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVRETOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVDSTADDR" attributes="__const__" citdl="Object" />
          <variable name="IP_RETOPTS" attributes="__const__" citdl="Object" />
          <variable name="IP_MINTTL" attributes="__const__" citdl="Object" />
          <variable name="IP_DONTFRAG" attributes="__const__" citdl="Object" />
          <variable name="IP_SENDSRCADDR" attributes="__const__" citdl="Object" />
          <variable name="IP_ONESBCAST" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVTTL" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVIF" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVSLLA" attributes="__const__" citdl="Object" />
          <variable name="IP_PORTRANGE" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_IF" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
          <variable name="IP_ADD_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DROP_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DEFAULT_MULTICAST_TTL" attributes="__const__" citdl="Object" />
          <variable name="IP_DEFAULT_MULTICAST_LOOP" attributes="__const__" citdl="Object" />
          <variable name="IP_MAX_MEMBERSHIPS" attributes="__const__" citdl="Object" />
          <variable name="IP_ROUTER_ALERT" attributes="__const__" citdl="Object" />
          <variable name="IP_PKTINFO" attributes="__const__" citdl="Object" />
          <variable name="IP_PKTOPTIONS" attributes="__const__" citdl="Object" />
          <variable name="IP_MTU_DISCOVER" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVERR" attributes="__const__" citdl="Object" />
          <variable name="IP_RECVTOS" attributes="__const__" citdl="Object" />
          <variable name="IP_MTU" attributes="__const__" citdl="Object" />
          <variable name="IP_FREEBIND" attributes="__const__" citdl="Object" />
          <variable name="IP_IPSEC_POLICY" attributes="__const__" citdl="Object" />
          <variable name="IP_XFRM_POLICY" attributes="__const__" citdl="Object" />
          <variable name="IP_PASSSEC" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_DONT" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_WANT" attributes="__const__" citdl="Object" />
          <variable name="IP_PMTUDISC_DO" attributes="__const__" citdl="Object" />
          <variable name="IP_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="IP_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="IP_ADD_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_DROP_SOURCE_MEMBERSHIP" attributes="__const__" citdl="Object" />
          <variable name="IP_MSFILTER" attributes="__const__" citdl="Object" />
          <variable name="MCAST_JOIN_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_BLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_UNBLOCK_SOURCE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_LEAVE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_JOIN_SOURCE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_LEAVE_SOURCE_GROUP" attributes="__const__" citdl="Object" />
          <variable name="MCAST_MSFILTER" attributes="__const__" citdl="Object" />
          <variable name="MCAST_EXCLUDE" attributes="__const__" citdl="Object" />
          <variable name="MCAST_INCLUDE" attributes="__const__" citdl="Object" />
          <variable name="SO_DEBUG" attributes="__const__" citdl="Object" />
          <variable name="SO_REUSEADDR" attributes="__const__" citdl="Object" />
          <variable name="SO_REUSEPORT" attributes="__const__" citdl="Object" />
          <variable name="SO_TYPE" attributes="__const__" citdl="Object" />
          <variable name="SO_ERROR" attributes="__const__" citdl="Object" />
          <variable name="SO_DONTROUTE" attributes="__const__" citdl="Object" />
          <variable name="SO_BROADCAST" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDBUF" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVBUF" attributes="__const__" citdl="Object" />
          <variable name="SO_KEEPALIVE" attributes="__const__" citdl="Object" />
          <variable name="SO_OOBINLINE" attributes="__const__" citdl="Object" />
          <variable name="SO_NO_CHECK" attributes="__const__" citdl="Object" />
          <variable name="SO_PRIORITY" attributes="__const__" citdl="Object" />
          <variable name="SO_LINGER" attributes="__const__" citdl="Object" />
          <variable name="SO_PASSCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_PEERCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVLOWAT" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDLOWAT" attributes="__const__" citdl="Object" />
          <variable name="SO_RCVTIMEO" attributes="__const__" citdl="Object" />
          <variable name="SO_SNDTIMEO" attributes="__const__" citdl="Object" />
          <variable name="SO_ACCEPTCONN" attributes="__const__" citdl="Object" />
          <variable name="SO_USELOOPBACK" attributes="__const__" citdl="Object" />
          <variable name="SO_ACCEPTFILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_DONTTRUNC" attributes="__const__" citdl="Object" />
          <variable name="SO_WANTMORE" attributes="__const__" citdl="Object" />
          <variable name="SO_WANTOOBFLAG" attributes="__const__" citdl="Object" />
          <variable name="SO_NREAD" attributes="__const__" citdl="Object" />
          <variable name="SO_NKE" attributes="__const__" citdl="Object" />
          <variable name="SO_NOSIGPIPE" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_AUTHENTICATION" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_ENCRYPTION_TRANSPORT" attributes="__const__" citdl="Object" />
          <variable name="SO_SECURITY_ENCRYPTION_NETWORK" attributes="__const__" citdl="Object" />
          <variable name="SO_BINDTODEVICE" attributes="__const__" citdl="Object" />
          <variable name="SO_ATTACH_FILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_DETACH_FILTER" attributes="__const__" citdl="Object" />
          <variable name="SO_PEERNAME" attributes="__const__" citdl="Object" />
          <variable name="SO_TIMESTAMP" attributes="__const__" citdl="Object" />
          <variable name="SO_TIMESTAMPNS" attributes="__const__" citdl="Object" />
          <variable name="SO_BINTIME" attributes="__const__" citdl="Object" />
          <variable name="SO_RECVUCRED" attributes="__const__" citdl="Object" />
          <variable name="SO_MAC_EXEMPT" attributes="__const__" citdl="Object" />
          <variable name="SO_ALLZONES" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_INTERACTIVE" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_NORMAL" attributes="__const__" citdl="Object" />
          <variable name="SOPRI_BACKGROUND" attributes="__const__" citdl="Object" />
          <variable name="IPX_TYPE" attributes="__const__" citdl="Object" />
          <variable name="TCP_NODELAY" attributes="__const__" citdl="Object" />
          <variable name="TCP_MAXSEG" attributes="__const__" citdl="Object" />
          <variable name="TCP_CORK" attributes="__const__" citdl="Object" />
          <variable name="TCP_DEFER_ACCEPT" attributes="__const__" citdl="Object" />
          <variable name="TCP_INFO" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPCNT" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPIDLE" attributes="__const__" citdl="Object" />
          <variable name="TCP_KEEPINTVL" attributes="__const__" citdl="Object" />
          <variable name="TCP_NOOPT" attributes="__const__" citdl="Object" />
          <variable name="TCP_NOPUSH" attributes="__const__" citdl="Object" />
          <variable name="TCP_QUICKACK" attributes="__const__" citdl="Object" />
          <variable name="TCP_SYNCNT" attributes="__const__" citdl="Object" />
          <variable name="TCP_WINDOW_CLAMP" attributes="__const__" citdl="Object" />
          <variable name="UDP_CORK" attributes="__const__" citdl="Object" />
          <variable name="EAI_ADDRFAMILY" attributes="__const__" citdl="Object" />
          <variable name="EAI_AGAIN" attributes="__const__" citdl="Object" />
          <variable name="EAI_BADFLAGS" attributes="__const__" citdl="Object" />
          <variable name="EAI_FAIL" attributes="__const__" citdl="Object" />
          <variable name="EAI_FAMILY" attributes="__const__" citdl="Object" />
          <variable name="EAI_MEMORY" attributes="__const__" citdl="Object" />
          <variable name="EAI_NODATA" attributes="__const__" citdl="Object" />
          <variable name="EAI_NONAME" attributes="__const__" citdl="Object" />
          <variable name="EAI_OVERFLOW" attributes="__const__" citdl="Object" />
          <variable name="EAI_SERVICE" attributes="__const__" citdl="Object" />
          <variable name="EAI_SOCKTYPE" attributes="__const__" citdl="Object" />
          <variable name="EAI_SYSTEM" attributes="__const__" citdl="Object" />
          <variable name="EAI_BADHINTS" attributes="__const__" citdl="Object" />
          <variable name="EAI_PROTOCOL" attributes="__const__" citdl="Object" />
          <variable name="EAI_MAX" attributes="__const__" citdl="Object" />
          <variable name="AI_PASSIVE" attributes="__const__" citdl="Object" />
          <variable name="AI_CANONNAME" attributes="__const__" citdl="Object" />
          <variable name="AI_NUMERICHOST" attributes="__const__" citdl="Object" />
          <variable name="AI_NUMERICSERV" attributes="__const__" citdl="Object" />
          <variable name="AI_MASK" attributes="__const__" citdl="Object" />
          <variable name="AI_ALL" attributes="__const__" citdl="Object" />
          <variable name="AI_ADDRCONFIG" attributes="__const__" citdl="Object" />
          <variable name="AI_DEFAULT" attributes="__const__" citdl="Object" />
          <variable name="NI_MAXHOST" attributes="__const__" citdl="Object" />
          <variable name="NI_MAXSERV" attributes="__const__" citdl="Object" />
          <variable name="NI_NOFQDN" attributes="__const__" citdl="Object" />
          <variable name="NI_NUMERICHOST" attributes="__const__" citdl="Object" />
          <variable name="NI_NAMEREQD" attributes="__const__" citdl="Object" />
          <variable name="NI_NUMERICSERV" attributes="__const__" citdl="Object" />
          <variable name="NI_DGRAM" attributes="__const__" citdl="Object" />
          <variable name="SHUT_RD" attributes="__const__" citdl="Object" />
          <variable name="SHUT_WR" attributes="__const__" citdl="Object" />
          <variable name="SHUT_RDWR" attributes="__const__" citdl="Object" />
          <variable name="INET_ADDRSTRLEN" attributes="__const__" citdl="Object" />
          <variable name="IFNAMSIZ" attributes="__const__" citdl="Object" />
          <variable name="IF_NAMESIZE" attributes="__const__" citdl="Object" />
          <variable name="SOMAXCONN" attributes="__const__" citdl="Object" />
          <variable name="SCM_RIGHTS" attributes="__const__" citdl="Object" />
          <variable name="SCM_TIMESTAMP" attributes="__const__" citdl="Object" />
          <variable name="SCM_TIMESTAMPNS" attributes="__const__" citdl="Object" />
          <variable name="SCM_BINTIME" attributes="__const__" citdl="Object" />
          <variable name="SCM_CREDENTIALS" attributes="__const__" citdl="Object" />
          <variable name="SCM_CREDS" attributes="__const__" citdl="Object" />
          <variable name="SCM_UCRED" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_PEERCRED" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_CREDS" attributes="__const__" citdl="Object" />
          <variable name="LOCAL_CONNWAIT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Option" ilk="class" classrefs="Object">
          <scope name="bool" ilk="function" signature="bool(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::Option object which contains boolean as data. Actually 0 or 1 as int is used. &#xA; p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, true)&#xA;=&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;&#xA;&#xA;p Socket::Option.bool(:INET, :SOCKET, :KEEPALIVE, false)&#xA;=&gt; #&lt;Socket::Option: AF_INET SOCKET KEEPALIVE 0&gt;" />
          <scope name="int" ilk="function" signature="int(p1, p2, p3, p4)" attributes="__classmethod__" doc="Creates a new Socket::Option object which contains an int as data. &#xA; The size and endian is dependent on the platform. &#xA; p Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;=&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;" />
          <scope name="linger" ilk="function" signature="linger(p1, p2)" attributes="__classmethod__" doc="Creates a new Socket::Option object for SOL_SOCKET/SO_LINGER. &#xA; _onoff_ should be an integer or a boolean. &#xA; _secs_ should be the number of seconds. &#xA; p Socket::Option.linger(true, 10)&#xA;=&gt; #&lt;Socket::Option: UNSPEC SOCKET LINGER on 10sec&gt;" />
          <scope name="new" ilk="function" signature="new(p1, p2, p3, p4)" attributes="__classmethod__ __ctor__" doc="Returns a new Socket::Option object. &#xA; sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;))&#xA;p sockopt =&gt; #&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;" />
          <scope name="bool" ilk="function" signature="bool()" doc="Returns the data in _sockopt_ as an boolean value. &#xA; sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;p sockopt.bool =&gt; true" />
          <scope name="data" ilk="function" signature="data()" doc="returns the socket option data as a string. &#xA; p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).data&#xA;=&gt; &quot;\x01\x00\x00\x00&quot;" />
          <scope name="family" ilk="function" signature="family()" doc="returns the socket family as an integer. &#xA; p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).family&#xA;=&gt; 10" />
          <scope name="inspect" ilk="function" signature="inspect()" doc="Returns a string which shows sockopt in human-readable form. &#xA; p Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;)).inspect&#xA;=&gt; &quot;#&lt;Socket::Option: INET SOCKET KEEPALIVE 1&gt;&quot;" />
          <scope name="int" ilk="function" signature="int()" doc="Returns the data in _sockopt_ as an int. &#xA; The size and endian is dependent on the platform. &#xA; sockopt = Socket::Option.int(:INET, :SOCKET, :KEEPALIVE, 1)&#xA;p sockopt.int =&gt; 1" />
          <scope name="level" ilk="function" signature="level()" doc="returns the socket level as an integer. &#xA; p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).level&#xA;=&gt; 41" />
          <scope name="linger" ilk="function" signature="linger()" doc="Returns the linger data in _sockopt_ as a pair of boolean and integer. &#xA; sockopt = Socket::Option.linger(true, 10)&#xA;p sockopt.linger =&gt; [true, 10]" />
          <scope name="optname" ilk="function" signature="optname()" doc="returns the socket option name as an integer. &#xA; p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).optname&#xA;=&gt; 2" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="returns the socket option data as a string. &#xA; p Socket::Option.new(:INET6, :IPV6, :RECVPKTINFO, [1].pack(&quot;i!&quot;)).data&#xA;=&gt; &quot;\x01\x00\x00\x00&quot;" />
          <scope name="unpack" ilk="function" signature="unpack(p1)" doc="Calls String#unpack on sockopt.data. &#xA; sockopt = Socket::Option.new(:INET, :SOCKET, :KEEPALIVE, [1].pack(&quot;i&quot;))&#xA;p sockopt.unpack(&quot;i&quot;)      =&gt; [1]&#xA;p sockopt.data.unpack(&quot;i&quot;) =&gt; [1]" />
        </scope>
        <scope name="UDPSource" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(remote_address, local_address, &amp;reply_proc)" attributes="__classmethod__ __ctor__" doc="+remote_adress+ is an Addrinfo object. &#xA; +local_adress+ is an Addrinfo object. &#xA; +reply_proc+ is a Proc used to send reply back to the source." />
          <scope name="reply" ilk="function" signature="reply(msg)" doc="Sends the String +msg+ to the source" />
          <scope ilk="function" name="local_address" />
          <scope ilk="function" name="remote_address" />
        </scope>
      </scope>
      <scope name="SocketError" ilk="class" classrefs="StandardError">
      </scope>
      <scope name="TCPServer" ilk="class" classrefs="TCPSocket">
        <scope name="new" ilk="function" signature="new(p1 = v1, p2)" attributes="__classmethod__ __ctor__" doc="Creates a new server socket bound to _port_. &#xA; If _hostname_ is given, the socket is bound to it. &#xA; serv = TCPServer.new(&quot;127.0.0.1&quot;, 28561)&#xA;s = serv.accept&#xA;s.puts Time.now&#xA;s.close" />
        <scope name="accept" ilk="function" signature="accept()" doc="TCPServer.open(&quot;127.0.0.1&quot;, 14641) {|serv| s = serv.accept&#xA;s.puts Time.now&#xA;s.close&#xA; }" />
        <scope name="accept_nonblock" ilk="function" signature="accept_nonblock()" doc="Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an accepted TCPSocket for the incoming connection. &#xA; Example require &apos;socket&apos;&#xA;serv = TCPServer.new(2202)&#xA;begin # emulate blocking accept&#xA;  sock = serv.accept_nonblock&#xA;rescue IO::WaitReadable, Errno::EINTR&#xA;  IO.select([serv])&#xA;  retry&#xA;end&#xA;# sock is an accepted socket.&#xA; Refer to Socket#accept for the exceptions that may be thrown if the call to TCPServer#accept_nonblock fails. &#xA; TCPServer#accept_nonblock may raise any error corresponding to accept(2) failure, including Errno::EWOULDBLOCK. &#xA; If the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED, Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock. " />
        <scope name="listen" ilk="function" signature="listen(p1)" doc="Listens for connections, using the specified +int+ as the backlog. A call to _listen_ only applies if the +socket+ is of type SOCK_STREAM or SOCK_SEQPACKET. &#xA; Parameter +backlog+ - the maximum length of the queue for pending connections. &#xA; Example 1 require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA;socket.listen( 5 )&#xA; Example 2 (listening on an arbitrary port, unix-based systems only): require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;socket.listen( 1 )&#xA; Unix-based Exceptions On unix based systems the above will work because a new +sockaddr+ struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the +socket+ is bound by calling _bind_ before it can _listen_. " />
        <scope name="sysaccept" ilk="function" signature="sysaccept()" doc="Returns a file descriptor of a accepted connection. &#xA; TCPServer.open(&quot;127.0.0.1&quot;, 28561) {|serv|&#xA;  fd = serv.sysaccept&#xA;  s = IO.for_fd(fd)&#xA;  s.puts Time.now&#xA;  s.close&#xA;}" />
      </scope>
      <scope name="TCPSocket" ilk="class" classrefs="IPSocket">
        <scope name="gethostbyname" ilk="function" signature="gethostbyname(p1)" attributes="__classmethod__" doc="Lookups host information by _hostname_. &#xA; TCPSocket.gethostbyname(&quot;localhost&quot;)&#xA;=&gt; [&quot;localhost&quot;, [&quot;hal&quot;], 2, &quot;127.0.0.1&quot;]" />
        <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="Opens a TCP connection to +remote_host+ on +remote_port+.  If +local_host+ and +local_port+ are specified, then those parameters are used on the local end to establish the connection." />
        <scope name="new" ilk="function" signature="new(p1, p2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="Opens a TCP connection to +remote_host+ on +remote_port+.  If +local_host+ and +local_port+ are specified, then those parameters are used on the local end to establish the connection." />
      </scope>
      <scope name="UDPSocket" ilk="class" classrefs="IPSocket">
        <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" doc="Creates a new UDPSocket object. &#xA; _address_family_ should be an integer, a string or a symbol: Socket::AF_INET, &quot;AF_INET&quot;, :INET, etc. &#xA; UDPSocket.new                   =&gt; #&lt;UDPSocket:fd 3&gt;&#xA;UDPSocket.new(Socket::AF_INET6) =&gt; #&lt;UDPSocket:fd 4&gt;" />
        <scope name="bind" ilk="function" signature="bind(host, port)" doc="Binds _udpsocket_ to _host_:_port_. &#xA; u1 = UDPSocket.new&#xA;u1.bind(&quot;127.0.0.1&quot;, 4913)&#xA;u1.send &quot;message-to-self&quot;, 0, &quot;127.0.0.1&quot;, 4913&#xA;p u1.recvfrom(10) =&gt; [&quot;message-to&quot;, [&quot;AF_INET&quot;, 4913, &quot;localhost&quot;, &quot;127.0.0.1&quot;]]" />
        <scope name="connect" ilk="function" signature="connect(host, port)" doc="Connects _udpsocket_ to _host_:_port_. &#xA; This makes possible to send without destination address. &#xA; u1 = UDPSocket.new&#xA;u1.bind(&quot;127.0.0.1&quot;, 4913)&#xA;u2 = UDPSocket.new&#xA;u2.connect(&quot;127.0.0.1&quot;, 4913)&#xA;u2.send &quot;uuuu&quot;, 0&#xA;p u1.recvfrom(10) =&gt; [&quot;uuuu&quot;, [&quot;AF_INET&quot;, 33230, &quot;localhost&quot;, &quot;127.0.0.1&quot;]]" />
        <scope name="recvfrom_nonblock" ilk="function" signature="recvfrom_nonblock(*args)" doc="Receives up to _maxlen_ bytes from +udpsocket+ using recvfrom(2) after O_NONBLOCK is set for the underlying file descriptor. If _maxlen_ is omitted, its default value is 65536. _flags_ is zero or more of the +MSG_+ options. The first element of the results, _mesg_, is the data received. The second element, _sender_inet_addr_, is an array to represent the sender address. &#xA; When recvfrom(2) returns 0, Socket#recvfrom_nonblock returns an empty string as data. It means an empty packet. &#xA; Parameters +maxlen+ - the number of bytes to receive from the socket&#xA;+flags+ - zero or more of the +MSG_+ options &#xA; Example require &apos;socket&apos;&#xA;s1 = UDPSocket.new&#xA;s1.bind(&quot;127.0.0.1&quot;, 0)&#xA;s2 = UDPSocket.new&#xA;s2.bind(&quot;127.0.0.1&quot;, 0)&#xA;s2.connect(*s1.addr.values_at(3,1))&#xA;s1.connect(*s2.addr.values_at(3,1))&#xA;s1.send &quot;aaa&quot;, 0&#xA;begin # emulate blocking recvfrom" />
        <scope name="send" ilk="function" signature="send(mesg, flags, *rest)" doc="Sends _mesg_ via _udpsocket_. &#xA; _flags_ should be a bitwise OR of Socket::MSG_* constants. &#xA; u1 = UDPSocket.new&#xA;u1.bind(&quot;127.0.0.1&quot;, 4913)&#xA;&#xA;u2 = UDPSocket.new&#xA;u2.send &quot;hi&quot;, 0, &quot;127.0.0.1&quot;, 4913&#xA;&#xA;mesg, addr = u1.recvfrom(10)&#xA;u1.send mesg, 0, addr[3], addr[1]&#xA;&#xA;p u2.recv(100) =&gt; &quot;hi&quot;" />
      </scope>
      <scope name="UNIXServer" ilk="class" classrefs="UNIXSocket">
        <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="Creates a new UNIX server socket bound to _path_. &#xA; serv = UNIXServer.new(&quot;/tmp/sock&quot;)&#xA;s = serv.accept&#xA;p s.read" />
        <scope name="accept" ilk="function" signature="accept()" doc="Accepts a new connection. It returns new UNIXSocket object. &#xA; UNIXServer.open(&quot;/tmp/sock&quot;) {|serv|&#xA;  UNIXSocket.open(&quot;/tmp/sock&quot;) {|c|&#xA;    s = serv.accept&#xA;    s.puts &quot;hi&quot;&#xA;    s.close&#xA;    p c.read =&gt; &quot;hi\n&quot;&#xA;  }&#xA;}" />
        <scope name="accept_nonblock" ilk="function" signature="accept_nonblock()" doc="Accepts an incoming connection using accept(2) after O_NONBLOCK is set for the underlying file descriptor. It returns an accepted UNIXSocket for the incoming connection. &#xA; Example require &apos;socket&apos;&#xA;serv = UNIXServer.new(&quot;/tmp/sock&quot;)&#xA;begin # emulate blocking accept&#xA;  sock = serv.accept_nonblock&#xA;rescue IO::WaitReadable, Errno::EINTR&#xA;  IO.select([serv])&#xA;  retry&#xA;end&#xA;# sock is an accepted socket.&#xA; Refer to Socket#accept for the exceptions that may be thrown if the call to UNIXServer#accept_nonblock fails. &#xA; UNIXServer#accept_nonblock may raise any error corresponding to accept(2) failure, including Errno::EWOULDBLOCK. &#xA; If the exception is Errno::EWOULDBLOCK, Errno::AGAIN, Errno::ECONNABORTED or Errno::EPROTO, it is extended by IO::WaitReadable. So IO::WaitReadable can be used to rescue the exceptions for retrying accept_nonblock. " />
        <scope name="listen" ilk="function" signature="listen(p1)" doc="Listens for connections, using the specified +int+ as the backlog. A call to _listen_ only applies if the +socket+ is of type SOCK_STREAM or SOCK_SEQPACKET. &#xA; Parameter +backlog+ - the maximum length of the queue for pending connections. &#xA; Example 1 require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;sockaddr = Socket.pack_sockaddr_in( 2200, &apos;localhost&apos; )&#xA;socket.bind( sockaddr )&#xA;socket.listen( 5 )&#xA; Example 2 (listening on an arbitrary port, unix-based systems only): require &apos;socket&apos;&#xA;include Socket::Constants&#xA;socket = Socket.new( AF_INET, SOCK_STREAM, 0 )&#xA;socket.listen( 1 )&#xA; Unix-based Exceptions On unix based systems the above will work because a new +sockaddr+ struct is created on the address ADDR_ANY, for an arbitrary port number as handed off by the kernel. It will not work on Windows, because Windows requires that the +socket+ is bound by calling _bind_ before it can _listen_. " />
        <scope name="sysaccept" ilk="function" signature="sysaccept()" doc="Accepts a new connection. It returns the new file descriptor which is an integer. &#xA; UNIXServer.open(&quot;/tmp/sock&quot;) {|serv|&#xA;  UNIXSocket.open(&quot;/tmp/sock&quot;) {|c|&#xA;    fd = serv.sysaccept&#xA;    s = IO.new(fd)&#xA;    s.puts &quot;hi&quot;&#xA;    s.close&#xA;    p c.read =&gt; &quot;hi\n&quot;&#xA;  }&#xA;}" />
      </scope>
      <scope name="UNIXSocket" ilk="class" classrefs="BasicSocket">
        <scope name="new" ilk="function" signature="new(p1)" attributes="__classmethod__ __ctor__" doc="Creates a new UNIX client socket connected to _path_. &#xA; s = UNIXSocket.new(&quot;/tmp/sock&quot;)&#xA;s.send &quot;hello&quot;, 0" />
        <scope name="pair" ilk="function" signature="pair(p1 = v1, p2 = v2)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA; s1, s2 = UNIXSocket.pair&#xA;s1.send &quot;a&quot;, 0&#xA;s1.send &quot;b&quot;, 0&#xA;p s2.recv(10) =&gt; &quot;ab&quot;" />
        <scope name="socketpair" ilk="function" signature="socketpair(p1 = v1, p2 = v2)" attributes="__classmethod__" doc="Creates a pair of sockets connected each other. &#xA; _socktype_ should be a socket type such as: :STREAM, :DGRAM, :RAW, etc. &#xA; _protocol_ should be a protocol defined in the domain. 0 is default protocol for the domain. &#xA; s1, s2 = UNIXSocket.pair&#xA;s1.send &quot;a&quot;, 0&#xA;s1.send &quot;b&quot;, 0&#xA;p s2.recv(10) =&gt; &quot;ab&quot;" />
        <scope name="addr" ilk="function" signature="addr()" doc="Returns the local address as an array which contains address_family and unix_path. &#xA; Example serv = UNIXServer.new(&quot;/tmp/sock&quot;)&#xA;p serv.addr =&gt; [&quot;AF_UNIX&quot;, &quot;/tmp/sock&quot;]" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the path of the local address of unixsocket. &#xA; s = UNIXServer.new(&quot;/tmp/sock&quot;)&#xA;p s.path =&gt; &quot;/tmp/sock&quot;" />
        <scope name="peeraddr" ilk="function" signature="peeraddr()" doc="Returns the remote address as an array which contains address_family and unix_path. &#xA; Example serv = UNIXServer.new(&quot;/tmp/sock&quot;)&#xA;c = UNIXSocket.new(&quot;/tmp/sock&quot;)&#xA;p c.peeraddr =&gt; [&quot;AF_UNIX&quot;, &quot;/tmp/sock&quot;]" />
        <scope name="recv_io" ilk="function" signature="recv_io(p1 = v1, p2 = v2)" doc="UNIXServer.open(&quot;/tmp/sock&quot;) {|serv| UNIXSocket.open(&quot;/tmp/sock&quot;) {|c|&#xA;  s = serv.accept&#xA;&#xA;  c.send_io STDOUT&#xA;  stdout = s.recv_io&#xA;&#xA;  p STDOUT.fileno =&gt; 1&#xA;  p stdout.fileno =&gt; 7&#xA;&#xA;  stdout.puts &quot;hello&quot; # outputs &quot;hello\n&quot; to standard output.&#xA;}&#xA; }" />
        <scope name="recvfrom" ilk="function" signature="recvfrom(*args)" doc="Receives a message via _unixsocket_. &#xA; _maxlen_ is the maximum number of bytes to receive. &#xA; _flags_ should be a bitwise OR of Socket::MSG_* constants. &#xA; s1 = Socket.new(:UNIX, :DGRAM, 0)&#xA;s1_ai = Addrinfo.unix(&quot;/tmp/sock1&quot;)&#xA;s1.bind(s1_ai)&#xA;&#xA;s2 = Socket.new(:UNIX, :DGRAM, 0)&#xA;s2_ai = Addrinfo.unix(&quot;/tmp/sock2&quot;)&#xA;s2.bind(s2_ai)&#xA;s3 = UNIXSocket.for_fd(s2.fileno)&#xA;&#xA;s1.send &quot;a&quot;, 0, s2_ai&#xA;p s3.recvfrom(10) =&gt; [&quot;a&quot;, [&quot;AF_UNIX&quot;, &quot;/tmp/sock1&quot;]]" />
        <scope name="send_io" ilk="function" signature="send_io(p1)" doc="Sends _io_ as file descriptor passing. &#xA; s1, s2 = UNIXSocket.pair&#xA;&#xA;s1.send_io STDOUT&#xA;stdout = s2.recv_io&#xA;&#xA;p STDOUT.fileno =&gt; 1&#xA;p stdout.fileno =&gt; 6&#xA;&#xA;stdout.puts &quot;hello&quot; # outputs &quot;hello\n&quot; to standard output." />
      </scope>
    </scope>
    <scope name="sync" ilk="blob" lang="Ruby">
      <scope name="Sync" ilk="class" classrefs="Object">
        <import symbol="Sync_m" />
      </scope>
      <scope name="Sync_m" ilk="namespace">
        <scope ilk="function" name="sync_ex_count" />
        <scope ilk="function" name="sync_ex_count=" />
        <scope ilk="function" name="sync_ex_locker" />
        <scope ilk="function" name="sync_ex_locker=" />
        <scope ilk="function" name="sync_mode" />
        <scope ilk="function" name="sync_mode=" />
        <scope ilk="function" name="sync_sh_locker" />
        <scope ilk="function" name="sync_sh_locker=" />
        <scope ilk="function" name="sync_upgrade_waiting" />
        <scope ilk="function" name="sync_upgrade_waiting=" />
        <scope ilk="function" name="sync_waiting" />
        <scope ilk="function" name="sync_waiting=" />
        <variable name="RCS_ID" attributes="__const__" citdl="Object" />
        <variable name="UN" attributes="__const__" citdl="Object" />
        <variable name="SH" attributes="__const__" citdl="Object" />
        <variable name="EX" attributes="__const__" citdl="Object" />
        <scope name="Err" ilk="class" classrefs="StandardError">
          <scope name="Fail" ilk="function" signature="Fail(*opt)" attributes="__classmethod__" />
          <scope name="LockModeFailer" ilk="class" classrefs="Sync_m::Err">
            <scope name="Fail" ilk="function" signature="Fail(mode)" attributes="__classmethod__" />
          </scope>
          <scope name="UnknownLocker" ilk="class" classrefs="Sync_m::Err">
            <scope name="Fail" ilk="function" signature="Fail(th)" attributes="__classmethod__" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="syslog" ilk="blob" lang="Ruby">
      <scope name="Syslog" ilk="namespace">
        <import symbol="Syslog::Constants" />
        <scope name="LOG_MASK" ilk="function" signature="LOG_MASK(p1)" attributes="__classmethod__" doc="Generates a mask bit for a priority level. See #mask=" />
        <scope name="LOG_UPTO" ilk="function" signature="LOG_UPTO(p1)" attributes="__classmethod__" doc="Generates a mask value for priority levels at or below the level specified. See #mask=" />
        <scope name="close" ilk="function" signature="close()" attributes="__classmethod__" doc="Closes the syslog facility. Raises a runtime exception if it is not open." />
        <scope name="facility" ilk="function" signature="facility()" attributes="__classmethod__" doc="Returns the facility number used in the last call to open()" />
        <scope name="ident" ilk="function" signature="ident()" attributes="__classmethod__" doc="Returns the identity string used in the last call to open()" />
        <scope name="inspect" ilk="function" signature="inspect()" attributes="__classmethod__" doc="Returns an inspect() string summarizing the object state." />
        <scope name="instance" ilk="function" signature="instance()" attributes="__classmethod__" doc="Returns self, for backward compatibility." />
        <scope name="log" ilk="function" signature="log(*args)" attributes="__classmethod__" doc="Log a message with the specified priority. Example: &#xA; Syslog.log(Syslog::LOG_CRIT, &quot;Out of disk space&quot;)&#xA;Syslog.log(Syslog::LOG_CRIT, &quot;User %s logged in&quot;, ENV[&apos;USER&apos;])&#xA; The priority levels, in descending order, are: &#xA; System is unusable&#xA;Action needs to be taken immediately&#xA;A critical condition has occurred&#xA;An error occurred&#xA;Warning of a possible problem&#xA;A normal but significant condition occurred&#xA;Informational message&#xA;Debugging information &#xA; Each priority level also has a shortcut method that logs with it&apos;s named priority. As an example, the two following statements would produce the same result: " />
        <scope name="mask" ilk="function" signature="mask()" attributes="__classmethod__" doc="Returns the log priority mask in effect. The mask is not reset by opening or closing syslog." />
        <scope name="mask=" ilk="function" signature="mask=(p1)" attributes="__classmethod__" doc="Sets the log priority mask. A method LOG_UPTO is defined to make it easier to set mask values. Example: &#xA; Syslog.mask = Syslog::LOG_UPTO(Syslog::LOG_ERR)&#xA; Alternatively, specific priorities can be selected and added together using binary OR. Example: &#xA; Syslog.mask = Syslog::LOG_MASK(Syslog::LOG_ERR) | Syslog::LOG_MASK(Syslog::LOG_CRIT)&#xA; The priority mask persists through calls to open() and close()." />
        <scope name="open" ilk="function" signature="open(p1 = v1, p2 = v2, p3 = v3)" attributes="__classmethod__" doc="Open the syslog facility. Raises a runtime exception if it is already open. &#xA; Can be called with or without a code block. If called with a block, the Syslog object created is passed to the block. &#xA; If the syslog is already open, raises a RuntimeError. &#xA; +ident+ is a String which identifies the calling program. &#xA; +options+ is the logical OR of any of the following: &#xA; If there is an error while sending to the system logger, write directly to the console instead. &#xA;Open the connection now, rather than waiting for the first message to be written. &#xA;Don&apos;t wait for any child processes created while logging messages. (Has no effect on Linux.) &#xA;Opposite of LOG_NDELAY; wait until a message is sent before opening the connection. (This is the default.) &#xA;Print the message to stderr as well as sending it to syslog. (Not in POSIX.1-2001.) &#xA;Include the current process ID with each message. &#xA; +facility+ describes the type of program opening the syslog, and is the logical OR of any of the following which are defined for the host OS: &#xA; Security or authorization. Deprecated, use LOG_AUTHPRIV instead. " />
        <scope name="open!" ilk="function" signature="open!(*args)" attributes="__classmethod__" doc="Closes and then reopens the syslog. &#xA; Arguments are the same as for open()." />
        <scope name="opened?" ilk="function" signature="opened?()" attributes="__classmethod__" doc="Returns true if the syslog is open." />
        <scope name="options" ilk="function" signature="options()" attributes="__classmethod__" doc="Returns the options bitmask used in the last call to open()" />
        <scope name="reopen" ilk="function" signature="reopen(*args)" attributes="__classmethod__" doc="Closes and then reopens the syslog. &#xA; Arguments are the same as for open()." />
        <scope name="Constants" ilk="namespace">
          <scope name="LOG_MASK" ilk="function" signature="LOG_MASK(p1)" attributes="__classmethod__" doc="Generates a mask bit for a priority level. See #mask=" />
          <scope name="LOG_UPTO" ilk="function" signature="LOG_UPTO(p1)" attributes="__classmethod__" doc="Generates a mask value for priority levels at or below the level specified. See #mask=" />
        </scope>
      </scope>
    </scope>
    <scope name="tempfile" ilk="blob" lang="Ruby">
      <scope name="Tempfile" ilk="class" classrefs="DelegateClass(File)">
        <scope name="new" ilk="function" signature="new(basename, *rest)" attributes="__classmethod__ __ctor__" doc="Creates a temporary file with permissions 0600 (= only readable and writable by the owner) and opens it with mode &quot;w+&quot;. &#xA; The +basename+ parameter is used to determine the name of the temporary file. You can either pass a String or an Array with 2 String elements. In the former form, the temporary file&apos;s base name will begin with the given string. In the latter form, the temporary file&apos;s base name will begin with the array&apos;s first element, and end with the second element. For example: &#xA; file = Tempfile.new(&apos;hello&apos;)&#xA;file.path  # =&gt; something like: &quot;/tmp/hello2843-8392-92849382--0&quot;&#xA;# Use the Array form to enforce an extension in the filename:&#xA;file = Tempfile.new([&apos;hello&apos;, &apos;.jpg&apos;])&#xA;file.path  # =&gt; something like: &quot;/tmp/hello2843-8392-92849382--0.jpg&quot;&#xA; The temporary file will be placed in the directory as specified by the +tmpdir+ parameter. By default, this is +Dir.tmpdir+. When $SAFE &gt; 0 and the given +tmpdir+ is tainted, it uses &apos;/tmp&apos; as the temporary directory. Please note that ENV values are tainted by default, and +Dir.tmpdir+&apos;s return value might come from environment variables (e.g. $TMPDIR). &#xA; file = Tempfile.new(&apos;hello&apos;, &apos;/home/aisaka&apos;)&#xA;file.path  # =&gt; something like: &quot;/home/aisaka/hello2843-8392-92849382--0&quot;&#xA; You can also pass an options hash. Under the hood, Tempfile creates the temporary file using +File.open+. These options will be passed to +File.open+. This is mostly useful for specifying encoding options, e.g.: &#xA; Tempfile.new(&apos;hello&apos;, &apos;/home/aisaka&apos;, :encoding =&gt; &apos;ascii-8bit&apos;)&#xA;# You can also omit the &apos;tmpdir&apos; parameter:" />
        <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Creates a new Tempfile. &#xA; If no block is given, this is a synonym for Tempfile.new. &#xA; If a block is given, then a Tempfile object will be constructed, and the block is run with said object as argument. The Tempfile oject will be automatically closed after the block terminates. The call returns the value of the block. &#xA; In any case, all arguments (+*args+) will be passed to Tempfile.new. &#xA; Tempfile.open(&apos;foo&apos;, &apos;/home/temp&apos;) do |f|&#xA;   ... do something with f ...&#xA;end&#xA;# Equivalent:&#xA;f = Tempfile.open(&apos;foo&apos;, &apos;/home/temp&apos;)&#xA;begin&#xA;   ... do something with f ...&#xA;ensure&#xA;   f.close" />
        <scope name="close" ilk="function" signature="close(unlink_now=false)" doc="Closes the file. If +unlink_now+ is true, then the file will be unlinked (deleted) after closing. Of course, you can choose to later call #unlink if you do not unlink it now. &#xA; If you don&apos;t explicitly unlink the temporary file, the removal will be delayed until the object is finalized." />
        <scope name="close!" ilk="function" signature="close!()" doc="Closes and unlinks (deletes) the file. Has the same effect as called close(true)." />
        <scope name="delete" ilk="function" signature="delete()" />
        <scope name="length" ilk="function" signature="length()" />
        <scope name="open" ilk="function" signature="open()" doc="Opens or reopens the file with mode &quot;r+&quot;." />
        <scope name="path" ilk="function" signature="path()" doc="Returns the full path name of the temporary file. This will be nil if #unlink has been called." />
        <scope name="size" ilk="function" signature="size()" doc="Returns the size of the temporary file.  As a side effect, the IO buffer is flushed before determining the size." />
        <scope name="unlink" ilk="function" signature="unlink()" doc="Unlinks (deletes) the file from the filesystem. One should always unlink the file after using it, as is explained in the &quot;Explicit close&quot; good practice section in the Tempfile overview: &#xA; file = Tempfile.new(&apos;foo&apos;)&#xA;begin&#xA;   ...do something with file...&#xA;ensure&#xA;   file.close&#xA;   file.unlink   # deletes the temp file&#xA;end&#xA; Unlink-before-close &#xA; On POSIX systems it&apos;s possible to unlink a file before closing it. This practice is explained in detail in the Tempfile overview (section &quot;Unlink after creation&quot;); please refer there for more information. &#xA; However, unlink-before-close may not be supported on non-POSIX operating systems. Microsoft Windows is the most notable case: unlinking a non-closed file will result in an error, which this method will silently ignore. If you want to practice unlink-before-close whenever possible, then you should write code like this: &#xA; file = Tempfile.new(&apos;foo&apos;)&#xA;file.unlink   # On Windows this silently fails." />
        <variable name="MAX_TRY" attributes="__const__" citdl="Object" />
        <scope name="Remover" ilk="class" classrefs="Object">
        </scope>
      </scope>
    </scope>
    <scope name="test/unit" ilk="blob" lang="Ruby">
      <scope name="Test" ilk="namespace">
        <scope name="Unit" ilk="namespace">
          <variable name="TEST_UNIT_IMPLEMENTATION" attributes="__const__" citdl="Object" />
          <scope name="AutoRunner" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(force_standalone = false, default_dir = nil, argv = ARGV)" attributes="__classmethod__ __ctor__" />
            <scope name="run" ilk="function" signature="run(*args)" attributes="__classmethod__" />
            <scope name="process_args" ilk="function" signature="process_args(*args)" />
            <scope name="run" ilk="function" signature="run()" />
            <scope ilk="function" name="options" />
            <scope ilk="function" name="options=" />
            <scope ilk="function" name="to_run" />
            <scope ilk="function" name="to_run=" />
            <scope name="Runner" ilk="class" classrefs="Test::Unit::Runner">
              <import symbol="Test::Unit::RequireFiles" />
            </scope>
          </scope>
          <scope name="GCStressOption" ilk="namespace">
            <scope name="non_options" ilk="function" signature="non_options(files, options)" />
            <scope name="setup_options" ilk="function" signature="setup_options(parser, options)" />
          </scope>
          <scope name="GlobOption" ilk="namespace">
            <import symbol="Options" />
            <scope name="non_options" ilk="function" signature="non_options(files, options)" />
            <scope name="setup_options" ilk="function" signature="setup_options(parser, options)" />
          </scope>
          <scope name="LoadPathOption" ilk="namespace">
            <import symbol="Options" />
            <scope name="setup_options" ilk="function" signature="setup_options(parser, options)" />
          </scope>
          <scope name="Options" ilk="namespace">
            <scope name="new" ilk="function" signature="new(*, &amp;block)" attributes="__classmethod__ __ctor__" />
            <scope name="option_parser" ilk="function" signature="option_parser()" />
            <scope name="process_args" ilk="function" signature="process_args(args = [])" />
          </scope>
          <scope name="RequireFiles" ilk="namespace">
            <scope name="non_options" ilk="function" signature="non_options(files, options)" />
          </scope>
          <scope name="RunCount" ilk="namespace">
            <scope name="have_run?" ilk="function" signature="have_run?()" attributes="__classmethod__" />
            <scope name="run_once" ilk="function" signature="run_once()" attributes="__classmethod__" />
            <scope name="run" ilk="function" signature="run(*)" />
          </scope>
          <scope name="Runner" ilk="class" classrefs="MiniTest::Unit">
            <import symbol="Test::Unit::GCStressOption" />
            <import symbol="Test::Unit::GlobOption" />
            <import symbol="Test::Unit::LoadPathOption" />
            <import symbol="Test::Unit::Options" />
            <import symbol="Test::Unit::RunCount" />
            <scope name="autorun" ilk="function" signature="autorun()" attributes="__classmethod__" />
            <scope name="_run_parallel" ilk="function" signature="_run_parallel(suites, type, result)" />
            <scope name="_run_suites" ilk="function" signature="_run_suites(suites, type)" />
            <scope name="after_worker_down" ilk="function" signature="after_worker_down(worker, e=nil, c=false)" />
            <scope name="after_worker_quit" ilk="function" signature="after_worker_quit(worker)" />
            <scope name="del_jobs_status" ilk="function" signature="del_jobs_status()" />
            <scope name="jobs_status" ilk="function" signature="jobs_status()" />
            <scope name="puke" ilk="function" signature="puke(klass, meth, e)" doc="Overriding of MiniTest::Unit#puke" />
            <scope name="status" ilk="function" signature="status(*args)" />
            <scope name="Worker" ilk="class" classrefs="Object">
              <scope name="launch" ilk="function" signature="launch(ruby,args=[])" attributes="__classmethod__" />
              <scope name="new" ilk="function" signature="new(io, pid, status)" attributes="__classmethod__ __ctor__" />
              <scope name="close" ilk="function" signature="close()" />
              <scope name="died" ilk="function" signature="died(*additional)" />
              <scope name="hook" ilk="function" signature="hook(id,&amp;block)" />
              <scope name="puts" ilk="function" signature="puts(*args)" />
              <scope name="read" ilk="function" signature="read()" />
              <scope name="run" ilk="function" signature="run(task,type)" />
              <scope name="to_s" ilk="function" signature="to_s()" />
              <scope ilk="function" name="file" />
              <scope ilk="function" name="file=" />
              <scope ilk="function" name="io" />
              <scope ilk="function" name="loadpath" />
              <scope ilk="function" name="loadpath=" />
              <scope ilk="function" name="pid" />
              <scope ilk="function" name="real_file" />
              <scope ilk="function" name="real_file=" />
              <scope ilk="function" name="status" />
              <scope ilk="function" name="status=" />
            </scope>
          </scope>
          <scope name="Worker" ilk="class" classrefs="Runner">
            <scope name="_run_suite" ilk="function" signature="_run_suite(suite, type)" />
            <scope name="_run_suites" ilk="function" signature="_run_suites(suites, type)" />
            <scope name="increment_io" ilk="function" signature="increment_io(orig)" />
            <scope name="orig_run_suite" ilk="function" signature="orig_run_suite(suite, type)" />
            <scope name="run" ilk="function" signature="run(args = [])" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="thwait" ilk="blob" lang="Ruby">
      <scope name="ThreadsWait" ilk="class" classrefs="Object">
        <scope ilk="function" name="threads" />
        <variable name="RCS_ID" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="timeout" ilk="blob" lang="Ruby">
      <scope name="Timeout" ilk="namespace">
        <scope name="timeout" ilk="function" signature="timeout(sec, klass = nil)" attributes="__classmethod__" doc="Perform an operation in a block, timing it out if it takes longer than +sec+ seconds to complete. &#xA; Number of seconds to wait for the block to terminate. Any number may be used, including Floats to specify fractional seconds.&#xA;Exception Class to raise if the block fails to terminate in +sec+ seconds.  Omitting will use the default, Timeout::Error &#xA; The block will be executed on another thread and will be given one argument: +sec+. &#xA; Returns the result of the block *if* the block completed before +sec+ seconds, otherwise throws an exception, based on the value of +klass+. &#xA; Note that this is both a method of module Timeout, so you can include Timeout into your classes so they have a #timeout method, as well as a module method, so you can call it directly as Timeout.timeout()." />
        <scope name="Error" ilk="class" classrefs="RuntimeError">
        </scope>
      </scope>
    </scope>
    <scope name="tracer" ilk="blob" lang="Ruby">
      <scope name="Tracer" ilk="class" classrefs="Object">
        <scope name="add_filter" ilk="function" signature="add_filter(p = proc)" attributes="__classmethod__" doc="Used to filter unwanted trace output &#xA; Example which only outputs lines of code executed within the Kernel class: &#xA; Tracer.add_filter do |event, file, line, id, binding, klass, *rest|&#xA;  &quot;Kernel&quot; == klass.to_s&#xA;end" />
        <scope name="off" ilk="function" signature="off()" attributes="__classmethod__" doc="Disable tracing" />
        <scope name="on" ilk="function" signature="on()" attributes="__classmethod__" doc="Start tracing &#xA; Example &#xA; Tracer.on&#xA;# code to trace here&#xA;Tracer.off&#xA; You can also pass a block: &#xA; Tracer.on {&#xA;  # trace everything in this block&#xA;}" />
        <scope name="set_get_line_procs" ilk="function" signature="set_get_line_procs(file_name, p = proc)" attributes="__classmethod__" doc="Register an event handler p which is called everytime a line in +file_name+ is executed. &#xA; Example: &#xA; Tracer.set_get_line_procs(&quot;example.rb&quot;, lambda { |line|&#xA;  puts &quot;line number executed is #{line}&quot;&#xA;})" />
        <scope name="trace_func" ilk="function" signature="trace_func(*vars)" attributes="__classmethod__" />
        <scope ilk="function" name="display_c_call" />
        <scope ilk="function" name="display_c_call=" />
        <scope ilk="function" name="display_c_call?" />
        <scope ilk="function" name="display_c_call?=" />
        <scope ilk="function" name="display_process_id" />
        <scope ilk="function" name="display_process_id=" />
        <scope ilk="function" name="display_process_id?" />
        <scope ilk="function" name="display_process_id?=" />
        <scope ilk="function" name="display_thread_id" />
        <scope ilk="function" name="display_thread_id=" />
        <scope ilk="function" name="display_thread_id?" />
        <scope ilk="function" name="display_thread_id?=" />
        <scope ilk="function" name="stdout" />
        <scope ilk="function" name="stdout=" />
        <scope ilk="function" name="stdout_mutex" />
        <scope ilk="function" name="verbose" />
        <scope ilk="function" name="verbose=" />
        <scope ilk="function" name="verbose?" />
        <scope ilk="function" name="verbose?=" />
        <variable name="EVENT_SYMBOL" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="tsort" ilk="blob" lang="Ruby">
      <scope name="TSort" ilk="namespace">
        <scope name="each_strongly_connected_component" ilk="function" signature="each_strongly_connected_component()" doc="The iterator version of the #strongly_connected_components method. obj.each_strongly_connected_component is similar to obj.strongly_connected_components.each, but modification of _obj_ during the iteration may lead to unexpected results. &#xA; #each_strongly_connected_component returns +nil+." />
        <scope name="each_strongly_connected_component_from" ilk="function" signature="each_strongly_connected_component_from(node, id_map={}, stack=[])" doc="Iterates over strongly connected component in the subgraph reachable from _node_. &#xA; Return value is unspecified. &#xA; #each_strongly_connected_component_from doesn&apos;t call #tsort_each_node." />
        <scope name="strongly_connected_components" ilk="function" signature="strongly_connected_components()" doc="Returns strongly connected components as an array of arrays of nodes. The array is sorted from children to parents. Each elements of the array represents a strongly connected component." />
        <scope name="tsort" ilk="function" signature="tsort()" doc="Returns a topologically sorted array of nodes. The array is sorted from children to parents, i.e. the first element has no child and the last node has no parent. &#xA; If there is a cycle, TSort::Cyclic is raised." />
        <scope name="tsort_each" ilk="function" signature="tsort_each()" doc="The iterator version of the #tsort method. obj.tsort_each is similar to obj.tsort.each, but modification of _obj_ during the iteration may lead to unexpected results. &#xA; #tsort_each returns +nil+. If there is a cycle, TSort::Cyclic is raised." />
        <scope name="tsort_each_child" ilk="function" signature="tsort_each_child(node)" doc="Should be implemented by a extended class. &#xA; #tsort_each_child is used to iterate for child nodes of _node_." />
        <scope name="tsort_each_node" ilk="function" signature="tsort_each_node()" doc="Should be implemented by a extended class. &#xA; #tsort_each_node is used to iterate for all nodes over a graph." />
        <scope name="Cyclic" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="uri" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <import symbol="REGEXP" />
        <scope name="decode_www_form" ilk="function" signature="decode_www_form(str, enc=Encoding::UTF_8)" attributes="__classmethod__" doc="Decode URL-encoded form data from given +str+. &#xA; This decodes application/x-www-form-urlencoded data and returns array of key-value array. This internally uses URI.decode_www_form_component. &#xA; _charset_ hack is not supported now because the mapping from given charset to Ruby&apos;s encoding is not clear yet. see also http://www.w3.org/TR/html5/syntax.html#character-encodings-0 &#xA; This refers http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; ary = URI.decode_www_form(&quot;a=1&amp;a=2&amp;b=3&quot;) p ary                  =&gt; [[&apos;a&apos;, &apos;1&apos;], [&apos;a&apos;, &apos;2&apos;], [&apos;b&apos;, &apos;3&apos;]] p ary.assoc(&apos;a&apos;).last  =&gt; &apos;1&apos; p ary.assoc(&apos;b&apos;).last  =&gt; &apos;3&apos; p ary.rassoc(&apos;a&apos;).last =&gt; &apos;2&apos; p Hash[ary]            # =&gt; {&quot;a&quot;=&gt;&quot;2&quot;, &quot;b&quot;=&gt;&quot;3&quot;} &#xA; See URI.decode_www_form_component, URI.encode_www_form" />
        <scope name="decode_www_form_component" ilk="function" signature="decode_www_form_component(str, enc=Encoding::UTF_8)" attributes="__classmethod__" doc="Decode given +str+ of URL-encoded form data. &#xA; This decods + to SP. &#xA; See URI.encode_www_form_component, URI.decode_www_form" />
        <scope name="encode_www_form" ilk="function" signature="encode_www_form(enum)" attributes="__classmethod__" doc="Generate URL-encoded form data from given +enum+. &#xA; This generates application/x-www-form-urlencoded data defined in HTML5 from given an Enumerable object. &#xA; This internally uses URI.encode_www_form_component(str). &#xA; This method doesn&apos;t convert the encoding of given items, so convert them before call this method if you want to send data as other than original encoding or mixed encoding data. (Strings which are encoded in an HTML5 ASCII incompatible encoding are converted to UTF-8.) &#xA; This method doesn&apos;t handle files.  When you send a file, use multipart/form-data. &#xA; This is an implementation of http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; URI.encode_www_form([[&quot;q&quot;, &quot;ruby&quot;], [&quot;lang&quot;, &quot;en&quot;]])&#xA;=&gt; &quot;q=ruby&amp;lang=en&quot;&#xA;URI.encode_www_form(&quot;q&quot; =&gt; &quot;ruby&quot;, &quot;lang&quot; =&gt; &quot;en&quot;)&#xA;=&gt; &quot;q=ruby&amp;lang=en&quot;&#xA;URI.encode_www_form(&quot;q&quot; =&gt; [&quot;ruby&quot;, &quot;perl&quot;], &quot;lang&quot; =&gt; &quot;en&quot;)&#xA;=&gt; &quot;q=ruby&amp;q=perl&amp;lang=en&quot;&#xA;URI.encode_www_form([[&quot;q&quot;, &quot;ruby&quot;], [&quot;q&quot;, &quot;perl&quot;], [&quot;lang&quot;, &quot;en&quot;]])" />
        <scope name="encode_www_form_component" ilk="function" signature="encode_www_form_component(str)" attributes="__classmethod__" doc="Encode given +str+ to URL-encoded form data. &#xA; This method doesn&apos;t convert *, -, ., 0-9, A-Z, _, a-z, but does convert SP (ASCII space) to + and converts others to %XX. &#xA; This is an implementation of http://www.w3.org/TR/html5/forms.html#url-encoded-form-data &#xA; See URI.decode_www_form_component, URI.encode_www_form" />
        <scope name="extract" ilk="function" signature="extract(str, schemes = nil, &amp;block)" attributes="__classmethod__" doc="Synopsis &#xA; URI::extract(str[, schemes][,&amp;blk])&#xA; Args &#xA; String to extract URIs from.&#xA;Limit URI matching to a specific schemes. &#xA; Description &#xA; Extracts URIs from a string. If block given, iterates through all matched URIs. Returns nil if block given or array with matches. &#xA; Usage &#xA; require &quot;uri&quot;&#xA;&#xA;URI.extract(&quot;text here http://foo.example.org/bla and here mailto:test@example.com and here also.&quot;)&#xA;# =&gt; [&quot;http://foo.example.com/bla&quot;, &quot;mailto:test@example.com&quot;]" />
        <scope name="join" ilk="function" signature="join(*str)" attributes="__classmethod__" doc="Synopsis &#xA; URI::join(str[, str, ...])&#xA; Args &#xA; String(s) to work with &#xA; Description &#xA; Joins URIs. &#xA; Usage &#xA; require &apos;uri&apos;&#xA;p URI.join(&quot;http://example.com/&quot;,&quot;main.rbx&quot;)&#xA;# =&gt; #&lt;URI::HTTP:0x2022ac02 URL:http://localhost/main.rbx&gt;&#xA;p URI.join(&apos;http://example.com&apos;, &apos;foo&apos;)&#xA;# =&gt; #&lt;URI::HTTP:0x01ab80a0 URL:http://example.com/foo&gt;&#xA;p URI.join(&apos;http://example.com&apos;, &apos;/foo&apos;, &apos;/bar&apos;)" />
        <scope name="parse" ilk="function" signature="parse(uri)" attributes="__classmethod__" doc="Synopsis &#xA; URI::parse(uri_str)&#xA; Args &#xA; String with URI. &#xA; Description &#xA; Creates one of the URI&apos;s subclasses instance from the string. &#xA; Raises &#xA; URI::InvalidURIError Raised if URI given is not a correct one.&#xA; Usage &#xA; require &apos;uri&apos;&#xA;uri = URI.parse(&quot;http://www.ruby-lang.org/&quot;)&#xA;p uri&#xA;# =&gt; #&lt;URI::HTTP:0x202281be URL:http://www.ruby-lang.org/&gt;" />
        <scope name="regexp" ilk="function" signature="regexp(schemes = nil)" attributes="__classmethod__" doc="Synopsis &#xA; URI::regexp([match_schemes])&#xA; Args &#xA; Array of schemes. If given, resulting regexp matches to URIs whose scheme is one of the match_schemes. &#xA; Description Returns a Regexp object which matches to URI-like strings. The Regexp object returned by this method includes arbitrary number of capture group (parentheses).  Never rely on it&apos;s number. &#xA; Usage &#xA; require &apos;uri&apos;&#xA;# extract first URI from html_string&#xA;html_string.slice(URI.regexp)&#xA;# remove ftp URIs&#xA;html_string.sub(URI.regexp([&apos;ftp&apos;])&#xA;# You should not rely on the number of parentheses&#xA;html_string.scan(URI.regexp) do |*matches|" />
        <scope name="scheme_list" ilk="function" signature="scheme_list()" attributes="__classmethod__" doc="Returns a Hash of the defined schemes" />
        <scope name="split" ilk="function" signature="split(uri)" attributes="__classmethod__" doc="Synopsis &#xA; URI::split(uri)&#xA; Args &#xA; String with URI. &#xA; Description &#xA; Splits the string on following parts and returns array with result: &#xA; * Scheme&#xA;* Userinfo&#xA;* Host&#xA;* Port&#xA;* Registry&#xA;* Path&#xA;* Opaque" />
        <variable name="DEFAULT_PARSER" attributes="__const__" citdl="Object" />
        <variable name="TBLENCWWWCOMP_" attributes="__const__" citdl="Object" />
        <variable name="TBLDECWWWCOMP_" attributes="__const__" citdl="Object" />
        <variable name="WFKV_" attributes="__const__" citdl="Object" />
      </scope>
    </scope>
    <scope name="uri/common" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="BadURIError" ilk="class" classrefs="URI::Error">
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="Escape" ilk="namespace">
          <scope name="decode" ilk="function" signature="decode(*arg)" />
          <scope name="encode" ilk="function" signature="encode(*arg)" />
          <scope name="escape" ilk="function" signature="escape(*arg)" doc="Synopsis &#xA; URI.escape(str [, unsafe])&#xA; Args &#xA; String to replaces in.&#xA;Regexp that matches all symbols that must be replaced with codes. By default uses REGEXP::UNSAFE. When this argument is a String, it represents a character set. &#xA; Description &#xA; Escapes the string, replacing all unsafe characters with codes. &#xA; Usage &#xA; require &apos;uri&apos;&#xA;enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)&#xA;p enc_uri&#xA;# =&gt; &quot;http://example.com/?a=%09%0D&quot;&#xA;p URI.unescape(enc_uri)" />
          <scope name="unescape" ilk="function" signature="unescape(*arg)" doc="Synopsis &#xA; URI.unescape(str)&#xA; Args &#xA; Unescapes the string. &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;enc_uri = URI.escape(&quot;http://example.com/?a=\11\15&quot;)&#xA;p enc_uri&#xA;# =&gt; &quot;http://example.com/?a=%09%0D&quot;&#xA;&#xA;p URI.unescape(enc_uri)&#xA;# =&gt; &quot;http://example.com/?a=\t\r&quot;" />
        </scope>
        <scope name="InvalidComponentError" ilk="class" classrefs="URI::Error">
        </scope>
        <scope name="InvalidURIError" ilk="class" classrefs="URI::Error">
        </scope>
        <scope name="Parser" ilk="class" classrefs="Object">
          <import symbol="REGEXP" />
          <scope name="new" ilk="function" signature="new(opts = {})" attributes="__classmethod__ __ctor__" doc="Synopsis &#xA; URI::Parser.new([opts])&#xA; Args &#xA; The constructor accepts a hash as options for parser. Keys of options are pattern names of URI components and values of options are pattern strings. The constructor generetes set of regexps for parsing URIs. &#xA; You can use the following keys: &#xA; * :ESCAPED (URI::PATTERN::ESCAPED in default)&#xA;* :UNRESERVED (URI::PATTERN::UNRESERVED in default)&#xA;* :DOMLABEL (URI::PATTERN::DOMLABEL in default)&#xA;* :TOPLABEL (URI::PATTERN::TOPLABEL in default)&#xA;* :HOSTNAME (URI::PATTERN::HOSTNAME in default)&#xA; Examples &#xA; p = URI::Parser.new(:ESCAPED =&gt; &quot;(?:%[a-fA-F0-9]{2}|%u[a-fA-F0-9]{4})&quot;)&#xA;u = p.parse(&quot;http://example.jp/%uABCD&quot;) =&gt; #&lt;URI::HTTP:0xb78cf4f8 URL:http://example.jp/%uABCD&gt;" />
          <scope name="escape" ilk="function" signature="escape(str, unsafe = @regexp[:UNSAFE])" doc="Args &#xA; String to make safe&#xA;Regexp to apply. Defaults to self.regexp[:UNSAFE] &#xA; Description &#xA; constructs a safe String from +str+, removing unsafe characters, replacing them with codes." />
          <scope name="extract" ilk="function" signature="extract(str, schemes = nil, &amp;block)" doc="Args &#xA; String to search&#xA;Patterns to apply to +str+ &#xA; Description &#xA; Attempts to parse and merge a set of URIs If no +block+ given , then returns the result, else it calls +block+ for each element in result. &#xA; see also URI::Parser.make_regexp" />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="join" ilk="function" signature="join(*uris)" doc="Args &#xA; an Array of Strings &#xA; Description &#xA; Attempts to parse and merge a set of URIs" />
          <scope name="make_regexp" ilk="function" signature="make_regexp(schemes = nil)" doc="returns Regexp that is default self.regexp[:ABS_URI_REF], unless +schemes+ is provided. Then it is a Regexp.union with self.pattern[:X_ABS_URI]" />
          <scope name="parse" ilk="function" signature="parse(uri)" doc="Args &#xA; String &#xA; Description &#xA; parses +uri+ and constructs either matching URI scheme object (FTP, HTTP, HTTPS, LDAP, LDAPS, or MailTo) or URI::Generic &#xA; Usage &#xA; p = URI::Parser.new&#xA;p.parse(&quot;ldap://ldap.example.com/dc=example?user=john&quot;)&#xA;=&gt; #&lt;URI::LDAP:0x00000000b9e7e8 URL:ldap://ldap.example.com/dc=example?user=john&gt;" />
          <scope name="split" ilk="function" signature="split(uri)" doc="Returns a split URI against regexp[:ABS_URI]" />
          <scope name="unescape" ilk="function" signature="unescape(str, escaped = @regexp[:ESCAPED])" doc="Args &#xA; String to remove escapes from&#xA;Regexp to apply. Defaults to self.regexp[:ESCAPED] &#xA; Description &#xA; Removes escapes from +str+" />
          <scope ilk="function" name="pattern" />
          <scope ilk="function" name="regexp" />
        </scope>
        <scope name="REGEXP" ilk="namespace">
          <scope name="PATTERN" ilk="namespace">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="uri/ftp" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="FTP" ilk="class" classrefs="URI::Generic">
          <import symbol="OpenURI::OpenRead" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Creates a new URI::FTP object from components, with syntax checking. &#xA; The components accepted are +userinfo+, +host+, +port+, +path+ and +typecode+. &#xA; The components should be provided either as an Array, or as a Hash with keys formed by preceding the component names with a colon. &#xA; If an Array is used, the components must be passed in the order If the path supplied is absolute, it will be escaped in order to make it absolute in the URI. Examples: &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI::FTP.build([&apos;user:password&apos;, &apos;ftp.example.com&apos;, nil,&#xA;  &apos;/path/file.&gt; zip&apos;, &apos;i&apos;])&#xA;puts uri.to_s  -&gt;  ftp://user:password@ftp.example.com/%2Fpath/file.zip;type=a&#xA;&#xA;uri2 = URI::FTP.build({:host =&gt; &apos;ftp.example.com&apos;,&#xA;  :path =&gt; &apos;ruby/src&apos;})&#xA;puts uri2.to_s  -&gt;  ftp://ftp.example.com/ruby/src" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Creates a new URI::FTP object from generic URL components with no syntax checking. &#xA; Unlike build(), this method does not escape the path component as required by RFC1738; instead it is treated as per RFC2396. &#xA; Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, +opaque+, +query+ and +fragment+, in that order." />
          <scope name="new2" ilk="function" signature="new2(user, password, host, port, path, typecode = nil, arg_check = true)" attributes="__classmethod__" doc="alternate initialization Creates a new URI::FTP object. &#xA; Unlike build(), this method does not escape the path component as required by RFC1738; instead it is treated as per RFC2396. &#xA; Arguments are user, password, host, port, path, typecode, and arg_check, in that order." />
          <scope name="path" ilk="function" signature="path()" doc="Returns the path from an FTP URI. &#xA; RFC 1738 specifically states that the path for an FTP URI does not include the / which separates the URI path from the URI host. Example: &#xA; ftp://ftp.example.com/pub/ruby&#xA; The above URI indicates that the client should connect to ftp.example.com then cd pub/ruby from the initial login directory. &#xA; If you want to cd to an absolute directory, you must include an escaped / (%2F) in the path. Example: &#xA; ftp://ftp.example.com/%2Fpub/ruby&#xA; This method will then return &quot;/pub/ruby&quot;" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope name="typecode=" ilk="function" signature="typecode=(typecode)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the typecode +v+. (with validation) &#xA; see also URI::FTP.check_typecode &#xA; Usage &#xA; require &apos;uri&apos;&#xA;uri = URI.parse(&quot;ftp://john@ftp.example.com/my_file.img&quot;)&#xA;=&gt; #&lt;URI::FTP:0x00000000923650 URL:ftp://john@ftp.example.com/my_file.img&gt;&#xA;uri.typecode = &quot;i&quot;&#xA;# =&gt;  &quot;i&quot;&#xA;uri&#xA;=&gt; #&lt;URI::FTP:0x00000000923650 URL:ftp://john@ftp.example.com/my_file.img;type=i&gt;" />
          <scope ilk="function" name="typecode" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="TYPECODE" attributes="__const__" citdl="Object" />
          <variable name="TYPECODE_PREFIX" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/generic" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="Generic" ilk="class" classrefs="Object">
          <import symbol="URI" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Synopsis &#xA; See #new &#xA; Description &#xA; Creates a new URI::Generic instance from components of URI::Generic with check.  Components are: scheme, userinfo, host, port, registry, path, opaque, query and fragment. You can provide arguments either by an Array or a Hash. See #new for hash keys to use or for order of array items." />
          <scope name="build2" ilk="function" signature="build2(args)" attributes="__classmethod__" doc="Synopsis &#xA; See #new &#xA; Description &#xA; At first, tries to create a new URI::Generic instance using URI::Generic::build. But, if exception URI::InvalidComponentError is raised, then it URI::Escape.escape all URI components and tries again." />
          <scope name="component" ilk="function" signature="component()" attributes="__classmethod__" doc="Components of the URI in the order." />
          <scope name="default_port" ilk="function" signature="default_port()" attributes="__classmethod__" doc="Returns default port" />
          <scope name="new" ilk="function" signature="new(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser = DEFAULT_PARSER, arg_check = false)" attributes="__classmethod__ __ctor__" doc="Args &#xA; Protocol scheme, i.e. &apos;http&apos;,&apos;ftp&apos;,&apos;mailto&apos; and so on.&#xA;User name and password, i.e. &apos;sdmitry:bla&apos;&#xA;Server host name&#xA;Server port&#xA;Registry of naming authorities.&#xA;Path on server&#xA;Opaque part&#xA;Query data&#xA;A part of URI after &apos;#&apos; sign&#xA;Parser for internal use [URI::DEFAULT_PARSER by default]&#xA;Check arguments [false by default] &#xA; Description " />
          <scope name="use_registry" ilk="function" signature="use_registry()" attributes="__classmethod__" doc="Returns whether a registry of naming authorities are being used." />
          <scope name="absolute" ilk="function" signature="absolute()" />
          <scope name="absolute?" ilk="function" signature="absolute?()" doc="Checks if URI is an absolute one" />
          <scope name="coerce" ilk="function" signature="coerce(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; attempt to parse other URI +oth+&#xA;return [parsed_oth, self]&#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;uri.coerce(&quot;http://foo.com&quot;)&#xA;=&gt; [#&lt;URI::HTTP:0x00000000bcb028 URL:http://foo.com/&gt;, #&lt;URI::HTTP:0x00000000d92178 URL:http://my.example.com&gt;]" />
          <scope name="component" ilk="function" signature="component()" doc="Components of the URI in the order." />
          <scope name="default_port" ilk="function" signature="default_port()" doc="Returns default port" />
          <scope name="eql?" ilk="function" signature="eql?(oth)" />
          <scope name="find_proxy" ilk="function" signature="find_proxy()" doc="returns a proxy URI. The proxy URI is obtained from environment variables such as http_proxy, ftp_proxy, no_proxy, etc. If there is no proper proxy, nil is returned. &#xA; Note that capitalized variables (HTTP_PROXY, FTP_PROXY, NO_PROXY, etc.) are examined too. &#xA; But http_proxy and HTTP_PROXY is treated specially under CGI environment. It&apos;s because HTTP_PROXY may be set by Proxy: header. So HTTP_PROXY is not used. http_proxy is not used too if the variable is case insensitive. CGI_HTTP_PROXY can be used instead." />
          <scope name="fragment=" ilk="function" signature="fragment=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the fragment component +v+. (with validation) &#xA; see also URI::Generic.check_fragment &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com/?id=25#time=1305212049&quot;)&#xA;uri.fragment = &quot;time=1305212086&quot;&#xA;# =&gt;  &quot;time=1305212086&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000007a81f8 URL:http://my.example.com/?id=25#time=1305212086&gt;" />
          <scope name="hash" ilk="function" signature="hash()" />
          <scope name="hierarchical?" ilk="function" signature="hierarchical?()" doc="Checks if URI has a path" />
          <scope name="host=" ilk="function" signature="host=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the host component +v+. (with validation) &#xA; see also URI::Generic.check_host &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;uri.host = &quot;foo.com&quot;&#xA;# =&gt;  &quot;foo.com&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000008e89e8 URL:http://foo.com&gt;" />
          <scope name="hostname" ilk="function" signature="hostname()" doc="extract the host part of the URI and unwrap brackets for IPv6 addresses. &#xA; This method is same as URI::Generic#host except brackets for IPv6 (andn future IP) addresses are removed. &#xA; u = URI(&quot;http://[::1]/bar&quot;) p u.hostname      =&gt; &quot;::1&quot; p u.host          =&gt; &quot;[::1]&quot;" />
          <scope name="hostname=" ilk="function" signature="hostname=(v)" doc="set the host part of the URI as the argument with brackets for IPv6 addresses. &#xA; This method is same as URI::Generic#host= except the argument can be bare IPv6 address. &#xA; u = URI(&quot;http://foo/bar&quot;) p u.to_s                  =&gt; &quot;http://foo/bar&quot; u.hostname = &quot;::1&quot; p u.to_s                  =&gt; &quot;http://[::1]/bar&quot; &#xA; If the arugument seems IPv6 address, it is wrapped by brackets." />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="merge" ilk="function" signature="merge(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Merges two URI&apos;s. &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;p uri.merge(&quot;/main.rbx?page=1&quot;)&#xA;# =&gt;  #&lt;URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1&gt;" />
          <scope name="merge!" ilk="function" signature="merge!(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Destructive form of #merge &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;uri.merge!(&quot;/main.rbx?page=1&quot;)&#xA;p uri&#xA;# =&gt;  #&lt;URI::HTTP:0x2021f3b0 URL:http://my.example.com/main.rbx?page=1&gt;" />
          <scope name="normalize" ilk="function" signature="normalize()" doc="Returns normalized URI" />
          <scope name="normalize!" ilk="function" signature="normalize!()" doc="Destructive version of #normalize" />
          <scope name="opaque=" ilk="function" signature="opaque=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the opaque component +v+. (with validation) &#xA; see also URI::Generic.check_opaque" />
          <scope name="parser" ilk="function" signature="parser()" doc="returns the parser to be used. &#xA; Unless a URI::Parser is defined, then DEFAULT_PARSER is used." />
          <scope name="password" ilk="function" signature="password()" doc="returns the password component" />
          <scope name="password=" ilk="function" signature="password=(password)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the +password+ component. (with validation) &#xA; see also URI::Generic.check_password &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://john:S3nsit1ve@my.example.com&quot;)&#xA;uri.password = &quot;V3ry_S3nsit1ve&quot;&#xA;# =&gt;  &quot;V3ry_S3nsit1ve&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x00000000881d90 URL:http://john:V3ry_S3nsit1ve@my.example.com&gt;" />
          <scope name="path=" ilk="function" signature="path=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the path component +v+. (with validation) &#xA; see also URI::Generic.check_path &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com/pub/files&quot;)&#xA;uri.path = &quot;/faq/&quot;&#xA;# =&gt;  &quot;/faq/&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000008e89e8 URL:http://my.example.com/faq/&gt;" />
          <scope name="port=" ilk="function" signature="port=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the port component +v+. (with validation) &#xA; see also URI::Generic.check_port &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;uri.port = 8080&#xA;# =&gt;  8080&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000008e89e8 URL:http://my.example.com:8080&gt;" />
          <scope name="query=" ilk="function" signature="query=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the query component +v+. (with validation) &#xA; see also URI::Generic.check_query &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com/?id=25&quot;)&#xA;uri.query = &quot;id=1&quot;&#xA;# =&gt;  &quot;id=1&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000008e89e8 URL:http://my.example.com/?id=1&gt;" />
          <scope name="registry=" ilk="function" signature="registry=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the registry component +v+. (with validation) &#xA; see also URI::Generic.check_registry" />
          <scope name="relative?" ilk="function" signature="relative?()" doc="Checks if URI is relative" />
          <scope name="route_from" ilk="function" signature="route_from(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Calculates relative path from oth to self &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&apos;http://my.example.com/main.rbx?page=1&apos;)&#xA;p uri.route_from(&apos;http://my.example.com&apos;)&#xA;=&gt; #&lt;URI::Generic:0x20218858 URL:/main.rbx?page=1&gt;" />
          <scope name="route_to" ilk="function" signature="route_to(oth)" doc="Args &#xA; URI or String &#xA; Description &#xA; Calculates relative path to oth from self &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&apos;http://my.example.com&apos;)&#xA;p uri.route_to(&apos;http://my.example.com/main.rbx?page=1&apos;)&#xA;=&gt; #&lt;URI::Generic:0x2020c2f6 URL:/main.rbx?page=1&gt;" />
          <scope name="scheme=" ilk="function" signature="scheme=(v)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the scheme component +v+. (with validation) &#xA; see also URI::Generic.check_scheme &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://my.example.com&quot;)&#xA;uri.scheme = &quot;https&quot;&#xA;# =&gt;  &quot;https&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x000000008e89e8 URL:https://my.example.com&gt;" />
          <scope name="select" ilk="function" signature="select(*components)" doc="Args &#xA; Multiple Symbol arguments defined in URI::HTTP &#xA; Description &#xA; Selects specified components from URI &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&apos;http://myuser:mypass@my.example.com/test.rbx&apos;)&#xA;p uri.select(:userinfo, :host, :path)&#xA;# =&gt; [&quot;myuser:mypass&quot;, &quot;my.example.com&quot;, &quot;/test.rbx&quot;]" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Constructs String from URI" />
          <scope name="user" ilk="function" signature="user()" doc="returns the user component" />
          <scope name="user=" ilk="function" signature="user=(user)" doc="Args &#xA; String &#xA; Description &#xA; public setter for the +user+ component. (with validation) &#xA; see also URI::Generic.check_user &#xA; Usage &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;http://john:S3nsit1ve@my.example.com&quot;)&#xA;uri.user = &quot;sam&quot;&#xA;# =&gt;  &quot;sam&quot;&#xA;uri&#xA;=&gt; #&lt;URI::HTTP:0x00000000881d90 URL:http://sam:V3ry_S3nsit1ve@my.example.com&gt;" />
          <scope name="userinfo" ilk="function" signature="userinfo()" doc="returns the userinfo, either as &apos;user&apos; or &apos;user:password&apos;" />
          <scope name="userinfo=" ilk="function" signature="userinfo=(userinfo)" doc="Sets userinfo, argument is string like &apos;name:pass&apos;" />
          <scope ilk="function" name="fragment" />
          <scope ilk="function" name="host" />
          <scope ilk="function" name="opaque" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="port" />
          <scope ilk="function" name="query" />
          <scope ilk="function" name="registry" />
          <scope ilk="function" name="scheme" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="USE_REGISTRY" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/http" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="HTTP" ilk="class" classrefs="URI::Generic">
          <import symbol="OpenURI::OpenRead" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Create a new URI::HTTP object from components, with syntax checking. &#xA; The components accepted are userinfo, host, port, path, query and fragment. &#xA; The components should be provided either as an Array, or as a Hash with keys formed by preceding the component names with a colon. &#xA; If an Array is used, the components must be passed in the order [userinfo, host, port, path, query, fragment]. &#xA; Example: &#xA; newuri = URI::HTTP.build({:host =&gt; &apos;www.example.com&apos;,&#xA;  :path&gt; =&gt; &apos;/foo/bar&apos;})&#xA;&#xA;newuri = URI::HTTP.build([nil, &quot;www.example.com&quot;, nil, &quot;/path&quot;,&#xA;  &quot;query&quot;, &apos;fragment&apos;])&#xA; Currently, if passed userinfo components this method generates invalid HTTP URIs as per RFC 1738." />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Create a new URI::HTTP object from generic URI components as per RFC 2396. No HTTP-specific syntax checking (as per RFC 1738) is performed. &#xA; Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, +opaque+, +query+ and +fragment+, in that order. &#xA; Example: &#xA; uri = URI::HTTP.new(&apos;http&apos;, nil, &quot;www.example.com&quot;, nil, &quot;/path&quot;,&#xA;  &quot;query&quot;, &apos;fragment&apos;)&#xA; See also URI::Generic.new" />
          <scope name="request_uri" ilk="function" signature="request_uri()" doc="Description &#xA; Returns the full path for an HTTP request, as required by Net::HTTP::Get. &#xA; If the URI contains a query, the full path is URI#path + &apos;?&apos; + URI#query. Otherwise, the path is simply URI#path." />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/https" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="HTTPS" ilk="class" classrefs="URI::HTTP">
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/ldap" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="LDAP" ilk="class" classrefs="URI::Generic">
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Create a new URI::LDAP object from components, with syntax checking. &#xA; The components accepted are host, port, dn, attributes, scope, filter, and extensions. &#xA; The components should be provided either as an Array, or as a Hash with keys formed by preceding the component names with a colon. &#xA; If an Array is used, the components must be passed in the order [host, port, dn, attributes, scope, filter, extensions]. &#xA; Example: &#xA; newuri = URI::LDAP.build({:host =&gt; &apos;ldap.example.com&apos;,&#xA;  :dn&gt; =&gt; &apos;/dc=example&apos;})&#xA;&#xA;newuri = URI::LDAP.build([&quot;ldap.example.com&quot;, nil,&#xA;  &quot;/dc=example;dc=com&quot;, &quot;query&quot;, nil, nil, nil])" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Create a new URI::LDAP object from generic URI components as per RFC 2396. No LDAP-specific syntax checking is performed. &#xA; Arguments are +scheme+, +userinfo+, +host+, +port+, +registry+, +path+, +opaque+, +query+ and +fragment+, in that order. &#xA; Example: &#xA; uri = URI::LDAP.new(&quot;ldap&quot;, nil, &quot;ldap.example.com&quot;, nil,&#xA;  &quot;/dc=example;dc=com&quot;, &quot;query&quot;, nil, nil, nil, nil)&#xA; See also URI::Generic.new" />
          <scope name="attributes" ilk="function" signature="attributes()" doc="returns attributes." />
          <scope name="attributes=" ilk="function" signature="attributes=(val)" doc="setter for attributes +val+" />
          <scope name="dn" ilk="function" signature="dn()" doc="returns dn." />
          <scope name="dn=" ilk="function" signature="dn=(val)" doc="setter for dn +val+" />
          <scope name="extensions" ilk="function" signature="extensions()" doc="returns extensions." />
          <scope name="extensions=" ilk="function" signature="extensions=(val)" doc="setter for extensions +val+" />
          <scope name="filter" ilk="function" signature="filter()" doc="returns filter." />
          <scope name="filter=" ilk="function" signature="filter=(val)" doc="setter for filter +val+" />
          <scope name="hierarchical?" ilk="function" signature="hierarchical?()" doc="Checks if URI has a path For URI::LDAP this will return +false+" />
          <scope name="scope" ilk="function" signature="scope()" doc="returns scope." />
          <scope name="scope=" ilk="function" signature="scope=(val)" doc="setter for scope +val+" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
          <variable name="SCOPE" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/ldaps" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="LDAPS" ilk="class" classrefs="LDAP">
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="uri/mailto" ilk="blob" lang="Ruby">
      <scope name="URI" ilk="namespace">
        <scope name="MailTo" ilk="class" classrefs="URI::Generic">
          <import symbol="REGEXP" />
          <scope name="build" ilk="function" signature="build(args)" attributes="__classmethod__" doc="Description &#xA; Creates a new URI::MailTo object from components, with syntax checking. &#xA; Components can be provided as an Array or Hash. If an Array is used, the components must be supplied as [to, headers]. &#xA; If a Hash is used, the keys are the component names preceded by colons. &#xA; The headers can be supplied as a pre-encoded string, such as &quot;subject=subscribe&amp;cc=address&quot;, or as an Array of Arrays like Examples: &#xA; require &apos;uri&apos;&#xA;&#xA;m1 = URI::MailTo.build([&apos;joe@example.com&apos;, &apos;subject=Ruby&apos;])&#xA;puts m1.to_s  -&gt;  mailto:joe@example.com?subject=Ruby&#xA;&#xA;m2 = URI::MailTo.build([&apos;john@example.com&apos;, [[&apos;Subject&apos;, &apos;Ruby&apos;], [&apos;Cc&apos;, &apos;jack@example.com&apos;]]])&#xA;puts m2.to_s  -&gt;  mailto:john@example.com?Subject=Ruby&amp;Cc=jack@example.com&#xA;&#xA;m3 = URI::MailTo.build({:to =&gt; &apos;listman@example.com&apos;, :headers =&gt; [[&apos;subject&apos;, &apos;subscribe&apos;]]})&#xA;puts m3.to_s  -&gt;  mailto:listman@example.com?subject=subscribe" />
          <scope name="new" ilk="function" signature="new(*arg)" attributes="__classmethod__ __ctor__" doc="Description &#xA; Creates a new URI::MailTo object from generic URL components with no syntax checking. &#xA; This method is usually called from URI::parse, which checks the validity of each component." />
          <scope name="headers=" ilk="function" signature="headers=(v)" doc="setter for headers +v+" />
          <scope name="to=" ilk="function" signature="to=(v)" doc="setter for to +v+" />
          <scope name="to_mailtext" ilk="function" signature="to_mailtext()" doc="Returns the RFC822 e-mail text equivalent of the URL, as a String. &#xA; Example: &#xA; require &apos;uri&apos;&#xA;&#xA;uri = URI.parse(&quot;mailto:ruby-list@ruby-lang.org?Subject=subscribe&amp;cc=myaddr&quot;)&#xA;uri.to_mailtext&#xA;# =&gt; &quot;To: ruby-list@ruby-lang.org\nSubject: subscribe\nCc: myaddr\n\n\n&quot;" />
          <scope name="to_rfc822text" ilk="function" signature="to_rfc822text()" />
          <scope name="to_s" ilk="function" signature="to_s()" doc="Constructs String from URI" />
          <scope ilk="function" name="headers" />
          <scope ilk="function" name="to" />
          <variable name="DEFAULT_PORT" attributes="__const__" citdl="Object" />
          <variable name="COMPONENT" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="weakref" ilk="blob" lang="Ruby">
      <scope name="WeakRef" ilk="class" classrefs="Delegator">
        <scope name="new" ilk="function" signature="new(orig)" attributes="__classmethod__ __ctor__" doc="Creates a weak reference to +orig+" />
        <scope name="weakref_alive?" ilk="function" signature="weakref_alive?()" doc="Returns true if the referenced object is still alive." />
        <scope name="RefError" ilk="class" classrefs="StandardError">
        </scope>
      </scope>
    </scope>
    <scope name="webrick" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <variable name="CR" attributes="__const__" citdl="Object" />
        <variable name="LF" attributes="__const__" citdl="Object" />
        <variable name="CRLF" attributes="__const__" citdl="Object" />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <scope name="FakeProxyURI" ilk="namespace">
          <scope name="method_missing" ilk="function" signature="method_missing(meth, *args)" attributes="__classmethod__" />
        </scope>
        <scope name="NullReader" ilk="namespace">
          <scope name="gets" ilk="function" signature="gets(*args)" attributes="__classmethod__" />
          <scope name="read" ilk="function" signature="read(*args)" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/accesslog" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="AccessLog" ilk="namespace">
          <scope name="escape" ilk="function" signature="escape(data)" />
          <scope name="format" ilk="function" signature="format(format_string, params)" />
          <scope name="setup_params" ilk="function" signature="setup_params(config, req, res)" doc="This format specification is a subset of mod_log_config of Apache: &#xA; Remote IP address&#xA;Total response size&#xA;Given variable in ENV&#xA;Response filename&#xA;Remote host name&#xA;Given request header&#xA;Remote logname, always &quot;-&quot;&#xA;Request method&#xA;Given request attribute from req.attributes&#xA;Given response header&#xA;Server&apos;s request port&#xA;The canonical port of the server serving the request or the actual port or the client&apos;s actual port.  Valid formats are canonical, local or remote." />
          <variable name="CLF_TIME_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="COMMON_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="CLF" attributes="__const__" citdl="Object" />
          <variable name="REFERER_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="AGENT_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <variable name="COMBINED_LOG_FORMAT" attributes="__const__" citdl="Object" />
          <scope name="AccessLogError" ilk="class" classrefs="StandardError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/cgi" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="CGI" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
          <scope name="service" ilk="function" signature="service(req, res)" />
          <scope name="start" ilk="function" signature="start(env=ENV, stdin=$stdin, stdout=$stdout)" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="logger" />
          <scope name="Socket" ilk="class" classrefs="Object">
            <import symbol="Enumerable" />
            <scope name="new" ilk="function" signature="new(config, env, stdin, stdout)" attributes="__classmethod__ __ctor__" />
            <scope name="addr" ilk="function" signature="addr()" />
            <scope name="cert" ilk="function" signature="cert()" />
            <scope name="cipher" ilk="function" signature="cipher()" />
            <scope name="each" ilk="function" signature="each()" />
            <scope name="eof?" ilk="function" signature="eof?()" />
            <scope name="gets" ilk="function" signature="gets(eol=LF, size=nil)" />
            <scope name="peer_cert" ilk="function" signature="peer_cert()" />
            <scope name="peer_cert_chain" ilk="function" signature="peer_cert_chain()" />
            <scope name="peeraddr" ilk="function" signature="peeraddr()" />
            <scope name="read" ilk="function" signature="read(size=nil)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/cookie" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Cookie" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(name, value)" attributes="__classmethod__ __ctor__" doc="attr_accessor :comment_url, :discard, :port" />
          <scope name="parse" ilk="function" signature="parse(str)" attributes="__classmethod__" doc="Cookie::parse() It parses Cookie field sent from the user agent." />
          <scope name="parse_set_cookie" ilk="function" signature="parse_set_cookie(str)" attributes="__classmethod__" />
          <scope name="parse_set_cookies" ilk="function" signature="parse_set_cookies(str)" attributes="__classmethod__" />
          <scope name="expires" ilk="function" signature="expires()" />
          <scope name="expires=" ilk="function" signature="expires=(t)" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="comment" />
          <scope ilk="function" name="comment=" />
          <scope ilk="function" name="domain" />
          <scope ilk="function" name="domain=" />
          <scope ilk="function" name="max_age" />
          <scope ilk="function" name="max_age=" />
          <scope ilk="function" name="name" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="path=" />
          <scope ilk="function" name="secure" />
          <scope ilk="function" name="secure=" />
          <scope ilk="function" name="value" />
          <scope ilk="function" name="value=" />
          <scope ilk="function" name="version" />
          <scope ilk="function" name="version=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/htmlutils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTMLUtils" ilk="namespace">
          <scope name="escape" ilk="function" signature="escape(string)" attributes="__classmethod__" doc="Escapes &amp;, &quot;, &gt; and &lt; in +string+" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="basic_auth" ilk="function" signature="basic_auth(req, res, realm)" doc="Simple wrapper for providing basic authentication for a request.  When called with a request +req+, response +res+, authentication +realm+ and +block+ the block will be called with a +username+ and +password+.  If the block returns true the request is allowed to continue, otherwise an HTTPStatus::Unauthorized error is raised." />
          <scope name="proxy_basic_auth" ilk="function" signature="proxy_basic_auth(req, res, realm)" doc="Simple wrapper for providing basic authentication for a proxied request. When called with a request +req+, response +res+, authentication +realm+ and +block+ the block will be called with a +username+ and +password+. If the block returns true the request is allowed to continue, otherwise an HTTPStatus::ProxyAuthenticationRequired error is raised." />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/authenticator" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Authenticator" ilk="namespace">
            <scope ilk="function" name="logger" />
            <scope ilk="function" name="realm" />
            <scope ilk="function" name="userdb" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyAuthenticator" ilk="namespace">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/basicauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="BasicAuth" ilk="class" classrefs="Object">
            <import symbol="Authenticator" />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" attributes="__classmethod__" doc="Used by UserDB to create a basic password entry" />
            <scope name="new" ilk="function" signature="new(config, default=Config::BasicAuth)" attributes="__classmethod__ __ctor__" doc="Creates a new BasicAuth instance. &#xA; See WEBrick::Config::BasicAuth for default configuration entries &#xA; You must supply the following configuration entries: &#xA; The name of the realm being protected.&#xA;A database of usernames and passwords. A WEBrick::HTTPAuth::Htpasswd instance should be used." />
            <scope name="authenticate" ilk="function" signature="authenticate(req, res)" doc="Authenticates a +req+ and returns a 401 Unauthorized using +res+ if the authentication was not correct." />
            <scope name="challenge" ilk="function" signature="challenge(req, res)" doc="Returns a challenge response which asks for for authentication information" />
            <scope ilk="function" name="logger" />
            <scope ilk="function" name="realm" />
            <scope ilk="function" name="userdb" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyBasicAuth" ilk="class" classrefs="WEBrick::HTTPAuth::BasicAuth">
            <import symbol="ProxyAuthenticator" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/digestauth" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="DigestAuth" ilk="class" classrefs="Object">
            <import symbol="Authenticator" />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" attributes="__classmethod__" doc="Used by UserDB to create a digest password entry" />
            <scope name="new" ilk="function" signature="new(config, default=Config::DigestAuth)" attributes="__classmethod__ __ctor__" doc="Creates a new DigestAuth instance.  Be sure to use the same DigestAuth instance for multiple requests as it saves state between requests in order to perform authentication. &#xA; See WEBrick::Config::DigestAuth for default configuration entries &#xA; You must supply the following configuration entries: &#xA; The name of the realm being protected.&#xA;A database of usernames and passwords. A WEBrick::HTTPAuth::Htdigest instance should be used." />
            <scope name="authenticate" ilk="function" signature="authenticate(req, res)" doc="Authenticates a +req+ and returns a 401 Unauthorized using +res+ if the authentication was not correct." />
            <scope name="challenge" ilk="function" signature="challenge(req, res, stale=false)" doc="Returns a challenge response which asks for for authentication information" />
            <scope ilk="function" name="algorithm" />
            <scope ilk="function" name="qop" />
          </scope>
        </scope>
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="ProxyDigestAuth" ilk="class" classrefs="WEBrick::HTTPAuth::DigestAuth">
            <import symbol="ProxyAuthenticator" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htdigest" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htdigest" ilk="class" classrefs="Object">
            <import symbol="UserDB" />
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" doc="Open a digest password database at +path+" />
            <scope name="delete_passwd" ilk="function" signature="delete_passwd(realm, user)" doc="Removes a password from the database for +user+ in +realm+." />
            <scope name="each" ilk="function" signature="each()" doc="Iterate passwords in the database." />
            <scope name="flush" ilk="function" signature="flush(output=nil)" doc="Flush the password database.  If +output+ is given the database will be written there instead of to the original path." />
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db)" doc="Retrieves a password from the database for +user+ in +realm+.  If +reload_db+ is true the database will be reloaded first." />
            <scope name="reload" ilk="function" signature="reload()" doc="Reloads passwords from the database" />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" doc="Sets a password in the database for +user+ in +realm+ to +pass+." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htgroup" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htgroup" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" doc="Open a group database at +path+" />
            <scope name="add" ilk="function" signature="add(group, members)" doc="Add an Array of +members+ to +group+" />
            <scope name="flush" ilk="function" signature="flush(output=nil)" doc="Flush the group database.  If +output+ is given the database will be written there instead of to the original path." />
            <scope name="members" ilk="function" signature="members(group)" doc="Retrieve the list of members from +group+" />
            <scope name="reload" ilk="function" signature="reload()" doc="Reload groups from the database" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/htpasswd" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="Htpasswd" ilk="class" classrefs="Object">
            <import symbol="UserDB" />
            <scope name="new" ilk="function" signature="new(path)" attributes="__classmethod__ __ctor__" doc="Open a password database at +path+" />
            <scope name="delete_passwd" ilk="function" signature="delete_passwd(realm, user)" doc="Removes a password from the database for +user+ in +realm+." />
            <scope name="each" ilk="function" signature="each()" doc="Iterate passwords in the database." />
            <scope name="flush" ilk="function" signature="flush(output=nil)" doc="Flush the password database.  If +output+ is given the database will be written there instead of to the original path." />
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db)" doc="Retrieves a password from the database for +user+ in +realm+.  If +reload_db+ is true the database will be reloaded first." />
            <scope name="reload" ilk="function" signature="reload()" doc="Reload passwords from the database" />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" doc="Sets a password in the database for +user+ in +realm+ to +pass+." />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpauth/userdb" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPAuth" ilk="namespace">
          <scope name="UserDB" ilk="namespace">
            <scope name="get_passwd" ilk="function" signature="get_passwd(realm, user, reload_db=false)" doc="Retrieves a password in +realm+ for +user+ for the auth_type of this database.  +reload_db+ is a dummy value." />
            <scope name="make_passwd" ilk="function" signature="make_passwd(realm, user, pass)" doc="Creates an obscured password in +realm+ with +user+ and +password+ using the auth_type of this database." />
            <scope name="set_passwd" ilk="function" signature="set_passwd(realm, user, pass)" doc="Sets a password in +realm+ with +user+ and +password+ for the auth_type of this database." />
            <scope ilk="function" name="auth_type" />
            <scope ilk="function" name="auth_type=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpproxy" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPProxyServer" ilk="class" classrefs="WEBrick::HTTPServer">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::HTTP)" attributes="__classmethod__ __ctor__" doc="Proxy server configurations.  The proxy server handles the following configuration items in addition to those supported by HTTPServer: &#xA; Called with a request and response to authorize a request&#xA;Appended to the via header&#xA;The proxy server&apos;s URI&#xA;Called with a request and resopnse and allows modification of the response&#xA;Sets the proxy timeouts to 30 seconds for open and 60 seconds for read operations" />
          <scope name="do_CONNECT" ilk="function" signature="do_CONNECT(req, res)" />
          <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
          <scope name="do_HEAD" ilk="function" signature="do_HEAD(req, res)" />
          <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
          <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
          <scope name="proxy_auth" ilk="function" signature="proxy_auth(req, res)" />
          <scope name="proxy_service" ilk="function" signature="proxy_service(req, res)" />
          <scope name="proxy_uri" ilk="function" signature="proxy_uri(req, res)" />
          <scope name="service" ilk="function" signature="service(req, res)" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httprequest" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPRequest" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" />
          <scope name="body" ilk="function" signature="body(&amp;block)" />
          <scope name="content_length" ilk="function" signature="content_length()" doc="The content-length header" />
          <scope name="content_type" ilk="function" signature="content_type()" doc="The content-type header" />
          <scope name="continue" ilk="function" signature="continue()" doc="Generate HTTP/1.1 100 continue response if the client expects it, otherwise does nothing." />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over the request headers" />
          <scope name="fixup" ilk="function" signature="fixup()" />
          <scope name="host" ilk="function" signature="host()" doc="The host this request is for" />
          <scope name="keep_alive?" ilk="function" signature="keep_alive?()" doc="Should the connection this request was made on be kept alive?" />
          <scope name="meta_vars" ilk="function" signature="meta_vars()" doc="This method provides the metavariables defined by the revision 3 of &quot;The WWW Common Gateway Interface Version 1.1&quot; http://Web.Golux.Com/coar/cgi/" />
          <scope name="orig_meta_vars" ilk="function" signature="orig_meta_vars()" />
          <scope name="orig_parse" ilk="function" signature="orig_parse(socket=nil)" />
          <scope name="orig_parse_uri" ilk="function" signature="orig_parse_uri(str, scheme=&quot;http&quot;)" />
          <scope name="parse" ilk="function" signature="parse(socket=nil)" />
          <scope name="port" ilk="function" signature="port()" doc="The port this request is for" />
          <scope name="query" ilk="function" signature="query()" doc="Request query as a Hash" />
          <scope name="remote_ip" ilk="function" signature="remote_ip()" doc="The client&apos;s IP address" />
          <scope name="server_name" ilk="function" signature="server_name()" doc="The server name this request is for" />
          <scope name="ssl?" ilk="function" signature="ssl?()" doc="Is this an SSL request?" />
          <scope ilk="function" name="accept" />
          <scope ilk="function" name="accept_charset" />
          <scope ilk="function" name="accept_encoding" />
          <scope ilk="function" name="accept_language" />
          <scope ilk="function" name="addr" />
          <scope ilk="function" name="attributes" />
          <scope ilk="function" name="cipher" />
          <scope ilk="function" name="client_cert" />
          <scope ilk="function" name="cookies" />
          <scope ilk="function" name="header" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="keep_alive" />
          <scope ilk="function" name="path" />
          <scope ilk="function" name="path_info" />
          <scope ilk="function" name="path_info=" />
          <scope ilk="function" name="peeraddr" />
          <scope ilk="function" name="query_string" />
          <scope ilk="function" name="query_string=" />
          <scope ilk="function" name="raw_header" />
          <scope ilk="function" name="request_line" />
          <scope ilk="function" name="request_method" />
          <scope ilk="function" name="request_time" />
          <scope ilk="function" name="request_uri" />
          <scope ilk="function" name="script_name" />
          <scope ilk="function" name="script_name=" />
          <scope ilk="function" name="server_cert" />
          <scope ilk="function" name="unparsed_uri" />
          <scope ilk="function" name="user" />
          <scope ilk="function" name="user=" />
          <variable name="BODY_CONTAINABLE_METHODS" attributes="__const__" citdl="Object" />
          <variable name="MAX_URI_LENGTH" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpresponse" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPResponse" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config)" attributes="__classmethod__ __ctor__" doc="Creates a new HTTP response object" />
          <scope name="chunked=" ilk="function" signature="chunked=(val)" doc="Enables chunked transfer encoding." />
          <scope name="chunked?" ilk="function" signature="chunked?()" doc="Will this response body be returned using chunked transfer-encoding?" />
          <scope name="content_length" ilk="function" signature="content_length()" doc="The content-length header" />
          <scope name="content_length=" ilk="function" signature="content_length=(len)" doc="Sets the content-length header to +len+" />
          <scope name="content_type" ilk="function" signature="content_type()" doc="The content-type header" />
          <scope name="content_type=" ilk="function" signature="content_type=(type)" doc="Sets the content-type header to +type+" />
          <scope name="each" ilk="function" signature="each()" doc="Iterates over each header in the resopnse" />
          <scope name="keep_alive?" ilk="function" signature="keep_alive?()" doc="Will this response&apos;s connection be kept alive?" />
          <scope name="send_body" ilk="function" signature="send_body(socket)" doc="Sends the body on +socket+" />
          <scope name="send_header" ilk="function" signature="send_header(socket)" doc="Sends the headers on +socket+" />
          <scope name="send_response" ilk="function" signature="send_response(socket)" doc="Sends the response on +socket+" />
          <scope name="set_error" ilk="function" signature="set_error(ex, backtrace=false)" doc="Creates an error page for exception +ex+ with an optional +backtrace+" />
          <scope name="set_redirect" ilk="function" signature="set_redirect(status, url)" doc="Redirects to +url+ with a WEBrick::HTTPStatus::Redirect +status+. &#xA; Example: &#xA; res.set_redirect WEBrick::HTTPStatus::TemporaryRedirect" />
          <scope name="setup_header" ilk="function" signature="setup_header()" doc="Sets up the headers for sending" />
          <scope name="status=" ilk="function" signature="status=(status)" doc="Sets the response&apos;s status to the +status+ code" />
          <scope name="status_line" ilk="function" signature="status_line()" doc="The response&apos;s HTTP status line" />
          <scope ilk="function" name="body" />
          <scope ilk="function" name="body=" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="cookies" />
          <scope ilk="function" name="filename" />
          <scope ilk="function" name="filename=" />
          <scope ilk="function" name="header" />
          <scope ilk="function" name="http_version" />
          <scope ilk="function" name="keep_alive" />
          <scope ilk="function" name="keep_alive=" />
          <scope ilk="function" name="reason_phrase" />
          <scope ilk="function" name="reason_phrase=" />
          <scope ilk="function" name="request_http_version" />
          <scope ilk="function" name="request_http_version=" />
          <scope ilk="function" name="request_method" />
          <scope ilk="function" name="request_method=" />
          <scope ilk="function" name="request_uri" />
          <scope ilk="function" name="request_uri=" />
          <scope ilk="function" name="sent_size" />
          <scope ilk="function" name="status" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpserver" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServer" ilk="class" classrefs="WEBrick::GenericServer">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::HTTP)" attributes="__classmethod__ __ctor__" doc="Creates a new HTTP server according to +config+ &#xA; An HTTP server uses the following attributes: &#xA; An array of access logs.  See WEBrick::AccessLog&#xA;Local address for the server to bind to&#xA;Root path to serve files from&#xA;Options for the default HTTPServlet::FileHandler&#xA;The HTTP version of this server&#xA;Port to listen on&#xA;Called with a request and response before each request is serviced.&#xA;Maximum time to wait between requests&#xA;Array of alternate names for this server for virtual hosting&#xA;Name for this server for virtual hosting" />
          <scope name="access_log" ilk="function" signature="access_log(config, req, res)" />
          <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
          <scope name="lookup_server" ilk="function" signature="lookup_server(req)" doc="Finds the appropriate virtual host to handle +req+" />
          <scope name="mount" ilk="function" signature="mount(dir, servlet, *options)" doc="Mounts +servlet+ on +dir+ passing +options+ to the servlet at creation time" />
          <scope name="mount_proc" ilk="function" signature="mount_proc(dir, proc=nil, &amp;block)" doc="Mounts +proc+ or +block+ on +dir+ and calls it with a WEBrick::HTTPRequest and WEBrick::HTTPResponse" />
          <scope name="run" ilk="function" signature="run(sock)" doc="Processes requests on +sock+" />
          <scope name="search_servlet" ilk="function" signature="search_servlet(path)" doc="Finds a servlet for +path+" />
          <scope name="service" ilk="function" signature="service(req, res)" doc="Services +req+ and fills in +res+" />
          <scope name="umount" ilk="function" signature="umount(dir)" />
          <scope name="unmount" ilk="function" signature="unmount(dir)" doc="Unmounts +dir+" />
          <scope name="virtual_host" ilk="function" signature="virtual_host(server)" doc="Adds +server+ as a virtual host." />
          <scope name="MountTable" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="delete" ilk="function" signature="delete(dir)" />
            <scope name="scan" ilk="function" signature="scan(path)" />
          </scope>
        </scope>
        <scope name="HTTPServerError" ilk="class" classrefs="ServerError">
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/abstract" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="AbstractServlet" ilk="class" classrefs="Object">
            <scope name="get_instance" ilk="function" signature="get_instance(server, *options)" attributes="__classmethod__" doc="Factory for servlet instances that will handle a request from +server+ using +options+ from the mount point.  By default a new servlet instance is created for every call." />
            <scope name="new" ilk="function" signature="new(server, *options)" attributes="__classmethod__ __ctor__" doc="Initializes a new servlet for +server+ using +options+ which are stored as-is in +@options+.  +@logger+ is also provided." />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" doc="Raises a NotFound exception" />
            <scope name="do_HEAD" ilk="function" signature="do_HEAD(req, res)" doc="Dispatches to do_GET" />
            <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" doc="Returns the allowed HTTP request methods" />
            <scope name="service" ilk="function" signature="service(req, res)" doc="Dispatches to a +do_+ method based on +req+ if such a method is available.  (+do_GET+ for a GET request).  Raises a MethodNotAllowed exception if the method is not implemented." />
          </scope>
        </scope>
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="HTTPServletError" ilk="class" classrefs="StandardError">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/cgihandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="CGIHandler" ilk="class" classrefs="AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, name)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/erbhandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="ERBHandler" ilk="class" classrefs="WEBrick::HTTPServlet::AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, name)" attributes="__classmethod__ __ctor__" doc="Creates a new ERBHandler on +server+ that will evaluate and serve the ERB file +name+" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" doc="Handles GET requests" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" doc="Handles POST requests" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/filehandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="DefaultFileHandler" ilk="class" classrefs="WEBrick::HTTPServlet::AbstractServlet">
            <scope name="new" ilk="function" signature="new(server, local_path)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="make_partial_content" ilk="function" signature="make_partial_content(req, res, filename, filesize)" />
            <scope name="not_modified?" ilk="function" signature="not_modified?(req, res, mtime, etag)" />
            <scope name="prepare_range" ilk="function" signature="prepare_range(range, filesize)" />
          </scope>
        </scope>
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="FileHandler" ilk="class" classrefs="WEBrick::HTTPServlet::AbstractServlet">
            <scope name="add_handler" ilk="function" signature="add_handler(suffix, handler)" attributes="__classmethod__" doc="Allow custom handling of requests for files with +suffix+ by class +handler+" />
            <scope name="new" ilk="function" signature="new(server, root, options={}, default=Config::FileHandler)" attributes="__classmethod__ __ctor__" doc="Creates a FileHandler servlet on +server+ that serves files starting at directory +root+ &#xA; If +options+ is a Hash the following keys are allowed: &#xA; Array of languages allowed for accept-language&#xA;Allows preprocessing of directory requests&#xA;If true, show an index for directories&#xA;Allows preprocessing of file requests&#xA;Allows preprocessing of requests&#xA;Maps file suffixes to file handlers. DefaultFileHandler is used by default but any servlet can be used.&#xA;Do not show files matching this array of globs&#xA;Directory inside ~user to serve content from for /~user requests.  Only works if mounted on / &#xA; If +options+ is true or false then +:FancyIndexing+ is enabled or disabled respectively." />
            <scope name="remove_handler" ilk="function" signature="remove_handler(suffix)" attributes="__classmethod__" doc="Remove custom handling of requests for files with +suffix+" />
            <scope name="do_GET" ilk="function" signature="do_GET(req, res)" />
            <scope name="do_OPTIONS" ilk="function" signature="do_OPTIONS(req, res)" />
            <scope name="do_POST" ilk="function" signature="do_POST(req, res)" />
            <scope name="service" ilk="function" signature="service(req, res)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpservlet/prochandler" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPServlet" ilk="namespace">
          <scope name="ProcHandler" ilk="class" classrefs="WEBrick::HTTPServlet::AbstractServlet">
            <scope name="new" ilk="function" signature="new(proc)" attributes="__classmethod__ __ctor__" />
            <scope name="do_GET" ilk="function" signature="do_GET(request, response)" />
            <scope name="do_POST" ilk="function" signature="do_POST(request, response)" />
            <scope name="get_instance" ilk="function" signature="get_instance(server, *options)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpstatus" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPStatus" ilk="namespace">
          <scope name="client_error?" ilk="function" signature="client_error?(code)" attributes="__classmethod__" doc="Is +code+ a client error status?" />
          <scope name="error?" ilk="function" signature="error?(code)" attributes="__classmethod__" doc="Is +code+ an error status?" />
          <scope name="info?" ilk="function" signature="info?(code)" attributes="__classmethod__" doc="Is +code+ an informational status?" />
          <scope name="reason_phrase" ilk="function" signature="reason_phrase(code)" attributes="__classmethod__" doc="Returns the description corresponding to the HTTP status +code+ &#xA; WEBrick::HTTPStatus.reason_phrase 404&#xA;=&gt; &quot;Not Found&quot;" />
          <scope name="redirect?" ilk="function" signature="redirect?(code)" attributes="__classmethod__" doc="Is +code+ a redirection status?" />
          <scope name="server_error?" ilk="function" signature="server_error?(code)" attributes="__classmethod__" doc="Is +code+ a server error status?" />
          <scope name="success?" ilk="function" signature="success?(code)" attributes="__classmethod__" doc="Is +code+ a successful status?" />
          <scope name="ClientError" ilk="class" classrefs="WEBrick::HTTPStatus::Error">
          </scope>
          <scope name="EOFError" ilk="class" classrefs="StandardError">
          </scope>
          <scope name="Error" ilk="class" classrefs="WEBrick::HTTPStatus::Status">
          </scope>
          <scope name="Info" ilk="class" classrefs="WEBrick::HTTPStatus::Status">
          </scope>
          <scope name="Redirect" ilk="class" classrefs="WEBrick::HTTPStatus::Status">
          </scope>
          <scope name="ServerError" ilk="class" classrefs="WEBrick::HTTPStatus::Error">
          </scope>
          <scope name="Status" ilk="class" classrefs="StandardError">
            <scope name="code" ilk="function" signature="code()" doc="Returns the HTTP status code" />
            <scope name="reason_phrase" ilk="function" signature="reason_phrase()" doc="Returns the HTTP status description" />
            <scope name="to_i" ilk="function" signature="to_i()" />
          </scope>
          <scope name="Success" ilk="class" classrefs="WEBrick::HTTPStatus::Status">
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httputils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPUtils" ilk="namespace">
          <scope name="dequote" ilk="function" signature="dequote(str)" attributes="__classmethod__" />
          <scope name="load_mime_types" ilk="function" signature="load_mime_types(file)" attributes="__classmethod__" doc="Load Apache compatible mime.types file." />
          <scope name="mime_type" ilk="function" signature="mime_type(filename, mime_tab)" attributes="__classmethod__" />
          <scope name="normalize_path" ilk="function" signature="normalize_path(path)" attributes="__classmethod__" />
          <scope name="parse_form_data" ilk="function" signature="parse_form_data(io, boundary)" attributes="__classmethod__" />
          <scope name="parse_header" ilk="function" signature="parse_header(raw)" attributes="__classmethod__" />
          <scope name="parse_query" ilk="function" signature="parse_query(str)" attributes="__classmethod__" />
          <scope name="parse_qvalues" ilk="function" signature="parse_qvalues(value)" attributes="__classmethod__" />
          <scope name="parse_range_header" ilk="function" signature="parse_range_header(ranges_specifier)" attributes="__classmethod__" />
          <scope name="quote" ilk="function" signature="quote(str)" attributes="__classmethod__" />
          <scope name="split_header_value" ilk="function" signature="split_header_value(str)" attributes="__classmethod__" />
          <scope name="_escape" ilk="function" signature="_escape(str, regex)" />
          <scope name="_make_regex" ilk="function" signature="_make_regex(str)" />
          <scope name="_make_regex!" ilk="function" signature="_make_regex!(str)" />
          <scope name="_unescape" ilk="function" signature="_unescape(str, regex)" />
          <scope name="escape" ilk="function" signature="escape(str)" />
          <scope name="escape8bit" ilk="function" signature="escape8bit(str)" />
          <scope name="escape_form" ilk="function" signature="escape_form(str)" />
          <scope name="escape_path" ilk="function" signature="escape_path(str)" />
          <scope name="unescape" ilk="function" signature="unescape(str)" />
          <scope name="unescape_form" ilk="function" signature="unescape_form(str)" />
          <variable name="UNESCAPED" attributes="__const__" citdl="Object" />
          <variable name="UNESCAPED_FORM" attributes="__const__" citdl="Object" />
          <variable name="NONASCII" attributes="__const__" citdl="Object" />
          <variable name="ESCAPED" attributes="__const__" citdl="Object" />
          <variable name="UNESCAPED_PCHAR" attributes="__const__" citdl="Object" />
          <scope name="FormData" ilk="class" classrefs="String">
            <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" />
            <scope name="append_data" ilk="function" signature="append_data(data)" />
            <scope name="each_data" ilk="function" signature="each_data()" />
            <scope name="list" ilk="function" signature="list()" />
            <scope name="to_ary" ilk="function" signature="to_ary()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="filename" />
            <scope ilk="function" name="filename=" />
            <scope ilk="function" name="name" />
            <scope ilk="function" name="name=" />
            <scope ilk="function" name="next_data" />
            <scope ilk="function" name="next_data=" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="webrick/httpversion" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="HTTPVersion" ilk="class" classrefs="Object">
          <import symbol="Comparable" />
          <scope name="convert" ilk="function" signature="convert(version)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(version)" attributes="__classmethod__ __ctor__" />
          <scope name="to_s" ilk="function" signature="to_s()" />
          <scope ilk="function" name="major" />
          <scope ilk="function" name="major=" />
          <scope ilk="function" name="minor" />
          <scope ilk="function" name="minor=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/log" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="BasicLog" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(log_file=nil, level=nil)" attributes="__classmethod__ __ctor__" doc="Initializes a new logger for +log_file+ that outputs messages at +level+ or higher.  +log_file+ can be a filename, an IO-like object that responds to #&lt;&lt; or nil which outputs to $stderr. &#xA; If no level is given INFO is chosen by default" />
          <scope name="close" ilk="function" signature="close()" doc="Closes the logger (also closes the log device associated to the logger)" />
          <scope name="debug" ilk="function" signature="debug(msg)" doc="Shortcut for logging a DEBUG message" />
          <scope name="debug?" ilk="function" signature="debug?()" doc="Will the logger output DEBUG messages?" />
          <scope name="error" ilk="function" signature="error(msg)" doc="Shortcut for logging an ERROR message" />
          <scope name="error?" ilk="function" signature="error?()" doc="Will the logger output ERROR messages?" />
          <scope name="fatal" ilk="function" signature="fatal(msg)" doc="Shortcut for logging a FATAL message" />
          <scope name="fatal?" ilk="function" signature="fatal?()" doc="Will the logger output FATAL messages?" />
          <scope name="info" ilk="function" signature="info(msg)" doc="Shortcut for logging an INFO message" />
          <scope name="info?" ilk="function" signature="info?()" doc="Will the logger output INFO messages?" />
          <scope name="log" ilk="function" signature="log(level, data)" doc="Logs +data+ at +level+ if the given level is above the current log level." />
          <scope name="warn" ilk="function" signature="warn(msg)" doc="Shortcut for logging a WARN message" />
          <scope name="warn?" ilk="function" signature="warn?()" doc="Will the logger output WARN messages?" />
          <scope ilk="function" name="level" />
          <scope ilk="function" name="level=" />
          <variable name="DEBUG" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="Log" ilk="class" classrefs="WEBrick::BasicLog">
          <scope name="new" ilk="function" signature="new(log_file=nil, level=nil)" attributes="__classmethod__ __ctor__" doc="Same as BasicLog#initialize &#xA; You can set the timestamp format through #time_format" />
          <scope name="log" ilk="function" signature="log(level, data)" doc="Same as BasicLog#log" />
          <scope ilk="function" name="time_format" />
          <scope ilk="function" name="time_format=" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/server" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Daemon" ilk="class" classrefs="Object">
          <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" doc="Performs the standard operations for daemonizing a process.  Runs a block, if given." />
        </scope>
        <scope name="ServerError" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="SimpleServer" ilk="class" classrefs="Object">
          <scope name="start" ilk="function" signature="start()" attributes="__classmethod__" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/ssl" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Config" ilk="namespace">
          <variable name="SSL" attributes="__const__" citdl="Object" />
          <variable name="LIBDIR" attributes="__const__" citdl="Object" />
          <variable name="HTTP" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="GenericServer" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(config={}, default=Config::General)" attributes="__classmethod__ __ctor__" />
          <scope name="listen" ilk="function" signature="listen(address, port)" />
          <scope name="run" ilk="function" signature="run(sock)" />
          <scope name="setup_ssl_context" ilk="function" signature="setup_ssl_context(config)" />
          <scope name="shutdown" ilk="function" signature="shutdown()" />
          <scope name="ssl_context" ilk="function" signature="ssl_context()" />
          <scope name="start" ilk="function" signature="start(&amp;block)" />
          <scope name="stop" ilk="function" signature="stop()" />
          <scope ilk="function" name="config" />
          <scope ilk="function" name="listeners" />
          <scope ilk="function" name="logger" />
          <scope ilk="function" name="status" />
          <scope ilk="function" name="tokens" />
        </scope>
      </scope>
    </scope>
    <scope name="webrick/utils" ilk="blob" lang="Ruby">
      <scope name="WEBrick" ilk="namespace">
        <scope name="Utils" ilk="namespace">
          <scope name="create_listeners" ilk="function" signature="create_listeners(address, port, logger=nil)" attributes="__classmethod__" doc="Creates TCP server sockets bound to +address+:+port+ and returns them. &#xA; It will create IPV4 and IPV6 sockets on all interfaces." />
          <scope name="create_self_signed_cert" ilk="function" signature="create_self_signed_cert(bits, cn, comment)" attributes="__classmethod__" />
          <scope name="getservername" ilk="function" signature="getservername()" attributes="__classmethod__" doc="The server hostname" />
          <scope name="random_string" ilk="function" signature="random_string(len)" attributes="__classmethod__" doc="Generates a random string of length +len+" />
          <scope name="set_close_on_exec" ilk="function" signature="set_close_on_exec(io)" attributes="__classmethod__" doc="Sets the close on exec flag for +io+" />
          <scope name="set_non_blocking" ilk="function" signature="set_non_blocking(io)" attributes="__classmethod__" doc="Sets IO operations on +io+ to be non-blocking" />
          <scope name="su" ilk="function" signature="su(user)" attributes="__classmethod__" doc="Changes the process&apos;s uid and gid to the ones of +user+" />
          <scope name="timeout" ilk="function" signature="timeout(seconds, exception=Timeout::Error)" attributes="__classmethod__" doc="Executes the passed block and raises +exception+ if execution takes more than +seconds+. &#xA; If +seconds+ is zero or nil, simply executes the block" />
          <variable name="RAND_CHARS" attributes="__const__" citdl="Object" />
          <scope name="TimeoutHandler" ilk="class" classrefs="Object">
            <import symbol="Singleton" />
            <scope name="cancel" ilk="function" signature="cancel(id)" attributes="__classmethod__" doc="Cancels the timeout handler +id+" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="register" ilk="function" signature="register(seconds, exception)" attributes="__classmethod__" doc="Registers a new timeout handler &#xA; Timeout in seconds&#xA;Exception to raise when timeout elapsed" />
            <scope name="cancel" ilk="function" signature="cancel(thread, id)" doc="Cancels the timeout handler +id+" />
            <scope name="interrupt" ilk="function" signature="interrupt(thread, id, exception)" doc="Interrupts the timeout handler +id+ and raises +exception+" />
            <scope name="register" ilk="function" signature="register(thread, time, exception)" doc="Registers a new timeout handler &#xA; Timeout in seconds&#xA;Exception to raise when timeout elapsed" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="win32/registry" ilk="blob" lang="Ruby">
      <scope name="Win32" ilk="namespace">
        <scope name="Registry" ilk="class" classrefs="Object">
          <import symbol="Constants" />
          <import symbol="Enumerable" />
          <scope name="create" ilk="function" signature="create(hkey, subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED)" attributes="__classmethod__" doc="--- Registry.create(key, subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED) &#xA; --- Registry.create(key, subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED) { |reg| ... } &#xA; Create or open the registry key subkey under key. You can use predefined key HKEY_* (see Constants) &#xA; If subkey is already exists, key is opened and Registry#created? method will return false. &#xA; If block is given, the key is closed automatically." />
          <scope name="expand_environ" ilk="function" signature="expand_environ(str)" attributes="__classmethod__" doc="Replace %\w+% into the environment value of what is contained between the %&apos;s This method is used for REG_EXPAND_SZ. &#xA; For detail, see expandEnvironmentStrings[http://msdn.microsoft.com/library/en-us/sysinfo/base/expandenvironmentstrings.asp] \Win32 \API." />
          <scope name="new" ilk="function" signature="new(hkey, parent, keyname, disposition)" attributes="__classmethod__ __ctor__" doc="initialize" />
          <scope name="open" ilk="function" signature="open(hkey, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED)" attributes="__classmethod__" doc="--- Registry.open(key, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED) &#xA; --- Registry.open(key, subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED) { |reg| ... } &#xA; Open the registry key subkey under key. key is Win32::Registry object of parent key. You can use predefined key HKEY_* (see Constants) desired and opt is access mask and key option. For detail, see the MSDN[http://msdn.microsoft.com/library/en-us/sysinfo/base/regopenkeyex.asp]. If block is given, the key is closed automatically." />
          <scope name="time2wtime" ilk="function" signature="time2wtime(time)" attributes="__classmethod__" doc="Convert Time object or Integer object into 64-bit FILETIME." />
          <scope name="type2name" ilk="function" signature="type2name(type)" attributes="__classmethod__" doc="Convert registry type value to readable string." />
          <scope name="wtime2time" ilk="function" signature="wtime2time(wtime)" attributes="__classmethod__" doc="Convert 64-bit FILETIME integer into Time object." />
          <scope name="_dump" ilk="function" signature="_dump(depth)" doc="marshalling is not allowed" />
          <scope name="close" ilk="function" signature="close()" doc="Close key. &#xA; After close, most method raise an error." />
          <scope name="create" ilk="function" signature="create(subkey, desired = KEY_ALL_ACCESS, opt = REG_OPTION_RESERVED, &amp;blk)" doc="Same as Win32::Registry.create (self, subkey, desired, opt)" />
          <scope name="created?" ilk="function" signature="created?()" doc="Returns if key is created ((*newly*)). (see Registry.create) -- basically you call create then when you call created? on the instance returned it will tell if it was successful or not" />
          <scope name="delete" ilk="function" signature="delete(name)" />
          <scope name="delete_key" ilk="function" signature="delete_key(name, recursive = false)" doc="Delete a subkey named name and all its values. &#xA; If recursive is false, the subkey must not have subkeys. Otherwise, this method deletes all subkeys and values recursively." />
          <scope name="delete_value" ilk="function" signature="delete_value(name)" doc="Delete a registry value named name. We can not delete the `default&apos; value." />
          <scope name="each" ilk="function" signature="each()" />
          <scope name="each_key" ilk="function" signature="each_key()" doc="Enumerate subkeys. &#xA; subkey is String which contains name of subkey. wtime is last write time as FILETIME (64-bit integer). (see Registry.wtime2time)" />
          <scope name="each_value" ilk="function" signature="each_value()" doc="Enumerate values." />
          <scope name="flush" ilk="function" signature="flush()" doc="Write all the attributes into the registry file." />
          <scope name="info" ilk="function" signature="info()" doc="Returns key information as Array of: :num_keys The number of subkeys.&#xA; :max_key_length Maximum length of name of subkeys.&#xA; :num_values The number of values.&#xA; :max_value_name_length Maximum length of name of values.&#xA; :max_value_length Maximum length of value of values.&#xA; :descriptor_length Length of security descriptor.&#xA; :wtime Last write time as FILETIME(64-bit integer)&#xA; For detail, see RegQueryInfoKey[http://msdn.microsoft.com/library/en-us/sysinfo/base/regqueryinfokey.asp] Win32 API." />
          <scope name="inspect" ilk="function" signature="inspect()" />
          <scope name="keys" ilk="function" signature="keys()" doc="return keys as an array" />
          <scope name="name" ilk="function" signature="name()" doc="Full path of key such as &apos;HKEY_CURRENT_USER\SOFTWARE\foo\bar&apos;." />
          <scope name="open" ilk="function" signature="open(subkey, desired = KEY_READ, opt = REG_OPTION_RESERVED, &amp;blk)" doc="Same as Win32::Registry.open (self, subkey, desired, opt)" />
          <scope name="open?" ilk="function" signature="open?()" doc="Returns if key is not closed." />
          <scope name="read" ilk="function" signature="read(name, *rtype)" doc="Read a registry value named name and return array of [ type, data ]. When name is nil, the `default&apos; value is read. type is value type. (see Win32::Registry::Constants module) data is value data, its class is: :REG_SZ, REG_EXPAND_SZ String&#xA; :REG_MULTI_SZ Array of String&#xA; :REG_DWORD, REG_DWORD_BIG_ENDIAN, REG_QWORD Integer&#xA; :REG_BINARY String (contains binary data)&#xA; When rtype is specified, the value type must be included by rtype array, or TypeError is raised." />
          <scope name="read_bin" ilk="function" signature="read_bin(name)" doc="Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry value named name. &#xA; If the values type does not match, TypeError is raised." />
          <scope name="read_i" ilk="function" signature="read_i(name)" doc="Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry value named name. &#xA; If the values type does not match, TypeError is raised." />
          <scope name="read_s" ilk="function" signature="read_s(name)" doc="Read a REG_SZ(read_s), REG_DWORD(read_i), or REG_BINARY(read_bin) registry value named name. &#xA; If the values type does not match, TypeError is raised." />
          <scope name="read_s_expand" ilk="function" signature="read_s_expand(name)" doc="Read a REG_SZ or REG_EXPAND_SZ registry value named name. &#xA; If the value type is REG_EXPAND_SZ, environment variables are replaced. Unless the value type is REG_SZ or REG_EXPAND_SZ, TypeError is raised." />
          <scope name="write" ilk="function" signature="write(name, type, data)" doc="Write data to a registry value named name. When name is nil, write to the `default&apos; value. &#xA; type is type value. (see Registry::Constants module) Class of data must be same as which #read method returns." />
          <scope name="write_bin" ilk="function" signature="write_bin(name, value)" doc="Write value to a registry value named name. &#xA; The value type is REG_SZ(write_s), REG_DWORD(write_i), or REG_BINARY(write_bin)." />
          <scope name="write_i" ilk="function" signature="write_i(name, value)" doc="Write value to a registry value named name. &#xA; The value type is REG_SZ(write_s), REG_DWORD(write_i), or REG_BINARY(write_bin)." />
          <scope name="write_s" ilk="function" signature="write_s(name, value)" doc="Write value to a registry value named name. &#xA; The value type is REG_SZ(write_s), REG_DWORD(write_i), or REG_BINARY(write_bin)." />
          <scope ilk="function" name="disposition" />
          <scope ilk="function" name="hkey" />
          <scope ilk="function" name="keyname" />
          <scope ilk="function" name="parent" />
          <scope name="API" ilk="namespace">
            <scope name="CloseKey" ilk="function" signature="CloseKey(hkey)" />
            <scope name="CreateKey" ilk="function" signature="CreateKey(hkey, name, opt, desired)" />
            <scope name="DeleteKey" ilk="function" signature="DeleteKey(hkey, name)" />
            <scope name="DeleteValue" ilk="function" signature="DeleteValue(hkey, name)" />
            <scope name="EnumKey" ilk="function" signature="EnumKey(hkey, index)" />
            <scope name="EnumValue" ilk="function" signature="EnumValue(hkey, index)" />
            <scope name="FlushKey" ilk="function" signature="FlushKey(hkey)" />
            <scope name="OpenKey" ilk="function" signature="OpenKey(hkey, name, opt, desired)" />
            <scope name="QueryInfoKey" ilk="function" signature="QueryInfoKey(hkey)" />
            <scope name="QueryValue" ilk="function" signature="QueryValue(hkey, name)" />
            <scope name="SetValue" ilk="function" signature="SetValue(hkey, name, type, data, size)" />
            <scope name="check" ilk="function" signature="check(result)" />
            <scope name="packdw" ilk="function" signature="packdw(dw)" />
            <scope name="packqw" ilk="function" signature="packqw(qw)" />
            <scope name="unpackdw" ilk="function" signature="unpackdw(dw)" />
            <scope name="unpackqw" ilk="function" signature="unpackqw(qw)" />
          </scope>
          <scope name="Constants" ilk="namespace">
            <variable name="HKEY_CLASSES_ROOT" attributes="__const__" citdl="Object" />
            <variable name="HKEY_CURRENT_USER" attributes="__const__" citdl="Object" />
            <variable name="HKEY_LOCAL_MACHINE" attributes="__const__" citdl="Object" />
            <variable name="HKEY_USERS" attributes="__const__" citdl="Object" />
            <variable name="HKEY_PERFORMANCE_DATA" attributes="__const__" citdl="Object" />
            <variable name="HKEY_PERFORMANCE_TEXT" attributes="__const__" citdl="Object" />
            <variable name="HKEY_PERFORMANCE_NLSTEXT" attributes="__const__" citdl="Object" />
            <variable name="HKEY_CURRENT_CONFIG" attributes="__const__" citdl="Object" />
            <variable name="HKEY_DYN_DATA" attributes="__const__" citdl="Object" />
            <variable name="REG_NONE" attributes="__const__" citdl="Object" />
            <variable name="REG_SZ" attributes="__const__" citdl="Object" />
            <variable name="REG_EXPAND_SZ" attributes="__const__" citdl="Object" />
            <variable name="REG_BINARY" attributes="__const__" citdl="Object" />
            <variable name="REG_DWORD" attributes="__const__" citdl="Object" />
            <variable name="REG_DWORD_LITTLE_ENDIAN" attributes="__const__" citdl="Object" />
            <variable name="REG_DWORD_BIG_ENDIAN" attributes="__const__" citdl="Object" />
            <variable name="REG_LINK" attributes="__const__" citdl="Object" />
            <variable name="REG_MULTI_SZ" attributes="__const__" citdl="Object" />
            <variable name="REG_RESOURCE_LIST" attributes="__const__" citdl="Object" />
            <variable name="REG_FULL_RESOURCE_DESCRIPTOR" attributes="__const__" citdl="Object" />
            <variable name="REG_RESOURCE_REQUIREMENTS_LIST" attributes="__const__" citdl="Object" />
            <variable name="REG_QWORD" attributes="__const__" citdl="Object" />
            <variable name="REG_QWORD_LITTLE_ENDIAN" attributes="__const__" citdl="Object" />
            <variable name="STANDARD_RIGHTS_READ" attributes="__const__" citdl="Object" />
            <variable name="STANDARD_RIGHTS_WRITE" attributes="__const__" citdl="Object" />
            <variable name="KEY_QUERY_VALUE" attributes="__const__" citdl="Object" />
            <variable name="KEY_SET_VALUE" attributes="__const__" citdl="Object" />
            <variable name="KEY_CREATE_SUB_KEY" attributes="__const__" citdl="Object" />
            <variable name="KEY_ENUMERATE_SUB_KEYS" attributes="__const__" citdl="Object" />
            <variable name="KEY_NOTIFY" attributes="__const__" citdl="Object" />
            <variable name="KEY_CREATE_LINK" attributes="__const__" citdl="Object" />
            <variable name="KEY_READ" attributes="__const__" citdl="Object" />
            <variable name="KEY_WRITE" attributes="__const__" citdl="Object" />
            <variable name="KEY_EXECUTE" attributes="__const__" citdl="Object" />
            <variable name="KEY_ALL_ACCESS" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_RESERVED" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_NON_VOLATILE" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_VOLATILE" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_CREATE_LINK" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_BACKUP_RESTORE" attributes="__const__" citdl="Object" />
            <variable name="REG_OPTION_OPEN_LINK" attributes="__const__" citdl="Object" />
            <variable name="REG_LEGAL_OPTION" attributes="__const__" citdl="Object" />
            <variable name="REG_CREATED_NEW_KEY" attributes="__const__" citdl="Object" />
            <variable name="REG_OPENED_EXISTING_KEY" attributes="__const__" citdl="Object" />
            <variable name="REG_WHOLE_HIVE_VOLATILE" attributes="__const__" citdl="Object" />
            <variable name="REG_REFRESH_HIVE" attributes="__const__" citdl="Object" />
            <variable name="REG_NO_LAZY_FLUSH" attributes="__const__" citdl="Object" />
            <variable name="REG_FORCE_RESTORE" attributes="__const__" citdl="Object" />
            <variable name="MAX_KEY_LENGTH" attributes="__const__" citdl="Object" />
            <variable name="MAX_VALUE_LENGTH" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="Error" ilk="class" classrefs="StandardError">
            <scope name="new" ilk="function" signature="new(code)" attributes="__classmethod__ __ctor__" />
            <scope ilk="function" name="code" />
            <scope name="Kernel32" ilk="namespace">
            </scope>
          </scope>
          <scope name="PredefinedKey" ilk="class" classrefs="Win32::Registry">
            <scope name="new" ilk="function" signature="new(hkey, keyname)" attributes="__classmethod__ __ctor__" />
            <scope name="class" ilk="function" signature="class()" doc="Fake #class method for Registry#open, Registry#create" />
            <scope name="close" ilk="function" signature="close()" doc="Predefined keys cannot be closed" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="win32/sspi" ilk="blob" lang="Ruby">
      <scope name="Win32" ilk="namespace">
        <scope name="Resolv" ilk="namespace">
          <scope name="get_hosts_path" ilk="function" signature="get_hosts_path()" attributes="__classmethod__" />
          <scope name="get_resolv_info" ilk="function" signature="get_resolv_info()" attributes="__classmethod__" />
          <variable name="API" attributes="__const__" citdl="Object" />
          <scope name="Kernel32" ilk="namespace">
          </scope>
        </scope>
        <scope name="SSPI" ilk="namespace">
          <variable name="SECPKG_CRED_INBOUND" attributes="__const__" citdl="Object" />
          <variable name="SECPKG_CRED_OUTBOUND" attributes="__const__" citdl="Object" />
          <variable name="SECPKG_CRED_BOTH" attributes="__const__" citdl="Object" />
          <variable name="SECURITY_NATIVE_DREP" attributes="__const__" citdl="Object" />
          <variable name="SECURITY_NETWORK_DREP" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_REPLAY_DETECT" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_SEQUENCE_DETECT" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_CONFIDENTIALITY" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_USE_SESSION_KEY" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_PROMPT_FOR_CREDS" attributes="__const__" citdl="Object" />
          <variable name="ISC_REQ_CONNECTION" attributes="__const__" citdl="Object" />
          <scope name="API" ilk="namespace">
          </scope>
          <scope name="Identity" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user = nil, domain = nil, password = nil)" attributes="__classmethod__ __ctor__" />
            <scope name="to_p" ilk="function" signature="to_p()" />
            <scope ilk="function" name="domain" />
            <scope ilk="function" name="domain=" />
            <scope ilk="function" name="password" />
            <scope ilk="function" name="password=" />
            <scope ilk="function" name="user" />
            <scope ilk="function" name="user=" />
            <variable name="SEC_WINNT_AUTH_IDENTITY_ANSI" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="NegotiateAuth" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(user = nil, domain = nil)" attributes="__classmethod__ __ctor__" doc="Creates a new instance ready for authentication as the given user in the given domain. Defaults to current user and domain as defined by ENV[&quot;USERDOMAIN&quot;] and ENV[&quot;USERNAME&quot;] if no arguments are supplied." />
            <scope name="proxy_auth_get" ilk="function" signature="proxy_auth_get(http, path, user = nil, domain = nil)" attributes="__classmethod__" doc="Given a connection and a request path, performs authentication as the current user and returns the response from a GET request. The connnection should be a Net::HTTP object, and it should have been constructed using the Net::HTTP.Proxy method, but anything that responds to &quot;get&quot; will work. If a user and domain are given, will authenticate as the given user. Returns the response received from the get method (usually Net::HTTPResponse)" />
            <scope name="complete_authentication" ilk="function" signature="complete_authentication(token)" doc="Takes a token and gets the next token in the Negotiate authentication chain. Token can be Base64 encoded or not. The token can include the &quot;Negotiate&quot; header and it will be stripped. Does not indicate if SEC_I_CONTINUE or SEC_E_OK was returned. Token returned is Base64 encoded w/ all new lines removed." />
            <scope name="get_initial_token" ilk="function" signature="get_initial_token()" doc="Gets the initial Negotiate token. Returns it as a base64 encoded string suitable for use in HTTP. Can be easily decoded, however." />
            <scope ilk="function" name="context" />
            <scope ilk="function" name="context=" />
            <scope ilk="function" name="contextAttributes" />
            <scope ilk="function" name="contextAttributes=" />
            <scope ilk="function" name="credentials" />
            <scope ilk="function" name="credentials=" />
            <scope ilk="function" name="domain" />
            <scope ilk="function" name="domain=" />
            <scope ilk="function" name="user" />
            <scope ilk="function" name="user=" />
            <variable name="REQUEST_FLAGS" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="SSPIResult" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(value)" attributes="__classmethod__ __ctor__" />
            <scope name="ok?" ilk="function" signature="ok?()" />
            <scope name="to_s" ilk="function" signature="to_s()" />
            <scope ilk="function" name="value" />
            <variable name="SEC_E_OK" attributes="__const__" citdl="Object" />
            <variable name="SEC_I_CONTINUE_NEEDED" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_INSUFFICIENT_MEMORY" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_INTERNAL_ERROR" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_INVALID_HANDLE" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_INVALID_TOKEN" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_LOGON_DENIED" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_NO_AUTHENTICATING_AUTHORITY" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_NO_CREDENTIALS" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_TARGET_UNKNOWN" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_UNSUPPORTED_FUNCTION" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_WRONG_PRINCIPAL" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_NOT_OWNER" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_SECPKG_NOT_FOUND" attributes="__const__" citdl="Object" />
            <variable name="SEC_E_UNKNOWN_CREDENTIALS" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="SecurityBuffer" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(buffer = nil)" attributes="__classmethod__ __ctor__" />
            <scope name="bufferSize" ilk="function" signature="bufferSize()" />
            <scope name="bufferType" ilk="function" signature="bufferType()" />
            <scope name="to_p" ilk="function" signature="to_p()" />
            <scope name="token" ilk="function" signature="token()" />
            <variable name="SECBUFFER_TOKEN" attributes="__const__" citdl="Object" />
            <variable name="TOKENBUFSIZE" attributes="__const__" citdl="Object" />
            <variable name="SECBUFFER_VERSION" attributes="__const__" citdl="Object" />
          </scope>
          <scope name="SecurityHandle" ilk="class" classrefs="Object">
            <scope name="lower" ilk="function" signature="lower()" />
            <scope name="to_p" ilk="function" signature="to_p()" />
            <scope name="upper" ilk="function" signature="upper()" />
          </scope>
          <scope name="TimeStamp" ilk="class" classrefs="Object">
            <scope name="to_p" ilk="function" signature="to_p()" />
            <scope ilk="function" name="struct" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="win32ole" ilk="blob" lang="Ruby">
      <scope name="WIN32OLE" ilk="class" classrefs="Object">
        <scope name="codepage" ilk="function" signature="codepage()" attributes="__classmethod__" doc="Returns current codepage. WIN32OLE.codepage # =&gt; WIN32OLE::CP_ACP" />
        <scope name="codepage=" ilk="function" signature="codepage=(p1)" attributes="__classmethod__" doc="Sets current codepage. The WIN32OLE.codepage is initialized according to Encoding.default_internal. If Encoding.default_internal is nil then WIN32OLE.codepage is initialized according to Encoding.default_external. &#xA; WIN32OLE.codepage = WIN32OLE::CP_UTF8&#xA;WIN32OLE.codepage = 65001" />
        <scope name="connect" ilk="function" signature="connect(p1, *args)" attributes="__classmethod__" doc="Returns running OLE Automation object or WIN32OLE object from moniker. 1st argument should be OLE program id or class id or moniker. &#xA; WIN32OLE.connect(&apos;Excel.Application&apos;) # =&gt; WIN32OLE object which represents running Excel." />
        <scope name="const_load" ilk="function" signature="const_load(p1, p2 = v2)" attributes="__classmethod__" doc="Defines the constants of OLE Automation server as mod&apos;s constants. The first argument is WIN32OLE object or type library name. If 2nd argument is omitted, the default is WIN32OLE. The first letter of Ruby&apos;s constant variable name is upper case, so constant variable name of WIN32OLE object is capitalized. For example, the &apos;xlTop&apos; constant of Excel is changed to &apos;XlTop&apos; in WIN32OLE. If the first letter of constant variabl is not [A-Z], then the constant is defined as CONSTANTS hash element. &#xA; module EXCEL_CONST&#xA;end&#xA;excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;WIN32OLE.const_load(excel, EXCEL_CONST)&#xA;puts EXCEL_CONST::XlTop # =&gt; -4160&#xA;puts EXCEL_CONST::CONSTANTS[&apos;_xlDialogChartSourceData&apos;] # =&gt; 541&#xA;WIN32OLE.const_load(excel)&#xA;puts WIN32OLE::XlTop # =&gt; -4160&#xA;module MSO&#xA;end&#xA;WIN32OLE.const_load(&apos;Microsoft Office 9.0 Object Library&apos;, MSO)&#xA;puts MSO::MsoLineSingle # =&gt; 1" />
        <scope name="create_guid" ilk="function" signature="create_guid()" attributes="__classmethod__" doc="Creates GUID. WIN32OLE.create_guid # =&gt; {1CB530F1-F6B1-404D-BCE6-1959BF91F4A8}" />
        <scope name="locale" ilk="function" signature="locale()" attributes="__classmethod__" doc="Returns current locale id (lcid). The default locale is LOCALE_SYSTEM_DEFAULT. &#xA; lcid = WIN32OLE.locale" />
        <scope name="locale=" ilk="function" signature="locale=(p1)" attributes="__classmethod__" doc="Sets current locale id (lcid). &#xA; WIN32OLE.locale = 1033 # set locale English(U.S)&#xA;obj = WIN32OLE_VARIANT.new(&quot;$100,000&quot;, WIN32OLE::VARIANT::VT_CY)" />
        <scope name="new" ilk="function" signature="new(p1, p2 = v2, *args)" attributes="__classmethod__ __ctor__" doc="Returns a new WIN32OLE object(OLE Automation object). The first argument server specifies OLE Automation server. The first argument should be CLSID or PROGID. If second argument host specified, then returns OLE Automation object on host. &#xA; WIN32OLE.new(&apos;Excel.Application&apos;) # =&gt; Excel OLE Automation WIN32OLE object.&#xA;WIN32OLE.new(&apos;{00024500-0000-0000-C000-000000000046}&apos;) # =&gt; Excel OLE Automation WIN32OLE object." />
        <scope name="ole_free" ilk="function" signature="ole_free(p1)" attributes="__classmethod__" doc="Invokes Release method of Dispatch interface of WIN32OLE object. You should not use this method because this method exists only for debugging WIN32OLE. The return value is reference counter of OLE object." />
        <scope name="ole_initialize" ilk="function" signature="ole_initialize()" attributes="__classmethod__" doc=":nodoc   " />
        <scope name="ole_reference_count" ilk="function" signature="ole_reference_count(p1)" attributes="__classmethod__" doc="Returns reference counter of Dispatch interface of WIN32OLE object. You should not use this method because this method exists only for debugging WIN32OLE." />
        <scope name="ole_show_help" ilk="function" signature="ole_show_help(p1, p2 = v2)" attributes="__classmethod__" doc="Displays helpfile. The 1st argument specifies WIN32OLE_TYPE object or WIN32OLE_METHOD object or helpfile. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;typeobj = excel.ole_type&#xA;WIN32OLE.ole_show_help(typeobj)" />
        <scope name="ole_uninitialize" ilk="function" signature="ole_uninitialize()" attributes="__classmethod__" doc=":nodoc   " />
        <scope name="_getproperty" ilk="function" signature="_getproperty(p1, p2, p3)" doc="Runs the early binding method to get property. The 1st argument specifies dispatch ID, the 2nd argument specifies the array of arguments, the 3rd argument specifies the array of the type of arguments. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;puts excel._getproperty(558, [], []) # same effect as puts excel.visible" />
        <scope name="_invoke" ilk="function" signature="_invoke(p1, p2, p3)" doc="Runs the early binding method. The 1st argument specifies dispatch ID, the 2nd argument specifies the array of arguments, the 3rd argument specifies the array of the type of arguments. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;excel._invoke(302, [], []) #  same effect as excel.Quit" />
        <scope name="_setproperty" ilk="function" signature="_setproperty(p1, p2, p3)" doc="Runs the early binding method to set property. The 1st argument specifies dispatch ID, the 2nd argument specifies the array of arguments, the 3rd argument specifies the array of the type of arguments. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;excel._setproperty(558, [true], [WIN32OLE::VARIANT::VT_BOOL]) # same effect as excel.visible = true" />
        <scope name="each" ilk="function" signature="each()" doc="Iterates over each item of OLE collection which has IEnumVARIANT interface. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;book = excel.workbooks.add&#xA;sheets = book.worksheets(1)&#xA;cells = sheets.cells(&quot;A1:A5&quot;)&#xA;cells.each do |cell|&#xA;  cell.value = 10&#xA;end" />
        <scope name="invoke" ilk="function" signature="invoke(*args)" doc="Runs OLE method. The first argument specifies the method name of OLE Automation object. The others specify argument of the method. If you can not execute method directly, then use this method instead. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;excel.invoke(&apos;Quit&apos;)  # =&gt; same as excel.Quit" />
        <scope name="method_missing" ilk="function" signature="method_missing(*args)" doc="Calls WIN32OLE#invoke method." />
        <scope name="ole_activex_initialize" ilk="function" signature="ole_activex_initialize()" doc="Initialize WIN32OLE object(ActiveX Control) by calling IPersistMemory::InitNew. &#xA; Before calling OLE method, some kind of the ActiveX controls created with MFC should be initialized by calling IPersistXXX::InitNew. &#xA; If and only if you received the exception &quot;HRESULT error code: 0x8000ffff catastrophic failure&quot;, try this method before invoking any ole_method. &#xA; obj = WIN32OLE.new(&quot;ProgID_or_GUID_of_ActiveX_Control&quot;)&#xA;obj.ole_activex_initialize&#xA;obj.method(...)" />
        <scope name="ole_free" ilk="function" signature="ole_free()" doc="invokes Release method of Dispatch interface of WIN32OLE object. Usually, you do not need to call this method because Release method called automatically when WIN32OLE object garbaged." />
        <scope name="ole_func_methods" ilk="function" signature="ole_func_methods()" doc="Returns the array of WIN32OLE_METHOD object . The element of the array is property (settable) of WIN32OLE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;properties = excel.ole_func_methods" />
        <scope name="ole_get_methods" ilk="function" signature="ole_get_methods()" doc="Returns the array of WIN32OLE_METHOD object . The element of the array is property (gettable) of WIN32OLE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;properties = excel.ole_get_methods" />
        <scope name="ole_method" ilk="function" signature="ole_method(p1)" doc="Returns WIN32OLE_METHOD object corresponding with method specified by 1st argument. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;method = excel.ole_method_help(&apos;Quit&apos;)" />
        <scope name="ole_method_help" ilk="function" signature="ole_method_help(p1)" />
        <scope name="ole_methods" ilk="function" signature="ole_methods()" doc="Returns the array of WIN32OLE_METHOD object. The element is OLE method of WIN32OLE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;methods = excel.ole_methods" />
        <scope name="ole_obj_help" ilk="function" signature="ole_obj_help()" />
        <scope name="ole_put_methods" ilk="function" signature="ole_put_methods()" doc="Returns the array of WIN32OLE_METHOD object . The element of the array is property (settable) of WIN32OLE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;properties = excel.ole_put_methods" />
        <scope name="ole_query_interface" ilk="function" signature="ole_query_interface(p1)" doc="Returns WIN32OLE object for a specific dispatch or dual interface specified by iid. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ie_web_app = ie.ole_query_interface(&apos;{0002DF05-0000-0000-C000-000000000046}&apos;) # =&gt; WIN32OLE object for dispinterface IWebBrowserApp" />
        <scope name="ole_respond_to?" ilk="function" signature="ole_respond_to?(p1)" doc="Returns true when OLE object has OLE method, otherwise returns false. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ie.ole_respond_to?(&quot;gohome&quot;) =&gt; true" />
        <scope name="ole_type" ilk="function" signature="ole_type()" doc="Returns WIN32OLE_TYPE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;tobj = excel.ole_type" />
        <scope name="ole_typelib" ilk="function" signature="ole_typelib()" doc="Returns the WIN32OLE_TYPELIB object. The object represents the type library which contains the WIN32OLE object. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;tlib = excel.ole_typelib&#xA;puts tlib.name  # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;" />
        <scope name="setproperty" ilk="function" signature="setproperty(*args)" doc="Sets property of OLE object. When you want to set property with argument, you can use this method. &#xA; excel = WIN32OLE.new(&apos;Excel.Application&apos;)&#xA;excel.Visible = true&#xA;book = excel.workbooks.add&#xA;sheet = book.worksheets(1)&#xA;sheet.setproperty(&apos;Cells&apos;, 1, 2, 10) # =&gt; The B1 cell value is 10." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="ARGV" attributes="__const__" citdl="Object" />
        <variable name="CP_ACP" attributes="__const__" citdl="Object" />
        <variable name="CP_OEMCP" attributes="__const__" citdl="Object" />
        <variable name="CP_MACCP" attributes="__const__" citdl="Object" />
        <variable name="CP_THREAD_ACP" attributes="__const__" citdl="Object" />
        <variable name="CP_SYMBOL" attributes="__const__" citdl="Object" />
        <variable name="LOCALE_SYSTEM_DEFAULT" attributes="__const__" citdl="Object" />
        <variable name="LOCALE_USER_DEFAULT" attributes="__const__" citdl="Object" />
        <scope name="VARIANT" ilk="namespace">
          <variable name="VT_EMPTY" attributes="__const__" citdl="Object" />
          <variable name="VT_NULL" attributes="__const__" citdl="Object" />
          <variable name="VT_CY" attributes="__const__" citdl="Object" />
          <variable name="VT_DATE" attributes="__const__" citdl="Object" />
          <variable name="VT_BSTR" attributes="__const__" citdl="Object" />
          <variable name="VT_USERDEFINED" attributes="__const__" citdl="Object" />
          <variable name="VT_PTR" attributes="__const__" citdl="Object" />
          <variable name="VT_DISPATCH" attributes="__const__" citdl="Object" />
          <variable name="VT_ERROR" attributes="__const__" citdl="Object" />
          <variable name="VT_BOOL" attributes="__const__" citdl="Object" />
          <variable name="VT_VARIANT" attributes="__const__" citdl="Object" />
          <variable name="VT_UNKNOWN" attributes="__const__" citdl="Object" />
          <variable name="VT_INT" attributes="__const__" citdl="Object" />
          <variable name="VT_UINT" attributes="__const__" citdl="Object" />
          <variable name="VT_ARRAY" attributes="__const__" citdl="Object" />
          <variable name="VT_BYREF" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
      <scope name="WIN32OLE_EVENT" ilk="class" classrefs="Object">
        <scope name="message_loop" ilk="function" signature="message_loop()" attributes="__classmethod__" doc="Translates and dispatches Windows message." />
        <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" doc="Returns OLE event object. The first argument specifies WIN32OLE object. The second argument specifies OLE event name. ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ev = WIN32OLE_EVENT.new(ie, &apos;DWebBrowserEvents&apos;)" />
        <scope name="handler" ilk="function" signature="handler()" doc="returns handler object." />
        <scope name="handler=" ilk="function" signature="handler=(p1)" doc="sets event handler object. If handler object has onXXX method according to XXX event, then onXXX method is called when XXX event occurs. &#xA; If handler object has method_missing and there is no method according to the event, then method_missing called and 1-st argument is event name. &#xA; If handler object has onXXX method and there is block defined by WIN32OLE_EVENT#on_event(&apos;XXX&apos;){}, then block is executed but handler object method is not called when XXX event occurs. &#xA; class Handler&#xA;  def onStatusTextChange(text)&#xA;    puts &quot;StatusTextChanged&quot;&#xA;  end&#xA;  def onPropertyChange(prop)&#xA;    puts &quot;PropertyChanged&quot;&#xA;  end&#xA;  def method_missing(ev, *arg)&#xA;    puts &quot;other event #{ev}&quot;&#xA;  end" />
        <scope name="off_event" ilk="function" signature="off_event(p1 = v1)" doc="removes the callback of event. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ev = WIN32OLE_EVENT.new(ie)&#xA;ev.on_event(&apos;BeforeNavigate2&apos;) {|*args|&#xA;  args.last[6] = true&#xA;}&#xA;  ...&#xA;ev.off_event(&apos;BeforeNavigate2&apos;)&#xA;  ..." />
        <scope name="on_event" ilk="function" signature="on_event(*args)" doc="Defines the callback event. If argument is omitted, this method defines the callback of all events. If you want to modify reference argument in callback, return hash in callback. If you want to return value to OLE server as result of callback use `return&apos; or :return. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ev = WIN32OLE_EVENT.new(ie)&#xA;ev.on_event(&quot;NavigateComplete&quot;) {|url| puts url}&#xA;ev.on_event() {|ev, *args| puts &quot;#{ev} fired&quot;}&#xA;ev.on_event(&quot;BeforeNavigate2&quot;) {|*args|&#xA;  ...&#xA;  # set true to BeforeNavigate reference argument `Cancel&apos;.&#xA;  # Cancel is 7-th argument of BeforeNavigate,&#xA;  # so you can use 6 as key of hash instead of &apos;Cancel&apos;.&#xA;  # The argument is counted from 0.&#xA;  # The hash key of 0 means first argument.)&#xA;  {:Cancel =&gt; true}  # or {&apos;Cancel&apos; =&gt; true} or {6 =&gt; true}" />
        <scope name="on_event_with_outargs" ilk="function" signature="on_event_with_outargs(*args)" doc="Defines the callback of event. If you want modify argument in callback, you could use this method instead of WIN32OLE_EVENT#on_event. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ev = WIN32OLE_EVENT.new(ie)&#xA;ev.on_event_with_outargs(&apos;BeforeNavigate2&apos;) {|*args|&#xA;  args.last[6] = true&#xA;}" />
        <scope name="unadvise" ilk="function" signature="unadvise()" doc="disconnects OLE server. If this method called, then the WIN32OLE_EVENT object does not receive the OLE server event any more. This method is trial implementation. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ev = WIN32OLE_EVENT.new(ie)&#xA;ev.on_event() {...}&#xA;   ...&#xA;ev.unadvise" />
      </scope>
      <scope name="WIN32OLE_METHOD" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" doc="Returns a new WIN32OLE_METHOD object which represents the information about OLE method. The first argument ole_type specifies WIN32OLE_TYPE object. The second argument method specifies OLE method name defined OLE class which represents WIN32OLE_TYPE object. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)" />
        <scope name="dispid" ilk="function" signature="dispid()" doc="Returns dispatch ID. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.dispid # =&gt; 181" />
        <scope name="event?" ilk="function" signature="event?()" doc="Returns true if the method is event. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SheetActivate&apos;)&#xA;puts method.event? # =&gt; true" />
        <scope name="event_interface" ilk="function" signature="event_interface()" doc="Returns event interface name if the method is event. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SheetActivate&apos;)&#xA;puts method.event_interface # =&gt;  WorkbookEvents" />
        <scope name="helpcontext" ilk="function" signature="helpcontext()" doc="Returns help context. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.helpcontext # =&gt; 65717" />
        <scope name="helpfile" ilk="function" signature="helpfile()" doc="Returns help file. If help file is not found, then the method returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.helpfile # =&gt; C:\...\VBAXL9.CHM" />
        <scope name="helpstring" ilk="function" signature="helpstring()" doc="Returns help string of OLE method. If the help string is not found, then the method returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &apos;IWebBrowser&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Navigate&apos;)&#xA;puts method.helpstring # =&gt; Navigates to a URL or file." />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns the method name with class name." />
        <scope name="invkind" ilk="function" signature="invkind()" doc="Returns the method invoke kind. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.invkind # =&gt; 1" />
        <scope name="invoke_kind" ilk="function" signature="invoke_kind()" doc="Returns the method kind string. The string is &quot;UNKNOWN&quot; or &quot;PROPERTY&quot; or &quot;PROPERTY&quot; or &quot;PROPERTYGET&quot; or &quot;PROPERTYPUT&quot; or &quot;PROPERTYPPUTREF&quot; or &quot;FUNC&quot;. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.invoke_kind # =&gt; &quot;FUNC&quot;" />
        <scope name="name" ilk="function" signature="name()" doc="call-seq WIN32OLE_METHOD#name&#xA; Returns the name of the method. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;puts method.name # =&gt; SaveAs" />
        <scope name="offset_vtbl" ilk="function" signature="offset_vtbl()" doc="Returns the offset ov VTBL. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.offset_vtbl # =&gt; 40" />
        <scope name="params" ilk="function" signature="params()" doc="returns array of WIN32OLE_PARAM object corresponding with method parameters. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;p method.params # =&gt; [Filename, FileFormat, Password, WriteResPassword,&#xA;                      ReadOnlyRecommended, CreateBackup, AccessMode,&#xA;                      ConflictResolution, AddToMru, TextCodepage,&#xA;                      TextVisualLayout]" />
        <scope name="return_type" ilk="function" signature="return_type()" doc="Returns string of return value type of method. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.return_type # =&gt; Workbook" />
        <scope name="return_type_detail" ilk="function" signature="return_type_detail()" doc="Returns detail information of return value type of method. The information is array. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;p method.return_type_detail # =&gt; [&quot;PTR&quot;, &quot;USERDEFINED&quot;, &quot;Workbook&quot;]" />
        <scope name="return_vtype" ilk="function" signature="return_vtype()" doc="Returns number of return value type of method. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.return_vtype # =&gt; 26" />
        <scope name="size_opt_params" ilk="function" signature="size_opt_params()" doc="Returns the size of optional parameters. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;puts method.size_opt_params # =&gt; 4" />
        <scope name="size_params" ilk="function" signature="size_params()" doc="Returns the size of arguments of the method. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;puts method.size_params # =&gt; 11" />
        <scope name="to_s" ilk="function" signature="to_s()" />
        <scope name="visible?" ilk="function" signature="visible?()" doc="Returns true if the method is public. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbooks&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;Add&apos;)&#xA;puts method.visible? # =&gt; true" />
      </scope>
      <scope name="WIN32OLE_PARAM" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" />
        <scope name="default" ilk="function" signature="default()" doc="Returns default value. If the default value does not exist, this method returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;method.params.each do |param|&#xA;  if param.default&#xA;    puts &quot;#{param.name} (= #{param.default})&quot;&#xA;  else&#xA;    puts &quot;#{param}&quot;&#xA;  end&#xA;end&#xA;The above script result is following:&#xA;    Filename&#xA;    FileFormat&#xA;    Password" />
        <scope name="input?" ilk="function" signature="input?()" doc="Returns true if the parameter is input. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;param1 = method.params[0]&#xA;puts param1.input? # =&gt; true" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns the parameter name with class name. If the parameter has default value, then returns name=value string with class name." />
        <scope name="name" ilk="function" signature="name()" doc="Returns name. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;param1 = method.params[0]&#xA;puts param1.name # =&gt; Filename" />
        <scope name="ole_type" ilk="function" signature="ole_type()" doc="Returns OLE type of WIN32OLE_PARAM object(parameter of OLE method). tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;param1 = method.params[0]&#xA;puts param1.ole_type # =&gt; VARIANT" />
        <scope name="ole_type_detail" ilk="function" signature="ole_type_detail()" doc="Returns detail information of type of argument. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;IWorksheetFunction&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SumIf&apos;)&#xA;param1 = method.params[0]&#xA;p param1.ole_type_detail # =&gt; [&quot;PTR&quot;, &quot;USERDEFINED&quot;, &quot;Range&quot;]" />
        <scope name="optional?" ilk="function" signature="optional?()" doc="Returns true if argument is optional. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Workbook&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;SaveAs&apos;)&#xA;param1 = method.params[0]&#xA;puts &quot;#{param1.name} #{param1.optional?}&quot; # =&gt; Filename true" />
        <scope name="output?" ilk="function" signature="output?()" doc="Returns true if argument is output. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &apos;DWebBrowserEvents&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;NewWindow&apos;)&#xA;method.params.each do |param|&#xA;  puts &quot;#{param.name} #{param.output?}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  URL false&#xA;  Flags false&#xA;  TargetFrameName false&#xA;  PostData false&#xA;  Headers false&#xA;  Processed true" />
        <scope name="retval?" ilk="function" signature="retval?()" doc="Returns true if argument is return value. tobj = WIN32OLE_TYPE.new(&apos;DirectX 7 for Visual Basic Type Library&apos;,&#xA;                         &apos;DirectPlayLobbyConnection&apos;)&#xA;method = WIN32OLE_METHOD.new(tobj, &apos;GetPlayerShortName&apos;)&#xA;param = method.params[0]&#xA;puts &quot;#{param.name} #{param.retval?}&quot;  # =&gt; name true" />
        <scope name="to_s" ilk="function" signature="to_s()" />
      </scope>
      <scope name="WIN32OLE_TYPE" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(p1, p2)" attributes="__classmethod__ __ctor__" doc="Returns a new WIN32OLE_TYPE object. The first argument typelib specifies OLE type library name. The second argument specifies OLE class name. &#xA; WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;    # =&gt; WIN32OLE_TYPE object of Application class of Excel." />
        <scope name="ole_classes" ilk="function" signature="ole_classes(p1)" attributes="__classmethod__" doc="Returns array of WIN32OLE_TYPE objects defined by the typelib type library. This method will be OBSOLETE. Use WIN32OLE_TYPELIB.new(typelib).ole_classes instead." />
        <scope name="progids" ilk="function" signature="progids()" attributes="__classmethod__" doc="Returns array of ProgID." />
        <scope name="typelibs" ilk="function" signature="typelibs()" attributes="__classmethod__" doc="Returns array of type libraries. This method will be OBSOLETE. Use WIN32OLE_TYPELIB.typelibs.collect{|t| t.name} instead." />
        <scope name="default_event_sources" ilk="function" signature="default_event_sources()" doc="Returns the array of WIN32OLE_TYPE object which is implemented by the WIN32OLE_TYPE object and having IMPLTYPEFLAG_FSOURCE and IMPLTYPEFLAG_FDEFAULT. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &quot;InternetExplorer&quot;)&#xA;p tobj.default_event_sources  # =&gt; [#&lt;WIN32OLE_TYPE:DWebBrowserEvents2&gt;]" />
        <scope name="default_ole_types" ilk="function" signature="default_ole_types()" doc="Returns the array of WIN32OLE_TYPE object which is implemented by the WIN32OLE_TYPE object and having IMPLTYPEFLAG_FDEFAULT. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &quot;InternetExplorer&quot;)&#xA;p tobj.default_ole_types&#xA;# =&gt; [#&lt;WIN32OLE_TYPE:IWebBrowser2&gt;, #&lt;WIN32OLE_TYPE:DWebBrowserEvents2&gt;]" />
        <scope name="guid" ilk="function" signature="guid()" doc="Returns GUID. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;puts tobj.guid  # =&gt; {00024500-0000-0000-C000-000000000046}" />
        <scope name="helpcontext" ilk="function" signature="helpcontext()" doc="Returns helpcontext. If helpcontext is not found, then returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Worksheet&apos;)&#xA;puts tobj.helpfile # =&gt; 131185" />
        <scope name="helpfile" ilk="function" signature="helpfile()" doc="Returns helpfile path. If helpfile is not found, then returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Worksheet&apos;)&#xA;puts tobj.helpfile # =&gt; C:\...\VBAXL9.CHM" />
        <scope name="helpstring" ilk="function" signature="helpstring()" doc="Returns help string. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &apos;IWebBrowser&apos;)&#xA;puts tobj.helpstring # =&gt; Web Browser interface" />
        <scope name="implemented_ole_types" ilk="function" signature="implemented_ole_types()" doc="Returns the array of WIN32OLE_TYPE object which is implemented by the WIN32OLE_TYPE object. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Worksheet&apos;)&#xA;p tobj.implemented_ole_types # =&gt; [_Worksheet, DocEvents]" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns the type name with class name. &#xA; ie = WIN32OLE.new(&apos;InternetExplorer.Application&apos;)&#xA;ie.ole_type.inspect =&gt; #&lt;WIN32OLE_TYPE:IWebBrowser2&gt;" />
        <scope name="major_version" ilk="function" signature="major_version()" doc="Returns major version. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Word 10.0 Object Library&apos;, &apos;Documents&apos;)&#xA;puts tobj.major_version # =&gt; 8" />
        <scope name="minor_version" ilk="function" signature="minor_version()" doc="Returns minor version. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Word 10.0 Object Library&apos;, &apos;Documents&apos;)&#xA;puts tobj.minor_version # =&gt; 2" />
        <scope name="name" ilk="function" signature="name()" doc="Returns OLE type name. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;puts tobj.name  # =&gt; Application" />
        <scope name="ole_methods" ilk="function" signature="ole_methods()" doc="Returns array of WIN32OLE_METHOD objects which represent OLE method defined in OLE type library. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Worksheet&apos;)&#xA;methods = tobj.ole_methods.collect{|m|&#xA;  m.name&#xA;}&#xA;# =&gt; [&apos;Activate&apos;, &apos;Copy&apos;, &apos;Delete&apos;,....]" />
        <scope name="ole_type" ilk="function" signature="ole_type()" doc="returns type of OLE class. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;puts tobj.ole_type  # =&gt; Class" />
        <scope name="ole_typelib" ilk="function" signature="ole_typelib()" doc="Returns the WIN32OLE_TYPELIB object which is including the WIN32OLE_TYPE object. If it is not found, then returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Worksheet&apos;)&#xA;puts tobj.ole_typelib # =&gt; &apos;Microsoft Excel 9.0 Object Library&apos;" />
        <scope name="progid" ilk="function" signature="progid()" doc="Returns ProgID if it exists. If not found, then returns nil. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;puts tobj.progid  # =&gt;   Excel.Application.9" />
        <scope name="source_ole_types" ilk="function" signature="source_ole_types()" doc="Returns the array of WIN32OLE_TYPE object which is implemented by the WIN32OLE_TYPE object and having IMPLTYPEFLAG_FSOURCE. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Internet Controls&apos;, &quot;InternetExplorer&quot;)&#xA;p tobj.source_ole_types&#xA;# =&gt; [#&lt;WIN32OLE_TYPE:DWebBrowserEvents2&gt;, #&lt;WIN32OLE_TYPE:DWebBrowserEvents&gt;]" />
        <scope name="src_type" ilk="function" signature="src_type()" doc="Returns source class when the OLE class is &apos;Alias&apos;. tobj =  WIN32OLE_TYPE.new(&apos;Microsoft Office 9.0 Object Library&apos;, &apos;MsoRGBType&apos;)&#xA;puts tobj.src_type # =&gt; I4" />
        <scope name="to_s" ilk="function" signature="to_s()" />
        <scope name="typekind" ilk="function" signature="typekind()" doc="Returns number which represents type. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Word 10.0 Object Library&apos;, &apos;Documents&apos;)&#xA;puts tobj.typekind # =&gt; 4" />
        <scope name="variables" ilk="function" signature="variables()" doc="Returns array of WIN32OLE_VARIABLE objects which represent variables defined in OLE class. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;vars = tobj.variables&#xA;vars.each do |v|&#xA;  puts &quot;#{v.name} = #{v.value}&quot;&#xA;end&#xA;&#xA;The result of above sample script is follows:&#xA;  xlChart = -4109&#xA;  xlDialogSheet = -4116&#xA;  xlExcel4IntlMacroSheet = 4&#xA;  xlExcel4MacroSheet = 3&#xA;  xlWorksheet = -4167" />
        <scope name="visible?" ilk="function" signature="visible?()" doc="Returns true if the OLE class is public. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;Application&apos;)&#xA;puts tobj.visible  # =&gt; true" />
      </scope>
      <scope name="WIN32OLE_TYPELIB" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(*args)" attributes="__classmethod__ __ctor__" doc="Returns a new WIN32OLE_TYPELIB object. &#xA; The first argument typelib  specifies OLE type library name or GUID or OLE library file. The second argument is major version or version of the type library. The third argument is minor version. The second argument and third argument are optional. If the first argument is type library name, then the second and third argument are ignored. &#xA; tlib1 = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;tlib2 = WIN32OLE_TYPELIB.new(&apos;{00020813-0000-0000-C000-000000000046}&apos;)&#xA;tlib3 = WIN32OLE_TYPELIB.new(&apos;{00020813-0000-0000-C000-000000000046}&apos;, 1.3)&#xA;tlib4 = WIN32OLE_TYPELIB.new(&apos;{00020813-0000-0000-C000-000000000046}&apos;, 1, 3)&#xA;tlib5 = WIN32OLE_TYPELIB.new(&quot;C:\\WINNT\\SYSTEM32\\SHELL32.DLL&quot;)&#xA;puts tlib1.name  # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;&#xA;puts tlib2.name  # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;&#xA;puts tlib3.name  # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;&#xA;puts tlib4.name  # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;&#xA;puts tlib5.name  # -&gt; &apos;Microsoft Shell Controls And Automation&apos;" />
        <scope name="typelibs" ilk="function" signature="typelibs()" attributes="__classmethod__" doc="Returns the array of WIN32OLE_TYPELIB object. &#xA; tlibs = WIN32OLE_TYPELIB.typelibs" />
        <scope name="guid" ilk="function" signature="guid()" doc="Returns guid string which specifies type library. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;guid = tlib.guid # -&gt; &apos;{00020813-0000-0000-C000-000000000046}&apos;" />
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns the type library name with class name. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;tlib.inspect # =&gt; &quot;&lt;#WIN32OLE_TYPELIB:Microsoft Excel 9.0 Object Library&gt;&quot;" />
        <scope name="library_name" ilk="function" signature="library_name()" doc="Returns library name. If the method fails to access library name, WIN32OLERuntimeError is raised. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;tlib.library_name # =&gt; Excel" />
        <scope name="major_version" ilk="function" signature="major_version()" doc="Returns the type library major version. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;puts tlib.major_version # -&gt; 1" />
        <scope name="minor_version" ilk="function" signature="minor_version()" doc="Returns the type library minor version. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;puts tlib.minor_version # -&gt; 3" />
        <scope name="name" ilk="function" signature="name()" doc="Returns the type library name. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;name = tlib.name # -&gt; &apos;Microsoft Excel 9.0 Object Library&apos;" />
        <scope name="ole_classes" ilk="function" signature="ole_classes()" />
        <scope name="ole_types" ilk="function" signature="ole_types()" doc="Returns the type library file path. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;classes = tlib.ole_types.collect{|k| k.name} # -&gt; [&apos;AddIn&apos;, &apos;AddIns&apos; ...]" />
        <scope name="path" ilk="function" signature="path()" doc="Returns the type library file path. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;puts tlib.path #-&gt; &apos;C:\...\EXCEL9.OLB&apos;" />
        <scope name="to_s" ilk="function" signature="to_s()" />
        <scope name="version" ilk="function" signature="version()" doc="Returns the type library version. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;puts tlib.version #-&gt; 1.3" />
        <scope name="visible?" ilk="function" signature="visible?()" doc="Returns true if the type library information is not hidden. If wLibFlags of TLIBATTR is 0 or LIBFLAG_FRESTRICTED or LIBFLAG_FHIDDEN, the method returns false, otherwise, returns true. If the method fails to access the TLIBATTR information, then WIN32OLERuntimeError is raised. &#xA; tlib = WIN32OLE_TYPELIB.new(&apos;Microsoft Excel 9.0 Object Library&apos;)&#xA;tlib.visible? # =&gt; true" />
      </scope>
      <scope name="WIN32OLE_VARIABLE" ilk="class" classrefs="Object">
        <scope name="inspect" ilk="function" signature="inspect()" doc="Returns the OLE variable name and the value with class name." />
        <scope name="name" ilk="function" signature="name()" doc="Returns the name of variable. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.name}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  xlChart&#xA;  xlDialogSheet&#xA;  xlExcel4IntlMacroSheet&#xA;  xlExcel4MacroSheet&#xA;  xlWorksheet" />
        <scope name="ole_type" ilk="function" signature="ole_type()" doc="Returns OLE type string. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.ole_type} #{variable.name}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  INT xlChart&#xA;  INT xlDialogSheet&#xA;  INT xlExcel4IntlMacroSheet&#xA;  INT xlExcel4MacroSheet&#xA;  INT xlWorksheet" />
        <scope name="ole_type_detail" ilk="function" signature="ole_type_detail()" doc="Returns detail information of type. The information is array of type. &#xA; tobj = WIN32OLE_TYPE.new(&apos;DirectX 7 for Visual Basic Type Library&apos;, &apos;D3DCLIPSTATUS&apos;)&#xA;variable = tobj.variables.find {|variable| variable.name == &apos;lFlags&apos;}&#xA;tdetail  = variable.ole_type_detail&#xA;p tdetail # =&gt; [&quot;USERDEFINED&quot;, &quot;CONST_D3DCLIPSTATUSFLAGS&quot;]" />
        <scope name="to_s" ilk="function" signature="to_s()" />
        <scope name="value" ilk="function" signature="value()" doc="Returns value if value is exists. If the value does not exist, this method returns nil. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.name} #{variable.value}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  xlChart = -4109&#xA;  xlDialogSheet = -4116&#xA;  xlExcel4IntlMacroSheet = 4&#xA;  xlExcel4MacroSheet = 3&#xA;  xlWorksheet = -4167" />
        <scope name="variable_kind" ilk="function" signature="variable_kind()" doc="Returns variable kind string. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.name} #{variable.variable_kind}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  xlChart CONSTANT&#xA;  xlDialogSheet CONSTANT&#xA;  xlExcel4IntlMacroSheet CONSTANT&#xA;  xlExcel4MacroSheet CONSTANT&#xA;  xlWorksheet CONSTANT" />
        <scope name="varkind" ilk="function" signature="varkind()" doc="Returns the number which represents variable kind. tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.name} #{variable.varkind}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;   xlChart 2&#xA;   xlDialogSheet 2&#xA;   xlExcel4IntlMacroSheet 2&#xA;   xlExcel4MacroSheet 2&#xA;   xlWorksheet 2" />
        <scope name="visible?" ilk="function" signature="visible?()" doc="Returns true if the variable is public. &#xA; tobj = WIN32OLE_TYPE.new(&apos;Microsoft Excel 9.0 Object Library&apos;, &apos;XlSheetType&apos;)&#xA;variables = tobj.variables&#xA;variables.each do |variable|&#xA;  puts &quot;#{variable.name} #{variable.visible?}&quot;&#xA;end&#xA;&#xA;The result of above script is following:&#xA;  xlChart true&#xA;  xlDialogSheet true&#xA;  xlExcel4IntlMacroSheet true&#xA;  xlExcel4MacroSheet true&#xA;  xlWorksheet true" />
      </scope>
    </scope>
    <scope name="win32ole/property" ilk="blob" lang="Ruby">
      <scope name="OLEProperty" ilk="class" classrefs="Object">
        <scope name="new" ilk="function" signature="new(obj, dispid, gettypes, settypes)" attributes="__classmethod__ __ctor__" />
      </scope>
    </scope>
    <scope name="xmlrpc/base64" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Base64" ilk="class" classrefs="Object">
          <scope name="decode" ilk="function" signature="decode(str)" attributes="__classmethod__" />
          <scope name="encode" ilk="function" signature="encode(str)" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new(str, state = :dec)" attributes="__classmethod__ __ctor__" />
          <scope name="decoded" ilk="function" signature="decoded()" />
          <scope name="encoded" ilk="function" signature="encoded()" />
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/client" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Client" ilk="class" classrefs="Object">
          <import symbol="ParseContentType" />
          <import symbol="ParserWriterChooseMixin" />
          <scope name="new" ilk="function" signature="new(host=nil, path=nil, port=nil, proxy_host=nil, proxy_port=nil, user=nil, password=nil, use_ssl=nil, timeout=nil)" attributes="__classmethod__ __ctor__" doc="Constructors -------------------------------------------------------------------" />
          <scope name="new2" ilk="function" signature="new2(uri, proxy=nil, timeout=nil)" attributes="__classmethod__" />
          <scope name="new3" ilk="function" signature="new3(hash={})" attributes="__classmethod__" />
          <scope name="new_from_hash" ilk="function" signature="new_from_hash(hash={})" attributes="__classmethod__" />
          <scope name="new_from_uri" ilk="function" signature="new_from_uri(uri, proxy=nil, timeout=nil)" attributes="__classmethod__" />
          <scope name="call" ilk="function" signature="call(method, *args)" doc="Call methods --------------------------------------------------------------" />
          <scope name="call2" ilk="function" signature="call2(method, *args)" />
          <scope name="call2_async" ilk="function" signature="call2_async(method, *args)" />
          <scope name="call_async" ilk="function" signature="call_async(method, *args)" />
          <scope name="multicall" ilk="function" signature="multicall(*methods)" doc="Multicall methods --------------------------------------------------------------" />
          <scope name="multicall2" ilk="function" signature="multicall2(*methods)" />
          <scope name="multicall2_async" ilk="function" signature="multicall2_async(*methods)" />
          <scope name="multicall_async" ilk="function" signature="multicall_async(*methods)" />
          <scope name="password=" ilk="function" signature="password=(new_password)" />
          <scope name="proxy" ilk="function" signature="proxy(prefix=nil, *args)" doc="Proxy generating methods ------------------------------------------" />
          <scope name="proxy2" ilk="function" signature="proxy2(prefix=nil, *args)" />
          <scope name="proxy2_async" ilk="function" signature="proxy2_async(prefix=nil, *args)" />
          <scope name="proxy_async" ilk="function" signature="proxy_async(prefix=nil, *args)" />
          <scope name="timeout=" ilk="function" signature="timeout=(new_timeout)" />
          <scope name="user=" ilk="function" signature="user=(new_user)" />
          <scope ilk="function" name="cookie" />
          <scope ilk="function" name="cookie=" />
          <scope ilk="function" name="http_header_extra" />
          <scope ilk="function" name="http_header_extra=" />
          <scope ilk="function" name="http_last_response" />
          <scope ilk="function" name="password" />
          <scope ilk="function" name="timeout" />
          <scope ilk="function" name="user" />
          <variable name="USER_AGENT" attributes="__const__" citdl="Object" />
          <scope name="Proxy" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(server, prefix, args=[], meth=:call, delim=&quot;.&quot;)" attributes="__classmethod__ __ctor__" />
            <scope name="method_missing" ilk="function" signature="method_missing(mid, *args)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/config" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Config" ilk="namespace">
          <variable name="DEFAULT_WRITER" attributes="__const__" citdl="Object" />
          <variable name="DEFAULT_PARSER" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_NIL_CREATE" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_NIL_PARSER" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_BIGINT" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_MARSHALLING" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_MULTICALL" attributes="__const__" citdl="Object" />
          <variable name="ENABLE_INTROSPECTION" attributes="__const__" citdl="Object" />
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/create" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Create" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(xml_writer = nil)" attributes="__classmethod__ __ctor__" />
          <scope name="methodCall" ilk="function" signature="methodCall(name, *params)" />
          <scope name="methodResponse" ilk="function" signature="methodResponse(is_ret, *params)" doc="generates a XML-RPC methodResponse document &#xA; if is_ret == false then the params array must contain only one element, which is a structure of a fault return-value. &#xA; if is_ret == true then a normal return-value of all the given params is created." />
        </scope>
        <scope name="XMLWriter" ilk="namespace">
          <scope name="each_installed_writer" ilk="function" signature="each_installed_writer()" attributes="__classmethod__" doc="yields an instance of each installed XML writer" />
          <scope name="Simple" ilk="class" classrefs="XMLRPC::XMLWriter::Abstract">
            <scope name="document" ilk="function" signature="document(*params)" />
            <scope name="document_to_str" ilk="function" signature="document_to_str(doc)" />
            <scope name="element" ilk="function" signature="element(name, attrs, *children)" />
            <scope name="pi" ilk="function" signature="pi(name, *params)" />
            <scope name="text" ilk="function" signature="text(txt)" />
          </scope>
          <scope name="XMLParser" ilk="class" classrefs="XMLRPC::XMLWriter::Abstract">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="document" ilk="function" signature="document(*params)" />
            <scope name="document_to_str" ilk="function" signature="document_to_str(doc)" />
            <scope name="element" ilk="function" signature="element(name, attrs, *children)" />
            <scope name="pi" ilk="function" signature="pi(name, *params)" />
            <scope name="text" ilk="function" signature="text(txt)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/datetime" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="DateTime" ilk="class" classrefs="Object">
          <scope name="new" ilk="function" signature="new(year, month, day, hour, min, sec)" attributes="__classmethod__ __ctor__" />
          <scope name="day=" ilk="function" signature="day=(value)" />
          <scope name="hour=" ilk="function" signature="hour=(value)" />
          <scope name="min=" ilk="function" signature="min=(value)" />
          <scope name="mon=" ilk="function" signature="mon=(value)" />
          <scope name="month=" ilk="function" signature="month=(value)" />
          <scope name="sec=" ilk="function" signature="sec=(value)" />
          <scope name="to_a" ilk="function" signature="to_a()" />
          <scope name="to_date" ilk="function" signature="to_date()" />
          <scope name="to_time" ilk="function" signature="to_time()" />
          <scope name="year=" ilk="function" signature="year=(value)" />
          <scope ilk="function" name="day" />
          <scope ilk="function" name="hour" />
          <scope ilk="function" name="min" />
          <scope ilk="function" name="mon" />
          <scope ilk="function" name="month" />
          <scope ilk="function" name="sec" />
          <scope ilk="function" name="year" />
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/marshal" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Marshal" ilk="class" classrefs="Object">
          <import symbol="ParserWriterChooseMixin" />
          <scope name="dump" ilk="function" signature="dump( param )" attributes="__classmethod__" />
          <scope name="dump_call" ilk="function" signature="dump_call( methodName, *params )" attributes="__classmethod__" />
          <scope name="dump_response" ilk="function" signature="dump_response( param )" attributes="__classmethod__" />
          <scope name="load" ilk="function" signature="load( stringOrReadable )" attributes="__classmethod__" />
          <scope name="load_call" ilk="function" signature="load_call( stringOrReadable )" attributes="__classmethod__" />
          <scope name="load_response" ilk="function" signature="load_response( stringOrReadable )" attributes="__classmethod__" />
          <scope name="new" ilk="function" signature="new( parser = nil, writer = nil )" attributes="__classmethod__ __ctor__" doc="instance methods ----------------------------" />
          <scope name="dump_call" ilk="function" signature="dump_call( methodName, *params )" />
          <scope name="dump_response" ilk="function" signature="dump_response( param )" />
          <scope name="load_call" ilk="function" signature="load_call( stringOrReadable )" doc="returns [ methodname, params ]" />
          <scope name="load_response" ilk="function" signature="load_response( stringOrReadable )" doc="returns paramOrFault" />
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/parser" ilk="blob" lang="Ruby">
      <scope name="NQXML" ilk="namespace">
        <scope name="Node" ilk="class" classrefs="Object">
          <scope name="childNodes" ilk="function" signature="childNodes()" />
          <scope name="hasChildNodes" ilk="function" signature="hasChildNodes()" />
          <scope name="nodeName" ilk="function" signature="nodeName()" />
          <scope name="nodeType" ilk="function" signature="nodeType()" />
          <scope name="nodeValue" ilk="function" signature="nodeValue()" />
          <scope name="removeChild" ilk="function" signature="removeChild(node)" />
        </scope>
      </scope>
      <scope name="XMLRPC" ilk="namespace">
        <scope name="Convert" ilk="namespace">
          <scope name="base64" ilk="function" signature="base64(str)" attributes="__classmethod__" />
          <scope name="boolean" ilk="function" signature="boolean(str)" attributes="__classmethod__" />
          <scope name="dateTime" ilk="function" signature="dateTime(str)" attributes="__classmethod__" />
          <scope name="double" ilk="function" signature="double(str)" attributes="__classmethod__" />
          <scope name="fault" ilk="function" signature="fault(hash)" attributes="__classmethod__" />
          <scope name="int" ilk="function" signature="int(str)" attributes="__classmethod__" />
          <scope name="struct" ilk="function" signature="struct(hash)" attributes="__classmethod__" />
        </scope>
        <scope name="FaultException" ilk="class" classrefs="StandardError">
          <scope name="new" ilk="function" signature="new(faultCode, faultString)" attributes="__classmethod__ __ctor__" />
          <scope name="to_h" ilk="function" signature="to_h()" doc="returns a hash" />
          <scope ilk="function" name="faultCode" />
          <scope ilk="function" name="faultString" />
        </scope>
        <scope name="XMLParser" ilk="namespace">
          <scope name="each_installed_parser" ilk="function" signature="each_installed_parser()" attributes="__classmethod__" doc="yields an instance of each installed parser" />
          <scope name="AbstractStreamParser" ilk="class" classrefs="Object">
            <scope name="parseMethodCall" ilk="function" signature="parseMethodCall(str)" />
            <scope name="parseMethodResponse" ilk="function" signature="parseMethodResponse(str)" />
          </scope>
          <scope name="AbstractTreeParser" ilk="class" classrefs="Object">
            <scope name="parseMethodCall" ilk="function" signature="parseMethodCall(str)" />
            <scope name="parseMethodResponse" ilk="function" signature="parseMethodResponse(str)" />
          </scope>
          <scope name="NQXMLParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractTreeParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          </scope>
          <scope name="NQXMLStreamParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractStreamParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="XMLRPCParser" ilk="class" classrefs="Object">
              <import symbol="StreamParserMixin" />
              <scope name="parse" ilk="function" signature="parse(str)" />
            </scope>
          </scope>
          <scope name="NQXMLTreeParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractTreeParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          </scope>
          <scope name="REXMLStreamParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractStreamParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="StreamListener" ilk="class" classrefs="Object">
              <import symbol="StreamParserMixin" />
              <scope name="method_missing" ilk="function" signature="method_missing(*a)" />
              <scope name="parse" ilk="function" signature="parse(str)" />
            </scope>
          </scope>
          <scope name="StreamParserMixin" ilk="namespace">
            <scope name="new" ilk="function" signature="new(*a)" attributes="__classmethod__ __ctor__" />
            <scope name="character" ilk="function" signature="character(data)" />
            <scope name="endElement" ilk="function" signature="endElement(name)" />
            <scope name="startElement" ilk="function" signature="startElement(name, attrs=[])" />
            <scope ilk="function" name="fault" />
            <scope ilk="function" name="method_name" />
            <scope ilk="function" name="params" />
          </scope>
          <scope name="XMLParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractTreeParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          </scope>
          <scope name="XMLScanStreamParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractStreamParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
            <scope name="XMLScanParser" ilk="class" classrefs="Object">
              <import symbol="StreamParserMixin" />
              <scope name="method_missing" ilk="function" signature="method_missing(*a)" />
              <scope name="on_cdata" ilk="function" signature="on_cdata(str)" />
              <scope name="on_chardata" ilk="function" signature="on_chardata(str)" />
              <scope name="on_charref" ilk="function" signature="on_charref(code)" />
              <scope name="on_charref_hex" ilk="function" signature="on_charref_hex(code)" />
              <scope name="on_entityref" ilk="function" signature="on_entityref(ent)" />
              <scope name="on_stag_end" ilk="function" signature="on_stag_end(name)" />
              <scope name="on_stag_end_empty" ilk="function" signature="on_stag_end_empty(name)" />
              <scope name="parse" ilk="function" signature="parse(str)" />
            </scope>
          </scope>
          <scope name="XMLStreamParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractStreamParser">
            <import symbol="StreamParserMixin" />
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          </scope>
          <scope name="XMLTreeParser" ilk="class" classrefs="XMLRPC::XMLParser::AbstractTreeParser">
            <scope name="new" ilk="function" signature="new()" attributes="__classmethod__ __ctor__" />
          </scope>
        </scope>
        <scope name="XMLWriter" ilk="namespace">
          <scope name="Abstract" ilk="class" classrefs="Object">
            <scope name="ele" ilk="function" signature="ele(name, *children)" />
            <scope name="tag" ilk="function" signature="tag(name, txt)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/server" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="BasicServer" ilk="class" classrefs="Object">
          <import symbol="ParseContentType" />
          <import symbol="ParserWriterChooseMixin" />
          <scope name="new" ilk="function" signature="new(class_delim=&quot;.&quot;)" attributes="__classmethod__ __ctor__" />
          <scope name="add_handler" ilk="function" signature="add_handler(prefix, obj_or_signature=nil, help=nil, &amp;block)" />
          <scope name="add_introspection" ilk="function" signature="add_introspection()" />
          <scope name="add_multicall" ilk="function" signature="add_multicall()" />
          <scope name="get_default_handler" ilk="function" signature="get_default_handler()" />
          <scope name="get_service_hook" ilk="function" signature="get_service_hook()" />
          <scope name="process" ilk="function" signature="process(data)" />
          <scope name="set_default_handler" ilk="function" signature="set_default_handler(&amp;handler)" />
          <scope name="set_service_hook" ilk="function" signature="set_service_hook(&amp;handler)" />
          <variable name="ERR_METHOD_MISSING" attributes="__const__" citdl="Object" />
          <variable name="ERR_UNCAUGHT_EXCEPTION" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_WRONG_PARAM" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_MISSING_PARAMS" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_MISSING_METHNAME" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_RECURSIVE_CALL" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_WRONG_PARAM_PARAMS" attributes="__const__" citdl="Object" />
          <variable name="ERR_MC_EXPECTED_STRUCT" attributes="__const__" citdl="Object" />
        </scope>
        <scope name="CGIServer" ilk="class" classrefs="XMLRPC::BasicServer">
          <scope name="new" ilk="function" signature="new(*a)" attributes="__classmethod__ __ctor__" />
          <scope name="serve" ilk="function" signature="serve()" />
        </scope>
        <scope name="ModRubyServer" ilk="class" classrefs="XMLRPC::BasicServer">
          <scope name="new" ilk="function" signature="new(*a)" attributes="__classmethod__ __ctor__" />
          <scope name="serve" ilk="function" signature="serve()" />
        </scope>
        <scope name="Server" ilk="class" classrefs="XMLRPC::WEBrickServlet">
          <scope name="new" ilk="function" signature="new(port=8080, host=&quot;127.0.0.1&quot;, maxConnections=4, stdlog=$stdout, audit=true, debug=true, *a)" attributes="__classmethod__ __ctor__" />
          <scope name="serve" ilk="function" signature="serve()" />
          <scope name="shutdown" ilk="function" signature="shutdown()" />
        </scope>
        <scope name="WEBrickServlet" ilk="class" classrefs="XMLRPC::BasicServer">
          <scope name="new" ilk="function" signature="new(*a)" attributes="__classmethod__ __ctor__" />
          <scope name="get_instance" ilk="function" signature="get_instance(config, *options)" />
          <scope name="get_valid_ip" ilk="function" signature="get_valid_ip()" />
          <scope name="require_path_info?" ilk="function" signature="require_path_info?()" doc="deprecated from WEBrick/1.2.2. but does not break anything." />
          <scope name="service" ilk="function" signature="service(request, response)" />
          <scope name="set_valid_ip" ilk="function" signature="set_valid_ip(*ip_addr)" />
        </scope>
      </scope>
    </scope>
    <scope name="xmlrpc/utils" ilk="blob" lang="Ruby">
      <scope name="XMLRPC" ilk="namespace">
        <scope name="iPIMethods" ilk="function" signature="iPIMethods(prefix)" attributes="__classmethod__" doc="short-cut for creating a PublicInstanceMethodsInterface" />
        <scope name="interface" ilk="function" signature="interface(prefix, &amp;p)" attributes="__classmethod__" doc="short-form to create a Service::Interface" />
        <scope name="Marshallable" ilk="namespace">
        </scope>
        <scope name="ParseContentType" ilk="namespace">
          <scope name="parse_content_type" ilk="function" signature="parse_content_type(str)" />
        </scope>
        <scope name="ParserWriterChooseMixin" ilk="namespace">
          <scope name="set_parser" ilk="function" signature="set_parser(parser)" />
          <scope name="set_writer" ilk="function" signature="set_writer(writer)" />
        </scope>
        <scope name="Service" ilk="namespace">
          <scope name="BasicInterface" ilk="class" classrefs="Object">
            <scope name="new" ilk="function" signature="new(prefix)" attributes="__classmethod__ __ctor__" />
            <scope name="add_method" ilk="function" signature="add_method(sig, help=nil, meth_name=nil)" />
            <scope ilk="function" name="methods" />
            <scope ilk="function" name="prefix" />
          </scope>
          <scope name="Interface" ilk="class" classrefs="XMLRPC::Service::BasicInterface">
            <scope name="new" ilk="function" signature="new(prefix, &amp;p)" attributes="__classmethod__ __ctor__" />
            <scope name="get_methods" ilk="function" signature="get_methods(obj, delim=&quot;.&quot;)" />
          </scope>
          <scope name="PublicInstanceMethodsInterface" ilk="class" classrefs="XMLRPC::Service::BasicInterface">
            <scope name="new" ilk="function" signature="new(prefix)" attributes="__classmethod__ __ctor__" />
            <scope name="get_methods" ilk="function" signature="get_methods(obj, delim=&quot;.&quot;)" />
          </scope>
        </scope>
      </scope>
    </scope>
    <scope name="zlib" ilk="blob" lang="Ruby">
      <scope name="Zlib" ilk="namespace">
        <scope name="adler32" ilk="function" signature="adler32(*args)" attributes="__classmethod__" doc="Calculates Adler-32 checksum for +string+, and returns updated value of +adler+. If +string+ is omitted, it returns the Adler-32 initial value. If +adler+ is omitted, it assumes that the initial value is given to +adler+. &#xA; FIXME: expression." />
        <scope name="adler32_combine" ilk="function" signature="adler32_combine(p1, p2, p3)" attributes="__classmethod__" doc="Combine two Adler-32 check values in to one.  +alder1+ is the first Adler-32 value, +adler2+ is the second Adler-32 value.  +len2+ is the length of the string used to generate +adler2+." />
        <scope name="crc32" ilk="function" signature="crc32(*args)" attributes="__classmethod__" doc="Calculates CRC checksum for +string+, and returns updated value of +crc+. If +string+ is omitted, it returns the CRC initial value. If +crc+ is omitted, it assumes that the initial value is given to +crc+. &#xA; FIXME: expression." />
        <scope name="crc32_combine" ilk="function" signature="crc32_combine(p1, p2, p3)" attributes="__classmethod__" doc="Combine two CRC-32 check values in to one.  +crc1+ is the first CRC-32 value, +crc2+ is the second CRC-32 value.  +len2+ is the length of the string used to generate +crc2+." />
        <scope name="crc_table" ilk="function" signature="crc_table()" attributes="__classmethod__" doc="Returns the table for calculating CRC checksum as an array." />
        <scope name="deflate" ilk="function" signature="deflate(p1, p2 = v2)" attributes="__classmethod__" doc="Compresses the given +string+. Valid values of level are NO_COMPRESSION, BEST_SPEED, BEST_COMPRESSION, DEFAULT_COMPRESSION, and an integer from 0 to 9 (the default is 6). &#xA; This method is almost equivalent to the following code: &#xA; def deflate(string, level)&#xA;  z = Zlib::Deflate.new(level)&#xA;  dst = z.deflate(string, Zlib::NO_FLUSH)&#xA;  z.close&#xA;  dst&#xA;end&#xA; See also Zlib.inflate" />
        <scope name="inflate" ilk="function" signature="inflate(p1)" attributes="__classmethod__" doc="Decompresses +string+. Raises a Zlib::NeedDict exception if a preset dictionary is needed for decompression. &#xA; This method is almost equivalent to the following code: &#xA; def inflate(string)&#xA;  zstream = Zlib::Inflate.new&#xA;  buf = zstream.inflate(string)&#xA;  zstream.finish&#xA;  zstream.close&#xA;  buf&#xA;end&#xA; See also Zlib.deflate" />
        <scope name="zlib_version" ilk="function" signature="zlib_version()" attributes="__classmethod__" doc="Returns the string which represents the version of zlib library." />
        <variable name="VERSION" attributes="__const__" citdl="Object" />
        <variable name="ZLIB_VERSION" attributes="__const__" citdl="Object" />
        <variable name="BINARY" attributes="__const__" citdl="Object" />
        <variable name="ASCII" attributes="__const__" citdl="Object" />
        <variable name="UNKNOWN" attributes="__const__" citdl="Object" />
        <variable name="NO_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="BEST_SPEED" attributes="__const__" citdl="Object" />
        <variable name="BEST_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_COMPRESSION" attributes="__const__" citdl="Object" />
        <variable name="FILTERED" attributes="__const__" citdl="Object" />
        <variable name="HUFFMAN_ONLY" attributes="__const__" citdl="Object" />
        <variable name="DEFAULT_STRATEGY" attributes="__const__" citdl="Object" />
        <variable name="MAX_WBITS" attributes="__const__" citdl="Object" />
        <variable name="DEF_MEM_LEVEL" attributes="__const__" citdl="Object" />
        <variable name="MAX_MEM_LEVEL" attributes="__const__" citdl="Object" />
        <variable name="NO_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="SYNC_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="FULL_FLUSH" attributes="__const__" citdl="Object" />
        <variable name="FINISH" attributes="__const__" citdl="Object" />
        <variable name="OS_CODE" attributes="__const__" citdl="Object" />
        <variable name="OS_MSDOS" attributes="__const__" citdl="Object" />
        <variable name="OS_AMIGA" attributes="__const__" citdl="Object" />
        <variable name="OS_VMS" attributes="__const__" citdl="Object" />
        <variable name="OS_UNIX" attributes="__const__" citdl="Object" />
        <variable name="OS_ATARI" attributes="__const__" citdl="Object" />
        <variable name="OS_MACOS" attributes="__const__" citdl="Object" />
        <variable name="OS_VMCMS" attributes="__const__" citdl="Object" />
        <variable name="OS_ZSYSTEM" attributes="__const__" citdl="Object" />
        <variable name="OS_CPM" attributes="__const__" citdl="Object" />
        <variable name="OS_QDOS" attributes="__const__" citdl="Object" />
        <variable name="OS_RISCOS" attributes="__const__" citdl="Object" />
        <variable name="OS_UNKNOWN" attributes="__const__" citdl="Object" />
        <scope name="BufError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="DataError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="Deflate" ilk="class" classrefs="Zlib::ZStream">
          <scope name="deflate" ilk="function" signature="deflate(p1, p2 = v2)" attributes="__classmethod__" doc="Compresses the given +string+. Valid values of level are NO_COMPRESSION, BEST_SPEED, BEST_COMPRESSION, DEFAULT_COMPRESSION, and an integer from 0 to 9 (the default is 6). &#xA; This method is almost equivalent to the following code: &#xA; def deflate(string, level)&#xA;  z = Zlib::Deflate.new(level)&#xA;  dst = z.deflate(string, Zlib::NO_FLUSH)&#xA;  z.close&#xA;  dst&#xA;end&#xA; See also Zlib.inflate" />
          <scope name="new" ilk="function" signature="new(p1 = v1, p2 = v2, p3 = v3, p4 = v4)" attributes="__classmethod__ __ctor__" doc="Arguments &#xA; An Integer compression level between BEST_SPEED and BEST_COMPRESSION&#xA;An Integer for the windowBits size. Should be in the range 8..15, larger values of this parameter result in better at the expense of memory usage.&#xA;Specifies how much memory should be allocated for the internal compression state. Between DEF_MEM_LEVEL and MAX_MEM_LEVEL&#xA;A parameter to tune the compression algorithm. Use the DEFAULT_STRATEGY for normal data, FILTERED for data produced by a filter (or predictor), HUFFMAN_ONLY to force Huffman encoding only (no string match). &#xA; Description &#xA; Creates a new deflate stream for compression. See zlib.h for details of each argument. If an argument is nil, the default value of that argument is used. &#xA; examples &#xA; basic &#xA; f = File.new(&quot;compressed.file&quot;,&quot;w+&quot;)&#xA;=&gt; #&lt;File:compressed.file&gt;&#xA;f &lt;&lt; Zlib::Deflate.new().deflate(File.read(&quot;big.file&quot;))&#xA;=&gt; #&lt;File:compressed.file&gt;" />
          <scope name="deflate" ilk="function" signature="deflate(p1, p2 = v2)" doc="Arguments &#xA; String &#xA;&#xA;Integer representing a flush code. Either NO_FLUSH, SYNC_FLUSH, FULL_FLUSH, or FINISH. See zlib.h for details. Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to decide how much data to accumulate before producing output, in order to maximize compression. &#xA; Description &#xA; Inputs +string+ into the deflate stream and returns the output from the stream.  On calling this method, both the input and the output buffers of the stream are flushed. &#xA; If +string+ is nil, this method finishes the stream, just like Zlib::ZStream#finish. &#xA; Usage &#xA; comp = Zlib.deflate(File.read(&quot;big.file&quot;))&#xA; or comp = Zlib.deflate(File.read(&quot;big.file&quot;), Zlib::FULL_FLUSH)" />
          <scope name="flush" ilk="function" signature="flush(p1 = v1)" doc="This method is equivalent to deflate(&apos;&apos;, flush).  If flush is omitted, SYNC_FLUSH is used as flush.  This method is just provided to improve the readability of your Ruby program. &#xA; Please visit your zlib.h for a deeper detail on NO_FLUSH, SYNC_FLUSH, FULL_FLUSH, and FINISH" />
          <scope name="initialize_copy" ilk="function" signature="initialize_copy(p1)" doc="Duplicates the deflate stream." />
          <scope name="params" ilk="function" signature="params(p1, p2)" doc="Changes the parameters of the deflate stream. See zlib.h for details. The output from the stream by changing the params is preserved in output buffer. &#xA; An Integer compression level between BEST_SPEED and BEST_COMPRESSION&#xA;A parameter to tune the compression algorithm. Use the DEFAULT_STRATEGY for normal data, FILTERED for data produced by a filter (or predictor), HUFFMAN_ONLY to force Huffman encoding only (no string match)." />
          <scope name="set_dictionary" ilk="function" signature="set_dictionary(p1)" doc="Sets the preset dictionary and returns +string+. This method is available just only after Zlib::Deflate.new or Zlib::ZStream#reset method was called. See zlib.h for details. &#xA; Can raise errors of Z_STREAM_ERROR if a parameter is invalid (such as NULL dictionary) or the stream state is inconsistent, Z_DATA_ERROR if the given dictionary doesn&apos;t match the expected one (incorrect adler32 value)" />
        </scope>
        <scope name="Error" ilk="class" classrefs="StandardError">
        </scope>
        <scope name="GzipFile" ilk="class" classrefs="Object">
          <scope name="wrap" ilk="function" signature="wrap(*args)" attributes="__classmethod__" doc="Creates a GzipFile object associated with +io+, and executes the block with the newly created GzipFile object, just like File.open. The GzipFile object will be closed automatically after executing the block. If you want to keep the associated IO object opening, you may call +Zlib::GzipFile#finish+ method in the block." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the GzipFile object. This method calls close method of the associated IO object. Returns the associated IO object." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Same as IO#closed?" />
          <scope name="comment" ilk="function" signature="comment()" doc="Returns comments recorded in the gzip file header, or nil if the comments is not present." />
          <scope name="crc" ilk="function" signature="crc()" doc="Returns CRC value of the uncompressed data." />
          <scope name="finish" ilk="function" signature="finish()" doc="Closes the GzipFile object. Unlike Zlib::GzipFile#close, this method never calls the close method of the associated IO object. Returns the associated IO object." />
          <scope name="level" ilk="function" signature="level()" doc="Returns compression level." />
          <scope name="mtime" ilk="function" signature="mtime()" doc="Returns last modification time recorded in the gzip file header." />
          <scope name="orig_name" ilk="function" signature="orig_name()" doc="Returns original filename recorded in the gzip file header, or +nil+ if original filename is not present." />
          <scope name="os_code" ilk="function" signature="os_code()" doc="Returns OS code number recorded in the gzip file header." />
          <scope name="sync" ilk="function" signature="sync()" doc="Same as IO#sync" />
          <scope name="sync=" ilk="function" signature="sync=(p1)" doc="Same as IO.  If flag is +true+, the associated IO object must respond to the +flush+ method.  While +sync+ mode is +true+, the compression ratio decreases sharply." />
          <scope name="to_io" ilk="function" signature="to_io()" doc="Same as IO." />
          <scope name="CRCError" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
          <scope name="Error" ilk="class" classrefs="Zlib::Error">
            <scope name="inspect" ilk="function" signature="inspect()" doc="Constructs a String of the GzipFile Error" />
            <scope ilk="function" name="input" />
          </scope>
          <scope name="LengthError" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
          <scope name="NoFooter" ilk="class" classrefs="Zlib::GzipFile::Error">
          </scope>
        </scope>
        <scope name="GzipReader" ilk="class" classrefs="Zlib::GzipFile">
          <import symbol="Enumerable" />
          <scope name="new" ilk="function" signature="new(p1, p2 = {})" attributes="__classmethod__ __ctor__" doc="Creates a GzipReader object associated with +io+. The GzipReader object reads gzipped data from +io+, and parses/decompresses them.  At least, +io+ must have a +read+ method that behaves same as the +read+ method in IO class. &#xA; If the gzip file header is incorrect, raises an Zlib::GzipFile::Error exception." />
          <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Opens a file specified by +filename+ as a gzipped file, and returns a GzipReader object associated with that file.  Further details of this method are in Zlib::GzipReader.new and ZLib::GzipFile.wrap." />
          <scope name="bytes" ilk="function" signature="bytes()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each" ilk="function" signature="each(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_byte" ilk="function" signature="each_byte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_char" ilk="function" signature="each_char()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="each_line" ilk="function" signature="each_line(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="eof" ilk="function" signature="eof()" doc="Returns +true+ or +false+ whether the stream has reached the end." />
          <scope name="eof?" ilk="function" signature="eof?()" doc="Returns +true+ or +false+ whether the stream has reached the end." />
          <scope name="getbyte" ilk="function" signature="getbyte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="getc" ilk="function" signature="getc()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="gets" ilk="function" signature="gets(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="lineno" ilk="function" signature="lineno()" doc="The line number of the last row read from this file." />
          <scope name="lineno=" ilk="function" signature="lineno=(p1)" doc="Specify line number of the last row read from this file." />
          <scope name="lines" ilk="function" signature="lines(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="pos" ilk="function" signature="pos()" doc="Total number of output bytes output so far." />
          <scope name="read" ilk="function" signature="read(p1 = v1)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readbyte" ilk="function" signature="readbyte()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readchar" ilk="function" signature="readchar()" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readline" ilk="function" signature="readline(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readlines" ilk="function" signature="readlines(*args)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="readpartial" ilk="function" signature="readpartial(p1, p2 = v2)" doc="Reads at most maxlen bytes from the gziped stream but it blocks only if gzipreader has no data immediately available. If the optional outbuf argument is present, it must reference a String, which will receive the data. It raises EOFError on end of file." />
          <scope name="rewind" ilk="function" signature="rewind()" doc="Resets the position of the file pointer to the point created the GzipReader object.  The associated IO object needs to respond to the +seek+ method." />
          <scope name="tell" ilk="function" signature="tell()" doc="Total number of output bytes output so far." />
          <scope name="ungetbyte" ilk="function" signature="ungetbyte(p1)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="ungetc" ilk="function" signature="ungetc(p1)" doc="See Zlib::GzipReader documentation for a description." />
          <scope name="unused" ilk="function" signature="unused()" doc="Returns the rest of the data which had read for parsing gzip format, or +nil+ if the whole gzip file is not parsed yet." />
        </scope>
        <scope name="GzipWriter" ilk="class" classrefs="Zlib::GzipFile">
          <scope name="new" ilk="function" signature="new(p1, p2 = v2, p3 = v3)" attributes="__classmethod__ __ctor__" doc="Creates a GzipWriter object associated with +io+. +level+ and +strategy+ should be the same as the arguments of Zlib::Deflate.new.  The GzipWriter object writes gzipped data to +io+.  At least, +io+ must respond to the +write+ method that behaves same as write method in IO class." />
          <scope name="open" ilk="function" signature="open(*args)" attributes="__classmethod__" doc="Opens a file specified by +filename+ for writing gzip compressed data, and returns a GzipWriter object associated with that file.  Further details of this method are found in Zlib::GzipWriter.new and Zlib::GzipFile.wrap." />
          <scope name="comment=" ilk="function" signature="comment=(p1)" doc="Specify the comment (+str+) in the gzip header." />
          <scope name="flush" ilk="function" signature="flush(p1 = v1)" doc="Flushes all the internal buffers of the GzipWriter object.  The meaning of +flush+ is same as in Zlib::Deflate#deflate.  Zlib::SYNC_FLUSH is used if +flush+ is omitted.  It is no use giving flush Zlib::NO_FLUSH." />
          <scope name="mtime=" ilk="function" signature="mtime=(p1)" doc="Specify the modification time (+mtime+) in the gzip header. Using a Fixnum or Integer" />
          <scope name="orig_name=" ilk="function" signature="orig_name=(p1)" doc="Specify the original name (+str+) in the gzip header." />
          <scope name="pos" ilk="function" signature="pos()" doc="Total number of input bytes read so far." />
          <scope name="print" ilk="function" signature="print(*args)" doc="Same as IO.&#xA; Same as IO." />
          <scope name="printf" ilk="function" signature="printf(*args)" doc="Same as IO.&#xA; Same as IO." />
          <scope name="putc" ilk="function" signature="putc(p1)" doc="Same as IO." />
          <scope name="puts" ilk="function" signature="puts(*args)" doc="Same as IO.&#xA; Same as IO." />
          <scope name="tell" ilk="function" signature="tell()" doc="Total number of input bytes read so far." />
          <scope name="write" ilk="function" signature="write(p1)" doc="Same as IO." />
        </scope>
        <scope name="Inflate" ilk="class" classrefs="Zlib::ZStream">
          <scope name="inflate" ilk="function" signature="inflate(p1)" attributes="__classmethod__" doc="Decompresses +string+. Raises a Zlib::NeedDict exception if a preset dictionary is needed for decompression. &#xA; This method is almost equivalent to the following code: &#xA; def inflate(string)&#xA;  zstream = Zlib::Inflate.new&#xA;  buf = zstream.inflate(string)&#xA;  zstream.finish&#xA;  zstream.close&#xA;  buf&#xA;end&#xA; See also Zlib.deflate" />
          <scope name="new" ilk="function" signature="new(p1 = v1)" attributes="__classmethod__ __ctor__" doc="Arguments &#xA; An Integer for the windowBits size. Should be in the range 8..15, larger values of this parameter result in better at the expense of memory usage. &#xA; Description &#xA; Creates a new inflate stream for decompression. See zlib.h for details of the argument.  If +window_bits+ is +nil+, the default value is used. &#xA; Example &#xA; cf = File.open(&quot;compressed.file&quot;)&#xA;ucf = File.open(&quot;uncompressed.file&quot;, &quot;w+&quot;)&#xA;zi = Zlib::Inflate.new(Zlib::MAX_WBITS)&#xA;ucf &lt;&lt; zi.inflate(cf.read)&#xA;ucf.close&#xA;zi.close&#xA;cf.close&#xA; or " />
          <scope name="inflate" ilk="function" signature="inflate(p1)" doc="Inputs +string+ into the inflate stream and returns the output from the stream.  Calling this method, both the input and the output buffer of the stream are flushed.  If string is +nil+, this method finishes the stream, just like Zlib::ZStream#finish. &#xA; Raises a Zlib::NeedDict exception if a preset dictionary is needed to decompress.  Set the dictionary by Zlib::Inflate#set_dictionary and then call this method again with an empty string.  (???) &#xA; See also Zlib::Inflate.new" />
          <scope name="set_dictionary" ilk="function" signature="set_dictionary(p1)" doc="Sets the preset dictionary and returns +string+.  This method is available just only after a Zlib::NeedDict exception was raised.  See zlib.h for details." />
          <scope name="sync" ilk="function" signature="sync(p1)" doc="Inputs +string+ into the end of input buffer and skips data until a full flush point can be found.  If the point is found in the buffer, this method flushes the buffer and returns false.  Otherwise it returns +true+ and the following data of full flush point is preserved in the buffer." />
          <scope name="sync_point?" ilk="function" signature="sync_point?()" doc="Quoted verbatim from original documentation: &#xA; What is this?&#xA; :)" />
        </scope>
        <scope name="MemError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="NeedDict" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="StreamEnd" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="StreamError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="VersionError" ilk="class" classrefs="Zlib::Error">
        </scope>
        <scope name="ZStream" ilk="class" classrefs="Object">
          <scope name="adler" ilk="function" signature="adler()" doc="Returns the adler-32 checksum." />
          <scope name="avail_in" ilk="function" signature="avail_in()" doc="Returns bytes of data in the input buffer. Normally, returns 0." />
          <scope name="avail_out" ilk="function" signature="avail_out()" doc="Returns number of bytes of free spaces in output buffer.  Because the free space is allocated automatically, this method returns 0 normally." />
          <scope name="avail_out=" ilk="function" signature="avail_out=(p1)" doc="Allocates +size+ bytes of free space in the output buffer. If there are more than +size+ bytes already in the buffer, the buffer is truncated. Because free space is allocated automatically, you usually don&apos;t need to use this method." />
          <scope name="close" ilk="function" signature="close()" doc="Closes the stream. All operations on the closed stream will raise an exception." />
          <scope name="closed?" ilk="function" signature="closed?()" doc="Returns true if the stream is closed." />
          <scope name="data_type" ilk="function" signature="data_type()" doc="Guesses the type of the data which have been inputed into the stream. The returned value is either BINARY, ASCII, or UNKNOWN." />
          <scope name="end" ilk="function" signature="end()" doc="Closes the stream. All operations on the closed stream will raise an exception." />
          <scope name="ended?" ilk="function" signature="ended?()" doc="Returns true if the stream is closed." />
          <scope name="finish" ilk="function" signature="finish()" doc="Finishes the stream and flushes output buffer. See Zlib::Deflate#finish and Zlib::Inflate#finish for details of this behavior." />
          <scope name="finished?" ilk="function" signature="finished?()" doc="Returns true if the stream is finished." />
          <scope name="flush_next_in" ilk="function" signature="flush_next_in()" doc="Flushes input buffer and returns all data in that buffer." />
          <scope name="flush_next_out" ilk="function" signature="flush_next_out()" doc="Flushes output buffer and returns all data in that buffer." />
          <scope name="reset" ilk="function" signature="reset()" doc="Resets and initializes the stream. All data in both input and output buffer are discarded." />
          <scope name="stream_end?" ilk="function" signature="stream_end?()" doc="Returns true if the stream is finished." />
          <scope name="total_in" ilk="function" signature="total_in()" doc="Returns the total bytes of the input data to the stream.  FIXME" />
          <scope name="total_out" ilk="function" signature="total_out()" doc="Returns the total bytes of the output data from the stream.  FIXME" />
        </scope>
      </scope>
    </scope>
  </file>
</codeintel>
